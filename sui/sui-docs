
../../Downloads/sui-stuff/sui-main/docs/content/concepts.mdx
```
---
title: Sui Concepts Overview
sidebar_label: Overview
---

Sui is different than other blockchains. The concepts explored in this section provide a background to the Sui blockchain and Web3 in general.

## App developers

<Cards>
<Card title="Move overview" href="/concepts/sui-move-concepts"/>
<Card title="Package upgrades" href="/concepts/sui-move-concepts/packages/upgrade"/>
<Card title="Gaming on Sui" href="/concepts/gaming"/>
<Card title="The Move Book" href="https://move-book.com">
A comprehensive guide to the Move programming language on the Sui blockchain.
</Card>
</Cards>

## Objects

<Cards>
<Card title="Object Model" href="concepts/object-model"/>
<Card title="Transfer to Object" href="concepts/transfers/transfer-to-object"/>
</Cards>

## Cryptography

<Cards>
<Card title="zkLogin" href="concepts/cryptography/zklogin"/>
<Card title="Transaction authentication" href="concepts/cryptography/transaction-auth"/>
</Cards>

## Tokenomics

<Cards>
<Card title="SUI tokenomics" href="concepts/tokenomics" />
<Card title="Gas in Sui" href="concepts/tokenomics/gas-in-sui" />
<Card title="Vesting strategies" href="concepts/tokenomics/vesting-strategies" />
</Cards>

```

../../Downloads/sui-stuff/sui-main/docs/content/guides.mdx
```
---
title: Guides Overview
sidebar_label: Overview
---

Often, the best way to learn a new technology is through experience. The content in this section contains concrete examples to guide your development on the Sui network. Whether you're a web3 novice or a seasoned Sui pro, the guides in this section help you get the most out of your Sui development experience.

## Guides by role

Instructions for common tasks, based on your role in the Sui ecosystem.
<Cards>
<Card title="Developer guides" href="/guides/developer">
Guides for developers of all levels.
</Card>
<Card title="Operator guides" href="/guides/operator">
Guides for validators and node operators.
</Card>
</Cards>

## Get started developing on Sui

You must crawl before you can run. Start your Sui journey here.
<Cards>
<Card title="Install Sui" href="/guides/developer/getting-started/sui-install">
Install Sui on your Windows, MacOS, or Linux system.
</Card>
<Card title="Your first Sui dApp" href="/guides/developer/first-app">
With Sui installed, you're ready to start developing.
</Card>
</Cards>

## Sui 101 for developers

Learn the basics of Sui and how they might differ from other blockchains.
<Cards>
<Card title="Transactions on Sui" href="/guides/developer/sui-101/building-ptb">
Transactions on Sui are more powerful than other blockchains. Learn why and how to use them.
</Card>
<Card title="Access time on chain" href="/guides/developer/sui-101/access-time" />
<Card title="Using events" href="/guides/developer/sui-101/using-events">
Monitor the Sui network and programmatically react to on-chain events.
</Card>
</Cards>

## Coins, tokens, and NFTs

Learn how to mint various tokens on the Sui blockchain.
<Cards>
<Card title="Coins and tokens" href="/guides/developer/coin" />
<Card title="Stablecoins" href="/guides/developer/stablecoins" />
<Card title="NFTs" href="/guides/developer/nft" />
</Cards>

## Validating and operating nodes on Sui

Processes and guides for validators and node operators on the Sui network.
<Cards>
<Card title="Validator configuration" href="/guides/operator/validator-config" />
<Card title="Run a Sui Full node" href="/guides/operator/sui-full-node">
Learn how to operate a Full node on Sui.
</Card>
<Card title="Full node data management" href="/guides/operator/data-management">
Optimize your Full node configuration for efficient node operation.
</Card>
<Card title="Sui Bridge Node configuration" href="/guides/operator/bridge-node-configuration">
</Card>
</Cards>

```

../../Downloads/sui-stuff/sui-main/docs/content/standards.mdx
```
---
title: Sui Standards Overview
sidebar_label: Overview
---

Standards on the Sui blockchain are features, frameworks, or apps that you can extend or customize.

<Cards>
	<Card title="Closed Loop Token" href="standards/closed-loop-token" />
	<Card title="Coin" href="standards/coin" />
	<Card title="Deepbook" href="standards/deepbook" />
	<Card title="Kiosk" href="standards/kiosk" />
	<Card title="Kiosk Apps" href="standards/kiosk-apps" />
	<Card title="Sui Object Display" href="standards/display" />
	<Card title="Wallet Standard" href="standards/wallet-standard" />
</Cards>

```

../../Downloads/sui-stuff/sui-main/docs/content/references.mdx
```
---
title: References Overview
sidebar_label: Overview
---

Already familiar with Sui? Use these valuable resources to continue your development journey.

## Sui RPC

Reference the Sui framework and Sui RPC documentation for details of the code that powers the Sui blockchain. 

<Cards>

<Card title="GraphQL for Sui RPC" href="references/sui-graphql"/>
<Card title="JSON-RPC" href="references/sui-api">
Use GraphQL for the Sui RPC for new projects. Use the JSON-RPC reference for legacy projects that have not migrated to GraphQL yet.
</Card>
</Cards>

## Move

Move powers smart contract logic for the Sui blockchain. Use these resources to learn Move or refresh your memory.

<Cards>
<Card title="Sui framework" href="references/framework"/>
<Card title="The Move Book" href="https://move-book.com/">
The Move Book is a comprehensive guide to the Move programming language on the Sui blockchain.
</Card>
<Card title="The Move Reference" href="https://move-book.com/reference/">
The Move Reference documents the architecture and syntax of the Move programming language.
</Card>
</Cards>

## Sui CLI

Interact directly with Sui networks and its features using the Sui command line interface (CLI). The CLI is divided into separate base commands that target a specific set of features.

<Cards>
<Card title="Sui Client CLI" href="references/cli/client">
Create a client on a Sui network to generate addresses, access networks, and more with the Sui Client CLI.
</Card>
<Card title="Sui Client PTB CLI" href="references/cli/ptb">
Build, preview, and execute programmable transaction blocks directly from your terminal with the Sui Client PTB CLI.
</Card>
<Card title="Sui Move CLI" href="references/cli/move">
Access Sui Move functions on chain using the Sui Move CLI.
</Card>
</Cards>

## Sui IDE support

Use the [Move](https://marketplace.visualstudio.com/items?itemName=mysten.move) and [Move Trace Debugger](https://marketplace.visualstudio.com/items?itemName=mysten.move-trace-debug) extensions for VSCode to quickly navigate and edit your Move codebase, and debug execution traces.

<Cards>
<Card title="Move" href="references/ide/move"/>
<Card title="Move Trace Debugger" href="references/ide/debugger"/>
</Cards>



## Sui software development kits

Official software development kits (SDKs) available for Sui include the TypeScript SDK and Rust SDK.

<Cards>
<Card title="Sui TypeScript SDK" href="https://sdk.mystenlabs.com/typescript">
The Sui TypeScript SDK has its own microsite. Click this box to go there.
</Card>
<Card title="Sui Rust SDK" href="references/rust-sdk"/>
</Cards>

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/transactions.mdx
```
---
title: Transactions
---

All updates to the Sui database happen via transactions. This topic describes the transaction types supported by Sui and explains how their execution changes the ledger.  There are only two kinds of transactions on Sui:

- Programmable transaction blocks, which anyone can submit on the network.  For information on these transactions, see [Programmable Transaction Blocks](./transactions/prog-txn-blocks.mdx).
- System transactions, which only validators can directly submit and are responsible for keeping the network running (changing epochs, starting checkpoints, and so on).

## Transaction metadata

All Sui transactions have the following common metadata:

- **Sender address:** The [address](guides/developer/getting-started/get-address.mdx) of the user sending this transaction.
- **Gas input:** An object reference pointing to the object that will be used to pay for this transaction's execution and storage. This object must be owned by the user and must be of type `sui::coin::Coin<SUI>` (i.e., the Sui native currency).
- **Gas price:** An unsigned integer specifying the number of native tokens per gas unit this transaction will pay. The gas price must always be nonzero.
- **Maximum gas budget:** The maximum number of gas units that can be expended by executing this transaction. If this budget is exceeded, transaction execution will abort and have no effects other than debiting the gas input object. Consequently, the gas input object must have a value higher than the gas price multiplied by the max gas, and this product is the maximum amount that the gas input object will be debited for the transaction.
- **Epoch:** The Sui epoch this transaction is intended for.
- **Type:** A call, publish, or native transaction and its type-specific-data (see below).
- **Authenticator:** A cryptographic signature and a public key that both verifies against the signature and is cryptographically committed to by the sender address.
- **Expiration:** An epoch reference that sets a deadline after which validators will no longer consider the transaction valid. The optional expiration epoch reference enables users to define transactions that either execute and commit by a set time (current epoch less than or equal to expiration epoch), or never execute after the deadline passes. By default, there is no deadline for when a transaction must execute. 

## Transactions flow - example

Here's an example showing how objects and transactions are connected to each other in Sui.

In the following example there are two objects:
- Object A is a coin of type SUI with a total balance of 5 SUI
- Object B with 2 SUI coins that belongs to John

Tom decides to send 1 SUI coin to Alice. In this case, Object A is the input to this transaction and 1 SUI coin is debited from this object. The output of the transaction is two objects: 
- Object A with 4 SUI coins that still belongs to Tom
- new created Object C with 1 SUI coin that belongs now to Alice

At the same time, John decides to send 2 SUI coins to Anna. Because the relationship between objects and transactions is written in a directed acyclic graph (DAG), and both transactions interact with different objects, this transaction executes in parallel with the transaction that sends coins from Tom to Alice. This transaction changes only the owner of Object B from John to Anna.

After receiving 2 SUI coins, Anna sent them immediately to Tom. Now Tom has 6 SUI coins (4 from Object A and 2 from Object B).

Finally, Tom sends all of his SUI coins to John. For this transaction, the input is actually two objects (Object A and Object B). Object B is destroyed, and its value is added to Object A. As a result, the transaction's output is only Object A with a value of 6 SUI.

```mermaid
flowchart LR
    id1(Object A\nfa:fa-coins 5 SUI\n fa:fa-person Tom):::object-a;
    id2(Object C\nfa:fa-coins 1 SUI\n fa:fa-person Alice);
    id3(Object A\nfa:fa-coins 4 SUI\n fa:fa-person Tom):::object-a;
    id4(Object B\nfa:fa-coins 2 SUI\n fa:fa-person John):::object-b;
    id5(Object B\nfa:fa-coins 2 SUI\n fa:fa-person Anna):::object-b;
    id6(Object B\nfa:fa-coins 2 SUI\n fa:fa-person Tom):::object-b;
    id7(Object A\nfa:fa-coins 6 SUI\n fa:fa-person John):::object-a;
    id1-->|tx-1|id2;
    id1-->|tx-1|id3;
    id4-->|tx-2|id5;
    id5-->|tx-3|id6;
    id3-->|tx-4|id7;
    id6-->|tx-4|id7;
    classDef object-a fill:#f225;
    classDef object-b fill:#ff43;
```

## Limits on transactions, objects, and data

Sui has some limits on transactions and the data used in them, such as a maximum size and number of objects used. You can find these limits in the [`sui-protocol-config` crate](https://github.com/MystenLabs/sui/blob/main/crates/sui-protocol-config/src/lib.rs) of the Sui repo. The limits are defined in the `ProtocolConfig` struct and values set in the `get_for_version_impl` function.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/research-papers.mdx
```
---
title: Sui-Related Research Papers
sidebar_label: Research Papers
---

This document contains a list of research papers that are relevant to Sui and have been co-authored by at least one member of the team.
Some of the ideas of these papers are currently being integrated into Sui, others are in our roadmap, and others are not in our roadmap
but could be integrated in the future. Start with the [Sui Smart Contract Platform](/doc/sui.pdf) white paper, which contains
our latest design inspired by previous works below.

<div class="bg-sui-blue-light dark:bg-sui-gray-95 p-8 rounded-lg border border-solid border-sui-blue-dark">

<p class="text-sui-gray-80 text-xl font-bold italic">Latest</p>

## Mysticeti: Reaching the Limits of Latency with Uncertified DAGs {#mysticeti}

- **Link:** https://arxiv.org/pdf/2310.14821
- **Publication:** Network and Distributed System Security Symposium (NDSS), accepted for 2025
- **Relevance:** We introduce Mysticeti-C, the first DAG-based Byzantine consensus protocol to achieve the lower bounds of latency of 3 message rounds. Since Mysticeti-C is built over DAGs it also achieves high resource efficiency and censorship resistance. Mysticeti-C achieves this latency improvement by avoiding explicit certification of the DAG blocks and by proposing a novel commit rule such that every block can be committed without delays, resulting in optimal latency in the steady state and under crash failures. We further extend Mysticeti-C to Mysticeti-FPC, which incorporates a fast commit path that achieves even lower latency for transferring assets. Unlike prior fast commit path protocols, Mysticeti-FPC minimizes the number of signatures and messages by weaving the fast path transactions into the DAG. This frees up resources, which subsequently result in better performance. We prove the safety and liveness in a Byzantine context. We evaluate both Mysticeti protocols and compare them with state-of-the-art consensus and fast path protocols to demonstrate their low latency and resource efficiency, as well as their more graceful degradation under crash failures. Mysticeti-C is the first Byzantine consensus protocol to achieve WAN latency of 0.5s for consensus commit while simultaneously maintaining state-of-the-art throughput of over 200k TPS. Finally, we report on integrating Mysticeti-C as the consensus protocol into the Sui blockchain, resulting in over 4x latency reduction.

## Sui Lutris: A Blockchain Combining Broadcast and Consensus

- **Link:** https://arxiv.org/pdf/2310.18042
- **Publication:** Conference on Computer and Communications Security (CCS), 2024
- **Relevance:** Sui Lutris is the first smart-contract platform to sustainably achieve sub-second finality. It achieves this significant decrease by employing consensusless agreement not only for simple payments but for a large variety of transactions. Unlike prior work, Sui Lutris neither compromises expressiveness nor throughput and can run perpetually without restarts. Sui Lutris achieves this by safely integrating consensuless agreement with a high-throughput consensus protocol that is invoked out of the critical finality path but ensures that when a transaction is at risk of inconsistent concurrent accesses, its settlement is delayed until the total ordering is resolved. Building such a hybrid architecture is especially delicate during reconfiguration events, where the system needs to preserve the safety of the consensusless path without compromising the long-term liveness of potentially misconfigured clients. We thus develop a novel reconfiguration protocol, the first to provably show the safe and efficient reconfiguration of a consensusless blockchain. Sui Lutris is currently running in production and underpins the Sui smart-contract platform. Combined with the use of Objects instead of accounts it enables the safe execution of smart contracts that expose objects as a first-class resource. In our experiments Sui Lutris achieves latency lower than 0.5 seconds for throughput up to 5,000 certificates per second (150k ops/s with transaction blocks), compared to the state-of-the-art real-world consensus latencies of 3 seconds. Furthermore, it gracefully handles validators crash-recovery and does not suffer visible performance degradation during reconfiguration.

## zkLogin: Privacy-Preserving Blockchain Authentication with Existing Credentials

- **Link:** https://arxiv.org/pdf/2401.11735
- **Publication:** Not published
- **Relevance:** For many users, a private key based wallet serves as the primary entry point to blockchains. Commonly recommended wallet authentication methods, such as mnemonics or hardware wallets, can be cumbersome. This difficulty in user onboarding has significantly hindered the adoption of blockchain-based applications.
We develop zkLogin, a novel technique that leverages identity tokens issued by popular platforms (any OpenID Connect enabled platform e.g. Google, Facebook, etc.) to authenticate transactions. At the heart of zkLogin lies a signature scheme allowing the signer to sign using their existing OpenID accounts and nothing else. This improves the user experience significantly as users do not need to remember a new secret and can reuse their existing accounts.
zkLogin provides strong security and privacy guarantees. By design, zkLogin builds on top of the underlying platform's authentication mechanisms, and derives its security from there. Unlike prior related works however, zkLogin avoids the use of additional trusted parties (e.g., trusted hardware or oracles) for its security guarantees. zkLogin leverages zero-knowledge proofs (ZKP) to ensure that the link between a user's off-chain and on-chain identities is hidden, even from the platform itself.
We have implemented and deployed zkLogin on the Sui blockchain as an alternative to traditional digital signature-based addresses. Due to the ease of web3 on-boarding just with social login, without requiring mnemonics, many hundreds of thousands zkLogin accounts have already been generated in various industries such as gaming, DeFi, direct payments, NFT collections, ride sharing, sports racing and many more.
</div>

## Be Aware of Your Leaders {#awareness}

- **Link:** https://arxiv.org/abs/2110.00960
- **Publication:** Financial Cryptography and Data Security (FC), 2022
- **Relevance:** Provides a performant leader election algorithm for partially-synchronous consensus protocol (such as Bullshark). Sui may want to use it
  alongside Bullshark to support shared objects.
- **Summary:** Advances in blockchains have influenced the State-Machine-Replication (SMR) world and many state-of-the-art blockchain-SMR solutions are
  based on two pillars: Chaining and Leader-rotation. A predetermined round-robin mechanism used for Leader-rotation, however, has an undesirable behavior:
  crashed parties become designated leaders infinitely often, slowing down overall system performance. In this paper, we provide a new Leader-Aware SMR
  framework that, among other desirable properties, formalizes a Leader-utilization requirement that bounds the number of rounds whose leaders are faulty
  in crash-only executions. We introduce Carousel, a novel, reputation-based Leader-rotation solution to achieve Leader-Aware SMR. The challenge in adaptive
  Leader-rotation is that it cannot rely on consensus to determine a leader, since consensus itself needs a leader. Carousel uses the available on-chain
  information to determine a leader locally and achieves Liveness despite this difficulty. A HotStuff implementation fitted with Carousel demonstrates
  drastic performance improvements: it increases throughput over 2x in faultless settings and provides a 20x throughput increase and 5x latency reduction
  in the presence of faults.

## Bullshark: DAG BFT Protocols Made Practical {#bullshark}

- **Link:** https://arxiv.org/abs/2201.05677
- **Publication:** Not published yet (under submission)
- **Relevance:** Provides a partially-synchronous consensus protocol running over Narwhal. Sui may want to use it instead of Tusk.
- **Summary:** We present Bullshark, the first directed acyclic graph (DAG) based Byzantine Fault Tolerant (BFT) protocol that is optimized for partial synchrony.
  Bullshark inherits all the desired properties of its predecessor (DAG-Rider) such as optimal amortized complexity, asynchronous liveness, zero-overhead,
  and post-quantum safety; but at the same time Bullshark provides a practical low-latency fast-path that exploits synchronous periods. In addition, we introduce
  a standalone partially synchronous version of Bullshark and evaluate it against the state of the art. The resulting protocol is embarrassingly simple 20 LOC
  on top of a DAG-based mempool implementation) and highly efficient, achieving for example, 125k transactions per second and 2 seconds latency with 50 nodes.

## FastPay: High-Performance Byzantine Fault Tolerant Settlement {#fastpay}

- **Link:** https://arxiv.org/abs/2003.11506
- **Publication:** ACM Conference on Advances in Financial Technologies (AFT), 2020
- **Relevance:** FastPay describes the core protocol at the heart of Sui.
- **Summary:** FastPay allows a set of distributed validators, some of which are Byzantine, to maintain a high-integrity and availability
  settlement system for pre-funded payments. It can be used to settle payments in a native unit of value (crypto-currency), or as a financial
  side-infrastructure to support retail payments in fiat currencies. This is not the protocol Sui uses, yet it proposes the basic safety mechanism
  that Sui extends. FastPay is based on Byzantine Consistent Broadcast as its core primitive, foregoing the expenses of full atomic commit channels
  (consensus). The resulting system has low-latency for both confirmation and payment finality. Remarkably, each validator can be sharded across many
  machines to allow unbounded horizontal scalability.

## HammerHead: Score-based Dynamic Leader Selection

- **Link:** https://arxiv.org/pdf/2309.12713
- **Publication:** IEEE International Conference on Distributed Computing Systems (ICDCS), 2024
- **Relevance:** The need for high throughput and censorship resistance in
blockchain technology has led to research on DAG-based consensus. The
Sui blockchain protocol uses a variant of the Bullshark consensus
algorithm due to its lower latency, but this leader-based protocol causes
performance issues when candidate leaders crash. In this paper, we explore the ideas pioneered by Carousel on providing Leader-Utilization
and present HammerHead. Unlike Carousel, which is built with a chained
and pipelined consensus protocol in mind, HammerHead does not need
to worry about chain quality as it is directly provided by the DAG, but
needs to make sure that even though validators might commit blocks
in different views the safety and liveness is preserved. Our implementation of HammerHead shows a slight performance increase in a faultless
setting, and a drastic 2x latency reduction and up to 40% throughput
increase when suffering faults (100 validators, 33 faults).

## Narwhal and Tusk: A DAG-based Mempool and Efficient BFT Consensus {#narwhal-and-tusk}

- **Link:** https://arxiv.org/abs/2105.11827
- **Publication:** EuroSys, 2022
- **Relevance:** The consensus system that we will likely use to support shared-objects in Sui.
- **Summary:** We propose separating the task of reliable transaction dissemination from transaction ordering to enable high-performance Byzantine
  fault-tolerant quorum-based consensus. We design and evaluate a mempool protocol, Narwhal, specializing in high-throughput reliable dissemination
  and storage of causal histories of transactions. Narwhal tolerates an asynchronous network and maintains high performance despite failures. Narwhal
  is designed to easily scale-out using multiple workers at each validator, and we demonstrate that there is no foreseeable limit to the throughput we
  can achieve. Composing Narwhal with a partially synchronous consensus protocol (Narwhal-HotStuff) yields significantly better throughput even in the
  presence of faults or intermittent loss of liveness due to asynchrony. However, loss of liveness can result in higher latency. To achieve overall
  good performance when faults occur we design Tusk, a zero-message overhead asynchronous consensus protocol, to work with Narwhal. We demonstrate its
  high performance under a variety of configurations and faults. As a summary of results, on a WAN, Narwhal-Hotstuff achieves more than 130,000 tx/sec at
  less than 2-sec latency compared with 1,800 tx/sec at 1-sec latency for Hotstuff. Additional workers increase throughput linearly to 600,000 tx/sec
  without any latency increase. Tusk achieves 160,000 tx/sec with about 3 seconds latency. Under faults, both protocols maintain high throughput, but
  Narwhal-HotStuff suffers from increased latency.

## SybilQuorum: Open Distributed Ledgers Through Trust Networks {#sybilquorum}

- **Link:** https://arxiv.org/abs/1906.12237
- **Publication:** Not published
- **Relevance:** Less related to Sui than the other papers, and the paper is in its early stages. It presents an algorithm to strengthen proof-of-Stake systems (like Sui). The paper is, however, theoretical and not on our roadmap.
- **Summary:** The Sybil attack plagues all peer-to-peer systems, and modern open distributed ledgers employ a number of tactics to prevent it from proof
  of work, or other resources such as space, stake or memory, to traditional admission control in permissioned settings. With SybilQuorum we propose an
  alternative approach to securing an open distributed ledger against Sybil attacks, and ensuring consensus amongst honest participants, leveraging social
  network based Sybil defenses. We show how nodes expressing their trust relationships through the ledger can bootstrap and operate a value system, and
  general transaction system, and how Sybil attacks are thwarted. We empirically evaluate our system as a secure Federated Byzantine Agreement System, and
  extend the theory of those systems to do so.

## Twins: BFT Systems Made Robust {#twins}

- **Link:** https://arxiv.org/abs/2004.10617
- **Publication:** International Conference on Principles of Distributed Systems (OPODIS), 2021
- **Relevance:** Less related to Sui than the other papers, this provides a way to test implementations of consensus systems, such as Tusk and Bullshark.
  The paper is, however, theoretical and not on our roadmap.
- **Summary:** This paper presents Twins, an automated unit test generator of Byzantine attacks. Twins implements three types of Byzantine behaviors: (i)
  leader equivocation, (ii) double voting, and (iii) losing internal state such as forgetting 'locks' guarding voted values. To emulate interesting attacks
  by a Byzantine node, it instantiates twin copies of the node instead of one, giving both twins the same identities and network credentials. To the rest of
  the system, the twins appear indistinguishable from a single node behaving in a 'questionable' manner. Twins can systematically generate Byzantine attack
  scenarios at scale, execute them in a controlled manner, and examine their behavior. Twins scenarios iterate over protocol rounds and vary the communication
  patterns among nodes. Twins runs in a production setting within DiemBFT where it can execute 44M Twins-generated scenarios daily. Whereas the system at hand
  did not manifest errors, subtle safety bugs that were deliberately injected for the purpose of validating the implementation of Twins itself were exposed
  within minutes. Twins can prevent developers from regressing correctness when updating the codebase, introducing new features, or performing routine
  maintenance tasks. Twins requires only a thin wrapper over DiemBFT; we thus envision other systems using it. Building on this idea, one new attack and
  several known attacks against other BFT protocols were materialized as Twins scenarios. In all cases, the target protocols break within fewer than a dozen
  protocol rounds. Hence it is realistic for the Twins approach to expose the problems.

## Zef: Low-latency, Scalable, Private Payments {#zef}

- **Link:** https://arxiv.org/abs/2201.05671
- **Publication:** Not published yet (under submission)
- **Relevance:** Extends the FastPay design to support objects (rather than accounts), what Sui actually uses. An additional contribution of this paper is
  to add strong privacy to FastPay transactions (but Sui does not plan to do this).
- **Summary:** We introduce Zef, the first Byzantine-Fault Tolerant (BFT) protocol to support payments in anonymous digital coins at arbitrary scale. Zef
  follows the communication and security model of FastPay: both protocols are asynchronous, low-latency, linearly-scalable, and powered by partially-trusted
  sharded validators. Zef further introduces opaque coins represented as off-chain certificates that are bound to user accounts. In order to hide the face
  values of coins when a payment operation consumes or creates them, Zef uses random commitments and NIZK proofs. Created coins are made unlinkable using the
  blind and randomizable threshold anonymous credentials of [Coconut](https://arxiv.org/pdf/1802.07344.pdf). To control storage costs associated with coin
  replay prevention, Zef accounts are designed so that data can be safely removed once an account is deactivated. Besides the specifications and a detailed
  analysis of the protocol, we are making available an open source implementation of Zef in Rust. Our extensive benchmarks on AWS confirm textbook linear
  scalability and demonstrate a confirmation time under one second at nominal capacity. Compared to existing anonymous payment systems based on a blockchain,
  this represents a latency speedup of three orders of magnitude, with no theoretical limit on throughput.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/architecture.mdx
```
---
title: Architecture
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/tokenomics.mdx
```
---
title: Sui Tokenomics
---

The term "tokenomics" is a combination of two words, “token” and “economics”, that is generally used to describe the economic principles and behaviors of a blockchain. 

The “token” part of the tokenomics portmanteau refers to the native token (or native coin) of the blockchain. On Sui, the native coin is SUI, which acts as the currency of the network. SUI also pays for the computational cost of transactions (gas fees) and storage on the network. 

## Proof of stake

Sui uses a proof-of-stake (PoS) consensus mechanism. This means that validators (entities that validate transactions) lock up a certain amount of SUI as collateral (stake). They then earn rewards for processing operations. Users of the network hold their own SUI, which they can delegate to the validators of their choice as part of the validators' stakes. In so doing, the validators reward users based on the amount of SUI they delegate. Users are free to withdraw their SUI or to change their selected validator when the epoch changes.

![Sui tokenomics flow](./images/sui-tokenomics-flow.png "Flowchart showing the tokenomics structure.")

## Stakeholders

Stakeholders in a blockchain's tokenomics have a vested interest in the viability of the blockchain economy. The Sui economy has three main groups of stakeholders:

- **Users** submit transactions to the Sui platform to create, mutate, and transfer digital assets or interact with more sophisticated applications enabled by smart contracts, interoperability, and composability.
- **SUI token holders** have the option of staking their tokens to validators and participating in the proof-of-stake mechanism. SUI owners also hold the rights to participate in Sui governance.
- **Validators** manage transaction processing and execution on the Sui platform.

## SUI coin

As mentioned, the native coin of Sui is SUI. The coin uses the capitalized version of SUI to distinguish the coin from the Sui network. A sound policy to govern the native coin on a blockchain ensures stability and encourages growth. The Sui tokenomics structure is designed to support the long-term financial needs of Web3, not get-rich-quick schemes that have plagued the industry in the past.

The SUI coin serves four purposes on the Sui network:

- You can stake SUI to participate in the proof-of-stake mechanism.
- SUI is the asset denomination needed to pay the gas fees required to execute and store transactions or other operations on the Sui network.
- You can use SUI as a versatile and liquid asset for various applications, including the standard features of money - a unit of account, a medium of exchange, or a store of value - and more complex functionality smart contracts enable, interoperability, and composability across the Sui ecosystem.
- SUI coins play an important role in governance by acting as a right to participate in on-chain voting on issues such as protocol upgrades.

### Supply

The total supply of SUI tokens on Mainnet is capped at 10,000,000,000 SUI (ten billion). This is the total number of SUI that can ever be minted, but the total supply is not available for transactions. Supply availability follows the designed unlocking schedules in place to enhance the tokenomics stability of the network and provide a long-term level of security. 

There is a finite supply of SUI. The balance must support all economic activities to scale as more and more people migrate to the Sui platform. In addition, the presence of a storage fund creates important monetary dynamics, in that higher on-chain data requirements translate into a larger storage fund, reducing the amount of SUI in circulation.

### Distribution

At the beginning of each epoch, three important events happen:

- SUI holders stake (some) of their tokens to validators and a new [committee](https://docs.sui.io/guides/operator/validator-committee) is formed.
- The reference gas prices are set as described in [Sui Gas Pricing](https://docs.sui.io/concepts/tokenomics/gas-pricing).
- The [storage fund](#storage-fund) size is adjusted using the net inflow of the previous epoch.

Following these actions, the protocol computes the total amount of stake as the sum of staked SUI plus the storage fund.

During each epoch, users submit transactions to the Sui platform and validators process them. For each transaction, users pay the associated computation and storage gas fees. In cases where users delete previous transaction data, users obtain a partial [rebate of their storage fees](#storage-fund-rewards). Validators observe the behavior of other validators and evaluate each other's performance.

At the end of each epoch, the protocol distributes stake rewards to participants of the PoS mechanism. This occurs through two main steps:

- The total amount of stake rewards is calculated as the sum of computation fees accrued throughout the epoch plus the epoch's stake reward subsidies. The latter component is temporary in that it will only exist in the network's first years and disappear in the long run as the amount of SUI in circulation reaches its total supply.
- The total amount of stake rewards is distributed across various entities. The storage fund is taken into account in the calculation of the epoch total stake, which is not owned by any entities in the way that staked SUI is. Instead, the Sui economic model distributes the stake rewards accruing to the storage fund to validators for compensation of their storage costs.

The distribution mechanisms built into Sui tokenomics encourages a healthy competition for fair prices where validators set low gas fees while operating with viable business models. Refer to the https://docs.sui.io/paper/tokenomics.pdf whitepaper for in-depth review of the mathematical proofs that support this structure.

### Unlocking schedules

Sui tokenomics design includes a vesting schedule (or unlock schedule) that dictates when certain blocks of SUI become accessible to the market. Like most blockchains concerned with stability and long-term commitment, Sui tokenomics design includes a multi-tiered SUI unlock schedule.

When Sui first launched its Mainnet network (initial SUI mint), there was a one-year cliff period. During this time, all initial investors were blocked from transferring their initial stake of SUI to the marketplace. A common practice for new cryptocurrency, the cliff period protected early network stability against large-scale sell-offs from early investors. The cliff period ended in May 2024.

### Airdrops

Often, when a new coin or token launches, its minters set aside a percentage of the sum to distribute to early adopters to drive interest in the associated blockchain project. This process is termed an “airdrop”. 

There were no SUI airdrops to support the launch of Sui's Mainnet network. This was a publicly-stated, intentional decision for the following reasons: 

- Airdrops expose a potential for bad actors to take advantage of the excitement around a new launch. By publicly stating there would be no airdrops, Sui attempted to mitigate the risk its users faced.
- Cryptocurrency is regulated differently across the globe. Airdrops can be viewed as taxable events in some jurisdictions, creating legal or financial complications.
- Sui is committed to the long-term success of the network and its stakeholders. Airdrops might generate excitement early in a project's lifecycle, but the long-term benefits are minimal.

## Storage fund

As previously mentioned, SUI pays for the gas fees and data storage on the network. A potential problem arises, however, when new validators come on chain. Even though the validator is new, it still must pay the storage cost for activity that happened before it was part of the network.

Sui addresses this problem with the storage fund. The storage fund is essentially a cache of SUI that never fully depletes. Each on-chain transaction that adds data to the chain includes a fee for storage, which the protocol adds to the storage fund. The storage fund itself essentially has a stake in the network, so it collects rewards based on that stake, just like every other on-chain stakeholder. The protocol then regularly distributes those storage fund rewards to Sui validators to pay for storage. In this way, new validators to the network get paid for storing data from past transactions.

### Storage fund rewards

The Sui delegated proof-of-stake (PoS) mechanism calculates total stake as the sum of user stake plus the SUI tokens deposited in the storage fund. Hence, the storage fund receives a proportional share of the overall stake rewards depending on its size relative to total stake. The largest share of these stake rewards are paid out to current validators to compensate for storage costs. The rewards that remain are reinvested into the fund. In other words, stake rewards accruing to the storage fees submitted by past transactions are paid out to current validators to compensate them for data storage costs. When on-chain storage requirements are high, validators receive substantial additional rewards to compensate for their storage costs. Vice versa when storage requirements are low.

The storage fund includes three key features:

- The storage fund is funded by past transactions and functions as a tool for shifting gas fees across different epochs. This ensures that future validators are compensated for their storage costs by the past users who created those storage requirements in the first place.
- The storage fund pays out only the returns on its capital and does not distribute its principal. In practice, this essentially means validators borrow the storage fund's SUI as additional stake and keep the majority of stake rewards. Validators do not, however, receive funds directly from the storage fund. This guarantees the fund never loses its capitalization and can survive indefinitely. This feature is further buttressed by the stake rewards reinvested into the fund.
- The storage fund includes a *deletion option*. If you delete data, you get a partial refund of the storage fees paid originally.

### Deflation

The storage fund also contributes to the deflationary aspect of the network. Unlike traditional economics, deflation is a feature of Sui rather than a bug. The total supply of SUI is capped, so increased activity on the network has a deflationary effect as the storage fund grows in relation to the amount of data stored, which effectively takes more SUI out of circulation.  The store of value for SUI increases in relation to the decrease in circulating supply, promoting long-term investment in SUI for a strong network into the future. 

## Validator rewards

With traditional PoS blockchains, validator rewards are somewhat randomized based on the amount of stake a validator holds. As the validators reinvest their rewards, their stake compounds, as does the probability that they receive more rewards based on that growing stake.

Sui takes a novel approach to rewarding its validators to avoid this effect. All honest validators on Sui receive their staking rewards with full certainty. The rewards are based only on the amount of stake the validators hold, removing randomness from the equation. 

## Validators and staking pools

Each Sui validator maintains its own staking pool to track the amount of stake and to compound staking rewards. Validator pools operate together with a time series of exchange rates that are computed at each epoch boundary. These exchange rates determine the amount of SUI tokens that each past SUI staker can withdraw in the future. Importantly, the exchange rates increase as more rewards are deposited into a staking pool and the longer an amount of SUI is deposited in a staking pool, the more rewards it will accrue.

When SUI is deposited to the staking pool in epoch `E`, those SUI are converted into liquidity tokens at the epoch `E` exchange rate. As the staking pool earns rewards, the exchange rate appreciates. At epoch `E'`, those liquidity tokens are worth more and translate into more SUI.
The only difference between Sui staking pools and typical liquidity pools is that in Sui the liquidity tokens do not exist. Rather, the global exchange rate table is used to track the accounting. Because all SUI tokens in the staking pool are treated the same, regardless of whether they were originally deposited as new stake or as stake rewards, all SUI tokens immediately count as stake and thus compound rewards immediately.

The staking pool is implemented in a system-level smart contract ([staking_pool.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-system/sources/staking_pool.move)) and is part of the Sui framework.

### Validator pool exchange rate 

The exchange rate for each validator pool is calculated at each epoch boundary as follows:

Exchange rate at E+1 = ( 1 + ( third-party staker rewards at E / third-party stake at E )) ( exchange rate at E )

The distinction between third-party owned vs validator-owned rewards and stake is relevant in that validators earn commissions on the staking pool's tokens but third-party stakers do not. This accounting enables Sui to keep track of the rewards accrued by both validators and third-party token holders using a single global exchange rate table.

{@include: ../snippets/staking-pool-reqs.mdx}

#### Understanding the voting power formula

SIP-39 uses the following formula to determine if a validator can join the set:

```
S / (S + T) > V / 10000
```

Where:
- S = The validator candidate's stake amount
- T = Total amount already staked in the network
- V = Minimum voting power threshold (3 in the final phase)
- 10000 = Total voting power units in the Sui system

This formula checks if the validator would have at least V voting power after joining. Let's break it down:

1. S / (S + T) calculates what proportion of the total stake the validator would control
2. When multiplied by 10000, this gives their voting power in Sui's standardized units
3. The validator can join if this value is greater than or equal to the threshold V

For example, with a network stake of 7.69B SUI and V=3:
- A validator with 2.31M SUI would have: 2,310,000 / (2,310,000 + 7,694,950,773) ≈ 0.0003 proportion
- Converting to voting power: 0.0003 × 10000 ≈ 3 units
- Since 3 ≥ 3, they meet the threshold to join

As the total network stake changes, the minimum required amount will adjust automatically.

## Related links

- [The Sui Smart Contracts Platform: Economics and Incentives](https://docs.sui.io/paper/tokenomics.pdf): Whitepaper that details Sui tokenomics.
- [Gas fees](https://docs.sui.io/concepts/tokenomics/gas-in-sui): Gas fees are charged on all network operations and used to reward participants of the proof-of-stake mechanism and prevent spam and denial-of-service attacks.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/components.mdx
```
---
title: Sui Components
---

The name Sui, pronounced swē in English, is derived from a Japanese word for the element of water. You can see this influence in the name of the blockchain, its native token elements (SUI and MIST), and the imagery used in its branding. 

When you read about Sui in this documentation, it's referencing all the pieces of the system that comprise the blockchain. This includes the blockchain itself, its various networks (Mainnet, for example), the activity on the blockchain (transaction blocks), the distributed entities that verify this activity (validators), and the Full nodes that execute transaction blocks. The documentation refers to the entirety of these elements as the Sui platform, or simply Sui.

## The Sui blockchain

Sui is defined as a Layer 1 protocol blockchain. In basic terms, this means that Sui performs its own consensus and validation for transaction blocks (activity) on its networks using its own native token (SUI, in this case). Ethereum (ETH) and Bitcoin (BTC) are other examples of Layer 1 blockchains. 

Layer 2 blockchains, by contrast, leverage the infrastructure of Layer 1 networks, relying on the Layer 1 blockchain to finalize transaction blocks. Polygon (MATIC) is an example of a Layer 2 blockchain that extends Ethereum.

## SUI tokens

The native token for Sui is SUI. Whenever the documentation mentions SUI (all uppercase letters), it's referring to this token. Transaction blocks on Sui often deal with small fractions of the value of one SUI. To make these transaction blocks easier to work with, Sui provides MIST. It takes one billion MIST to equal one SUI. 

There is a cost associated with everything, and blockchain transactions are no exception. It costs money to provide computational power to process transaction blocks and store their results. The term for the cost of processing transaction blocks is "gas". You pay for gas and the cost of storing data with a blockchain's native tokens, in this case, SUI (or MIST).

To learn more about the tokenomics of Sui, see the following topics:

- [Sui Tokenomics](./tokenomics.mdx)
- [Gas in Sui](./tokenomics/gas-in-sui.mdx)
- [Gas Pricing](./tokenomics/gas-pricing.mdx)
- [Staking and Unstaking](./tokenomics/staking-unstaking.mdx)
- [Sui Bridging](./tokenomics/sui-bridging.mdx)

## Delegated proof-of-stake consensus

Sui uses a delegated proof-of-stake (DPoS) consensus mechanism to validate on-chain transaction blocks. This means that validators on the Sui network must have a certain amount of SUI secured on Sui Mainnet, either with their own funds or in partnership with Sui Foundation, to prove their interest in the security of the blockchain. This approach aligns the interest of all validators with that of Sui users (an efficient, secure blockchain), without the high energy-resource demands of earlier blockchains. 

To learn more about consensus on Sui, see the following guides and topics:

- [Validator Committee](guides/operator/validator-committee.mdx)
- [Sui Full Node Data Management](guides/operator/data-management.mdx) 

## Sui networks

Sui has several networks available, each serving a different purpose.

- **Mainnet:** The network that processes production transaction blocks. When you trade SUI or NFTs that are ultimately based on fiat currency, you are doing so on the Mainnet network of Sui.
- **Testnet:** Staging network to provide quality assurance that any planned changes to Sui do not adversely impact performance. Developers can use this network to test their code before placing it in production.
- **Devnet:** A more unstable network that is used to develop new features. Developers can leverage this network to code against the latest planned features of Sui.
- **Localnet:** You can run a Sui network on your local computer. Developing on a local network provides an optimized workflow in an environment you control. 

To learn more about these networks and how to interact with them, see the following guides:

- [Create a Local Sui Network](guides/developer/getting-started/local-network.mdx)
- [Connect to Sui](guides/developer/getting-started/connect.mdx)

## Move

The Move language provides the logic for all activity on Sui, like trading NFTs, playing Sui-integrated games (dApps), and all other transaction-based events. The Sui platform uses a concept novel to earlier blockchains, where blocks on the chain are actually objects that define assets rather than simple key-value stores that define addresses. The increased programmability inherent with objects required a more robust logic engine to maximize the benefits of this new approach to blockchain technology. 

To learn more about Move, see [Move Concepts](./sui-move-concepts.mdx).

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/gaming.mdx
```
---
title: Gaming on Sui
description: Sui offers features like dynamic NFTs, kiosks, soulbound assets, and on-chain randomness, to provide builders with the tools to create immersive, transparent, and fair gaming experiences.
---

import YTCarousel from "@site/src/components/YTCarousel"

Gaming on Sui leverages blockchain technology to enhance in-game economies, ownership, and interactions. With features like dynamic NFTs, kiosks, soulbound assets, and on-chain randomness, Sui provides builders with the tools to create immersive, transparent, and fair gaming experiences. Players benefit from true asset ownership, decentralized marketplaces, and seamless Web3 integration without compromising usability.

This topic explores the key features of Sui for gaming, real-world use cases, and essential tools for builders. Whether you're building an RPG, a racing game, or a digital card game, Sui provides the Web3 infrastructure to power your next-generation gaming projects.

## Representing in-game objects on chain

One of the aspects that defines a Web3 game is having objects within the game reside on a blockchain. Whether it's in-game currency, battle passes, skins, or any number of other objects, knowing how to create and integrate these items is the first step in building the desired user experience on Sui.

### In-game currencies

In-game currencies allow users to purchase game features like items, upgrades, and premium content. Before Web3, these currencies remained only in the game and their values were set by the game developers. 

Using Sui, players can now have true ownership of their in-game currency. The currency exists as a token on the Sui blockchain, where players can conceivably buy, sell, or swap that currency for anything else that also lives on chain. If you create an ecosystem of games, players can purchase currency in one of your games but spend it in another one that also uses that same currency. The possibilities are vast, but you must first learn how to create the currency. The following topics can get you started.

- [Coin Standard](../standards/coin.mdx)
- [In-Game Currency](../guides/developer/coin/in-game-token.mdx)

### Tokens

Similar to in-game currencies, tokens provide a level of engagement and control integrated into the game experience that isn't possible without Web3. For example, you can create tokens associated with your game that reward loyalty amongst your user base. You can also produce regulated tokens that allow the bearer of a specific capability to control the addresses that have access to the token, facilitating gated access to special events, leagues, or other game features. The following topics provide more insight into tokens on Sui.

- [Regulated Coin and Deny List](../guides/developer/coin/regulated.mdx)
- [Loyalty Tokens](../guides/developer/coin/loyalty.mdx)
- [Closed-Loop Token](../standards/closed-loop-token.mdx)

### Game features

NFTs are able to represent many traditional game features. For example, in-game objects, battle passes, rewards, skins, game cards or keys, and loot boxes are just a few of the features that you can create using NFTs on Sui. The following topics and sections provide more details.

- [Create a Non-Fungible Token](../guides/developer/nft.mdx)
- [Soulbound assets](#soulbound-assets)
- [Game economies](#game-economies)
- [Sui Object Display](#sui-object-display) 

### Dynamic assets {#dynamic-assets}

On Sui, everything is an object and all objects are NFTs. For the purpose of the gaming discussion, you can also think of these NFTs as game assets. 

You can view an object on Sui as a key-value pair data structure. In Move, the smart contract language of Sui, objects are defined as a `struct`. As an example, consider the game board of a tic-tac-toe game: 

{@inject: examples/tic-tac-toe/move/sources/owned.move#struct=Game noComments}

The first key-value pair for any object is `id: address`, which is a unique value of type `UID`. Every object has a different address, which is why every object is an NFT because this mandatory key-value pair sets each object apart and makes it unique.

#### Creating assets

Smart contracts contain the functions that create objects. Using the previous example, the function (`new`) that creates the object represented (a digital tic-tac-toe gameboard) provides the values for each attribute. The Sui framework creates the UID that uniquely identifies this particular game.

{@inject: examples/tic-tac-toe/move/sources/owned.move#fun=new noComments}

This is an on-chain action, or transaction. In this case, the transaction is a request to the chain to create an object. You provide the necessary data to the function and pay the gas fee for the computation effort of the network validators. The result is the creation of a new NFT that exists on the Sui blockchain at the address (`id`).

#### Updating assets

On Sui, you can update an NFT asset using a separate transaction, provided the smart contract that defines the NFT allows it. Similar to creation, you provide data to the relevant update function and pay the gas fee, and the smart contract updates the object at the correct address with the new information. 

Using the tic-tac-toe example, you might instruct the smart contract to update the gameboard object to place an `x` on an available square. Because the computation effort required for most updates is less than the effort to create the original object, the resulting gas fees are typically less, as well.

For more information on the computation of gas fees, see [Sui Gas Pricing](./tokenomics/gas-pricing.mdx).

#### Composing assets

On Sui, you can include one object inside of another (dynamic fields). For example, an object named `Parent` might contain objects of type `Child`. The smart contract can provide the necessary functions to add and remove the child objects from their parents. 

{@inject: examples/move/dynamic_fields/sources/example.move#struct=Parent,Child}

The function to add child objects to a parent might resemble the following. In this case, `ofield` is an alias for the `sui::dynamic_object_field` package.

{@inject: examples/move/dynamic_fields/sources/example.move#fun=add_child}

You can apply dynamic fields to many use cases. An object named `TicketBooth`, for example, could contain objects of type `ConcertTicket`. An object of type `Car` might have a field named `is_functioning` that is `false` until all necessary objects (`Engine`, `Tires`, `Body`, `Wheel`) are present, at which point it can automatically update its `is_functioning` field to `true`.

Composability is a really important feature of Sui. While it provides many options when developing an idea on Sui, it also allows building on top of existing projects, using third-party assets in your project. This can range from “*Only users who own a particular NFT are eligible for a discount*” to full collaboration between two distinct projects and everything in between on the smart contract level.

#### Transfer to object

Sui enables more use cases with the transfer to object feature, which allows an owned object to be sent to another object (shared or owned). In this case, the sent object appears as owned by the parent object. In the above examples, the objects are wrapped inside other objects and this can be seen in the parent object's metadata when inspecting the parent object.

When an object is sent to another object, the metadata of the parent object remain the same, but its `id` has a new object. This feature can enable use cases such as on-chain wallets where a `Wallet` object is used to deposit other objects. Combining this with transfer to object can lead to complex and exciting use cases.

See [Transfer to Object](./transfers/transfer-to-object.mdx) for more details on how to effectively transfer objects to other objects on Sui.

#### Deleting assets

On Sui, you can delete an object if the smart contract allows the operation. If the correct smart contract function is present, then you can delete the object in a single transaction. This results in a gas-fee rebate, which happens whenever bytes are freed on chain. The transaction's gas payer receives a rebate to account for the future storage of the object no longer being necessary but having already been paid for. See the [Storage fund](./tokenomics#storage-fund) section in Tokenomics to learn more about rebates. 

### Soulbound assets {#soulbound-assets}

A soulbound asset is an NFT that belongs to an address and cannot be transferred or deleted. On Sui, assets are usually freely transferable between addresses, but this is undesirable behavior in some cases.

Assets such as game season passes, loyalty accrual assets, avatars, identification assets for a product, and assets that grant certain privileges at the smart contract level are well-suited to be bound to an address without the option of transfer or deletion.

On Sui, it is straightforward to implement such an asset, and the infrastructure guarantees that the desired behavior always holds.

You define an NFT asset as soulbound at the contract level. After designated as soulbound, it cannot be converted to a normal transferable asset. Changing it would require creating a new asset with the same name and a migration strategy, such as deleting the soulbound asset and creating a normal one to take its place.

Soulbound assets are created by omitting the `store` ability. Without this ability, you cannot store soulbound assets inside other objects. Keep this behavior in mind when deciding the asset type. This means that Soulbound assets are not fully composable; they can store other assets but cannot be stored inside other assets.

The same pattern can be used to implement NFT assets that are transferable/burnable only under certain circumstances. You can define these circumstances at the smart contract level by making the asset soulbound and defining custom transfer and burn functions.

### Sui Object Display {#sui-object-display}

The Sui Object Display standard is a tool that helps define how objects appear in apps and interfaces. It works like a template where you can insert data from an object to control how it's displayed. Use it to manage how different types of data are shown, even if the data itself is stored on chain while the display happens off chain (in apps or websites).

The Sui Object Display standard provides several key benefits and components:

- Controlled representation: Manages how assets are displayed online without directly interacting with the underlying asset. You can make updates to the display independent of the assets and affect how all assets of type `<T>` are displayed.
- Flexibility: No limits on the fields you can customize.
- Enhancing asset information: Similar to enhancing ERC721 or ERC1155 NFTs with extra details, the Sui Object Display allows you to add specific details to your digital items, such as names, descriptions, images, and more.
- Stored data and off-chain representation: Manages stored data based on metadata standards and controls how it's represented off chain.
- Dynamic display: Ensures a uniform presentation of shared attributes across all NFTs of type `<T>`, maintaining a consistent representation of common fields (such as image URLs derived from unique IDs) and a cohesive display format across the asset collection.

There are a few limitations to be aware of. First, the current structure of Sui Object Display is per type, limiting its scope. Secondly, its structure does not allow for nested attributes or enums.

#### Implementation overview

At a high level, you implement this feature using the following steps:

1. Use a `Publisher` object you own to set `sui::display` for a specific type.
2. Sui Move's `Display<T>` defines how different types look. For example, `Display<0x2::capy::Capy>` shapes the appearance of a type.
3. Sui Full nodes use Display definitions to organize data when requested with `{ showDisplay: true }` in queries.

A display is a map of keys and values, both strings. Values allow for string interpolation, meaning the value changes dynamically depending on the NFT being viewed.

A basic example is to create a `Display` for `Asset` objects:

```move
public struct Asset has key, store {
  id: "0x3301",
  expiration: 123456789
}

public struct Display has store {
  "random_field": "The id is {id} and it expires at {expiration}"
}
```

The above `Display` as is defined, for the example `Asset` will become:

```jsx
Display
{
  "random_field": "The id is 0x3301 and it expires at 123456789"
}
```

For another Asset, the `id` and `expiration` values change according to the new `Asset`s values.

An app can use the `Display` object, where any custom keys can be understood. By default, most third-party apps like explorers or wallets recognize the attributes described below.

- `name`: A name for the object, displayed when users view the object.
- `description`: A description for the object, displayed when users view the object.
- `link`: A link to the object for use in an application.
- `image_url`: A URL or a blob with the image for the object.
- `thumbnail_url`: A URL to a smaller image for use in wallets, explorers, and other products as a preview.
- `project_url`: A link to a website associated with the object or creator.
- `creator`: A string indicating the object creator.


See [Sui Object Display](../standards/display) for more details on the standard.

{/*Minting → Minting Strategies*/}
 
## Game economies

Designing and managing tokens and coins on the Sui blockchain is crucial to creating a viable game economy. 

### GameFi

GameFi (Gaming Finance) combines gaming with blockchain-based financial incentives. It provides players with economic benefits through token rewards for in-game achievements. The recent rise of GameFi has led to significant growth in token launches to support gaming ecosystems.

The terms that follow are frequently used when discussing GameFi, so it's important to make sure your definition of the terms match the documentation.

- Token generation event (TGE): The first creation and distribution of tokens.
- Initial coin offering (ICO): An early fundraising model using token sales.
- Vesting: The gradual release of tokens over time.
- Staking: Locking tokens to participate in network operations and earn rewards.
- Cliff: An initial waiting period before token vesting begins.
- Annual percentage yield (APY): The effective return on a staked asset over a year.
- Decentralized autonomous organization (DAO): A governance model where decisions are made using smart contracts and tokens.
- Governance token: A token granting voting power in decentralized networks.

### Token economics (Tokenomics)

Tokenomics refers to the model and design of the rules that govern tokens for a Web3 ecosystem. In the case of GameFi, it defines how a token is created, distributed, utilized, and maintained within your gaming platform. Some of the features that comprise a token's economics include supply details, distribution mechanisms, staking and vesting.

There are several types of token supply that are considered when discussing tokenomics for an on-chain ecosystem.

| Supply type | Description |
| --- | --- |
| Total supply | Maximum number of tokens that will ever exist. |
| Circulating supply | Tokens currently in use and available for trading. |
| Adjusted supply | Tokens adjusted after burning or minting events. |
| Fixed supply | A predetermined number of tokens with no future changes. |

There is more than one type of distribution mechanics, but they are not necessarily all used.

| Distribution mechanisms | Description |
| --- | --- |
| Initial distribution | Through ICO, TGE, airdrops, or private sales. |
| Ongoing distribution | Through staking, liquidity mining, or incentive programs. |

Ongoing distribution refers to staking and vesting of GameFi tokens. Not all game economies include staking or vesting models. When deciding whether yours should, consider the benefits:

- Encourages long-term participation.
- Reduces circulating supply, potentially stabilizing token prices.
- Rewards active participants in the ecosystem.
- Rewards team members over the course of their involvement. 

To learn more about token vesting strategies, see [Token Vesting Strategies](./tokenomics/vesting-strategies.mdx).

When deciding how best to launch your tokens, it's important to consider some key points:

- Should you go with a fixed or adjusted supply of coins? A fixed supply means all tokens mint at the TGE. Adjusted supply requires careful control over minting and burning functions.
- Does your token need to be regulated? A regulated coin provides greater control over who has access to your token but comes at the cost of additional maintenance of a deny list. You can learn more about regulated tokens at [Regulated Coin and Deny List](../guides/developer/coin/regulated.mdx).
- Consider your metadata requirements, as well.
    - Decimal places: Predefine precision of the token.
    - Metadata management: Determine if metadata should be immutable.
    - Burning mechanisms: Define rules for token burning.

### Kiosk

On Sui, owned objects are either freely transferable or non-transferable. To ensure royalties, Sui provides a standard called Kiosk. A kiosk is a shared object that restricts access to a single address or user. See [Sui Kiosk](../standards/kiosk.mdx) for an in-depth look at the Kiosk standard. 

The kiosk "owner" (although a shared object has no owner from the perspective of Sui, the smart contract ensures that only one address is permitted to access it) is allowed to:

- Place Assets from their address inside the Kiosk.
- Take Assets from the Kiosk back to their address.
- Lock Assets from their address or already placed inside the Kiosk, making the “take” operation impossible.
- Destroy a Kiosk that has no Assets inside.
- List an Asset for sale with a price denoted in SUI.
- List an Asset for sale only to a specific address, with the price denoted in SUI.

Any other address is allowed to:

- Buy an item that has undergone the “list” operation.
- Buy an item meant for a specific address if the asset was “listed” in such a way.

The adoption of Kiosks implies that marketplaces become aggregators of “listed” items inside different Kiosks.

An Asset that has undergone the “lock” operation cannot undergo the “take” operation anymore; it can only undergo the “list” operation.

### Transfer Policy

The “buy” operation requires the use of another Object called Transfer Policy. This is usually a Shared Object and contains Rules that govern the “buy” operation, the most common Rule being “Royalties.”

A “buy” operation cannot be completed for an Asset without a defined Transfer Policy.

An empty Transfer Policy, one that does not have Rules, means that the Asset is freely tradable. Since Kiosk only allows the “list” and “buy” pair of operations, a transfer is possible by setting the price to 0 SUI.

Rules can be anything programmable with Move. To use marketplaces, an Asset creator should use Rules defined in https://github.com/MystenLabs/apps/tree/main/kiosk/sources/rules

Common Rules include:

- **Royalty Rule:** A percentage of the price that goes to the Asset creator (practically it goes inside the Transfer Policy and the creator may transfer it at any point in time).
- **Floor Price Rule:** A minimum price that an Asset may be “listed” for.
- **Lock Rule:** Enforce the Asset to be locked inside a Kiosk after a “buy” operation.

The combination of the Lock Rule and the Royalty Rule enforces royalties to be paid to the creator. The Lock Rule ensures an Asset cannot be “taken” out of a Kiosk (to be freely traded), while the Royalty Rule ensures that any Asset traded through Kiosk will have royalties deducted from the transaction.

Adding the Lock Rule is recommended when royalties are a strict requirement. As long as marketplaces support only Kiosk on Sui, even without the Lock Rule, users may not have other options. It is safe to assume that peer-to-peer trading is unsafe, and most, if not all, users will avoid it since there is no way to ensure the transaction will take place smoothly. In peer-to-peer transactions, someone has to initiate either the Asset transfer or the payment transfer, and there are no guarantees that the follow-up will take place.

The most important thing is during the initial airdrop or minting of the asset to ensure the Asset is put inside a Kiosk and not sent to an address directly.

## Tools

There are a number of tools available in the Sui ecosystem to help you realize your Sui game vision.

<Tabs>

<TabItem label="Playtron GameOS" value="playtron-os" >

Playtron GameOS is a Linux-based operating system that seeks to turn PCs, handhelds, and desktops into dedicated gaming consoles. It supports multiple game stores like Steam and Epic Games, offering a seamless gaming experience across devices such as Steam Deck, ROG Ally, and Lenovo Legion Go. 

https://www.playtron.one/playtron-os 
</TabItem>

<TabItem label="E4C: Ludus" value="ludus" >

E4C: Ludus is a cross-platform gaming layer designed to unify Web2 and Web3 gaming experiences on a single platform. Leveraging the Sui blockchain, it offers developers access to dynamic NFTs and zkLogin, facilitating integration of blockchain features into games across various platforms. The native E4C token is its primary currency, enabling in-game purchases and transactions. E4C: Ludus also provides a unified frontend for players to access a range of games, with the aim to enhance user engagement and simplify the gaming experience. The platform is set to launch globally in 2025, with a demo currently available for users to explore. 

https://ludus.ambrus.studio/ 
</TabItem>
<TabItem label="Sui Coins" value="suicoins" >

Sui Coins is the utility layer for tokens and NFTs on the Sui network, offering asset management tools that include token swaps, automated dollar-cost averaging, airdrops, an incinerator for deleting assets, zkSend for private transfers, and a merger tool to consolidate small balances. Sui Coins also features an open-source SuiCoins Terminal for integrating crypto swaps across platforms.

https://www.suicoins.com/ 
https://terminal.suicoins.com/
</TabItem>
<TabItem label="Beamable" value="beamable" >

Beamable is a development platform that helps you integrate live services and backend features into your games. It offers SDKs for both Unity and Unreal Engine, facilitating development and deployment of online game functionalities. You can incorporate features such as player authentication, inventory management, and microservices within the environments of your chosen game engines. Beamable provides support for the Sui blockchain, allowing for the integration of Web3 elements like NFTs and on-chain assets into games. The Beamable SDKs offer tools and sample projects to help you build on the Sui network.

https://beamable.com/ 
</TabItem>
<TabItem label="Forge.gg" value="forge" >
Forge is a platform that enables game developers to create custom loyalty programs, rewarding players for engaging in community activities and in-game challenges. Players earn loyalty points by completing actions you define, which can be redeemed for in-game items and digital content. Forge also offers analytics tools to help developers understand their audience and improve monetization strategies.

https://forge.gg/
</TabItem>
<TabItem label="Snag Solutions" value="snagsolutions" >

Snag Solutions provides white-label loyalty and marketplace platforms to enhance community engagement and control your digital ecosystems. Their solutions enable you to track and reward user contributions, create customizable marketplaces, and integrate social features like peer-to-peer trading and user profiles. Snag Solutions offers customization options, APIs, and SDKs to align with your brand's identity.

https://www.snagsolutions.io/ 
</TabItem>
<TabItem label="Venly" value="venly" >

Venly is a developer platform that aids blockchain integration for businesses through secure digital wallets, tokenization services, and payment solutions. It offers APIs and SDKs for management of digital assets. Venly enables you to create, trade, and manage NFTs, tokens, and payments securely while maintaining full ownership of your assets.

https://www.venly.io/ 
</TabItem>

</Tabs>

## Videos

Cycle through the available videos using the thumbnails, then tap or click the video to play.

<YTCarousel ids={["qnnXCO5cXu4","h-csO8Z9g3o","uwtF8jFXX1U","OBNbxqoLPiw","udzx0vXEpjc","6mjj3isfrs0","K2ufEN6zzpM","P70R_p0xQEg","e4FWIupRehA"]}/>

## Example integrations

There aren't real-world implementations for the integrations described in this section. These examples are meant to be a thought exercise to showcase the possibilities for viable game integration on the Sui network. 

<Tabs>
<TabItem label="ShadowQuest" value="shadowquest">
ShadowQuest is a multiplayer game that combines fantasy with RPG battle mechanics. To enhance the gaming experience with Web3 technologies, ShadowQuest is integrating with Sui offering seamless blockchain interactions to players without compromising the overall gaming experience.

**Seamless player onboarding and wallet integration**
    
ShadowQuest wants to onboard players without adding complexity, especially those unfamiliar with Web3. By using [zkLogin](../concepts/cryptography/zklogin.mdx), users can sign in using social platforms like Google, Facebook, Twitch, and Apple. This automatically creates a Sui wallet linked to their ShadowQuest account, making blockchain interactions seamless.
    
**Simplified transaction handling**
    
Players in ShadowQuest earn or use in-game assets such as NFTs or $SHADOW tokens. To attract users unfamiliar with Web3, ShadowQuest manages game transactions to avoid Web3 friction, like wallets popping up for signing transactions. By sponsoring user transactions, the friction is minimized because ShadowQuest users do not directly pay for transaction costs and gas fees.
    
Enoki transactions can be signed without requiring confirmation from the user to approve the transaction.
    
ShadowQuest uses Enoki Gas Pool to sponsor transactions, covering gas fees for players. This ensures all in-game transactions are seamless and cost-free for players, providing a better user experience.
    
**NFT marketplace and royalty enforcement**
    
ShadowQuest allows players to buy, sell, or trade in-game items, such as weapons, armor, and cosmetics. The items should respect royalties to ensure that creators benefit from each transaction.
    
Kiosk provides a decentralized marketplace solution, ensuring royalties are enforced on all NFT trades. This helps both the game developers and creators maintain control over secondary sales, ensuring revenue generation throughout the asset's lifecycle.
    
**NFT usage for game access**
    
ShadowQuest uses NFTs as entry tickets for different game modes and events. Players can acquire or earn various Runes, which grant access to specific game challenges or seasonal competitions. These NFTs cannot be traded or transferred to other players.
    
Soulbound NFTs represent different Runes that are either earned through gameplay or purchased. These NFTs grant exclusive access to matches and seasonal challenges but cannot be traded after bound to a player.
</TabItem>

<TabItem label="Sui for Speed" value="sui-for-speed">
Sui for Speed is a racing game set in the Sui ecosystem. Players pilot customizable vehicles through fantastical terrains, competing in races, time trials, and exploration challenges. By integrating with the Sui network's blockchain technology—including features such as Walrus, dynamic NFTs, SuiNS, and asset tokenization—the game offers players true ownership of their vehicles and in-game assets, along with a vibrant, player-driven economy.

**Customizable vehicles with dynamic NFTs**

In Sui for Speed, players own racing vehicles represented by dynamic NFTs that you can upgrade and customize with new parts, skins, and abilities. As players progress and win races, their vehicles evolve, reflecting their achievements and style.

Dynamic NFTs on the Sui network allow vehicles to securely update attributes and metadata over time. Every upgrade and customization is recorded on-chain, ensuring each vehicle's uniqueness and authenticity.

**SuiNS: Personalized racer profiles and teams**

Players can register unique names for their racer profiles and teams using SuiNS, like speedster@suiforspeed.sui or dragonracer@suiforspeed.sui. This simplifies social interactions, team coordination, and improves the community aspect of the game.

SuiNS provides a decentralized domain naming system, allowing memorable and personalized names on the blockchain.

**Tokenized circuits and earnings from circuit usage**

Race circuits are tokenized as unique NFTs allowing players to own, design, and vote to enable track customization and drive better changes. When other players race on these circuits, the owners earn $RALLY tokens as usage fees or royalties. This system incentivizes creativity and allows players to monetize their track designs.

Asset tokenization on the Sui network enables minting of circuits as unique assets with secure ownership. Smart contracts automatically distribute earnings to circuit owners when their tracks are used, enhancing the game's economy through player-driven content.

**Decentralized storage for game data**

The game world includes extensive data such as track designs and leaderboards. Leveraging decentralized and efficient storage, combined with asset tokenization, enables true decentralization of these terrains and models.

Walrus offers scalable off-chain storage for large amounts of game data. This ensures high availability and security, protecting against data loss and enhancing player trust.

**Competitive events and betting mechanisms**

The game hosts regular competitive events and tournaments where players can participate individually or as teams. Additionally, players can place bets on race outcomes using $RALLY tokens, adding an extra layer of excitement and engagement.

On-chain logic enables secure and transparent management of events and betting systems. The Sui network ensures fairness, with immutable records of bets and outcomes.
</TabItem>

<TabItem label="ArcaneBattles" value="arcanebattles">
ArcaneBattles is a strategic, multiplayer card game inspired by classics like Hearthstone. Players collect, trade, and battle with a variety of magical cards representing spells, creatures, and heroes. By integrating with the Sui blockchain, ArcaneBattles aims to enrich the gameplay experience through decentralized features that promote true ownership, fairness, and a dynamic in-game economy.

**Dynamic in-game economy with two closed loop tokens**

ArcaneBattles implemented two stable in-game currencies to facilitate various transactions, enhancing player engagement and economic depth.

**Closed loop token (CLT)**
    
ArcaneBattles utilizes two Closed Loop Tokens within its ecosystem:

1. Arcane Gems: The primary in-game currency used to purchase card packs and enter tournaments. Players earn Arcane Gems through gameplay achievements, daily quests, and participating in events. This token ensures that all players have access to essential game features without exposure to external market volatility.
2. Mystic Dust: A secondary token obtained by discarding unwanted cards. Mystic Dust is used to craft new cards and upgrade existing ones to "gold" versions, which have enhanced visuals and possibly minor gameplay benefits. This mirrors the crafting system in games like Hearthstone, allowing players to strategically manage their collections and customize their decks.

The dual-token system adds depth to the in-game economy, encouraging players to engage in various activities and make strategic decisions about resource allocation.

**True ownership and NFT card rental**

ArcaneBattles allows players to own their cards as NFTs and provide a rental marketplace for rare or powerful cards.
    
Each card in ArcaneBattles is represented as an NFT on the Sui blockchain, granting players true ownership of their digital assets. The NFT Rental feature allows players to rent out their rare or high-level cards to others for a fee. This creates a community-driven economy where new or casual players can access powerful cards temporarily, while owners earn passive income from their collections.

**Fair and unpredictable gameplay**

ArcaneBattles ensures randomness in card draws and in-game events to prevent manipulation and enhance fairness.
    
By leveraging Sui's on-chain randomness, ArcaneBattles introduces unpredictable elements such as random card draws, critical hit chances, and random effects from certain cards. This randomness is verifiable and secure, preventing manipulation by any party and maintaining fairness across all gameplay aspects.
    
**Enhanced card visualization and dynamic wear mechanism**

ArcaneBattles provides rich, dynamic displays of card information and introduces a wear-and-tear mechanic to simulate card degradation over time.
    
ArcaneBattles uses Sui's Display Standard to offer detailed metadata for each card NFT, including stats, abilities, and artwork. Beyond static information, the game introduces a dynamic display mechanism where cards visually show signs of wear as they are used in battles. Over time, frequently used cards may appear scratched, faded, or have other visual cues indicating wear. After extensive use, cards have a chance to be destroyed entirely.

This wear-and-tear mechanic simulates the experience of physical card games, where rare cards are often kept in pristine condition and used sparingly. It encourages players to strategically decide when to use their valuable cards and adds a layer of depth to the game's economy and strategy.

Players can mitigate or repair wear on their cards by using **Mystic Dust** to restore them or upgrade them to gold versions, which are more durable and feature enhanced visuals. This system adds a strategic resource management element, as players must balance the benefits of using powerful cards against the potential cost of their degradation.

By integrating these Sui blockchain features, ArcaneBattles not only enhances the gaming experience but also pioneers the next generation of digital card games. The dual-token economy adds complexity and depth to in-game transactions, encouraging strategic decision-making. The wear-and-tear mechanic introduces a novel layer of strategy and realism, as players must consider the longevity of their cards. Together, these features create a rich, engaging, and immersive experience that leverages the full potential of blockchain technology within a gaming context.
</TabItem>
</Tabs>

## Related links

- [Coin Standard](../standards/coin.mdx): The Sui Coin standard enables you to create a broad range of fungible tokens on the Sui network to satisfy a number of use cases. The Coin standed on Sui is equivalent to the ERC-20 technical standard on Ethereum.
- [Create Coins and Tokens](../guides/developer/coin.mdx): Learn how to mint coins and tokens on the Sui network.
- [Create a Non-Fungible Token](../guides/developer/nft.mdx): On Sui, everything is an object. Moreover, everything is a non-fungible token (NFT) as its objects are unique, non-fungible, and owned.
- [Asset Tokenization](../guides/developer/nft/asset-tokenization.mdx): Learn how to tokenize assets on the Sui blockchain. Asset tokenization refers to the process of representing real-world assets, such as real estate, art, commodities, stocks, or other valuable assets, as digital tokens on the blockchain network.
- [NFT Rental Example](../guides/developer/nft/nft-rental.mdx): An example using the Kiosk Apps standard that provides the ability for users to rent NFTs according to the rules of a provided policy instead of outright owning them. This approach closely aligns with the ERC-4907 renting standard, making it a suitable choice for Solidity-based use cases intended for implementation on Sui.
- [Kiosk](../standards/kiosk.mdx): Kiosk is a decentralized system for commerce applications on Sui. Kiosk is a part of the Sui framework, native to the system, and available to everyone.
- [Kiosk Apps](../standards/kiosk-apps.mdx): Kiosk apps are a way to extend the functionality of Sui Kiosk while keeping the core functionality intact. You can develop apps to add new features to a kiosk without having to modify the core code or move the assets elsewhere.
- [zkLogin](../concepts/cryptography/zklogin.mdx): zkLogin is a Sui primitive that enables you to send transactions from a Sui address using an OAuth credential, without publicly linking the two.
- [Sui Foundation blog](https://blog.sui.io/tag/gaming/): Blog posts from the Sui Foundation with the `gaming` tag.
- Guides for example games
    - [Coin Flip](../guides/developer/app-examples/coin-flip.mdx): Learn Sui through a coin flip dApp that covers the full end-to-end flow of building a Sui Move module and connecting it to a React Sui dApp.
    - [Blackjack](../guides/developer/app-examples/blackjack.mdx): Learn Sui using an example implementation of the popular casino game blackjack.
    - [Plinko](../guides/developer/app-examples/plinko.mdx): Learn Sui through an example implementation of the popular casino game, Plinko.
- [Mysticon Legends](https://github.com/MystenLabs/mysticon-legends) repo on GitHub: A blockchain-based game where players collect, train, and battle with mythical creatures called Mysticons.
- [Web3 Mini Games built on Sui](https://mini-games.sui.io/): A collection of mini games, to inspire the community of Sui.
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-move-concepts.mdx
```
---
title: Move Concepts
description: Move is an open-source language for writing safe packages to manipulate on-chain objects
---

{@include: ../snippets/move-summary.mdx}

You can use Move to define, create, and manage programmable Sui objects representing user-level assets. Sui's object system is implemented by adding new functionality to Move while also imposing additional restrictions. See [Object Model](./object-model.mdx) for more details.

## Move on Sui

Move on Sui contains some important differences from Move on other blockchains. Sui takes advantage of Move's security and flexibility and enhances it with the features to vastly improve throughput, reduce delays in finality, and make Move programming more approachable. For full details, see the [Sui Smart Contracts Platform](/doc/sui.pdf) whitepaper.

:::tip

Where the Sui documentation refers to the Move language, the content is documenting the specific Move implementation on the Sui blockchain. If relevant, the documentation expressly refers to the original use case for the Move language as Move on Diem.

:::

## Key differences {#differences}

Key differences with Move on Sui include:

- Sui uses its own [object-centric global storage](#global-storage)
- Addresses represent [Object IDs](#object-ids)
- Sui objects have [globally unique IDs](#global-unique)
- Sui has [module initializers](#module-initializers) (init)
- Sui has unique use cases for the [`entry` keyword](#entry-functions)

### Object-centric global storage {#global-storage}

In Move on Diem, global storage is part of the programming model. Resources and modules are held in global storage, owned by an account which has an address. Transactions are free to access resources from any account in global storage when they run, using special operations such as `move_to` and `move_from`.

This approach introduces a scaling issue, as it is not possible to statically determine which transactions are contending over the same resource and which are not.  This is similar to the scaling issues faced by other blockchains where smart contracts typically store account information in large, internal mappings, which limit throughput.

Move on Sui addresses the scaling issue by not having global storage, or its related operations. When objects (in contrast to resources) and packages (sets of modules) are stored on Sui, they are each given unique identifiers. All a transaction's inputs are explicitly specified up-front using these unique identifiers, to allow the chain to schedule transactions with non-overlapping inputs in parallel.

### Addresses represent Object IDs {#object-ids}

In Move on Diem, there is a 16-byte `address` type used to represent account addresses in global storage. A 16 byte address is sufficient for the Move on Diem security model.

Sui doesn't have global storage, so `address` is re-purposed as a 32-byte identifier used for both objects and accounts. Each transaction is signed by an account (the "sender") that is accessible from the transaction context, and each object stores its `address` wrapped in its `id: UID` field. 

See [Address](https://move-book.com/reference/primitive-types/address.html) in The Move Book for an overview on addresses and refer to <a href="/references/framework/sui-framework/object" data-noBrokenLinkCheck='true'>object.move</a> in the Sui Framework for implementation details.

### Object with key ability, globally unique IDs {#global-unique}

In Move on Diem, the `key` ability indicates that the type is a resource, meaning it (along with an account address) can be used as a key in global storage.

On Sui, the `key` ability indicates that a struct is an object type and comes with an additional requirement that the first field of the struct has signature `id: UID`, to contain the object's unique address on-chain. Sui's bytecode verifier ensures that new objects are always assigned fresh `UID`s (identifiers are never re-used).

### Module initializers {#module-initializers}

As described in [Object-centric global storage](#global-storage), you publish Move modules into Sui storage. The Sui runtime executes a special initializer function you optionally define in a module only once at the time of module publication to pre-initialize module-specific data (for example, creating singleton objects). See [Module Initializer](https://move-book.com/programmability/module-initializer.html) in The Move Book for more information.

### Entry functions {#entry-functions}

The `entry` keyword has a specific use case in Move on Sui. Use `entry` when you want some functionality to be usable by anyone on chain, but not be wrapped around other Move logic. In other words, a function can be called in [PTBs](/concepts/transactions/prog-txn-blocks) but not in other Sui packages. For example, this is utilized when using Sui's on-chain randomness standard to prevent other smart contract engineers from creating logic to essentially front- or back-run the randomness generation. Find more information about this in the [on-chain randomness page](/guides/developer/advanced/randomness-onchain.mdx#use-non-public-entry-functions). 

Make your function private (don't add the `public` visibility keyword) and mark it with the `entry` keyword, as in `entry fun example_function`.

In addition to this Sui-specific use case, there are other rules and restrictions for `entry` functions. 
- `entry` functions can only return types with the `drop` ability. 
- `entry` functions can only take objects as inputs if they weren't used as inputs in any non-`entry` functions in the same PTB. 

## Related links

To learn more about using Move on Sui, see the following sites:

- [The Move Book](https://move-book.com): A comprehensive guide to the Move programming language on the Sui blockchain.
- [The Move Reference](https://move-book.com/reference): Language reference for Move on Sui.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/object-ownership.mdx
```
---
title: Object Ownership
description: Every object has an owner field that dictates how you can use it in transactions. Each object is either address-owned, dynamic fields, immutable, shared, or wrapped.
---

Every object has an owner field that dictates how you can use it in transactions. Objects can have the following types of ownership:

## Address-owned

An address-owned object is owned by a specific 32-byte address that is either an account address (derived from a particular signature scheme) or an object ID. An address-owned object is accessible only to its owner and no others. 

Go to [Address-Owned Objects](./object-ownership/address-owned.mdx).

## Immutable

An immutable object is an object that can't be mutated, transferred, or deleted. Immutable objects have no owner, so anyone can use them.

Go to [Immutable Objects](./object-ownership/immutable.mdx).

## Shared

A shared object is an object that is shared using the `0x2::transfer::share_object` function and is accessible to everyone. Unlike owned objects, anyone can access shared ones on the network.

Go to [Shared Objects](./object-ownership/shared.mdx).

## Wrapped

In Move, you can organize data structures by putting a field of `struct` type in another.

Go to [Wrapped Objects](./object-ownership/wrapped.mdx).
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/app-devs.mdx
```
---
title: App Developers
---

The topics in this section explore some of the concepts that are of interest to developers creating smart contracts on Sui. After becoming familiar with these concepts, be sure to check out the [Guides](../guides.mdx) section for instruction on how to implement these concepts in your own code. 

## Object Model

The basic unit of storage in Sui is the object. In contrast to many other blockchains where storage is centered around accounts containing key-value stores, Sui's storage is centered around objects addressable on-chain by unique IDs. The topics in this section examine the model for objects on Sui.

Go to [Object Model](./object-model.mdx).

## Move Overview

{@include: ../snippets/move-summary.mdx}

The topics in this section describe some of the key features and coding patterns of Move applied to the Sui network. 

Go to [Move Overview](./sui-move-concepts.mdx).

## Transactions

Transactions define the history of activity on a blockchain. On Sui, you can develop complex programmable transaction blocks that perform several transaction commands in a single execution. You can also sponsor transactions for your smart contract users to streamline onboarding. The topics in this section explore transactions on Sui at a conceptual level.  

Go to [Transactions](./transactions.mdx).

## gRPC API for Sui

Overview of the gRPC API to interact with the Sui network.

Go to [gRPC Overview](./grpc-overview.mdx).

## GraphQL RPC for Sui

Basics of the GraphQL service to interact with the Sui network.

Go to [GraphQL for Sui RPC](./graphql-rpc.mdx).
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/grpc-overview.mdx
```
---
title: gRPC Overview (Beta)
description: Overview of the gRPC API to access Sui network data.
beta: devnet, testnet, mainnet
---

The [Sui Full Node gRPC API](../references/fullnode-protocol.mdx) provides a fast, type-safe, and efficient interface for interacting with the Sui blockchain. Designed for power users, indexers, explorers, and decentralized apps, this API enables access to Sui data with high performance and low latency.

:::info

{@include: ../snippets/data-serving-msg.mdx}

:::

## What is gRPC?

gRPC offers a high-performance, efficient communication protocol that uses [Protocol Buffers](https://protobuf.dev/overview/) for fast, compact data serialization. Its strongly typed interfaces reduce runtime errors and simplify client/server development across multiple languages. With built-in support for code generation, you can scaffold clients in Typescript, Go, Rust, and more. This makes it ideal for scalable backend systems like indexers, blockchain explorers, and data-intensive decentralized apps.

In addition to request-response calls, gRPC supports server-side streaming, enabling real-time data delivery without constant polling. This is especially useful in environments where you need to track events and transactions live. gRPC's binary format is significantly faster and lighter than JSON, saving bandwidth and improving latency.

Refer to [when to use gRPC vs GraphQL](../guides/developer/getting-started/data-serving#when-to-use-grpc-vs-graphql-with-indexer-20) to access Sui data.

## gRPC on Sui

Protocol buffers define the gRPC interface. You can find the relevant beta `.proto` files at [sui-rpc-api on Github](https://github.com/MystenLabs/sui/tree/main/crates/sui-rpc-api/proto), which apart from the gRPC messages (request and response payloads) include the following services and types:

- `sui/rpc/v2beta/transaction_execution_service.proto`
- `sui/rpc/v2beta/ledger_service.proto`

These definitions can be used to generate client libraries in various programming languages.

:::info

There are some proto files in the folder `sui/rpc/v2alpha` as well. Those are in alpha because they are early experimental versions that are subject to change and not recommended for production use.

:::

The `TransactionExecutionService` currently offers a single RPC method: `ExecuteTransaction(ExecuteTransactionRequest)`, which is used to execute a transaction request. Whereas the `LedgerService` includes the core lookup queries for Sui data. Some of the RPCs in that service include:

- `GetObject(GetObjectRequest)`: Retrieves details of a specific on-chain object.
- `GetTransaction(GetTransactionRequest)`: Fetches information about a particular transaction.
- `GetCheckpoint(GetCheckpointRequest)`: Fetches information about a particular checkpoint.

### Field masks

A [`FieldMask` in Protocol Buffers](https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask) is a mechanism used to specify a subset of fields within a message that should be read, updated, or returned. Instead of retrieving the entire object, a client can request only the specific fields they need by providing a list of field paths. This improves performance and reduces unnecessary data transfer.

In the Sui gRPC API, `FieldMask`s are used in requests like `GetTransaction` to control which parts of the transaction (such as, `effects`, `events`) are included in the response. Field paths must match the structure of the response message. This selective querying is especially useful for building efficient applications and tools.

### Encoding

In the Sui gRPC API, identifiers with standard human-readable formats are represented as `string`s in the proto schema:

- `Address` and `ObjectId`: Represented as 64 hexadecimal characters with a leading `0x`.
- `Digest`s: Represented as [Base58](https://learnmeabitcoin.com/technical/keys/base58/).
- `TypeTag` and `StructTag`: Represented in their canonical string format (for example, `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI>`)

## Access using grpcurl

Simplest way to experiment with gRPC is by using [grpcurl](https://github.com/fullstorydev/grpcurl).

:::note

Your results might differ from the examples that follow, depending on the breadth and maturity of the gRPC APIs available on Sui Full nodes.

:::

### List available gRPC services

```shell
$ grpcurl <full node URL:port> list
```

where the port on Sui Foundation managed Full nodes is `443`. It should return something like:

```shell
grpc.health.v1.Health
grpc.reflection.v1.ServerReflection
sui.rpc.v2alpha.LiveDataService
sui.rpc.v2alpha.SubscriptionService
sui.rpc.v2beta.LedgerService
sui.rpc.v2beta.TransactionExecutionService
```

### List available APIs in the LedgerService

```shell
$ grpcurl <full node URL:port> list sui.rpc.v2beta.LedgerService
```

which should return something like:

```shell
sui.rpc.v2beta.LedgerService.BatchGetObjects
sui.rpc.v2beta.LedgerService.BatchGetTransactions
sui.rpc.v2beta.LedgerService.GetCheckpoint
sui.rpc.v2beta.LedgerService.GetEpoch
sui.rpc.v2beta.LedgerService.GetObject
sui.rpc.v2beta.LedgerService.GetServiceInfo
sui.rpc.v2beta.LedgerService.GetTransaction
```

### Get the `events` and `effects` details of a particular transaction

```shell
$ grpcurl -d '{ "digest": "3ByWphQ5sAVojiTrTrGXGM5FmCVzpzYmhsjbhYESJtxp" }' <full node URL:port> sui.rpc.v2beta.LedgerService/GetTransaction
```

### Get the transactions in a particular checkpoint

```shell
$ grpcurl -d '{ "sequence_number": "180529334", "read_mask": { "paths": ["transactions"]} }' <full node URL:port> sui.rpc.v2beta.LedgerService/GetCheckpoint
```

## Sample clients in different programming languages

<Tabs groupId="language">

<TabItem value="typescript" label="TypeScript">

This is an example to build a Typescript client for Sui gRPC API. If you want to use a different set of tools or modules that you’re comfortable with, you can adjust the instructions accordingly.

**Install dependencies**

```shell
npm init -y
```
```shell
npm install @grpc/grpc-js @grpc/proto-loader
```
```shell
npm i -D tsx
```

**Project structure**

```shell
.
├── protos/
│   └── sui/
│       └── node/
│           └── v2beta/
│               ├── ledger_service.proto
│               └── *.proto
├── client.ts
├── package.json
```

Download all the `sui/rpc/v2beta` proto files from [Github v2beta](https://github.com/MystenLabs/sui/tree/main/crates/sui-rpc-api/proto) in the same folder.

**Sample client.ts to get `events` and `effects` details of a particular transaction**

```ts
import * as grpc from '@grpc/grpc-js';
import * as protoLoader from '@grpc/proto-loader';
import * as path from 'path';

const PROTO_PATH = path.join(__dirname, 'protos/sui/rpc/v2beta/ledger_service.proto');

// Load proto definitions
const packageDefinition = protoLoader.loadSync(PROTO_PATH, {
  keepCase: true,
  longs: String,
  enums: String,
  defaults: true,
  oneofs: true,
  includeDirs: [path.join(__dirname, 'protos')],
});

const suiProto = grpc.loadPackageDefinition(packageDefinition) as any;
const LedgerService = suiProto.sui.rpc.v2beta.LedgerService;

// Create gRPC client
const client = new LedgerService(
  '<full node URL>:443',
  grpc.credentials.createSsl()
);

// Sample transaction digest in Base58 format
const base58Digest = '3ByWphQ5sAVojiTrTrGXGM5FmCVzpzYmhsjbhYESJtxp';

// Construct the request
const request = {
  digest: base58Digest,
  read_mask: {
    paths: ['events', 'effects'],
  },
};

// Make gRPC call
client.GetTransaction(request, (err: any, response: any) => {
  if (err) {
    console.error('Error:', err);
  } else {
    console.log('Response:', JSON.stringify(response, null, 2));
  }
});
```

**Run the sample client**

```shell
npx tsx c
```

:::info

- `proto-loader` handles any nested `.proto` files - just make sure paths and imports are correct.
- The example assumes that gRPC is available on port `443` which requires SSL.
- Digest in the request is directly provided in the `Base58` format, but check if you need to decode from your source format.

:::

</TabItem>

<TabItem value="golang" label="Golang">

This is an example to build a golang client for Sui gRPC API. Feel free to use another set of tools or modules that you’re comfortable with.

**Install dependencies**

First make sure you have `go` and `protoc` installed in your environment, and then install:

```shell
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
```
```shell
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```

In your `go.mod`, add the following (make sure to update the version numbers to the latest versions):

```
require (
  google.golang.org/grpc v1.60.0
  google.golang.org/protobuf v1.33.0
)
```

**Generate Golang code from proto files**

Assuming you have the proto files from [Github v2beta](https://github.com/MystenLabs/sui/tree/main/crates/sui-rpc-api/proto), run:

```shell
protoc --proto_path=./protos --go_out=. --go-grpc_out=. protos/sui/rpc/v2beta/ledger_service.proto
```

**Sample main.go to get `events` and `effects` details of a particular transaction**

```go
package main

import (
    "context"
    "crypto/tls"
    "fmt"
    "log"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials"
    
    pb "your_project/sui/rpc/v2beta" // adjust path based on where your generated .pb.go files are
)

func main() {
    // Set up gRPC connection with TLS (port 443)
		creds := credentials.NewTLS(&tls.Config{})
		conn, err := grpc.Dial("<full node URL>:443", grpc.WithTransportCredentials(creds))
		if err != nil {
			log.Fatalf("failed to connect: %v", err)
		}
		defer conn.Close()

    client := pb.NewLedgerServiceClient(conn)
    
    // Sample transaction digest in Base58 format
    base58Digest := "3ByWphQ5sAVojiTrTrGXGM5FmCVzpzYmhsjbhYESJtxp"

    // Build request
		req := &pb.GetTransactionRequest{
			Digest: base58Digest,
			ReadMask: &pb.TransactionReadMask{
				Paths: []string{"events", "effects"},
			},
		}

    // Make the request
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    resp, err := client.GetTransaction(ctx, req)
    if err != nil {
        log.Fatalf("GetTransaction failed: %v", err)
    }

    // Print the response
    fmt.Printf("Response:\n%+v\n", resp)
}
```

**Run the sample client**

If your `go.mod` is properly set up, and you've already generated the gRPC code (`*.pb.go`, `*_grpc.pb.go`), simply run:

```shell
go run main.go
```

:::info

- If you see errors like `cannot find package`, ensure you’ve generated the proto files and imported them correctly.
- If your generated files are in a nested directory like `sui/rpc/v2beta`, your import in `main.go` should match:
```go
import pb "your_project/sui/rpc/v2beta"
```
You can replace `your_project` with a module name or relative import path depending on how your `go.mod` is defined.
- The example assumes that gRPC is available on port `443` which requires SSL.
- Digest in the request is directly provided in the `Base58` format, but check if you need to decode from your source format.

:::

</TabItem>

<TabItem value="python" label="Python">

This is an example to build a python client for Sui gRPC API. Feel free to use another set of tools or modules that you’re comfortable with.

**Install dependencies**

First make sure you have `python` and `protoc` installed in your environment, and then install:

```shell
pip install grpcio grpcio-tools protobuf
```

**Generate Python code from proto files**

Assuming you have the proto files from [Github v2beta](https://github.com/MystenLabs/sui/tree/main/crates/sui-rpc-api/proto), run:

```shell
python -m grpc_tools.protoc -I./protos --python_out=. --grpc_python_out=. ./protos/sui/rpc/v2beta/ledger_service.proto
```

**Sample client.py to get `events` and `effects` details of a particular transaction**

```python
import grpc
from sui.rpc.v2beta import ledger_service_pb2, ledger_service_pb2_grpc

def main():
    # Create secure channel to port 443
    channel = grpc.secure_channel("<full node URL>:443", grpc.ssl_channel_credentials())
    stub = ledger_service_pb2_grpc.LedgerServiceStub(channel)

    # Sample transaction digest in Base58 format
    base58_digest = "3ByWphQ5sAVojiTrTrGXGM5FmCVzpzYmhsjbhYESJtxp"

    # Build the request
    request = ledger_service_pb2.GetTransactionRequest(
        digest=base58_digest,
        read_mask=ledger_service_pb2.TransactionReadMask(paths=["events", "effects"])
    )

    # Make the RPC call
    response = stub.GetTransaction(request)

    # Print response
    print(response)

if __name__ == "__main__":
    main()
```

**Run the sample client**

```shell
python client.py
```

:::info

- The import paths like `sui.rpc.v2beta.ledger_service_pb2` depend on your proto structure.
- You might need to adjust `__init__.py` files or PYTHONPATH to ensure proper module resolution.
- The example assumes that gRPC is available on port `443` which requires SSL.
- Digest in the request is directly provided in the `Base58` format, but check if you need to decode from your source format.

:::

</TabItem>

</Tabs>

## Frequently asked questions

- Q: In a batch object request (`BatchGetObjects`), does the field mask specified in individual `GetObjectRequest`s override the top-level field mask in the `BatchGetObjectsRequest`?
  - A: **No**, only the top-level field mask defined in the `BatchGetObjectsRequest` is used. Any field masks specified within individual `GetObjectRequest` entries are ignored. This behavior also applies to other batch request APIs in the `LedgerService` interface.

- Q: In `ExecuteTransactionRequest`, why is the `transaction` field marked as `optional`?
  - A: While the `transaction` field is marked as `optional` in the `TransactionExecutionService` .proto file, it is not optional in the API contract. It is required when making the request. This is a quirk of Protocol Buffers: marking a field as `optional` enables [field presence](https://protobuf.dev/programming-guides/field_presence/), which allows the API to distinguish between fields that were explicitly set and those that were left unset. Some of the benefits of field presence include:
    - Differentiating between missing and default values
    - Enabling patch or partial update semantics
    - Avoiding ambiguity when default values (like `0`, `""`, or `false`) are valid inputs

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture.mdx
```
---
title: Sui Architecture
---

Sui shares some similarities with other blockchains but is unique in many ways. Use the topics in this section to understand the features that define the Sui network.

## Understand Sui Security

Learn about the mechanisms available to secure on-chain assets, and the assurances Sui provides regarding asset security. Understand Sui Security explores the overall Sui security architecture to ensure the asset types you design leverage Sui to provide a secure experience for asset holders.

Go to [Understand Sui Security](./sui-architecture/sui-security.mdx).

## Life of a Transaction

Life of a Transaction details the transitions that all transactions on Sui go through from creation to finality. This topic also explores some features of the blockchain (like epochs and checkpoints) that play a role in the life of a transaction.

Go to [Life of a Transaction](./sui-architecture/transaction-lifecycle.mdx).

## Consensus

Every transaction on Sui is sequenced by consensus, where validators agree to the same order of execution of the transactions, even if a minority of them are down or are malicious actors that want to harm the network and users.
Sui currently uses the [Mysticeti](https://arxiv.org/pdf/2310.14821) consensus algorithm.

Go to [Consensus](./sui-architecture/consensus.mdx).

## Sui Indexer

Running a Sui indexer offloads data processing from your Full node and stores it in a relational database. This topic explores some of the benefits running an indexer has and points to instruction on how to run your own. 

Go to [Sui Indexer](./sui-architecture/indexer-functions.mdx).

## Protocol Upgrades

The Sui protocol, framework, and execution engine are frequently extended to include new functionality and bug fixes. This functionality is added in the form of new code which is released to validator operators as part of our regular software releases. The Sui protocol, however, requires that all Sui validators agree about the results of executing each transaction.

Go to [Protocol Upgrades](./sui-architecture/protocol-upgrades.mdx).

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/dynamic-fields.mdx
```
---
title: Dynamic (Object) Fields
description: Dynamic fields and dynamic object fields on Sui are added and removed dynamically, affect gas only when accessed, and store heterogeneous values.
---

There are various ways to use object fields to store primitive data and other objects (wrapping), but there are a few limitations to these:

1. Object's have a finite set of fields keyed by identifiers that are fixed when you publish its module (limited to the fields in the `struct` declaration).
1. An object can become very large if it wraps several other objects. Larger objects can lead to higher gas fees in transactions. In addition, there is an upper bound on object size.
1. There are use cases where you need to store a collection of objects of heterogeneous types. Because the Move `vector` type must be instantiated with one single type `<T>`, it is not suitable for this.

Fortunately, Sui provides *dynamic fields* with arbitrary names (not just identifiers), added and removed on-the-fly (not fixed at publish), which only affect gas when they are accessed, and can store heterogeneous values. Use the libraries in this topic to interact with this kind of field.

### Fields versus object fields

There are two flavors of dynamic field -- "fields" and "object fields" -- which differ based on how you store their values:

| Type | Description | Module |
| --- | --- | --- |
| Fields | Can store any value that has `store`, however an object stored in this kind of field is considered wrapped and is not accessible via its ID by external tools (explorers, wallets, and so on) accessing storage.| [`dynamic_field`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/dynamic_field.move) |
| Object field | Values must be objects (have the `key` ability, and `id: UID` as the first field), but are still accessible at their ID to external tools.| [`dynamic_object_field`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/dynamic_object_field.move) |

### Field names

Unlike an object's regular fields where names must be Move identifiers, dynamic field names can be any value that has `copy`, `drop`, and `store`. This includes all Move primitives (integers, Booleans, byte strings), and structs whose contents all have `copy`, `drop`, and `store`.

### Adding dynamic fields

Use the `add` function from the relevant Sui framework module to add dynamic fields:

**Dynamic field**

{@inject: crates/sui-framework/packages/sui-framework/sources/dynamic_field.move#fun=add noComments}

**Dynamic object field**

{@inject: crates/sui-framework/packages/sui-framework/sources/dynamic_object_field.move#fun=add noComments}

These functions add a field with name `name` and value `value` to `object`. To see it in action, consider these code snippets:

First, define two object types for the parent and the child:

{@inject: examples/move/dynamic_fields/sources/example.move#struct=Parent,Child noComments}

Next, define an API to add a `Child` object as a dynamic field of a `Parent` object:

{@inject: examples/move/dynamic_fields/sources/example.move#fun=add_child}

This function takes the `Child` object by value and makes it a dynamic field of `parent` with name `b"child"` (a byte string of type `vector<u8>`). This call results in the following ownership relationship:

1. Sender address (still) owns the `Parent` object.
1. The `Parent` object owns the `Child` object, and can refer to it by the name `b"child"`.

It is an error to overwrite a field (attempt to add a field with the same `<Name>` type and value as one that is already defined), and a transaction that does this fails. You can modify fields in-place by borrowing them mutably and you can overwrite them safely (such as to change its value type) by removing the old value first.

### Accessing dynamic fields

You can reference dynamic fields by reference using the following APIs:

{@inject: crates/sui-framework/packages/sui-framework/sources/dynamic_field.move#fun=borrow,borrow_mut noComments}

Where `object` is the UID of the object the field is defined on and `name` is the field's name.

:::info

`sui::dynamic_object_field` has equivalent functions for object fields, but with the added constraint `Value: key + store`.

:::

To use these APIs with the `Parent` and `Child` types defined earlier:

{@inject: examples/move/dynamic_fields/sources/example.move#fun=mutate_child,mutate_child_via_parent noComments}

The first function accepts a mutable reference to the `Child` object directly, and you can call it with `Child` objects that haven't been added as fields to `Parent` objects.

The second function accepts a mutable reference to the `Parent` object and accesses its dynamic field using `borrow_mut`, to pass to `mutate_child`. This can only be called on `Parent` objects that have a `b"child"` field defined. A `Child` object that has been added to a `Parent` must be accessed via its dynamic field, so it can only be mutated using `mutate_child_via_parent`, not `mutate_child`, even if its ID is known.

:::tip

A transaction fails if it attempts to borrow a field that does not exist.

:::

The `<Value>` type passed to `borrow` and `borrow_mut` must match the type of the stored field, or the transaction aborts.

You must access dynamic object field values through these APIs. A transaction that attempts to use those objects as inputs (by value or by reference), is rejected for having invalid inputs.

### Removing a dynamic field

Similar to unwrapping an object held in a regular field, you can remove a dynamic field, exposing its value:

{@inject: crates/sui-framework/packages/sui-framework/sources/dynamic_field.move#fun=remove noComments}

This function takes a mutable reference to the ID of the `object` the field is defined on, and the field's `name`.  If a field with a `value: Value` is defined on `object` at `name`, it is removed and `value` returned, otherwise it aborts. Future attempts to access this field on `object` will fail.

:::tip

`sui::dynamic_object_field` has an equivalent function for object fields.

:::

The value that is returned can be interacted with just like any other value (because it is any other value). For example, removed dynamic object field values can then be `delete`-d or `transfer`-ed to an address (back to the sender):

{@inject: examples/move/dynamic_fields/sources/example.move#fun=delete_child,reclaim_child noComments}

Similar to borrowing a field, a transaction that attempts to remove a non-existent field, or a field with a different `Value` type, fails.

### Deleting an object with dynamic fields

It is possible to delete an object that has (potentially non-`drop`) dynamic fields still defined on it. Because field values can be accessed only via the dynamic field's associated object and field name, deleting an object that has dynamic fields still defined on it renders them all inaccessible to future transactions. This is true regardless of whether the field's value has the `drop` ability. This might not be a concern when adding a small number of statically known additional fields to an object, but is particularly undesirable for on-chain collection types that could be holding unboundedly many key-value pairs as dynamic fields.

Sui provides `Table` and `Bag` collections built using dynamic fields, but with additional support to count the number of entries they contain to protect against accidental deletion when non-empty. To learn more, see [Tables and Bags](./dynamic-fields/tables-bags.mdx).

## Related links

- [Dynamic fields](https://move-book.com/programmability/dynamic-fields.html) in The Move Book: The Move Book is a comprehensive guide to the Move programming language and the Sui blockchain. This page explores using dynamic fields in your Move development.
- [Dynamic Object Fields](https://move-book.com/programmability/dynamic-object-fields.html) in The Move Book: This page of The Move Book discusses using dynamic object fields in your smart contracts.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/graphql-rpc.mdx
```
---
title: GraphQL for Sui RPC (Alpha)
beta: devnet, testnet, mainnet
---

This section explains some of the common concepts when working with GraphQL, such as altering behavior using HTTP headers, re-using query snippets with variables and fragments, consuming paginated queries, and understanding and working within the limits enforced by the service.

Jump to the following sections for more details:

- [Headers](#headers)
- [Variables](#variables)
- [Fragments](#fragments)
- [Pagination](#pagination)
- [Limits](#limits)

For more details on GraphQL fundamentals, see the introductory documentation from [GraphQL](https://graphql.org/learn/) and [GitHub](https://docs.github.com/en/graphql/guides/introduction-to-graphql).

:::info

{@include: ../snippets/data-serving-msg.mdx}

{@include: ../snippets/data-serving-gql-alpha.mdx}

:::

## Headers

The service accepts the following optional headers:

- `x-sui-rpc-version` to specify which RPC version to use (currently only one version is supported),
- `x-sui-rpc-show-usage` returns the response with extra query complexity information.

By default, each request returns the service's version in the response header: `x-sui-rpc-version`.

```sh
$ curl -i -X POST https://sui-mainnet.mystenlabs.com/graphql \
     --header 'x-sui-rpc-show-usage: true'                 \
     --header 'Content-Type: application/json'             \
     --data '{
          "query": "query { epoch { referenceGasPrice } }"
     }'
```

The response for the previous request looks similar to the following:

```sh
HTTP/2 200
content-type: application/json
content-length: 159
x-sui-rpc-version: 2024.1.0
date: Tue, 30 Jan 2024 23:50:43 GMT
via: 1.1 google
alt-svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000

{
  "data": {
    "epoch": {
      "referenceGasPrice": "1000"
    }
  },
  "extensions": {
    "usage": {
      "inputNodes": 2,
      "outputNodes": 2,
      "depth": 2,
      "variables": 0,
      "fragments": 0,
      "queryPayload": 37
    }
  }
}
```

## Variables

Variables offer a way to introduce dynamic inputs to a re-usable/static query. Declare variables in the parameters to a `query` or `mutation`, using the `$` symbol and its type (in this example `Int`), which must be a `scalar`, `enum`, or `input` type. In the query body, refer to it by its name (prefixed with the `$` symbol).

If you declare a variable but don't use it or define it (supply a value) in the query, the query fails to execute.

To learn more, read the GraphQL documentation on [Variables](https://graphql.org/learn/queries/#variables).

In the following example, a variable supplies the ID of the epoch being queried.

```graphql
query ($epochID: Int) {
  epoch(id: $epochID) {
    referenceGasPrice
  }
}
```

**Variables**:
```json
{
   "epochID": 100
}
```

### In the IDE

When using the online IDE, supply variables as a JSON object to the query in the **Variables** pane at the bottom of the main editing window. You receive a warning if you supply a variable but don't declare it.

### In requests

When making a request to the GraphQL service (for example, using `curl`), pass the query and variables as two fields of a single JSON object:

```sh
$ curl -X POST https://sui-testnet.mystenlabs.com/graphql \
    --header 'Content-Type: application/json' \
    --data '{
      "query": "query ($epochID: Int) { epoch(id: $epochID) { referenceGasPrice } }",
      "variables": { "epochID": 100 }
  }'
```

## Fragments

Fragments are reusable units that you can include in queries as needed. To learn more, consult the official GraphQL [documentation](https://graphql.org/learn/queries/#fragments). The following example uses fragments to factor out a reusable snippet representing a Move value.

```graphql
query DynamicField {
  object(
    address: "0xb57fba584a700a5bcb40991e1b2e6bf68b0f3896d767a0da92e69de73de226ac"
  ) {
    dynamicField(
      name: {
        type: "0x2::kiosk::Lock",
        bcs: "NLArx1UJguOUYmXgNG8Pv8KbKXLjWtCi6i0Yeq1Vhfw=",
      }
    ) {
      ...DynamicFieldSelect
    }
  }
}

fragment DynamicFieldSelect on DynamicField {
  name {
    ...MoveValueFields
  }
  value {
    ...DynamicFieldValueSelection
  }
}

fragment DynamicFieldValueSelection on DynamicFieldValue {
  __typename
  ... on MoveValue {
    ...MoveValueFields
  }
  ... on MoveObject {
    hasPublicTransfer
    contents {
      ...MoveValueFields
    }
  }
}

fragment MoveValueFields on MoveValue {
  type {
    repr
  }
  data
  bcs
}
```

## Pagination

GraphQL supports queries that fetch multiple kinds of data, potentially nested. For example, the following query retrieves the first 20 transaction blocks (along with the digest, the sender's address, the gas object used to pay for the transaction, the gas price, and the gas budget) after a specific transaction block at epoch `97`.

```graphql
query {
  epoch(id: 97) {
    transactionBlocks(first: 10) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        digest
        sender {
          address
        }
        effects {
          gasEffects {
            gasObject {
              address
            }
          }
        }
        gasInput {
          gasPrice
          gasBudget
        }
      }
    }
  }
}
```

If there are too many transactions to return in a single response, the service applies a [limit](#limits) on the maximum page size for variable size responses (like the `transactionBlock` query) and you must fetch further results through [pagination](https://graphql.org/learn/pagination/).

### Connections

Fields that return a paginated response accept at least the following optional parameters:

- `first`, a limit on page size that is met by dropping excess results from the end.
- `after`, a cursor that bounds the results from below, exclusively.
- `last`, a limit on page size that is met by dropping excess results from the start.
- `before`, a cursor that bounds the results from above, exclusively.

They also return a type that conforms to the [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm), meaning its name ends in `Connection`, and it contains at least the following fields:

- `pageInfo`, of type <a href="/references/sui-api/sui-graphql/reference/objects/page-info" data-noBrokenLinkCheck='true'>PageInfo</a>, which indicates whether there are more pages before or after the page returned.
- `nodes`, the content of the paginated response, as a list of the type being paginated (`TransactionBlock` in the previous example).
- `edges`, similar to `nodes` but associating each node with its [cursor](#cursors).

### Cursors

Cursors are opaque identifiers for paginated results. The only valid source for a cursor parameter (like `after` and `before`) is a cursor field from a previous paginated response (like `PageInfo.startCursor`, `PageInfo.endCursor`, or `Edge.cursor`). The underlying format of the cursor is an implementation detail, and is not guaranteed to remain fixed across versions of the GraphQL service, so do not rely on it -- generating cursors out of thin air is not expected or supported.

Cursors are used to bound results from below (with `after`) and above (with `before`). In both cases, the bound is exclusive, meaning it does not include the result that the cursor points to in the bounded region.

#### Consistency

Cursors also guarantee **consistent** pagination. If the first paginated query reads the state of the network at checkpoint `X`, then a future call to fetch the next page of results using the cursors returned by the first query continues to read from the network at checkpoint `X`, even if data for future checkpoints is now available.

This property requires that cursors that are used together (for example when supplying an `after` and `before` bound) are fixed on the same checkpoint, otherwise the query produces an error.

#### Available range

The GraphQL service does not support consistent pagination for arbitrarily old cursors. A cursor can grow stale, if the checkpoint it is from is no longer in the **available range**. You can query the upper- and lower-bounds of that range as follows:

```graphql
{
  availableRange {
    first { sequenceNumber }
    last { sequenceNumber }
  }
}
```

The results are the first and last checkpoint for which pagination continues to work and produce a consistent result. At the time of writing the available range offers a 5- to 15-minute buffer period to finish pagination.

### Page limits

After results are bounded using cursors, a page size limit is applied using the `first` and `last` parameters. The service requires these parameters to be less than or equal to the max page size [limit](#limits), and if you provide neither, it selects a default. In addition to setting a limit, `first` and `last` control where excess elements are discarded from. For example, if there are `10` potential results -- `R0`, `R1`, ..., `R9` -- after cursor bounds have been applied, then

- a limit of `first: 3` would select `R0`, `R1`, `R2`, and
- a limit of `last: 3` would select `R7`, `R8`, `R9`.

:::info

It is an error to apply both a `first` and a `last` limit.

:::

### Examples

To see these principles put into practice, consult the examples for [paginating forwards](../guides/developer/getting-started/graphql-rpc.mdx#page-forward) and [paginating backwards](../guides/developer/getting-started/graphql-rpc.mdx#page-back) in the getting started guide.

## Limits

The GraphQL service for Sui RPC is rate-limited on all available instances to keep network throughput optimized and to protect against excessive or abusive calls to the service.

### Rate limits

Queries are rate-limited at the number of attempts per minute to ensure high availability of the service to all users.

### Query limits

In addition to rate limits, queries are also validated against a number of rules on their complexity, such as the number of nodes, the depth of the query, or their payload size. Query the `serviceConfig` field to retrieve these limits. An example of how to query for some of the available limits follows:

```graphql
{
  serviceConfig {
    maxQueryDepth
    maxQueryNodes
    maxOutputNodes
    maxDbQueryCost
    defaultPageSize
    maxPageSize
    requestTimeoutMs
    maxQueryPayloadSize
    maxTypeArgumentDepth
    maxTypeArgumentWidth
    maxTypeNodes
    maxMoveValueDepth
  }
}
```

## Related links

- [Querying Sui RPC with GraphQL](../guides/developer/getting-started/graphql-rpc.mdx): Gets you started using GraphQL to query the Sui RPC for on-chain data.  
- [Migrating to GraphQL](../guides/developer/advanced/graphql-migration.mdx): Guides you through migrating Sui RPC projects from JSON-RPC to GraphQL. 
- [GraphQL for Sui RPC](../references/sui-graphql.mdx): Auto-generated GraphQL reference for Sui RPC.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography.mdx
```
---
title: Cryptography
---

Cryptographic agility is core to Sui. The system supports multiple cryptography algorithms and primitives and can switch between them rapidly. With Sui, you can choose the right cryptography solution for your system and implement the latest algorithms as they become available.

Sui defines its cryptography primitives, such as public key, signature, aggregated signature, and hash functions, under one unified type alias or enum wrapper that is shared across the entire repository. Making changes to these primitives affects all of an application's components. You can quickly update application cryptography and be assured of uniform security.

## Transaction Authentication

Transaction authentication features on Sui provide security against unauthorized access to on-chain data. Transaction Authentication provides an overview of related topics.

Go to [Transaction Authentication](./cryptography/transaction-auth.mdx).

## zkLogin

zkLogin is a Sui primitive that enables you to send transactions from a Sui address using an OAuth credential, without publicly linking the two.

Go to [zkLogin](./cryptography/zklogin.mdx).

## Passkey

Sui supports the passkey signature scheme that enables you to sign-in to apps and sign transactions for Sui using a private key securely stored on a passkey authenticator. It uses the WebAuthn standard.

Go to [Passkey](./cryptography/passkeys.mdx).

## Related links

- [Cryptography guides](../guides/developer/cryptography.mdx): See the cryptography guides for instruction on applying these concepts.
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/versioning.mdx
```
---
title: Object and Package Versioning
description: Versioning provides the ability to upgrade packages and objects on the Sui network.
---

You reference every object stored on chain by an ID and version. When a transaction modifies an object, it writes the new contents to an on-chain reference with the same ID but a later version. This means that a single object (with ID `I`) might appear in multiple entries in the distributed store:

```
(I, v0) => ...
(I, v1) => ...  # v0 < v1
(I, v2) => ...  # v1 < v2
```

Despite appearing multiple times in the store, only one version of the object is available to transactions - the latest version (v2 in the previous example). Moreover, only one transaction can modify the object at that version to create a new version, guaranteeing a linear history (`v1` was created in a state where `I` was at `v0`, and `v2` was created in a state where `I` was at `v1`).

Versions are strictly increasing and (ID, version) pairs are never re-used. This structure allows node operators to prune their stores of old object versions that are now inaccessible, if they choose. This is not a requirement, though, as node operators might keep prior object versions around to serve requests for an object's history, either from other nodes that are catching up, or from RPC requests.

## Move objects

Sui uses [Lamport timestamps](https://en.wikipedia.org/wiki/Lamport_timestamp) in its versioning algorithm for objects. The use of Lamport timestamps guarantees that versions never get re-used as the new version for objects touched by a transaction is one greater than the latest version among all input objects to the transaction. For example, a transaction transferring an object `O` at version 5 using a gas object `G` at version 3 updates both `O` and `G` versions to `1 + max(5, 3) = 6` (version 6).

The following sections detail the relevance of Lamport versions for maintaining the "no (ID, version) re-use" invariant or for accessing an object as a transaction input changes depending on that object's ownership.

### Address-owned objects

You must reference address-owned transaction inputs at a specific ID and version. When a validator signs a transaction with an owned object input at a specific version, that version of the object is locked to that transaction. Validators reject requests to sign other transactions that require the same input (same ID and version).

If `F + 1` validators sign one transaction that takes an object as input, and a different `F + 1` validators sign a different transaction that takes the same object as input, that object (and all the other inputs to both transactions) is equivocated, meaning they cannot be used for any further transactions in that epoch. This is because neither transaction can form a quorum without relying on a signature from a validator that has already committed the object to a different transaction, which it cannot get. All locks are reset at the end of the epoch, which frees the objects again.

:::info

Only an object's owner can equivocate it, but this is not a desirable thing to do. You can avoid equivocation by carefully managing the versions of address-owned input objects: never attempt to execute two different transactions that use the same object. If you don't get a definite success or failure response from the network for a transaction, assume that the transaction might have gone through, and do not re-use any of its objects for different transactions.

:::

### Immutable objects

Like address-owned objects, you reference immutable objects at an ID and version, but they do not need to be locked as their contents and versions do not change. Their version is relevant because they could have started life as an address-owned object before being frozen. The given version identifies the point at which they became immutable.

### Shared objects

Specifying a shared transaction input is slightly more complex. You reference it by its ID, the version it was shared at, and a flag indicating whether it is accessed mutably. You don't specify the precise version the transaction accesses because consensus decides that during transaction scheduling. When scheduling multiple transactions that touch the same shared object, validators agree the order of those transactions, and pick each transaction's input versions for the shared object accordingly (one transaction's output version becomes the next transaction's input version, and so on).

Shared transaction inputs that you reference immutably participate in scheduling, but don't modify the object or increment its version.

### Wrapped objects

You can't access wrapped objects by their ID in the object store, you must access them by the object that wraps them. Consider the following example that creates a `make_wrapped` function with an `Inner` object, wrapped in an `Outer` object, which is returned to the transaction sender.

```move
module example::wrapped {
    use sui::object::{Self, UID};
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};

    struct Inner has key, store {
        id: UID,
        x: u64,
    }

    struct Outer has key {
        id: UID,
        inner: Inner,
    }

    entry fun make_wrapped(ctx: &mut TxContext) {
        let inner = Inner {
            id: object::new(ctx),
            x: 42,
        };

        let outer = Outer {
            id: object::new(ctx),
            inner,
        };

        transfer::transfer(outer, tx_context::sender(ctx));
    }
}
```

The owner of `Outer` in this example must specify it as the transaction input and then access its `inner` field to read the instance of `Inner`. Validators refuse to sign transactions that directly specify wrapped objects (like the `inner` of an `Outer`) as inputs. As a result, you don't need to specify a wrapped object's version in a transaction that reads that object.

Wrapped objects can eventually become "unwrapped", meaning that they are once again accessible at their ID:

```move
module example::wrapped {
    // ...

    entry fun unwrap(outer: Outer, ctx: &TxContext) {
        let Outer { id, inner } = outer;
        object::delete(id);
        transfer::transfer(inner, tx_context::sender(ctx));
    }
}
```

The `unwrap` function in the previous code takes an instance of `Outer`, destroys it, and sends the `Inner` back to the sender. After calling this function, the previous owner of `Outer` can access `Inner` directly by its ID because it is now unwrapped. Wrapping and unwrapping of an object can happen multiple times across its lifespan, and the object retains its ID across all those events.

The Lamport timestamp-based versioning scheme ensures that the version that an object is unwrapped at is always greater than the version it was wrapped at, to prevent version re-use.

- After a transaction, `W`, where object `I` is wrapped by object `O`, the `O` version is greater than or equal to the `I` version. This means one of the following conditions is true:
    - `I` is an input so has a strictly lower version.
    - `I` is new and has an equal version.
- After a later transaction unwrapping `I` out of `O`, the following must be true:
    - The `O` input version is greater than or equal to its version after `W` because it is a later transaction, so the version can only have increased.
    - The `I` version in the output must be strictly greater than the `O` input version.

This leads to the following chain of inequalities for I's version before wrapping:

- less than or equal to O's version after wrapping
- less than or equal to O's version before unwrapping
- less than I's version after unwrapping

So the `I` version before wrapping is less than the `I` version after unwrapping.

### Dynamic fields

From a versioning perspective, values held in dynamic fields behave like wrapped objects:

- They are only accessible via the field's parent object, not as direct transaction inputs.
- Based on the previous point, you do not need to supply their IDs or versions with the transaction inputs.
- Lamport timestamp-based versioning makes sure that when a field contains an object and a transaction removes that field, its value becomes accessible by its ID and the value's version has been incremented to a previously unused version.

:::info

One distinction dynamic fields have to wrapped objects is that if a transaction modifies a dynamic object field, its version is incremented in that transaction, where a wrapped object's version would not be.

:::

Adding a new dynamic field to a parent object also creates a `Field` object, responsible for associating the field name and value with that parent. Unlike other newly created objects, the ID for the resulting instance of `Field` is not created using `sui::object::new`. Instead, it is computed as a hash of the parent object ID and the type and value of the field name, so that you can use it to look-up the `Field` via its parent and name.

When you remove a field, Sui deletes its associated `Field`, and if you add a new field with the same name, Sui creates a new instance with the same ID. Versioning using Lamport timestamps, coupled with dynamic fields being only accessible through their parent object, ensures that (ID, version) pairs are not reused in the process:

- The transaction that deletes the original field increments the parent's version to be greater than the deleted field's version.
- The transaction that creates the new version of the same field creates the field with a version that is greater than the parent's version.

So the version of the new `Field` instance is greater than the version of the deleted `Field`.

## Packages

Move packages are also versioned and stored on chain, but follow a different versioning scheme to objects because they are immutable from their inception. This means that you refer to package transaction inputs (for example, the package that a function is from for a Move call transaction) by just their ID, and are always loaded at their latest version.

### User packages

Every time you publish or upgrade a package, Sui generates a new ID. A newly published package has its version set to 1, whereas an upgraded package's version is one greater than the package it is upgrading. Unlike objects, older versions of a package remain accessible even after being upgraded. For example, imagine a package `P` that is published and upgraded twice. It might be represented in the store as:

```
(0x17fb7f87e48622257725f584949beac81539a3f4ff864317ad90357c37d82605, 1) => P v1
(0x260f6eeb866c61ab5659f4a89bc0704dd4c51a573c4f4627e40c5bb93d4d500e, 2) => P v2
(0xd24cc3ec3e2877f085bc756337bf73ae6976c38c3d93a0dbaf8004505de980ef, 3) => P v3
```

In this example, all three versions of the same package are at different IDs. The packages have increasing versions but it is possible to call into `v1`, even though `v2` and `v3` exist on chain.

### Framework packages

Framework packages (such as the Move standard library at `0x1`,the Sui Framework at `0x2`, Sui System at `0x3` and Deepbook at `0xdee9`) are a special-case because their IDs must remain stable across upgrades. The network can upgrade framework packages while preserving their IDs via a system transaction, but can only perform this operation on epoch boundaries because they are considered immutable like other packages. New versions of framework packages retain the same ID as their predecessor, but increment their version by one:

```
(0x1, 1) => MoveStdlib v1
(0x1, 2) => MoveStdlib v2
(0x1, 3) => MoveStdlib v3
```

The prior example shows the on-chain representation of the first three versions of the Move standard library.

### Package versions

Sui smart contracts are organized into upgradeable packages and, as a result, multiple versions of any given package can exist on chain. Before someone can use an on-chain package, you must publish its first, original version. When you upgrade a package, you create a new version of that package. Each upgrade of a package is based on the immediately preceding version of that package in the versions history. In other words, you can upgrade the `nth` version of a package from only the `nth - 1` version. For example, you can upgrade a package from version 1 to 2, but afterwards you can upgrade that package only from version 2 to 3; you're not allowed to upgrade from version 1 to 3.

There is a notion of versioning in package manifest files, existing in both the package section and in the dependencies section. For example, consider the manifest code that follows:

```toml
[package]
name = "some_pkg"
version = "1.0.0"

[dependencies]
another_pkg = { git = "https://github.com/another_pkg/another_pkg.git" , version = "2.0.0"}
```

At this point, the version references in the manifest are used only for user-level documentation as the `publish` and `upgrade` commands do not leverage this information. If you publish a package with a certain package version in the manifest file and then modify and re-publish the same package with a different version (using `publish` command rather than `upgrade` command), the two are considered different packages, rather than on-chain versions of the same package. You cannot use any of these packages as a dependency override to stand in for the other one. While you can specify this type of override when building a package, it results in an error when publishing or upgrading on chain.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/object-model.mdx
```
---
title: Object Model
description: Everything on the Sui blockchain is an object, with metadata, type of ownership, and a referencing scheme. 
---

import ProtocolConfig from "@site/src/components/ProtocolConfig";

The basic unit of storage in Sui is the object. In contrast to many other blockchains where storage is centered around accounts containing key-value stores, Sui's storage is centered around objects addressable on-chain by unique IDs. A smart contract is an object (called a Sui Move package), and these smart contracts manipulate objects on the Sui network:

- Sui Move Package: a set of Sui Move bytecode modules. Each module has a name that's unique within the containing package. The combination of the package's on-chain ID and the name of a module uniquely identify the module. When you publish smart contracts to Sui, a package is the unit of publishing. After you publish a package object, it is immutable and can never be changed or removed. A package object can depend on other package objects that were previously published to Sui.
- Sui Move Object: typed data governed by a particular Sui Move module from a Sui Move package. Each object value is a struct with fields that can contain primitive types (such as integers and addresses), other objects, and non-object structs. 

## Object metadata 

Each Sui object has the following metadata:

- A 32-byte globally unique ID. An object ID is derived from the digest of the transaction that created the object and from a counter encoding the number of IDs generated by the transaction.
- An 8-byte unsigned integer version that monotonically increases with every transaction that modifies it (see [Object and Package Versioning](./versioning.mdx)).
- A 32-byte transaction digest indicating the last transaction that included this object as an output.
- A 32-byte owner field that indicates how this object can be accessed. See [Object Ownership](./object-ownership.mdx) for more information.

In addition to common metadata, objects have a category-specific, variable-sized contents field containing a [Binary Canonical Serialization (BCS)](https://docs.rs/bcs/latest/bcs/)-encoded payload.

- Move Objects contain their Move type, whether the object can be transferred using `public_transfer`, and its fields, again encoded as BCS.
- Move Packages contain the bytecode modules in the package, a table identifying which versions of a package introduced each of its types (the type origin table), and a table mapping each of its transitive dependencies to a specific version of that package to use (the linkage table).

## Referring to objects 

There are a few different ways to concisely refer to an object without specifying its entire contents and metadata, each with slightly different use cases:
- **ID:** the globally unique ID of the object mentioned above. ID is a stable identifier for the object across time and is useful for querying the current state of an object or describing which object was transferred between two addresses.
- **Versioned ID:** an (ID, version) pair. Versioned ID describes the state of the object at a particular point in the object's history and is useful for asking what the value of the object was at some point in the past or determining how fresh some view of an object is now.
- **Object Reference:** an (ID, version, object digest) triple. The object digest is the hash of the object's contents and metadata. An object reference provides an authenticated view of the object at a particular point in the object's history. Transactions require object inputs to be specified via object references to ensure the transaction's sender and a validator processing the transaction agree on the contents and metadata of the object.

## The transaction-object DAG: Relating objects and transactions 

Transactions take objects as input, read/write/mutate these inputs, and produce mutated or freshly created objects as output. Each object knows the (hash of the) last transaction that produced it as an output. Thus, a natural way to represent the relationship between objects and transactions is a directed acyclic graph (DAG) where:

- Nodes are transactions.
- Directed edges go from transaction `A` to transaction `B` if an output object of `A` is an input object of `B`. They are labeled by the reference of the object in question (which specifies the exact version of the object created by `A` and used by `B`).

The root of this DAG is a genesis transaction that takes no inputs and produces the objects that exist in the system's initial state. The DAG can be extended by identifying mutable transaction outputs that have not yet been consumed by any committed transaction and sending a new transaction that takes these outputs (and optionally, immutable transaction outputs) as inputs.

The set of objects that are available to be taken as input by a transaction are the live objects, and the global state maintained by Sui consists of the totality of such objects. The live objects for a particular Sui address A are all objects owned by A, along with all shared and immutable objects in the system.

When this DAG contains all committed transactions in the system, it forms a complete (and cryptographically auditable) view of the system's state and history. In addition, you can use the scheme above to construct a DAG of the relevant history for a subset of transactions or objects (for example, the objects owned by a single address).

## Limits on transactions, objects, and data 

Sui has some limits on transactions and data used in transactions, such as a maximum size and number of objects used. For more information on limits, see [Building against Limits](https://move-book.com/guides/building-against-limits.html) in The Move Book.

The `ProtocolConfig` struct in the [`sui-protocol-config` crate](https://github.com/MystenLabs/sui/blob/main/crates/sui-protocol-config/src/lib.rs) itemizes these limits. Expand the following code to see the `ProtocolConfig` struct and the comments that explain each parameter.

<details>
<summary>
`lib.rs`
</summary>
{@inject: crates/sui-protocol-config/src/lib.rs#struct=ProtocolConfig}
</details>

Select a network from the following tabs to see the currently configured limits and values.

<ProtocolConfig fields="[max_accumulated_randomness_txn_cost_per_object_in_mysticeti_commit, max_accumulated_txn_cost_per_object_in_mysticeti_commit, max_accumulated_txn_cost_per_object_in_narwhal_commit, max_arguments, max_input_objects, max_gas_computation_bucket, max_gas_payment_objects, max_gas_price, max_move_object_size, max_num_event_emit, max_transactions_per_checkpoint, max_tx_gas, max_tx_size_bytes, max_txn_cost_overage_per_object_in_commit, max_type_argument_depth, max_type_arguments, max_type_nodes, max_type_to_layout_nodes, max_value_stack_size]"/>

## Related links

- [Object and Package Versioning](./versioning.mdx): Versioning provides the ability to upgrade packages and objects on the Sui network.
- [Object Ownership](./object-ownership.mdx): Every object has an owner field that dictates how you can use it in transactions.
- [`sui-protocol-config`](https://github.com/MystenLabs/sui/blob/main/crates/sui-protocol-config/src/lib.rs): Crate that defines the `ProtocolConfig` struct with limit definitions.
- [Building against Limits](https://move-book.com/guides/building-against-limits.html): The Move Book provides a concise overview for limits most projects deal with.
- [The Move Book](https://move-book.com/): A comprehensive guide to the Move programming language used on the Sui network.
- [The Move Reference](https://move-book.com/reference/): Reference guide for the Move language.
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/transfers.mdx
```
---
title: Transfers
---

Everything on Sui is an object and your smart contracts are inevitably going to need to move those objects around the network, transferring them from one owner to another. The topics in this section explore the options you have on Sui around transferring objects on the network.

## Custom Transfer Rules

On Sui, you can create custom transfer rules for objects that define the conditions that must be met for a valid transfer operation. The object you want to create custom transfer rules for cannot have the `store` ability, as that ability enables unrestricted transfers for the type via `sui::transfer::public_transfer` or the `TransferObjects` transaction command.

Go to [Custom Transfer Rules](./transfers/custom-rules.mdx).

## Transfer to Object

On Sui, you are not limited to only transferring objects to an address. You can transfer an object to another object, where the receiving object provides access control to the received object. 

Go to [Transfer to Object](./transfers/transfer-to-object.mdx). 
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/object-ownership/immutable.mdx
```
---
title: Immutable Objects
---

Objects in Sui can have different types of ownership, with two broad categories: immutable objects and mutable objects. An immutable object is an object that can't be mutated, transferred, or deleted. Immutable objects have no owner, so anyone can use them.

## Create immutable object

To convert an object into an immutable object, call the `public_freeze_object` function from the [transfer module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/transfer.move):

```move
public native fun public_freeze_object<T: key>(obj: T);
```

This call makes the specified object immutable. This is a non-reversible operation. You should freeze an object only when you are certain that you don't need to mutate it.

You can see this function's use in one of the [color_object example module](https://github.com/MystenLabs/sui/blob/main/examples/move/color_object/sources/example.move) tests. The test creates a new (owned) `ColorObject`, then calls `public_freeze_object` to turn it into an immutable object.

```move
{
    ts.next_tx(alice);
    // Create a new ColorObject
    let c = new(255, 0, 255, ts.ctx());
    // Make it immutable.
    transfer::public_freeze_object(c);
};
```

In the preceding test, you must already own a `ColorObject` to pass it in. At the end of this call, this object is frozen and can never be mutated. It is also no longer owned by anyone.

The `transfer::public_freeze_object` function requires that you pass the object by value. If you are allowed to pass the object by a mutable reference, you could still mutate the object after the `public_freeze_object` call. This contradicts the fact that it should have become immutable.

Alternatively, you can also provide an API that creates an immutable object at creation:

```move
public fun create_immutable(red: u8, green: u8, blue: u8, ctx: &mut TxContext) {
    let color_object = new(red, green, blue, ctx);
    transfer::public_freeze_object(color_object)
}
```

This function creates a new `ColorObject` and immediately makes it immutable before it has an owner.

## Use immutable object

After an object becomes immutable, the rules of who can use this object in Sui Move calls change:
You can only pass an immutable object as a read-only, immutable reference to Sui Move entry functions as `&T`.

Anyone can use immutable objects.

Consider a function that copies the value of one object to another:

```move
public fun copy_into(from: &ColorObject, into: &mut ColorObject);
```

In this function, anyone can pass an immutable object as the first argument, `from`, but not the second argument.
Because you can never mutate immutable objects, there's no data race, even when multiple transactions are using the same immutable object at the same time. Hence, the existence of immutable objects does not pose any requirement on consensus.

## Test immutable object

You can interact with immutable objects in unit tests using `test_scenario::take_immutable<T>` to take an immutable object wrapper from global storage, and `test_scenario::return_immutable` to return the wrapper back to the global storage.

The `test_scenario::take_immutable<T>` function is required because you can access immutable objects solely through read-only references. The `test_scenario` runtime keeps track of the usage of this immutable object. If the compiler does not return the object via `test_scenario::return_immutable` before the start of the next transaction, the test stops.

To see it work in action:

```move
let sender1 = @0x1;
let scenario_val = test_scenario::begin(sender1);
let scenario = &mut scenario_val;
{
    let ctx = test_scenario::ctx(scenario);
    color_object::create_immutable(255, 0, 255, ctx);
};
scenario.next_tx(sender1);
{
    // has_most_recent_for_sender returns false for immutable objects.
    assert!(!test_scenario::has_most_recent_for_sender<ColorObject>(scenario))
};
```

This test submits a transaction as `sender1`, which tries to create an immutable object.

The `has_most_recent_for_sender<ColorObject>` function no longer returns `true`, because the object is no longer owned. To take this object:

```move
// Any sender can work.
let sender2 = @0x2;
scenario.next_tx(sender2);
{
    let object = test_scenario::take_immutable<ColorObject>(scenario);
    let (red, green, blue) = color_object::get_color(object);
    assert!(red == 255 && green == 0 && blue == 255)
    test_scenario::return_immutable(object);
};
```

To show that this object is indeed not owned by anyone, start the next transaction with `sender2`. Note that it used `take_immutable` and succeeded. This means that any sender can take an immutable object. To return the object, call the `return_immutable` function.

To examine whether this object is immutable, add a function that tries to mutate a `ColorObject`:

```move
public fun update(
    object: &mut ColorObject,
    red: u8, green: u8, blue: u8,
) {
    object.red = red;
    object.green = green;
    object.blue = blue;
}
```

As you have learned, the function fails when the `ColorObject` is immutable.

## On-chain interactions

First, view the objects you own:

```sh
$ export ADDR=`sui client active-address`
```
```sh
$ sui client objects $ADDR
```

Publish the `ColorObject` code on-chain using the Sui Client CLI:

{@include: ../../snippets/info-gas-budget.mdx}

```sh
$ sui client publish $ROOT/examples/move/color_object --gas-budget <GAS-AMOUNT>
```

Set the package object ID to the `$PACKAGE` environment variable, if you have it set. Then create a new `ColorObject`:

```sh
$ sui client call --gas-budget <GAS-AMOUNT> --package $PACKAGE --module "color_object" --function "create" --args 0 255 0
```

Set the newly created object ID to `$OBJECT`. To view the objects in the current active address:

```sh
$ sui client objects $ADDR
```

You should see an object with the ID you used for `$OBJECT`. To turn it into an immutable object:

```sh
$ sui client call --gas-budget <GAS-AMOUNT> --package $PACKAGE --module "color_object" --function "freeze_object" --args \"$OBJECT\"
```

View the list of objects again:

```sh
$ sui client objects $ADDR
```

`$OBJECT` is no longer listed. It's no longer owned by anyone. You can see that it's now immutable by querying the object information:

```sh
$ sui client object $OBJECT
```

The response includes:

```sh
Owner: Immutable
```

If you try to mutate it:

```sh
$ sui client call --gas-budget <GAS-AMOUNT> --package $PACKAGE --module "color_object" --function "update" --args \"$OBJECT\" 0 0 0
```

The response indicates that you can't pass an immutable object to a mutable argument.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/object-ownership/wrapped.mdx
```
---
title: Wrapped Objects
---

In many programming languages, you organize data structures in layers by nesting complex data structures in another data structure. In Move, you can organize data structures by putting a field of `struct` type in another, like the following:

```move
public struct Foo has key {
    id: UID,
    bar: Bar,
}

public struct Bar has store {
    value: u64,
}
```

To embed a struct type in a Sui object struct (with a `key` ability), the struct type must have the `store` ability.

In the preceding example, `Bar` is a normal struct, but it is not a Sui object since it doesn't have the `key` ability.

The following code turns `Bar` into an object, which you can still wrap in `Foo`:

```move
public struct Bar has key, store {
    id: UID,
    value: u64,
}
```

Now `Bar` is also a Sui object type. If you put a Sui object of type `Bar` into a Sui object of type `Foo`, the object type `Foo` wraps the object type `Bar`. The object type `Foo` is the wrapper or wrapping object.

There are some interesting consequences of wrapping a Sui object into another. When an object is wrapped, the object no longer exists independently on-chain. You can no longer look up the object by its ID. The object becomes part of the data of the object that wraps it. Most importantly, you can no longer pass the wrapped object as an argument in any way in Sui Move calls. The only access point is through the wrapping object.

It is not possible to create circular wrapping behavior, where A wraps B, B wraps C, and C also wraps A.

At some point, you can then take out the wrapped object and transfer it to an address, modify it, delete it, or freeze it. This is called **unwrapping**. When an object is **unwrapped**, it becomes an independent object again, and can be accessed directly on-chain. There is also an important property about wrapping and unwrapping: the object's ID stays the same across wrapping and unwrapping.

There are a few ways to wrap a Sui object into another Sui object, and their use cases are typically different. This section describes three different ways to wrap a Sui object with typical use cases.

### Direct wrapping

If you put a Sui object type directly as a field in another Sui object type (as in the preceding example), it is called _direct wrapping_. The most important property achieved through direct wrapping is that the wrapped object cannot be unwrapped unless the wrapping object is destroyed. In the preceding example, to make `Bar` a standalone object again, unpack (and hence delete) the `Foo` object. Direct wrapping is the best way to implement object locking, which is to lock an object with constrained access. You can unlock it only through specific contract calls.

The following example implementation of a trusted swap demonstrates how to use direct wrapping. Assume there is an NFT-style `Object` type that has `scarcity` and `style`. In this example, `scarcity` determines how rare the object is (presumably the more scarce the higher its market value), and `style` determines the object content/type or how it's rendered. If you own some of these objects and want to trade your objects with others, you want to make sure it's a fair trade. You are willing to trade an object only with another one that has identical `scarcity`, but want a different `style` (so that you can collect more styles).

First, define such an object type:

```move
public struct Object has key, store {
    id: UID,
    scarcity: u8,
    style: u8,
}
```

In a real application, you might make sure that there is a limited supply of the objects, and there is a mechanism to mint them to a list of owners. For simplicity and demonstration purposes, this example simplifies creation:

```move
public fun new(scarcity: u8, style: u8, ctx: &mut TxContext): Object {
    Object { id: object::new(ctx), scarcity, style }
}

```

You can also enable a swap/trade between your object and others' objects. For example, define a function that takes two objects from two addresses and swaps their ownership. But this doesn't work in Sui. Only object owners can send a transaction to mutate the object. So one person cannot send a transaction that would swap their own object with someone else's object.

Another common solution is to send your object to a pool - such as an NFT marketplace or a staking pool - and perform the swap in the pool (either right away, or later when there is demand). Other chapters explore the concept of shared objects that can be mutated by anyone, and show how it enables anyone to operate in a shared object pool. This chapter focuses on how to achieve the same effect using owned objects. Transactions using only owned objects are faster and less expensive (in terms of gas) than using shared objects, since they do not require consensus in Sui.

To swap objects, the same address must own both objects. Anyone who wants to swap their object can send their objects to the third party, such as a site that offers swapping services, and the third party helps perform the swap and send the objects to the appropriate owner. To ensure that you retain custody of your objects (such as coins and NFTs) and not give full custody to the third party, use direct wrapping. To define a wrapper object type:

```move
public struct SwapRequest has key {
    id: UID,
    owner: address,
    object: Object,
    fee: Balance<SUI>,
}
```

`SwapRequest` defines a Sui object type, wraps the `object` to swap, and tracks the original `owner` of the object. You might need to also pay the third party some fee for this swap. To define an interface to request a swap by someone who owns an `Object`:

```move
public fun request_swap(
    object: Object,
    fee: Coin<SUI>,
    service: address,
    ctx: &mut TxContext,
) {
    assert!(coin::value(&fee) >= MIN_FEE, EFeeTooLow);

    let request = SwapRequest {
        id: object::new(ctx),
        owner: ctx.sender(),
        object,
        fee: coin::into_balance(fee),
    };

    transfer::transfer(request, service)
}

```

In the preceding function, you must pass the object by value so that it's fully consumed and wrapped into `SwapRequest` to request swapping an `object`. The example also provides a fee (in the type of `Coin<SUI>`) and checks that the fee is sufficient. The example turns `Coin` into `Balance` when it's put into the `wrapper` object. This is because `Coin` is a Sui object type and used only to pass around as Sui objects (such as transaction inputs or objects sent to addresses). For coin balances that need to be embedded in other structs, use `Balance` instead because to avoid the overhead of carrying around an unnecessary `UID` field.

The wrapper object is then sent to the service operator, with the address specified in the call as `service`.

The function interface for the function that the service operator can call to perform a swap between two objects sent from two addresses resembles:

```move
public fun execute_swap(s1: SwapRequest, s2: SwapRequest): Balance<SUI>;
```

Where `s1` and `s2` are two wrapped objects that were sent from different object owners to the service operator. Both wrapped objects are passed by value because they eventually need to be [unpacked](https://move-book.com/advanced-topics/struct.html#destructing-structures).

First, unpack the two object to obtain the inner fields:

```move
let SwapRequest {id: id1, owner: owner1, object: o1, fee: fee1} = s1;
let SwapRequest {id: id2, owner: owner2, object: o2, fee: fee2} = s2;
```

Then, check that the swap is legitimate (the two objects have identical scarcity and different styles):

```move
assert!(o1.scarcity == o2.scarcity, EBadSwap);
assert!(o1.style != o2.style, EBadSwap);
```

To perform the actual swap:

```move
transfer::transfer(o1, owner2);
transfer::transfer(o2, owner1);
```

The preceding code sends `o1` to the original owner of `o2`, and sends `o2` to the original owner of `o1`. The service can then delete the wrapping `SwapRequest` objects:

```move
id1.delete();
id2.delete();
```

Finally, the service merges together the `fee1` and `fee2`, and returns it.  The service provider can then turn it into a coin, or merge it into some larger pool where it collects all fees:

```move
fee1.join(fee2);
```

After this call, the two objects are swapped and the service provider takes the service fee.

Since the contract defined only one way to deal with `SwapRequest` - `execute_swap` - there is no other way the service operator can interact with `SwapRequest` despite its ownership.

Find the full source code in the [trusted_swap](https://github.com/MystenLabs/sui/blob/main/examples/move/trusted_swap) example.

To view a more complex example of how to use direct wrapping, see the [escrow](https://github.com/MystenLabs/sui/tree/main/examples/move/escrow) example.

### Wrapping through `Option`

When Sui object type `Bar` is directly wrapped into `Foo`, there is not much flexibility: a `Foo` object must have a `Bar` object in it, and to take out the `Bar` object you must destroy the `Foo` object. However, for more flexibility, the wrapping type might not always have the wrapped object in it, and the wrapped object might be replaced with a different object at some point.

To demonstrate this use case, design a simple game character: A warrior with a sword and shield. A warrior might have a sword and shield, or might not have either. The warrior should be able to add a sword and shield, and replace the current ones at any time. To design this, define a `SimpleWarrior` type:

```move
public struct SimpleWarrior has key {
    id: UID,
    sword: Option<Sword>,
    shield: Option<Shield>,
}
```

Each `SimpleWarrior` type has an optional `sword` and `shield` wrapped in it, defined as:

```move
public struct Sword has key, store {
    id: UID,
    strength: u8,
}

public struct Shield has key, store {
    id: UID,
    armor: u8,
}
```

When you create a new warrior, set the `sword` and `shield` to `none` to indicate there is no equipment yet:

```move
public fun create_warrior(ctx: &mut TxContext) {
    let warrior = SimpleWarrior {
        id: object::new(ctx),
        sword: option::none(),
        shield: option::none(),
    };
    transfer::transfer(warrior, ctx.sender())
}
```

You can then define functions to equip new swords or new shields:

```move
public fun equip_sword(warrior: &mut SimpleWarrior, sword: Sword, ctx: &mut TxContext) {
    if (warrior.sword.is_some()) {
        let old_sword = warrior.sword.extract();
        transfer::transfer(old_sword, ctx.sender());
    };
    warrior.sword.fill(sword);
}
```

The function in the preceding example passes a `warrior` as a mutable reference of `SimpleWarrior`, and passes a `sword` by value to wrap it into the `warrior`.

Note that because `Sword` is a Sui object type without `drop` ability, if the warrior already has a sword equipped, the warrior can't drop that sword. If you call `option::fill` without first checking and taking out the existing sword, an error occurs. In `equip_sword`, first check whether there is already a sword equipped. If so, remove it out and send it back to the sender. To a player, this returns an equipped sword to their inventory when they equip the new sword.

Find the source code in the [simple_warrior](https://github.com/MystenLabs/sui/tree/main/examples/move/simple_warrior) example.

To view a more complex example, see [hero](https://github.com/MystenLabs/sui/tree/main/examples/move/hero).

### Wrapping through `vector`

The concept of wrapping objects in a vector field of another Sui object is very similar to wrapping through `Option`: an object can contain 0, 1, or many of the wrapped objects of the same type.

Wrapping through vector resembles:

```move
public struct Pet has key, store {
    id: UID,
    cuteness: u64,
}

public struct Farm has key {
    id: UID,
    pets: vector<Pet>,
}
```

The preceding example wraps a vector of `Pet` in `Farm`, and can be accessed only through the `Farm` object.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/object-ownership/address-owned.mdx
```
---
title: Address-Owned Objects
description: Address-owned objects are owned by a Sui 32-byte address, which can either be an account address or an object ID. Learn how to create and access these objects.
---

An address-owned object is owned by a specific 32-byte address that is either an account address (derived from a particular signature scheme) or an object ID. An address-owned object is accessible only to its owner and no others.

As the owner (of the address that owns) an address-owned objects, you can transfer it to different addresses. Because only a single owner can access these objects, you can execute transactions that use only owned objects in parallel with other transactions that don't have any objects in common without needing to go through consensus.

## Creating address-owned objects

You can use one of the following functions (defined in the [transfer module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/transfer.move)) to create address-owned objects.

```move
public fun transfer<T: key>(obj: T, recipient: address)
public fun public_transfer<T: key + store>(obj: T, recipient: address)
```

You should use the `sui::transfer::transfer` function if you are defining a [custom transfer policy](../transfers/custom-rules.mdx) for the object. Use the `sui::transfer::public_transfer` function to create an address-owned object if the object has the `store` capability.

After you declare an object as address-owned, its ownership can change over the life of that object - either by adding it as a dynamic object field, transferring it to a different address, or making it immutable. Importantly though, after you create an object and set its ownership, it cannot be shared.

## Accessing address-owned objects

You can access address-owned objects in two different ways, depending on whether or not the address owner of the object corresponds to an object ID.

If the address owner of the object corresponds to an object ID, then you must access and dynamically authenticate it during the execution of the transaction using the mechanisms defined in [Transfer to Object](../transfers/transfer-to-object.mdx).

If the address owner of the object is a signature-derived address (an account address), then you can use and access it directly as an owned object during the execution of a transaction that address signs. Other addresses cannot access owned objects in any way in a transaction - even to just read the object.

## When to use address-owned objects

Use address-owned objects in cases where you want or need only a single owner for the object at any point in time. When designing, you should generally prefer address-owned objects over shared objects as address-owned objects whenever it is reasonable or possible to do so. Owned objects do not need to be sequenced through consensus, and are therefore less prone to throughput bottlenecks if the object is being used extensively.

## Example

An example of an object that is frequently address-owned is that of a [Coin object](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/coin.move). If address `0xA11CE` had a coin `C` with 100 SUI and wanted to pay address `0xB0B` 100 SUI, `0xA11CE` could do so by transferring `C` to `0xB0B`.

```move
transfer::public_transfer(C, @0xB0B);
```

This results in `C` having a new address owner of `0xB0B`, and `0xB0B` can later use that 100 SUI coin.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/object-ownership/shared.mdx
```
---
title: Shared Objects
description: Anyone can access shared objects on the Sui network, so care must be taken to secure access, if needed.
---

A shared object is an object that is shared using the `sui::transfer::share_object` function and is accessible to everyone. Unlike owned objects, anyone can access shared ones on the network. Extended functionality and accessibility of this kind of objects requires additional effort by securing access, if needed.

Shared objects require the `key` ability.

## Example

The following example creates a shop to sell digital donuts. Everyone needs access to the shop to purchase donuts from it, so the example creates the shop as a shared object using `sui::transfer::share_object`.

```move
module examples::donuts;

use sui::sui::SUI;
use sui::coin::{Self, Coin};
use sui::balance::{Self, Balance};

/// For when Coin balance is too low.
const ENotEnough: u64 = 0;

/// Capability that grants an owner the right to collect profits.
public struct ShopOwnerCap has key { id: UID }

/// A purchasable Donut. For simplicity's sake we ignore implementation.
public struct Donut has key { id: UID }

/// A shared object. `key` ability is required.
public struct DonutShop has key {
    id: UID,
    price: u64,
    balance: Balance<SUI>
}

/// Init function is often ideal place for initializing
/// a shared object as it is called only once.
fun init(ctx: &mut TxContext) {
    transfer::transfer(ShopOwnerCap {
        id: object::new(ctx)
    }, ctx.sender());

    // Share the object to make it accessible to everyone!
    transfer::share_object(DonutShop {
        id: object::new(ctx),
        price: 1000,
        balance: balance::zero()
    })
}

/// Entry function available to everyone who owns a Coin.
public fun buy_donut(
    shop: &mut DonutShop, payment: &mut Coin<SUI>, ctx: &mut TxContext
) {
    assert!(coin::value(payment) >= shop.price, ENotEnough);

    // Take amount = `shop.price` from Coin<SUI>
    let paid = payment.balance_mut.split(shop.price);

    // Put the coin to the Shop's balance
    shop.balance.join(paid);

    transfer::transfer(Donut {
        id: object::new(ctx)
    }, ctx.sender())
}

/// Consume donut and get nothing...
public fun eat_donut(d: Donut) {
    let Donut { id } = d;
    id.delete();
}

/// Take coin from `DonutShop` and transfer it to tx sender.
/// Requires authorization with `ShopOwnerCap`.
public fun collect_profits(
    _: &ShopOwnerCap, shop: &mut DonutShop, ctx: &mut TxContext
) {
    let amount = shop.balance.value();
    let profits = shop.balance.split(amount).into_coin(ctx);

    transfer::public_transfer(profits, ctx.sender())
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-move-concepts/packages.mdx
```
---
title: Packages
description: A Move package on Sui includes one or more modules that define that package's interaction with on-chain objects. Upgrading on-chain packages provides a way to improve your code or add features without affecting packages that use your published modules.
---

A Move package on Sui includes one or more modules that define that package's interaction with on-chain objects. You develop the logic for those modules using Move, which you then compile into an object. Finally, you publish your package object onto a Sui network. On chain, anyone can view your package contents and the logic it employs to manipulate other on-chain objects using a Sui network explorer.

## Packages are immutable

After you publish a package object on chain to a network, it lives there forever. You cannot directly change the code of an on-chain package object. After a package object appears on chain, other packages can use the modules that the original package provides. Bad actors aside, imagine if someone changed the logic in their on-chain package to correct unintentional behavior that was overlooked during development. This would cause a ripple effect, changing the logic of every package that uses that module to perform in ways the developers might have never intended.

## Upgrading packages

While you can't manipulate on-chain packages directly, you do have the ability to upgrade them. Upgrading on-chain packages provides a way to improve your code or add features without affecting packages that use the original package. When you upgrade a package, you're creating a new object on chain instead of modifying the original package. See [Upgrading Packages](./packages/upgrade.mdx) to learn more about the process.

## Using Sui Client CLI to upgrade packages

The [Sui Client CLI](/references/cli/client.mdx) `upgrade` command offers an approachable way to upgrade packages when the CLI active address owns the `UpgradeCap` object associated with those packages.

Using the Sui CLI is useful to get started with upgrades, or in the early stages of package development, but protecting the ability to upgrade a package on chain using a single key can pose a security risk for several reasons:

{@include: ../../snippets/upgrade-single-key-risk.mdx}

### Making packages immutable

You can make a package _immutable_ when it goes live to mitigate the single-key risk using the Move `sui::package::make_immutable` function to destroy its `UpgradeCap`. Making the package immutable, however, prevents future bug fixes and new features, which might not be practical or desired.

To protect your package from single-key risk on chain, see [Custom Upgrade Policies](./packages/custom-policies.mdx).

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-move-concepts/conventions.mdx
```
---
title: Move Conventions
description: Recommended Move 2024 best practices for Sui development.
---

This guide outlines recommended conventions and best practices for writing Move smart contracts on Sui. Following these guidelines helps create more maintainable, secure, and composable code that aligns with ecosystem standards.

While these conventions are recommendations rather than strict rules, they represent patterns that have proven effective across many Sui projects. They help create consistency across the ecosystem and make code easier to understand and maintain.

## Organization principles

### Package

A Sui package consists of:
- a `sources` directory containing the Move code to be uploaded to the blockchain
- a `Move.toml` manifest file that declares dependencies and other information about the package
- a `Move.lock` file that the Sui Move toolchain automatically generates to lock the versions of the dependencies and track the different published and upgraded versions of the package that exist on the different networks

For this reason, the `Move.lock` file should always be part of the package (don't add it to the `.gitignore` file). Use the [automated address management](https://docs.sui.io/concepts/sui-move-concepts/packages/automated-address-management) instead of the old `published-at` field in the manifest file.

Optionally, you can add a `tests` directory to contain the tests for the package and an `examples` directory to provide use cases for the package. Neither directory is uploaded on chain when you publish the package.

```
sources/
    my_module.move
    another_module.move
    ...
tests/
    my_module_tests.move
    ...
examples/
    using_my_module.move
Move.lock
Move.toml
```

In your package manifest, the package name should be in PascalCase: `name = "MyPackage"`. Ideally, the named address representing the package should be the same as the package name, but in snake_case: `my_package = 0x0`.

### Modules

Modules are the main building blocks of your Move code. They are used to organize and encapsulate related functionality. Design your modules around one object or data structure. A variant structure should have its own module to avoid complexity and bugs.

Module declarations don't need to use brackets anymore and the compiler provides default `use` statements for widely used modules, so you don't need to declare all of them.

```move
module conventions::wallet;

public struct Wallet has key, store {
    id: UID,
    amount: u64
}
```

### Body

Structure your code using comments to create sections for your Move code files. Structure your titles using `===` on either side of the title.

```move
module conventions::comments;

// === Imports ===

// === Errors ===

// === Constants ===

// === Structs ===

// === Events ===

// === Method Aliases ===

// === Public Functions ===

// === View Functions ===

// === Admin Functions ===

// === Package Functions ===

// === Private Functions ===

// === Test Functions ===
```

Here, "public functions" are the functions modifying state, "view functions" are often on-chain getters or off-chain helpers. The latter are not necessary because you can query objects to read their data. The `init` function should be the first function in the module, if it exists.

Try to sort your functions by their purpose and according to the user flow to improve readability. You can also use explicit function names like `admin_set_fees` to make it clear what the function does.

Ideally, test functions should only consist of `[test_only]` helpers for the actual tests that are located in the `tests` directory.

Group imports by dependency, for example:

```move
use std::string::String;
use sui::{
    coin::Coin,
    balance,
    table::Table
};
use my_dep::battle::{Battle, Score};
```

## Naming conventions

Adhering to naming conventions in your code helps readability and ultimately makes your codebase easier to maintain. The following sections outline the key naming conventions to follow when writing Move code.

### Constants

Constants should be uppercase and formatted as snake case. Errors are specific constants that use PascalCase and start with an E. Make them descriptive.

```move
module conventions::constants;

// correct non-error constant
const MAX_NAME_LENGTH: u64 = 64;

// correct error constant
const EInvalidName: u64 = 0;

// wrong error constant
const E_INVALID_NAME: u64 = 0;
```

### Structs

Always declare struct abilities in this order: `key`, `copy`, `drop`, `store`.

Do not use 'potato' in the name of structs. The lack of abilities define it as a potato pattern.

Structs support positional fields that can be used for simple wrappers, dynamic field keys, or as tuples.

Use the `Event` suffix to name structs that emit events.

```move
module conventions::request;

// dynamic field keys
public struct ReceiptKey(ID) has copy, drop, store;

// dynamic field
public struct Receipt<Data> has key, store {
    id: UID,
    data: Data
}

// right naming
public struct Request();

// wrong naming
public struct RequestPotato {}
```

### CRUD function names

The following functions follow standard CRUD (Create, Read, Update, Delete) naming conventions:

- `new`: Creates an empty object.
- `empty`: Creates an empty struct.
- `create`: Creates an initialized object or struct.
- `add`: Adds a value.
- `remove`: Removes a value.
- `exists`: Checks if a key exists.
- `contains`: Checks if a collection contains a value.
- `borrow`: Returns an immutable reference of a struct or object.
- `borrow_mut`: Returns a mutable reference of a struct or object.
- `property_name`: Returns an immutable reference or a copy of a field.
- `property_name_mut`: Returns a mutable reference of a field.
- `drop`: Drops a struct.
- `destroy`: Destroys an object or data structure that has values with the **drop** ability.
- `destroy_empty`: Destroys an empty object or data structure that has values with the **drop** ability.
- `to_name`: Transforms a Type X to Type Y.
- `from_name`: Transforms a Type Y to Type X.

### Generics

Declare generics using single letter names or full names. By convention, developers use `T` and `U` for generic types, but you can use a more descriptive name if it is not confusing with other types. Always prioritize readability.

```move
module conventions::generics;

// single letter name
public struct Receipt<T> has store { ... }

// full name
public struct Receipt<Data> has store { ... }
```

## Code Structure

The following section covers common patterns and best practices specific to Move development on Sui, including object ownership models and function design principles.

### Shared objects

Library modules that share objects should provide two functions: one to instantiate and return the object, and another one to share it. It allows the caller to pass it to other functions and run custom functionality before sharing it.

```move
module conventions::shop;

public struct Shop has key {
    id: UID
}

public fun new(ctx: &mut TxContext): Shop {
    Shop {
        id: object::new(ctx)
    }
}

public fun share(shop: Shop) {
    transfer::share_object(shop);
}
```

### Pure functions

Keep your functions pure to maintain composability. Do not use `transfer::transfer` or `transfer::public_transfer` inside core functions, except in specific cases where the object is not transferable and shouldn't be modified.

```move
module conventions::amm;

use sui::coin::Coin;

public struct Pool has key {
    id: UID
}

// right -> returns the excess coins even if they have zero value.
public fun add_liquidity<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>): (Coin<LpCoin>, Coin<CoinX>, Coin<CoinY>) {
    // Implementation omitted.
    abort(0)
}

// right but not recommended
public fun add_liquidity_and_transfer<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>, recipient: address) {
    let (lp_coin, coin_x, coin_y) = add_liquidity<CoinX, CoinY, LpCoin>(pool, coin_x, coin_y);
    transfer::public_transfer(lp_coin, recipient);
    transfer::public_transfer(coin_x, recipient);
    transfer::public_transfer(coin_y, recipient);
}

// wrong
public fun impure_add_liquidity<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>, ctx: &mut TxContext): Coin<LpCoin> {
    let (lp_coin, coin_x, coin_y) = add_liquidity<CoinX, CoinY, LpCoin>(pool, coin_x, coin_y);
    transfer::public_transfer(coin_x, tx_context::sender(ctx));
    transfer::public_transfer(coin_y, tx_context::sender(ctx));

    lp_coin
}
```

### Coin argument

Pass the `Coin` object by value with the exact right amount directly to improve transaction readability from the frontend.

```move
module conventions::amm;

use sui::coin::Coin;

public struct Pool has key {
    id: UID
}

// right
public fun swap<CoinX, CoinY>(coin_in: Coin<CoinX>): Coin<CoinY> {
    // Implementation omitted.
    abort(0)
}

// wrong
public fun exchange<CoinX, CoinY>(coin_in: &mut Coin<CoinX>, value: u64): Coin<CoinY> {
    // Implementation omitted.
    abort(0)
}
```

### Access control

To maintain composability, use capability objects instead of arrays of addresses for access control.

```move
module conventions::access_control;

use sui::sui::SUI;
use sui::balance::Balance;
use sui::coin::{Self, Coin};
use sui::table::{Self, Table};

public struct Account has key, store {
    id: UID,
    balance: u64
}

public struct State has key {
    id: UID,
    // field not necessary as the state lives in the Account objects
    accounts: Table<address, u64>,
    balance: Balance<SUI>
}

// right -> with this function, another protocol can hold the `Account` on behalf of a user.
public fun withdraw(state: &mut State, account: &mut Account, ctx: &mut TxContext): Coin<SUI> {
    let authorized_balance = account.balance;

    account.balance = 0;

    coin::take(&mut state.balance, authorized_balance, ctx)
}

// wrong -> this is less composable.
public fun wrong_withdraw(state: &mut State, ctx: &mut TxContext): Coin<SUI> {
    let sender = tx_context::sender(ctx);

    let authorized_balance = table::borrow_mut(&mut state.accounts, sender);
    let value = *authorized_balance;
    *authorized_balance = 0;
    coin::take(&mut state.balance, value, ctx)
}
```

### Data storage in owned vs shared objects

If your dApp data has a one to one relationship, it's best to use owned objects.

```move
module conventions::vesting_wallet;

use sui::sui::SUI;
use sui::coin::Coin;
use sui::table::Table;
use sui::balance::Balance;

public struct OwnedWallet has key {
    id: UID,
    balance: Balance<SUI>
}

public struct SharedWallet has key {
    id: UID,
    balance: Balance<SUI>,
    accounts: Table<address, u64>
}


// A vesting wallet releases a certain amount of coin over a period of time.
// If the entire balance belongs to one user and the wallet has no additional functionalities, it is best to store it in an owned object.
public fun new(deposit: Coin<SUI>, ctx: &mut TxContext): OwnedWallet {
    // Implementation omitted.
    abort(0)
}

// If you wish to add extra functionality to a vesting wallet, it is best to share the object.
// For example, if you wish the issuer of the wallet to be able to cancel the contract in the future.
public fun new_shared(deposit: Coin<SUI>, ctx: &mut TxContext) {
    // Implementation omitted.
    // shares the `SharedWallet`.
    abort(0)
}
```

### Admin capability

In admin-gated functions, the first parameter should be the capability. It helps the autocomplete with user types.

```move
module conventions::social_network;

use std::string::String;

public struct Account has key {
    id: UID,
    name: String
}

public struct Admin has key {
    id: UID,
}

// right -> cap.update(&mut account, b"jose".to_string());
public fun update(_: &Admin, account: &mut Account, new_name: String) {
    // Implementation omitted.
    abort(0)
}

// wrong -> account.update(&cap, b"jose".to_string());
public fun set(account: &mut Account, _: &Admin, new_name: String) {
    // Implementation omitted.
    abort(0)
}
```

## Documentation

There is nothing more pleasant than a well-written and well-documented codebase. While some argue that clean code is self-documenting, well-documented code is self-explanatory.

### Comments

Document your code by explaining functions and structs in simple terms using the `///` syntax (doc comment). If you want to add technical insights for developers that might use your code, use the `//` syntax (regular comment).

Use field comments to describe the properties of your structs. In complex functions, you can also describe the parameters and return values.

```move
module conventions::hero;

use std::string::String;
use sui::kiosk::{Kiosk, KioskOwnerCap};

public struct Hero has key, store {
    id: UID,
    // power of the nft
    power: u64
}

/// Creates and returns a new Hero object
public fun new(ctx: &mut TxContext): Hero {
    Hero {
        id: object::new(ctx),
        power: 0
    }
}

// should be initialized before being shared
public fun initialize_hero(hero: &mut Hero) {
    hero.power = 100;
}

public fun start_battle(
    self: &mut Kiosk, // user kiosk
    cap: &KioskOwnerCap, // user kiosk owner cap
    _policy: &TransferPolicy<Hero>, // transfer policy for the game
    hero_id: ID, // hero to use
    battle_id: String // id of the battle to start
) {
    // Implementation omitted.
    abort(0)
}
```

### README

Create a `README.md` file in the root of the package. Include a description of the package, the purpose of the package, and how to use it.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-move-concepts/packages/custom-policies.mdx
```
---
title: Custom Upgrade Policies
---

Protecting the ability to upgrade a package on chain using a single key can pose a security risk for several reasons:

{@include: ../../../snippets/upgrade-single-key-risk.mdx}

To address the security risk of single-key upgrade ownership poses while still providing the opportunity to [upgrade live packages](./upgrade.mdx), Sui offers _custom upgrade policies_. These policies protect `UpgradeCap` access and issue `UpgradeTicket` objects that authorize upgrades on a case-by-case basis.

## Compatibility {#compatibility}

Sui comes with a set of built-in package compatibility policies, listed here from most to least strict:

| Policy          | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Immutable       | No one can upgrade the package.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Dependency-only | You can modify the dependencies of the package only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Additive        | You can add new functionality to the package (e.g., new public functions or structs) but you can't change any of the existing functionality (e.g., the code in existing public functions cannot change).                                                                                                                                                                                                                                                                                                                                                                        |
| Compatible      | The most relaxed policy. In addition to what the more restrictive policies allow, in an upgraded version of the package: <ul><li>You can change all function implementations.</li><li>You can remove the ability constraints on generic type parameters in function signatures.</li><li>You can change, remove, or make `public` any `private`, `public(friend)`, and `entry` function signatures.</li><li>You cannot change `public` function signatures (except in the case of ability constraints mentioned previously).</li><li>You cannot change existing types.</li></ul> |

Each of these policies, in the order listed, is a superset of the previous one in the type of changes allowed in the upgraded package.

When you publish a package, by default it adopts the most relaxed, compatible policy. You can publish a package as part of a transaction that can change the policy before the transaction successfully completes, making the package available on chain for the first time at the desired policy level, rather than at the default one.

You can change the current policy by calling one of the functions in `sui::package` (`only_additive_upgrades`, `only_dep_upgrades`, `make_immutable`) on the package's `UpgradeCap` and a policy can become only more restrictive. For example, after you call `sui::package::only_dep_upgrades` to restrict the policy to become additive, calling `sui::package::only_additive_upgrades` on the `UpgradeCap` of the same package results in an error.

## Upgrade overview {#upgrade-overview}

Package upgrades must occur end-to-end in a single transaction and are composed of three commands:

1. **Authorization:** Get permission from the `UpgradeCap` to perform
   the upgrade, creating an `UpgradeTicket`.
1. **Execution:** Consume the `UpgradeTicket` and verify the package
   bytecode and compatibility against the previous version, and create
   the on-chain object representing the upgraded package. Return an
   `UpgradeReceipt` as a result on success.
1. **Commit:** Update the `UpgradeCap` with information about the
   newly created package.

While step 2 is a built-in command, steps 1 and 3 are implemented as Move functions. The Sui framework provides their most basic implementation:

{@inject: crates/sui-framework/packages/sui-framework/sources/package.move#fun=authorize_upgrade,commit_upgrade noComments}

These are the functions that `sui client upgrade` calls for authorization and commit. Custom upgrade policies work by guarding
access to a package `UpgradeCap` (and therefore to calls of these functions) behind extra conditions that are specific to that policy
(such as voting, governance, permission lists, timelocks, and so on).

Any pair of functions that produces an `UpgradeTicket` from an `UpgradeCap` and consumes an `UpgradeReceipt` to update an
`UpgradeCap` constitutes a custom upgrade policy.

## UpgradeCap {#upgradecap}

The `UpgradeCap` is the central type responsible for coordinating package upgrades.

{@inject: crates/sui-framework/packages/sui-framework/sources/package.move#struct=UpgradeCap noComments}

Publishing a package creates the `UpgradeCap` object and upgrading the package updates that object. The owner of this object has permission to:

- Change the compatibility requirements for future upgrades.
- Authorize future upgrades.
- Make the package immutable (not upgradeable).

And its API guarantees the following properties:

- Only the latest version of a package can be upgraded (a linear history is guaranteed).
- Only one upgrade can be in-flight at any time (cannot authorize multiple concurrent upgrades).
- An upgrade can only be authorized for the extent of a single transaction; no one can `store` the `UpgradeTicket` that proves authorization.
- Compatibility requirements for a package can be made only more restrictive over time.

## UpgradeTicket {#upgradeticket}

{@inject: crates/sui-framework/packages/sui-framework/sources/package.move#struct=UpgradeTicket noComments}

An `UpgradeTicket` is proof that an upgrade has been authorized. This authorization is specific to:

- A particular `package: ID` to upgrade from, which must be the latest package in the family identified by the `UpgradeCap` at `cap: ID`.
- A particular `policy: u8` that attests to the kind of compatibility guarantees that the upgrade expects to adhere to.
- A particular `digest: vector<u8>` that identifies the contents of the package after the upgrade.

When you attempt to run the upgrade, the validator checks that the upgrade it is about to perform matches the upgrade that was authorized along all those lines, and does not perform the upgrade if any of these criteria are not met.

After creating an `UpgradeTicket`, you must use it within that transaction (you cannot store it for later, drop it, or burn it), or the transaction fails.

### Package digest {#package-digest}

The `UpgradeTicket` `digest` field comes from the `digest` parameter to `authorize_upgrade`, which the caller must supply. While
`authorize_upgrade` does not process the `digest`, custom policies can use it to authorize only upgrades that it has seen the
bytecode or source code for ahead of time. Sui calculates the digest as follows:

- Take the bytecode for each module, represented as an array of bytes.
- Append the list of the package's transitive dependencies, each represented as an array of bytes.
- Sort this list of byte-arrays lexicographically.
- Feed each element in the sorted list, in order, into a `Blake2B` hasher.
- Compute the digest from this hash state.

Refer to the [implementation for digest calculation](https://github.com/MystenLabs/sui/blob/d8cb153d886d54752763fbdab631b062da7d894b/crates/sui-types/src/move_package.rs#L232-L251) for more information, but in most cases, you can rely on the Move toolchain to output the digest as part of the build, when passing the `--dump-bytecode-as-base64` flag:

```sh
$ sui move build --dump-bytecode-as-base64
```
```sh
FETCHING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test
{"modules":[<MODULE-BYTES-BASE64>],"dependencies":[<DEPENDENCY-IDS>],"digest":[59,43,173,195,216,88,176,182,18,8,24,200,200,192,196,197,248,35,118,184,207,205,33,59,228,109,184,230,50,31,235,201]}
```

## UpgradeReceipt {#upgradereceipt}

{@inject: crates/sui-framework/packages/sui-framework/sources/package.move#struct=UpgradeReceipt noComments}

The `UpgradeReceipt` is proof that the `Upgrade` command ran successfully, and Sui added the new package to the set of created
objects for the transaction. It is used to update its `UpgradeCap` (identified by `cap: ID`) with the ID of the latest package in its
family (`package: ID`).

After Sui creates an `UpgradeReceipt`, you must use it to update its `UpgradeCap` within the same transaction (you cannot store it for later, drop it, or burn it), or the transaction fails.

## Isolating policies {#isolating-policies}

When writing custom upgrade policies, prefer:

- separating them into their own package (not co-located with the code they govern the upgradeability of),
- making that package immutable (not upgradeable), and
- locking in the policy of the `UpgradeCap`, so that the policy cannot be made less restrictive later.

These best practices help uphold **informed user consent** and **bounded risk** by making it clear what a package's upgrade policy is
at the moment a user locks value into it, and ensuring that the policy does not evolve to be more permissive with time, without the package user realizing and choosing to accept the new terms.

## Example: "Day of the Week" upgrade policy {#example-upgrade}

Time to put everything into practice by writing a toy upgrade policy that only authorizes upgrades on a particular day of the week (of the package creator's choosing).

### Creating an upgrade policy {#creating-upgrade-policy}

Start by creating a new Move package for the upgrade policy:

```sh
$ sui move new policy
```

The command creates a `policy` directory with a `sources` folder and `Move.toml` manifest.

In the `sources` folder, create a source file named `day_of_week.move`. Copy and paste the following code into the file:

```move
module policy::day_of_week;

use sui::package;

/// Day is not a week day (number in range 0 <= day < 7).
const ENotWeekDay: u64 = 1;

public struct UpgradeCap has key, store {
    id: UID,
    cap: package::UpgradeCap,
    day: u8,
}

public fun new_policy(
    cap: package::UpgradeCap,
    day: u8,
    ctx: &mut TxContext,
): UpgradeCap {
    assert!(day < 7, ENotWeekDay);
    UpgradeCap { id: object::new(ctx), cap, day }
}
```

This code includes a constructor and defines the object type for the custom upgrade policy.

You then need to add a function to authorize an upgrade, if on the correct day of the week. First, define a couple of constants, one for the error code that identifies an attempted upgrade on a day the policy doesn't allow, and another to define the number of milliseconds in a day (to be used shortly). Add these definitions directly under the current `ENotWeekDay` one.

```move
// Request to authorize upgrade on the wrong day of the week.
const ENotAllowedDay: u64 = 2;

const MS_IN_DAY: u64 = 24 * 60 * 60 * 1000;
```

After the `new_policy` function, add a `week_day` function to get the current weekday. As promised, the function uses the `MS_IN_DAY` constant you defined earlier.

```move
fun week_day(ctx: &TxContext): u8 {
    let days_since_unix_epoch = ctx.epoch_timestamp_ms() / MS_IN_DAY;
    // The unix epoch (1st Jan 1970) was a Thursday so shift days
    // since the epoch by 3 so that 0 = Monday.
    ((days_since_unix_epoch + 3) % 7 as u8)
}

```

This function uses the epoch timestamp from `TxContext` rather than `Clock` because it needs only daily granularity, which means the upgrade transactions don't require consensus.

Next, add an `authorize_upgrade` function that calls the previous function to get the current day of the week, then checks whether that value violates the policy, returning the `ENotAllowedDay` error value if it does.

```move
public fun authorize_upgrade(
    cap: &mut UpgradeCap,
    policy: u8,
    digest: vector<u8>,
    ctx: &TxContext,
): package::UpgradeTicket {
    assert!(week_day(ctx) == cap.day, ENotAllowedDay);
    cap.cap.authorize_upgrade(policy, digest)
}
```

The signature of a custom `authorize_upgrade` can be different from the signature of `sui::package::authorize_upgrade` as long as it returns an `UpgradeTicket`.

Finally, provide implementations of `commit_upgrade` and `make_immutable` that delegate to their respective functions in `sui::package`:

```move
public fun commit_upgrade(
    cap: &mut UpgradeCap,
    receipt: package::UpgradeReceipt,
) {
    cap.cap.commit_upgrade(receipt)
}

public fun make_immutable(cap: UpgradeCap) {
    let UpgradeCap { id, cap, day: _ } = cap;
    id.delete();
    cap.make_immutable()
}
```

The final code in your `day_of_week.move` file should resemble the following:

```move
module policy::day_of_week;

use sui::package;

// Day is not a week day (number in range 0 <= day < 7).
const ENotWeekDay: u64 = 1;
const ENotAllowedDay: u64 = 2;
const MS_IN_DAY: u64 = 24 * 60 * 60 * 1000;

public struct UpgradeCap has key, store {
    id: UID,
    cap: package::UpgradeCap,
    day: u8,
}

public fun new_policy(
    cap: package::UpgradeCap,
    day: u8,
    ctx: &mut TxContext,
): UpgradeCap {
    assert!(day < 7, ENotWeekDay);
    UpgradeCap { id: object::new(ctx), cap, day }
}

fun week_day(ctx: &TxContext): u8 {
    let days_since_unix_epoch = ctx.epoch_timestamp_ms() / MS_IN_DAY;
    // The unix epoch (1st Jan 1970) was a Thursday so shift days
    // since the epoch by 3 so that 0 = Monday.
    ((days_since_unix_epoch + 3) % 7 as u8)
}

public fun authorize_upgrade(
    cap: &mut UpgradeCap,
    policy: u8,
    digest: vector<u8>,
    ctx: &TxContext,
): package::UpgradeTicket {
    assert!(week_day(ctx) == cap.day, ENotAllowedDay);
    cap.cap.authorize_upgrade(policy, digest)
}

public fun commit_upgrade(
    cap: &mut UpgradeCap,
    receipt: package::UpgradeReceipt,
) {
    cap.cap.commit_upgrade(receipt)
}

public fun make_immutable(cap: UpgradeCap) {
    let UpgradeCap { id, cap, day: _ } = cap;
    id.delete();
    cap.make_immutable()
}
```

### Publishing an upgrade policy {#publishing-an-upgrade-policy}

Use the `sui client publish` command to publish the policy.

{@include: ../../../snippets/info-gas-budget.mdx}

```sh
$ sui client publish
```

<details>
  <summary>
  Console output
  </summary>

A successful publish returns the following:

```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING policy
Successfully verified dependencies on-chain against source.
Transaction Digest: 5BzYX5iV6GP2RaSkZ7JPBRmListD5cEVC7REoKsNoCYc
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                             │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                                   │
│ Gas Owner: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                                │
│ Gas Budget: 11773600 MIST                                                                                    │
│ Gas Price: 1000 MIST                                                                                         │
│ Gas Payment:                                                                                                 │
│  ┌──                                                                                                         │
│  │ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                                    │
│  │ Version: 149516398                                                                                        │
│  │ Digest: HRU5orvkMeouFUVf7MXUpJpXP6W7u8DBzhyMichbW8KP                                                      │
│  └──                                                                                                         │
│                                                                                                              │
│ Transaction Kind: Programmable                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Input Objects                                                                                            │ │
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │
│ │ 0   Pure Arg: Type: address, Value: "0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241" │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│ ╭─────────────────────────────────────────────────────────────────────────╮                                  │
│ │ Commands                                                                │                                  │
│ ├─────────────────────────────────────────────────────────────────────────┤                                  │
│ │ 0  Publish:                                                             │                                  │
│ │  ┌                                                                      │                                  │
│ │  │ Dependencies:                                                        │                                  │
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000001 │                                  │
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000002 │                                  │
│ │  └                                                                      │                                  │
│ │                                                                         │                                  │
│ │ 1  TransferObjects:                                                     │                                  │
│ │  ┌                                                                      │                                  │
│ │  │ Arguments:                                                           │                                  │
│ │  │   Result 0                                                           │                                  │
│ │  │ Address: Input  0                                                    │                                  │
│ │  └                                                                      │                                  │
│ ╰─────────────────────────────────────────────────────────────────────────╯                                  │
│                                                                                                              │
│ Signatures:                                                                                                  │
│    ijPCo4IFqacqAN64UAaJR+J5YhE3+IiEhXA5eEJiI0LZo1y3+byq1WHb3lgU8HLLJTgp+Cuv5GYHsBN5tofYAA==                  │
│                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: 5BzYX5iV6GP2RaSkZ7JPBRmListD5cEVC7REoKsNoCYc                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 589                                                                               │
│                                                                                                   │
│ Created Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x4de927a10f97520311239cadb7159d4b893275bc74ab4e0af1b16c41ba8275a0                         │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  │
│  │ Version: 149516399                                                                             │
│  │ Digest: HLSLcEb3S8t3Zb4cjjSw8dsYhExLyLJ3ParJt2fnoZUu                                           │
│  └──                                                                                              │
│  ┌──                                                                                              │
│  │ ID: 0xa864e0122efbd1755c387c31bf4ce45c649548d2238c8fcffab4f77cfdab7c1a                         │
│  │ Owner: Immutable                                                                               │
│  │ Version: 1                                                                                     │
│  │ Digest: C9YEPnbCs8dtMUTPrXaSNziXkLWSEnz2zaZsxp1rYYCk                                           │
│  └──                                                                                              │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                         │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  │
│  │ Version: 149516399                                                                             │
│  │ Digest: F4zEiy3eS1h9V2EfrV3WXWe8bktA28sbKxzNCqtTRK2T                                           │
│  └──                                                                                              │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                         │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  │
│  │ Version: 149516399                                                                             │
│  │ Digest: F4zEiy3eS1h9V2EfrV3WXWe8bktA28sbKxzNCqtTRK2T                                           │
│  └──                                                                                              │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 9773600 MIST                                                                     │
│    Computation Cost: 1000000 MIST                                                                 │
│    Storage Rebate: 978120 MIST                                                                    │
│    Non-refundable Storage Fee: 9880 MIST                                                          │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    F2edqX6W9HXU7KzVmfwv9fhGMB6fbjrFo3gVd73S4tK5                                                   │
│    Gtwgse64nSVXhQvmqCpwCe5xJz9N4VypvEGJUy5DyG4e                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────╮
│ No transaction block events │
╰─────────────────────────────╯

╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                   │
├──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x4de927a10f97520311239cadb7159d4b893275bc74ab4e0af1b16c41ba8275a0                  │
│  │ Sender: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                    │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 ) │
│  │ ObjectType: 0x2::package::UpgradeCap                                                          │
│  │ Version: 149516399                                                                            │
│  │ Digest: HLSLcEb3S8t3Zb4cjjSw8dsYhExLyLJ3ParJt2fnoZUu                                          │
│  └──                                                                                             │
│ Mutated Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                  │
│  │ Sender: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                    │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 ) │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 149516399                                                                            │
│  │ Digest: F4zEiy3eS1h9V2EfrV3WXWe8bktA28sbKxzNCqtTRK2T                                          │
│  └──                                                                                             │
│ Published Objects:                                                                               │
│  ┌──                                                                                             │
│  │ PackageID: 0xa864e0122efbd1755c387c31bf4ce45c649548d2238c8fcffab4f77cfdab7c1a                 │
│  │ Version: 1                                                                                    │
│  │ Digest: C9YEPnbCs8dtMUTPrXaSNziXkLWSEnz2zaZsxp1rYYCk                                          │
│  │ Modules: day_of_week                                                                          │
│  └──                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Balance Changes                                                                                   │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                              │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: -9795480                                                                               │
│  └──                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

</details>

Following best practices, use the Sui Client CLI to call `sui::package::make_immutable` on the `UpgradeCap` to make the policy immutable. In your shell, create a variable `upgradecap` and set its value to the `UpgradeCap` object ID listed in the *Object Changes* section of your publish response. Of course, the object ID for your upgrade capability is different than the following example.

```sh
$ upgradecap=0x4de927a10f97520311239cadb7159d4b893275bc74ab4e0af1b16c41ba8275a0

$ sui client call \
    --package 0x2 \
    --module 'package' \
    --function 'make_immutable' \
    --args $upgradecap
```

<details>
  <summary>
  Console output
  </summary>

A successful call returns a response similar to the following:

```sh
Transaction Digest: EuQYMunxnMUFedvXXPck9HrehQnNY4GJ27eFBD7ptk2H
╭─────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                │
├─────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                      │
│ Gas Owner: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                   │
│ Gas Budget: 2000000 MIST                                                                        │
│ Gas Price: 1000 MIST                                                                            │
│ Gas Payment:                                                                                    │
│  ┌──                                                                                            │
│  │ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                       │
│  │ Version: 149516399                                                                           │
│  │ Digest: F4zEiy3eS1h9V2EfrV3WXWe8bktA28sbKxzNCqtTRK2T                                         │
│  └──                                                                                            │
│                                                                                                 │
│ Transaction Kind: Programmable                                                                  │
│ ╭─────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Input Objects                                                                               │ │
│ ├─────────────────────────────────────────────────────────────────────────────────────────────┤ │
│ │ 0   Imm/Owned Object ID: 0x4de927a10f97520311239cadb7159d4b893275bc74ab4e0af1b16c41ba8275a0 │ │
│ ╰─────────────────────────────────────────────────────────────────────────────────────────────╯ │
│ ╭──────────────────────────────────────────────────────────────────────────────────╮            │
│ │ Commands                                                                         │            │
│ ├──────────────────────────────────────────────────────────────────────────────────┤            │
│ │ 0  MoveCall:                                                                     │            │
│ │  ┌                                                                               │            │
│ │  │ Function:  make_immutable                                                     │            │
│ │  │ Module:    package                                                            │            │
│ │  │ Package:   0x0000000000000000000000000000000000000000000000000000000000000002 │            │
│ │  │ Arguments:                                                                    │            │
│ │  │   Input  0                                                                    │            │
│ │  └                                                                               │            │
│ ╰──────────────────────────────────────────────────────────────────────────────────╯            │
│                                                                                                 │
│ Signatures:                                                                                     │
│    TiJ5uDmG/d8Ca9xLWY0UEx8VnNO2Va6zBwHoFonWVdQNIgj4ghv+ZrbHW85zHw0WanM8hGebANTxrf12pmHmDQ==     │
│                                                                                                 │
╰─────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: EuQYMunxnMUFedvXXPck9HrehQnNY4GJ27eFBD7ptk2H                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 589                                                                               │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                         │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  │
│  │ Version: 149516400                                                                             │
│  │ Digest: GVZLEsYEDuaZoFoTnvzoHsjGLuVYfZrZEomLRnSCFkzR                                           │
│  └──                                                                                              │
│ Deleted Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x4de927a10f97520311239cadb7159d4b893275bc74ab4e0af1b16c41ba8275a0                         │
│  │ Version: 149516400                                                                             │
│  │ Digest: 7gyGAp71YXQRoxmFBaHxofQXAipvgHyBKPyxmdSJxyvz                                           │
│  └──                                                                                              │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                         │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  │
│  │ Version: 149516400                                                                             │
│  │ Digest: GVZLEsYEDuaZoFoTnvzoHsjGLuVYfZrZEomLRnSCFkzR                                           │
│  └──                                                                                              │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 988000 MIST                                                                      │
│    Computation Cost: 1000000 MIST                                                                 │
│    Storage Rebate: 2595780 MIST                                                                   │
│    Non-refundable Storage Fee: 26220 MIST                                                         │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    5BzYX5iV6GP2RaSkZ7JPBRmListD5cEVC7REoKsNoCYc                                                   │
│    Gtwgse64nSVXhQvmqCpwCe5xJz9N4VypvEGJUy5DyG4e                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────╮
│ No transaction block events │
╰─────────────────────────────╯

╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                   │
├──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Mutated Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                  │
│  │ Sender: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                    │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 ) │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 149516400                                                                            │
│  │ Digest: GVZLEsYEDuaZoFoTnvzoHsjGLuVYfZrZEomLRnSCFkzR                                          │
│  └──                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Balance Changes                                                                                   │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                              │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: 607780                                                                                 │
│  └──                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

</details>

### Creating a package for testing {#creating-testing-package}

With a policy now available on chain, you need a package to upgrade. This topic creates a basic package and references it in the following scenarios, but you can use any package you might have available instead of creating a new one.

If you don't have a package available, use the `sui move new` command to create the template for a new package called `example`.

```sh
$ sui move new example
```

In the `example/sources` directory, create an `example.move` file with the following code:

```move
module example::example {
    struct Event has copy, drop { x: u64 }
    entry fun nudge() {
        sui::event::emit(Event { x: 41 })
    }
}
```

The instruction that follows publishes this example package and then upgrades it to change the value in the `Event` it emits. Because you are using a custom upgrade policy, you need to use the TypeScript SDK to build the package's publish and upgrade commands.

### Using TypeScript SDK {#using-typeccript-sdk}

Create a new directory to store a Node.js project. You can use the `npm init` function to create the `package.json`, or manually create the file. Depending on your approach to creating `package.json`, populate or add the following JSON to it:

```json
{ "type": "module" }
```

Open a terminal or console to the root of your Node.js project. Run the following command to add the Sui TypeScript SDK as a dependency:

```sh
$ npm install @mysten/sui
```

### Publishing a package with custom policy {#publishing-custom-policy}

In the root of your Node.js project, create a script file named `publish.js`. Open the file for editing and define some constants:

- `SUI`: the location of the `sui` CLI binary.
- `POLICY_PACKAGE_ID`: the ID of our published `day_of_week` package.

```js
const SUI = 'sui';
const POLICY_PACKAGE_ID = '<POLICY-PACKAGE>';
```

Next, add boilerplate code to get the signer key pair for the currently active address in the Sui Client CLI:

```js
import { execSync } from 'child_process';
import { readFileSync } from 'fs';
import { homedir } from 'os';
import path from 'path';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { fromBase64 } from '@mysten/sui/utils';

const sender = execSync(`${SUI} client active-address`, { encoding: 'utf8' }).trim();
const signer = (() => {
	const keystore = JSON.parse(
		readFileSync(path.join(homedir(), '.sui', 'sui_config', 'sui.keystore'), 'utf8'),
	);

	for (const priv of keystore) {
		const raw = fromBase64(priv);
		if (raw[0] !== 0) {
			continue;
		}

		const pair = Ed25519Keypair.fromSecretKey(raw.slice(1));
		if (pair.getPublicKey().toSuiAddress() === sender) {
			return pair;
		}
	}

	throw new Error(`keypair not found for sender: ${sender}`);
})();
```

Next, define the path of the package you are publishing. The following snippet assumes that the package is in a sibling directory to
`publish.js`, called `example`:

```js
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
// Location of package relative to current directory
const packagePath = path.join(__dirname, 'example');
```

Next, build the package:

```js
const { modules, dependencies } = JSON.parse(
	execSync(`${SUI} move build --dump-bytecode-as-base64 --path ${packagePath}`, {
		encoding: 'utf-8',
	}),
);
```

Next, construct the transaction to publish the package. Wrap its `UpgradeCap` in a "day of the week" policy, which permits upgrades on Tuesdays, and send the new policy back:

```js
import { Transaction } from '@mysten/sui/transactions';

const tx = new Transaction();
const packageUpgradeCap = tx.publish({ modules, dependencies });
const tuesdayUpgradeCap = tx.moveCall({
	target: `${POLICY_PACKAGE_ID}::day_of_week::new_policy`,
	arguments: [
		packageUpgradeCap,
		tx.pure(1), // Tuesday
	],
});

tx.transferObjects([tuesdayUpgradeCap], tx.pure(sender));
```

And finally, execute that transaction and display its effects to the console. The following snippet assumes that you're running your examples against a local network. Pass `devnet`, `testnet`, or `mainnet` to the `getFullnodeUrl()` function to run on Devnet, Testnet, or Mainnet respectively:

```js
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';

const client = new SuiClient({ url: getFullnodeUrl('localnet') });
const result = await client.signAndExecuteTransaction({
	signer,
	transaction: tx,
	options: {
		showEffects: true,
		showObjectChanges: true,
	},
});

console.log(result);
```

<details>
  <summary>
  `publish.js`
  </summary>

```js
import { execSync } from 'child_process';
import { readFileSync } from 'fs';
import { homedir } from 'os';
import path from 'path';
import { fileURLToPath } from 'url';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';
import { fromBase64 } from '@mysten/sui/utils';

const SUI = 'sui';
const POLICY_PACKAGE_ID = '<POLICY-PACKAGE>';
const sender = execSync(`${SUI} client active-address`, { encoding: 'utf8' }).trim();
const signer = (() => {
	const keystore = JSON.parse(
		readFileSync(path.join(homedir(), '.sui', 'sui_config', 'sui.keystore'), 'utf8'),
	);

	for (const priv of keystore) {
		const raw = fromBase64(priv);
		if (raw[0] !== 0) {
			continue;
		}

		const pair = Ed25519Keypair.fromSecretKey(raw.slice(1));
		if (pair.getPublicKey().toSuiAddress() === sender) {
			return pair;
		}
	}

	throw new Error(`keypair not found for sender: ${sender}`);
})();

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const packagePath = path.join(__dirname, 'example');

const { modules, dependencies } = JSON.parse(
	execSync(`${SUI} move build --dump-bytecode-as-base64 --path ${packagePath}`, {
		encoding: 'utf-8',
	}),
);

const tx = new Transaction();
const packageUpgradeCap = tx.publish({ modules, dependencies });
const tuesdayUpgradeCap = tx.moveCall({
	target: `${POLICY_PACKAGE_ID}::day_of_week::new_policy`,
	arguments: [
		packageUpgradeCap,
		tx.pure(1), // Tuesday
	],
});

tx.transferObjects([tuesdayUpgradeCap], tx.pure(sender));

const client = new SuiClient({ url: getFullnodeUrl('localnet') });
const result = await client.signAndExecuteTransaction({
	signer,
	transaction: tx,
	options: {
		showEffects: true,
		showObjectChanges: true,
	},
});

console.log(result);
```

</details>

Save your `publish.js` file, and then use Node.js to run the script:

```sh
$ node publish.js
```

<details>
  <summary>
  Console output
  </summary>

If the script is successful, the console prints the following response:

```sh
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING example
{
  digest: '9NBLe61sRqe7wS6y8mMVt6vhwA9W5Sz5YVEmuCwNMT64',
  effects: {
    messageVersion: 'v1',
    status: { status: 'success' },
    executedEpoch: '0',
    gasUsed: {
      computationCost: '1000000',
      storageCost: '6482800',
      storageRebate: '978120',
      nonRefundableStorageFee: '9880'
    },
    modifiedAtVersions: [ [Object] ],
    transactionDigest: '9NBLe61sRqe7wS6y8mMVt6vhwA9W5Sz5YVEmuCwNMT64',
    created: [ [Object], [Object] ],
    mutated: [ [Object] ],
    gasObject: { owner: [Object], reference: [Object] },
    dependencies: [
      'BMVXjS7GG3d5W4Prg7gMVyvKTzEk1Hazx7Tq4WCcbcz9',
      'CAFFD2HHnULQMCycL9xgad5JJpjFu2nuftf2xyugQu4t',
      'GGDUeVkDoNFcyGibGNeiaGSiKsxf9QLzbjqPzdqi3dNJ'
    ]
  },
  objectChanges: [
    {
      type: 'mutated',
      sender: '<SENDER>',
      owner: [Object],
      objectType: '0x2::coin::Coin<0x2::sui::SUI>',
      objectId: '<GAS>',
      version: '10',
      previousVersion: '9',
      digest: 'Dz38faAzFsRzKQyT7JTkVydCcvNNxbUdZiutGmA2Eyy6'
    },
    {
      type: 'published',
      packageId: '<EXAMPLE-PACKAGE>',
      version: '1',
      digest: '5JdU8hkFTjyqg4fHyC8JtdHBV11yCCKdFuyf9j4kKY3o',
      modules: [Array]
    },
    {
      type: 'created',
      sender: '<SENDER>',
      owner: [Object],
      objectType: '<POLICY-PACKAGE>::day_of_week::UpgradeCap',
      objectId: '<EXAMPLE-UPGRADE-CAP>',
      version: '10',
      digest: '3uAMFHFKunX9XrufMe27MHDbeLpgHBSsCPN3gSa93H3v'
    }
  ],
  confirmedLocalExecution: true
}
```

</details>

:::tip

If you receive a `ReferenceError: fetch is not defined` error, use Node.js version 18 or greater.

:::

Use the CLI to test that your newly published package works:

```sh
$ sui client call --gas-budget 10000000 \
    --package '<EXAMPLE-PACKAGE-ID>' \
    --module 'example' \
    --function 'nudge' \
```

<details>
  <summary>
  Console output
  </summary>

A successful call responds with the following:

```sh
----- Transaction Digest ----
Bx1GA8EsBjoLKvXV2GG92DC5Jt58dbytf6jFcLg18dDR
----- Transaction Data ----
Transaction Signature: [Signature(Ed25519SuiSignature(Ed25519SuiSignature([0, 92, 22, 253, 150, 35, 134, 140, 185, 239, 72, 194, 25, 250, 153, 98, 134, 26, 219, 232, 199, 122, 56, 189, 186, 56, 126, 184, 147, 148, 184, 4, 17, 177, 156, 231, 198, 74, 118, 28, 187, 132, 94, 141, 44, 55, 70, 207, 157, 143, 182, 83, 59, 156, 116, 226, 22, 65, 211, 179, 187, 18, 76, 245, 4, 92, 225, 85, 204, 230, 61, 45, 147, 106, 193, 13, 195, 116, 230, 99, 61, 161, 251, 251, 68, 154, 46, 172, 143, 122, 101, 212, 120, 80, 164, 214, 54])))]
Transaction Kind : Programmable
Inputs: []
Commands: [
  MoveCall(<EXAMPLE-PACKAGE>::example::nudge()),
]

Sender: <SENDER>
Gas Payment: Object ID: <GAS>, version: 0xb, digest: 93nZ3uLmLfJdHWoSHMuHsjFstEf45EM2pfovu3ibo4iH
Gas Owner: <SENDER>
Gas Price: 1000
Gas Budget: 10000000

----- Transaction Effects ----
Status : Success
Mutated Objects:
  - ID: <GAS> , Owner: Account Address ( <SENDER> )

----- Events ----
Array [
    Object {
        "id": Object {
            "txDigest": String("Bx1GA8EsBjoLKvXV2GG92DC5Jt58dbytf6jFcLg18dDR"),
            "eventSeq": String("0"),
        },
        "packageId": String("<EXAMPLE-PACKAGE>"),
        "transactionModule": String("example"),
        "sender": String("<SENDER>"),
        "type": String("<EXAMPLE-PACKAGE>::example::Event"),
        "parsedJson": Object {
            "x": String("41"),
        },
        "bcs": String("7rkaa6aDvyD"),
    },
]
----- Object changes ----
Array [
    Object {
        "type": String("mutated"),
        "sender": String("<SENDER>"),
        "owner": Object {
            "AddressOwner": String("<SENDER>"),
        },
        "objectType": String("0x2::coin::Coin<0x2::sui::SUI>"),
        "objectId": String("<GAS>"),
        "version": String("12"),
        "previousVersion": String("11"),
        "digest": String("9aNuZF63uBVaWF9L6cVmk7geimmpP9h9StigdNDPSiy3"),
    },
]
----- Balance changes ----
Array [
    Object {
        "owner": Object {
            "AddressOwner": String("<SENDER>"),
        },
        "coinType": String("0x2::sui::SUI"),
        "amount": String("-1009880"),
    },
]
```

</details>

If you used the example package provided, notice you have an `Events` section that contains a field `x` with value `41`.

### Upgrading a package with custom policy {#upgrading-custom-policy}

With your package published, you can prepare an `upgrade.js` script to perform an upgrade using the new policy. It behaves identically to `publish.js` up until building the package. When building the package, the script also captures its `digest`, and the transaction now performs the three upgrade commands (authorize, execute, commit). The full script for `upgrade.js` follows:

```js
import { execSync } from 'child_process';
import { readFileSync } from 'fs';
import { homedir } from 'os';
import path from 'path';
import { fileURLToPath } from 'url';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction, UpgradePolicy } from '@mysten/sui/transactions';
import { fromBase64 } from '@mysten/sui/utils';

const SUI = 'sui';
const POLICY_PACKAGE_ID = '<POLICY-PACKAGE>';
const EXAMPLE_PACKAGE_ID = '<EXAMPLE-PACKAGE>';
const CAP_ID = '<EXAMPLE-UPGRADE-CAP>';
const sender = execSync(`${SUI} client active-address`, { encoding: 'utf8' }).trim();
const signer = (() => {
	const keystore = JSON.parse(
		readFileSync(path.join(homedir(), '.sui', 'sui_config', 'sui.keystore'), 'utf8'),
	);

	for (const priv of keystore) {
		const raw = fromBase64(priv);
		if (raw[0] !== 0) {
			continue;
		}

		const pair = Ed25519Keypair.fromSecretKey(raw.slice(1));
		if (pair.getPublicKey().toSuiAddress() === sender) {
			return pair;
		}
	}

	throw new Error(`keypair not found for sender: ${sender}`);
})();

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const packagePath = path.join(__dirname, 'example');

const { modules, dependencies, digest } = JSON.parse(
	execSync(`${SUI} move build --dump-bytecode-as-base64 --path ${packagePath}`, {
		encoding: 'utf-8',
	}),
);

const tx = new Transaction();
const cap = tx.object(CAP_ID);
const ticket = tx.moveCall({
	target: `${POLICY_PACKAGE_ID}::day_of_week::authorize_upgrade`,
	arguments: [cap, tx.pure(UpgradePolicy.COMPATIBLE), tx.pure(digest)],
});

const receipt = tx.upgrade({
	modules,
	dependencies,
	packageId: EXAMPLE_PACKAGE_ID,
	ticket,
});

tx.moveCall({
	target: `${POLICY_PACKAGE_ID}::day_of_week::commit_upgrade`,
	arguments: [cap, receipt],
});

const client = new SuiClient({ url: getFullnodeUrl('localnet') });
const result = await client.signAndExecuteTransaction({
	signer,
	transaction: tx,
	options: {
		showEffects: true,
		showObjectChanges: true,
	},
});

console.log(result);
```

If today is not Tuesday, wait until next Tuesday to run the script, when your policy allows you to perform upgrades. At that point, update your `example.move` so the event is emitted with a different constant and use Node.js to run the upgrade script:

```sh
$ node upgrade.js
```

<details>
  <summary>
  Console output
  </summary>

If the script is successful (and today is Tuesday), your console displays the following response:

```sh
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING example
{
  digest: 'EzJyH6BX231sw4jY6UZ6r9Dr28SKsiB2hg3zw4Jh4D5P',
  effects: {
    messageVersion: 'v1',
    status: { status: 'success' },
    executedEpoch: '0',
    gasUsed: {
      computationCost: '1000000',
      storageCost: '6482800',
      storageRebate: '2874168',
      nonRefundableStorageFee: '29032'
    },
    modifiedAtVersions: [ [Object], [Object] ],
    transactionDigest: 'EzJyH6BX231sw4jY6UZ6r9Dr28SKsiB2hg3zw4Jh4D5P',
    created: [ [Object] ],
    mutated: [ [Object], [Object] ],
    gasObject: { owner: [Object], reference: [Object] },
    dependencies: [
      '62BxVq24tgaRrFTXR3i944RRZ6x8sgTGbjFzpFDe2RAB',
      'BMVXjS7GG3d5W4Prg7gMVyvKTzEk1Hazx7Tq4WCcbcz9',
      'Bx1GA8EsBjoLKvXV2GG92DC5Jt58dbytf6jFcLg18dDR',
      'CAFFD2HHnULQMCycL9xgad5JJpjFu2nuftf2xyugQu4t'
    ]
  },
  objectChanges: [
    {
      type: 'mutated',
      sender: '<SENDER>',
      owner: [Object],
      objectType: '0x2::coin::Coin<0x2::sui::SUI>',
      objectId: '<GAS>',
      version: '13',
      previousVersion: '12',
      digest: 'DF4aebHRYrVdxtfAaFfET3hLHn5hqsoty4joMYxLDBuc'
    },
    {
      type: 'mutated',
      sender: '<SENDER>',
      owner: [Object],
      objectType: '<POLICY-PACKAGE>::day_of_week::UpgradeCap',
      objectId: '<EXAMPLE-UPGRADE-CAP>',
      version: '13',
      previousVersion: '11',
      digest: '5Wtuw9mAGBuP5qFdTzDCRxBF9LqJ7uZbpxk2UXhAkrXL'
    },
    {
      type: 'published',
      packageId: '<UPGRADED-EXAMPLE-PACKAGE>',
      version: '2',
      digest: '7mvnMEXezAGcWqYSt6R4QUpPjY8nqTSmb5Dv2SqkVq7a',
      modules: [Array]
    }
  ],
  confirmedLocalExecution: true
}
```

</details>

Use the Sui Client CLI to test the upgraded package (the package ID is **different** from the original version of your example package):

```sh
$ sui client call --gas-budget 10000000 \
    --package '<UPGRADED-EXAMPLE-PACKAGE>' \
    --module 'example' \
    --function 'nudge'
```

<details>
  <summary>
  Console output
  </summary>

If successful, the console prints the following response:

```sh
----- Transaction Digest ----
EF2rQzWHmtjPvkqzFGyFvANA8e4ETULSBqDMkzqVoshi
----- Transaction Data ----
Transaction Signature: [Signature(Ed25519SuiSignature(Ed25519SuiSignature([0, 88, 98, 118, 173, 218, 55, 4, 48, 166, 42, 106, 193, 210, 159, 75, 233, 95, 77, 201, 38, 0, 234, 183, 77, 252, 178, 22, 221, 106, 202, 42, 166, 29, 130, 164, 97, 110, 201, 153, 91, 149, 50, 72, 6, 213, 183, 70, 83, 55, 5, 190, 182, 5, 98, 212, 134, 103, 181, 204, 247, 90, 28, 125, 14, 92, 225, 85, 204, 230, 61, 45, 147, 106, 193, 13, 195, 116, 230, 99, 61, 161, 251, 251, 68, 154, 46, 172, 143, 122, 101, 212, 120, 80, 164, 214, 54])))]
Transaction Kind : Programmable
Inputs: []
Commands: [
  MoveCall(<UPGRADE-EXAMPLE-PACKAGE>::example::nudge()),
]

Sender: <SENDER>
Gas Payment: Object ID: <GAS>, version: 0xd, digest: DF4aebHRYrVdxtfAaFfET3hLHn5hqsoty4joMYxLDBuc
Gas Owner: <SENDER>
Gas Price: 1000
Gas Budget: 10000000

----- Transaction Effects ----
Status : Success
Mutated Objects:
  - ID: <GAS> , Owner: Account Address ( <SENDER> )

----- Events ----
Array [
    Object {
        "id": Object {
            "txDigest": String("EF2rQzWHmtjPvkqzFGyFvANA8e4ETULSBqDMkzqVoshi"),
            "eventSeq": String("0"),
        },
        "packageId": String("<UPGRADE-EXAMPLE-PACKAGE>"),
        "transactionModule": String("example"),
        "sender": String("<SENDER>"),
        "type": String("<EXAMPLE-PACKAGE>::example::Event"),
        "parsedJson": Object {
            "x": String("42"),
        },
        "bcs": String("82TFauPiYEj"),
    },
]
----- Object changes ----
Array [
    Object {
        "type": String("mutated"),
        "sender": String("<SENDER>"),
        "owner": Object {
            "AddressOwner": String("<SENDER>"),
        },
        "objectType": String("0x2::coin::Coin<0x2::sui::SUI>"),
        "objectId": String("<GAS>"),
        "version": String("14"),
        "previousVersion": String("13"),
        "digest": String("AmGocCxy6cHvCuGG3izQ8a7afp6qWWt14yhowAzBYa44"),
    },
]
----- Balance changes ----
Array [
    Object {
        "owner": Object {
            "AddressOwner": String("<SENDER>"),
        },
        "coinType": String("0x2::sui::SUI"),
        "amount": String("-1009880"),
    },
]
```

</details>

Now, the `Events` section emitted for the `x` field has a value of `42` (changed from the original `41`).

If you attempt the first upgrade before Tuesday or you change the constant again and try the upgrade the following day, the script receives a response that includes an error similar to the following, which indicates that the upgrade aborted with code `2` (`ENotAllowedDay`):

```sh
...
status: {
  status: 'failure',
  error: 'MoveAbort(MoveLocation { module: ModuleId { address: <POLICY-PACKAGE>, name: Identifier("day_of_week") }, function: 1, instruction: 11, function_name: Some("authorize_upgrade") }, 2) in command 0'
},
...
```

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-move-concepts/packages/automated-address-management.mdx
```
---
title: Automated Address Management
---

When you publish or upgrade a package, its address (also known as the package ID) is tracked in the `Move.lock` file. This bookkeeping is done automatically so that you can avoid recording or updating hex addresses (for example, in the `Move.toml` file). 

When you publish or upgrade your package on multiple chains (Mainnet, Testnet, Devnet) separate addresses for each chain are tracked for you. This tracking is based on your active environment (run `sui client active-env` if unsure). For example, if you set your active environment to an RPC connected to `testnet` and publish a package, the `Move.lock` records the address for that package and associates it with your active environment (`testnet`).

Note that automated address management works for one package published to one or more chains. When you publish or upgrade, address management uses the contents of the package's working directory. If a package is republished to a chain, addresses tracked for the previously published package are overwritten for that chain.

## Adopting automated address management for published packages

Previously a `published-at` entry was **mandatory** in the `Move.toml` file, which sets the address of the latest published package. It is no longer required if this data is tracked in the `Move.lock` file. For an existing package, add the necessary data to the `Move.lock` file so that it can be automatically tracked:

1. Switch to your active environment for the chain that your package is published on
      ```
      sui client --switch --env <YOUR-CHAIN-ENVIRONMENT>
      ```
1. Run the `manage-package` command with the data for your published package
      ```
      sui move manage-package --environment "$(sui client active-env)" \
                        --network-id "$(sui client chain-identifier)" \
                        --original-id 'ORIGINAL-ADDRESS' \
                        --latest-id 'LATEST-ADDRESS' \
                        --version-number 'VERSION-NUMBER'
      ```
      - `ORIGINAL-ADDRESS` should be the address your package was first published at. If you never upgraded your package, this is the same address as your `published-at` address in the `Move.toml`
      - `LATEST-ADDRESS` should be the latest package address. If you never upgraded your package, it is the same as `ORIGINAL-ADDRESS`. If you upgraded your package, this is the same address as your current `published-at` address in the `Move.toml`.
      - `VERSION-NUMBER` is `1` if you never upgraded your package. Otherwise, it is a number greater than `1` depending on how many times you upgraded your package. In this case, look up the package at `LATEST-ADDRESS` to determine the version number.
1. Delete the `published-at` line in your `Move.toml`.
1. Set your package's address to `0x0` in the `[addresses]` section. For example:

```toml
[package]
name = "Kiosk"

[dependencies]
# ... your dependencies ...

[addresses]
kiosk = "0x0"
```

Your package is now tracked. You can repeat the above steps to track addresses for additional environments.

## Package upgrade guidance

- When [upgrading](./upgrade#upgrade-requirements), you need to retrieve the `UpgradeCap` ID of your published package. Automated address management does not track your `UpgradeCap`.

- When [upgrading](./upgrade#example), you first need to set the `[addresses]` value for your package to `0x0` in the `Move.toml`, and restore its ID with the `ORIGINAL-ADDRESS` after upgrading.

## Troubleshooting

Conflicting published package addresses might happen when the state of package data is inconsistent.

For example, you might have an existing package with a `published-at` value in the `Move.toml`. The package is re-published for testing purposes, and is now tracked in `Move.lock` with automated address management. The address in the `Move.toml` and `Move.lock` now differ, and there will be an error the next time you try to publish or upgrade the package.

Here are steps to remediate conflicting addresses:

- If the conflict is in a package you maintain:
  - Delete the `published-at` value in your `Move.toml` if this published address is no longer needed. Then set the package's address to `0x0` in the `[addresses]` section.
  - Alternatively, follow the steps to [adopt automated address management](#adopting-automated-address-management-for-published-packages)

- If the conflict is in a package that you do not maintain (such as a dependency), consider fixing the issue locally with the steps above, or contacting the maintainer to upstream changes.

## Internal reference

This section is an overview of the schema and internal operation of tracked address in the `Move.lock` file. Most developers do not need to understand these internals. It is a reference for those who want a complete interface or control to internal state tracking.

A concrete example of the schema and state you might find in a `Move.lock` file:

```toml
[env]

[env.testnet]
chain-id = "4c78adac"
original-published-id = "0xa6041ac57f9151d49d00dcdc4f79f8c5ba1e399e1005dcb0fdd1c8632020d5a6"
latest-published-id = "0xa6041ac57f9151d49d00dcdc4f79f8c5ba1e399e1005dcb0fdd1c8632020d5a6"
published-version = "1"

[env.mainnet]
chain-id = "35834a8a"
original-published-id = "0xaee5759aedf6c533634cdd2de412f6e6dfc754a89b0ec554a73597348f334477"
latest-published-id = "0xaee5759aedf6c533634cdd2de412f6e6dfc754a89b0ec554a73597348f334477"
published-version = "1"
```

:::info

- An `[env]` table contains entries for each environment. When a package is published for an active environment, an entry is added or updated.
 
- An entry is added or updated based on its the `chain-id` of the environment. As in, addresses are keyed by `chain-id`, not the `[env.NAME]` part. This is so that packages and their dependencies are resolved canonically by chain identifier: keying by `[env.NAME]` is not robust when users can choose arbitrary environment `NAME` aliases.

- Key-value entries correspond to data explained in [adopting automated address management](#adopting-automated-address-management-for-published-packages). Use the `sui move manage-package` command as a frontend to manipulate these values.
:::

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-move-concepts/packages/upgrade.mdx
```
---
title: Upgrading Packages
description: Sui provides a method of upgrading your packages while still retaining their immutable properties.
---

Sui smart contracts are immutable package objects consisting of a collection of Move modules. Because the packages are immutable, transactions can safely access smart contracts without full consensus (fastpath transactions). If someone could change these packages, they would become [shared objects](/concepts/object-ownership/shared.mdx#shared), which would require full consensus before completing a transaction.

The inability to change package objects, however, becomes a problem when considering the iterative nature of code development. Builders require the ability to update their code and pull changes from other developers while still being able to reap the benefits of fastpath transactions. Fortunately, the Sui network provides a method of upgrading your packages while still retaining their immutable properties.

## Upgrade considerations

There are some details of the process that you should consider before upgrading your packages.

For example, module initializers do not re-run with package upgrades. When you publish your initial package, Move runs the `init` function you define for the package once (and only once) at the time of the publish event. Any `init` functions you might include in subsequent versions of your package are ignored. See [Module Initializer](https://move-book.com/programmability/module-initializer.html) in The Move Book for more information.

As alluded to previously, all packages on the Sui network are immutable. Because of this fact, you cannot delete old packages from the chain. As a result, there is nothing that prevents other packages from accessing the methods and types defined in the old versions of your upgraded packages. By default, users can choose to keep using the old version of a package, as well. As a package developer, you must be aware of and account for this possibility.

For example, you might define an `increment` function in your original package:

```move
public fun increment(c: &mut Counter) {
    c.value = c.value + 1;
}
```

Then, your package upgrade might add an emit event to the `increment` function:

```move
public struct Progress has copy, drop {
    reached: u64
}

public fun increment(c: &mut Counter) {
    c.value = c.value + 1;

    if (c.value % 100 == 0) {
        event::emit(Progress { reached: c.value });
    }
}
```

If there is a mix of callers for both the old and upgraded `increment` function, then the process fails because the old function is not aware of the `Progress` event.

Similar to mismatched function definitions, you might also run into issues maintaining dynamic fields that need to remain in sync with a struct's original fields. To address these issues, you can introduce a new type as part of the upgrade and port users over to it, breaking backwards compatibility. For example, if you're using owned objects to demonstrate proof, like proof of ownership, and you develop a new version of your package to address problematic code, you can introduce a new type in the upgraded package. You can then add a function to your package that trades old objects for new ones. Because your logic only recognizes objects with the new type, you effectively force users to update.

Another example of having users update to the latest package is when you have a bookkeeping shared object in your package that you discover has flawed logic so is not functioning as expected. As in the previous example, you want users to use only the object defined in the upgraded package with the correct logic, so you add a new type and migration function to your package upgrade. This process requires a couple of transactions, one for the upgrade and another that you call from the upgraded package to set up the new shared object that replaces the existing one. To protect the setup function, you would need to create an `AdminCap` object or similar as part of your package to make sure you, as the package owner, are the only authorized initiator of that function. Perhaps even more useful, you might include a flag in the shared object that allows you, as the package owner, to toggle the enabled state of that shared object. You can add a check for the enabled state to prevent access to that object from the on-chain public while you perform the migration. Of course, you would probably create this flag only if you expected to perform this migration at some point in the future, not because you're intentionally developing objects with flawed logic.

### Versioned shared objects

When you create packages that involve shared objects, you need to think about upgrades and versioning from the start given that **all prior versions of a package still exist on-chain**. A useful pattern is to introduce versioning to the shared object and using a version check to guard access to functions in the package. This enables you to limit access to the shared object to only the latest version of a package.

Considering the earlier `counter` example, which might have started life as follows:

```move
module example::counter;

public struct Counter has key {
    id: UID,
    value: u64,
}

fun init(ctx: &mut TxContext) {
    transfer::share_object(Counter {
        id: object::new(ctx),
        value: 0,
    })
}

public fun increment(c: &mut Counter) {
    c.value = c.value + 1;
}
```

To ensure that upgrades to this package can limit access of the shared object to the latest version of the package, you need to:

1. Track the current version of the module in a constant, `VERSION`.
2. Track the current version of the shared object, `Counter`, in a new `version` field.
3. Introduce an `AdminCap` to protect privileged calls, and associate the `Counter` with its `AdminCap` with a new field (you might already have a similar type for shared object administration, in which case you can re-use that). This cap is used to protect calls to migrate the shared object from version to version.
4. Guard the entry of all functions that access the shared object with a check that its `version` matches the package `VERSION`.

An upgrade-aware `counter` module that incorporates all these ideas looks as follows:

```move
module example::counter;

/// Not the right admin for this counter
const ENotAdmin: u64 = 0;

/// Calling functions from the wrong package version
const EWrongVersion: u64 = 1;

// 1. Track the current version of the module
const VERSION: u64 = 1;

public struct Counter has key {
    id: UID,
    // 2. Track the current version of the shared object
    version: u64,
    // 3. Associate the `Counter` with its `AdminCap`
    admin: ID,
    value: u64,
}

public struct AdminCap has key {
    id: UID,
}

fun init(ctx: &mut TxContext) {
    let admin = AdminCap { id: object::new(ctx) };

    transfer::share_object(Counter {
        id: object::new(ctx),
        version: VERSION,
        admin: object::id(&admin),
        value: 0,
    });

    transfer::transfer(admin, ctx.sender());
}

public fun increment(c: &mut Counter) {
    // 4. Guard the entry of all functions that access the shared object
    //    with a version check.
    assert!(c.version == VERSION, EWrongVersion);
    c.value = c.value + 1;
}
```

To upgrade a module using this pattern requires making two extra changes, on top of any implementation changes your upgrade requires:

1. Bump the `VERSION` of the package.
2. Introduce a `migrate` function to upgrade the shared object.

The following module is an upgraded `counter` that emits `Progress` events as originally discussed, but also provides tools for an admin (`AdminCap` holder) to prevent accesses to the counter from older package versions:

```move
module example::counter;

use sui::event;

/// Not the right admin for this counter
const ENotAdmin: u64 = 0;

/// Migration is not an upgrade
const ENotUpgrade: u64 = 1;

/// Calling functions from the wrong package version
const EWrongVersion: u64 = 2;

// 1. Bump the `VERSION` of the package.
const VERSION: u64 = 2;

public struct Counter has key {
    id: UID,
    version: u64,
    admin: ID,
    value: u64,
}

public struct AdminCap has key {
    id: UID,
}

public struct Progress has copy, drop {
    reached: u64,
}

fun init(ctx: &mut TxContext) {
    let admin = AdminCap {
        id: object::new(ctx),
    };

    transfer::share_object(Counter {
        id: object::new(ctx),
        version: VERSION,
        admin: object::id(&admin),
        value: 0,
    });

    transfer::transfer(admin, ctx.sender());
}

public fun increment(c: &mut Counter) {
    assert!(c.version == VERSION, EWrongVersion);
    c.value = c.value + 1;

    if (c.value % 100 == 0) {
        event::emit(Progress { reached: c.value })
    }
}

// 2. Introduce a migrate function
entry fun migrate(c: &mut Counter, a: &AdminCap) {
    assert!(c.admin == object::id(a), ENotAdmin);
    assert!(c.version < VERSION, ENotUpgrade);
    c.version = VERSION;
}
```

Upgrading to this version of the package requires performing the package upgrade, and calling the `migrate` function in a follow-up transaction. Note that the `migrate` function:

- Is an `entry` function and **not `public`**. This allows it to be entirely changed (including changing its signature or removing it entirely) in later upgrades.
- Accepts an `AdminCap` and checks that its ID matches the ID of the counter being migrated, making it a privileged operation.
- Includes a sanity check that the version of the module is actually an upgrade for the object. This helps catch errors such as failing to bump the module version before upgrading.

After a successful upgrade, calls to `increment` on the previous version of the package aborts on the version check, while calls on the later version should succeed.

### Extensions

This pattern forms the basis for upgradeable packages involving shared objects, but you can extend it in a number of ways, depending on your package's needs:

- The version constraints can be made more expressive:
  - Rather than using a single `u64`, versions could be specified as a `String`, or a pair of upper and lower bounds.
  - You can control access to specific functions or sets of functions by adding and removing marker types as dynamic fields on the shared object.
- The `migrate` function could be made more sophisticated (modifying other fields in the shared object, adding/removing dynamic fields, migrating multiple shared objects simultaneously).
- You can implement large migrations that need to run over multiple transactions in a three phase set-up:
  - Disable general access to the shared object by setting its version to a sentinel value (e.g. `U64_MAX`), using an `AdminCap`-guarded call.
  - Run the migration over the course of multiple transactions (e.g. if a large volume of objects need to be moved, it is best to do this in batches, to avoid hitting transaction limits).
  - Set the version of the shared object back to a usable value.

## Upgrade requirements

To upgrade a package, your package must satisfy the following requirements:

- You must have an `UpgradeTicket` for the package you want to upgrade. The Sui network issues `UpgradeCap`s when you publish a package, then you can issue `UpgradeTicket`s as the owner of that `UpgradeCap`. The Sui Client CLI handles this requirement automatically.
- Your changes must be layout-compatible with the previous version.
  - Existing `public` function signatures must remain the same.
  - Existing struct layouts (including struct abilities) must remain the same.
  - You can add new structs and functions.
  - You can remove generic type constraints from existing functions (public or otherwise).
  - You can change function implementations.
  - You can change non-`public` function signatures, including `friend` and `entry` function signatures.

:::info

If you have a package with a dependency, and that dependency is upgraded, your package does not automatically depend on the newer version. You must explicitly upgrade your own package to point to the new dependency.

:::

## Upgrading

Use the `sui client upgrade` command to upgrade packages that meet the previous requirements, providing values for the following flags:

{@include: ../../../snippets/info-gas-budget.mdx}

- `--gas-budget`: The maximum number of gas units that can be expended before the network cancels the transaction.
- `--cap`: The ID of the `UpgradeCap`. You receive this ID as a return from the publish command.

Developers upgrading packages using Move code have access to types and functions to define custom upgrade policies. For example, a Move developer might want to disallow upgrading a package, regardless of the current package owner. The [`make_immutable` function](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/package.md#0x2_package_make_immutable) is available to them to create this behavior. More advanced policies using available types like `UpgradeTicket` and `Upgrade Receipt` are also possible. For an example, see this [custom upgrade policy](https://github.com/MystenLabs/sui/issues/2045#:~:text=Implement%20a%20custom%20upgrade%20policy) on GitHub.

When you use the Sui Client CLI, the `upgrade` command handles generating the upgrade digest, authorizing the upgrade with the `UpgradeCap` to get an `UpgradeTicket`, and updating the `UpgradeCap` with the `UpgradeReceipt` after a successful upgrade. To learn more about these processes, see the Move documentation for the [package module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/package.md).

## Example

You develop a package named `sui_package`. Its manifest looks like the following:

```toml
[package]
name = "sui_package"
version = "0.0.0"

[addresses]
sui_package = "0x0"
```

When your package is ready, you publish it:

```sh
$ sui client publish
```

And receive the response:

```sh
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING my_first_package
Successfully verified dependencies on-chain against source.
Transaction Digest: GPSpH264CjQPaXQPpMHpkzyGidZnQFvd1yUH5s9ncesi
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                             │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: PUBLISHER-ID                                                                                         │
│ Gas Owner: PUBLISHER-ID                                                                                      │
│ Gas Budget: 12298000 MIST                                                                                    │
│ Gas Price: 1000 MIST                                                                                         │
│ Gas Payment:                                                                                                 │
│  ┌──                                                                                                         │
│  │ ID: GAS-COIN-ID                                                                                           │
│  │ Version: 2                                                                                                │
│  │ Digest: QDssxM4QKnhutWCYijiWWmYPtKWnHB9xVaLqPsDHiep                                                       │
│  └──                                                                                                         │
│                                                                                                              │
│ Transaction Kind: Programmable                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Input Objects                                                                                            │ │
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │
│ │ 0   Pure Arg: Type: address, Value: "PUBLISHER-ID"                                                       │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│ ╭─────────────────────────────────────────────────────────────────────────╮                                  │
│ │ Commands                                                                │                                  │
│ ├─────────────────────────────────────────────────────────────────────────┤                                  │
│ │ 0  Publish:                                                             │                                  │
│ │  ┌                                                                      │                                  │
│ │  │ Dependencies:                                                        │                                  │
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000001 │                                  │
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000002 │                                  │
│ │  └                                                                      │                                  │
│ │                                                                         │                                  │
│ │ 1  TransferObjects:                                                     │                                  │
│ │  ┌                                                                      │                                  │
│ │  │ Arguments:                                                           │                                  │
│ │  │   Result 0                                                           │                                  │
│ │  │ Address: Input  0                                                    │                                  │
│ │  └                                                                      │                                  │
│ ╰─────────────────────────────────────────────────────────────────────────╯                                  │
│                                                                                                              │
│ Signatures:                                                                                                  │
│    4NqP6CL1/LN1Ekr9NeL82PFGgVdEjrwsP82l/0mFvCd9TYO94CKBQAm8C/D6DsAuBrwu4cogQ3Mbh1huGc0yCg==                  │
│                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: GPSpH264CjQPaXQPpMHpkzyGidZnQFvd1yUH5s9ncesi                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 285                                                                               │
│                                                                                                   │
│ Created Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: ORIGINAL-PACKAGE-ID                                                                        │
│  │ Owner: Immutable                                                                               │
│  │ Version: 1                                                                                     │
│  │ Digest: 4ZvhnDgehkRmzo3mtHjCc6aQkEz1SA87rDpDS6pGarFR                                           │
│  └──                                                                                              │
│  ┌──                                                                                              │
│  │ ID: 0xaa06f409af7a36c20a552e729eb985a9979149ae9ada5ce3ed413836fd12ed16                         │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                        │
│  │ Version: 3                                                                                     │
│  │ Digest: 71G4PuCUoqx1KDTnt8zGMYUf6Qpf4CWgZsDxYN1d7mXE                                           │
│  └──                                                                                              │
│  ┌──                                                                                              │
│  │ ID: UPGRADE-CAP-ID                                                                             │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                        │
│  │ Version: 3                                                                                     │
│  │ Digest: FNxdiGCk1fwXByda6Q2sx8RjuwUQBFYQk7C4Zr2H4qVw                                           │
│  └──                                                                                              │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: GAS-COIN-ID                                                                                │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                        │
│  │ Version: 3                                                                                     │
│  │ Digest: 9Fet6LPSBsjYjVMEQxkB4LRHfAJDFCQQ2iUAiUQ5eygF                                           │
│  └──                                                                                              │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: GAS-COIN-ID                                                                                │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                        │
│  │ Version: 3                                                                                     │
│  │ Digest: 9Fet6LPSBsjYjVMEQxkB4LRHfAJDFCQQ2iUAiUQ5eygF                                           │
│  └──                                                                                              │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 10298000 MIST                                                                    │
│    Computation Cost: 1000000 MIST                                                                 │
│    Storage Rebate: 978120 MIST                                                                    │
│    Non-refundable Storage Fee: 9880 MIST                                                          │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    3eHwwq6p2xQwBtXDE9KKNQwZFdHUGEKiJsR5LDmv4o7b                                                   │
│    7KAuWTJHCZmh2rMSAqobkhU5cuRBoVicwae78i9woDUK                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────╮
│ No transaction block events │
╰─────────────────────────────╯

╭────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                     │
├────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                   │
│  ┌──                                                                                               │
│  │ ObjectID: 0xaa06f409af7a36c20a552e729eb985a9979149ae9ada5ce3ed413836fd12ed16                    │
│  │ Sender: PUBLISHER-ID                                                                            │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                         │
│  │ ObjectType: ORIGINAL-PACKAGE-ID::module::TYPE                                                   │
│  │ Version: 3                                                                                      │
│  │ Digest: 71G4PuCUoqx1KDTnt8zGMYUf6Qpf4CWgZsDxYN1d7mXE                                            │
│  └──                                                                                               │
│  ┌──                                                                                               │
│  │ ObjectID: UPGRADE-CAP-ID                                                                        │
│  │ Sender: PUBLISHER-ID                                                                            │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                         │
│  │ ObjectType: 0x2::package::UpgradeCap                                                            │
│  │ Version: 3                                                                                      │
│  │ Digest: FNxdiGCk1fwXByda6Q2sx8RjuwUQBFYQk7C4Zr2H4qVw                                            │
│  └──                                                                                               │
│ Mutated Objects:                                                                                   │
│  ┌──                                                                                               │
│  │ ObjectID: GAS-COIN-ID                                                                           │
│  │ Sender: PUBLISHER-ID                                                                            │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                         │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                      │
│  │ Version: 3                                                                                      │
│  │ Digest: 9Fet6LPSBsjYjVMEQxkB4LRHfAJDFCQQ2iUAiUQ5eygF                                            │
│  └──                                                                                               │
│ Published Objects:                                                                                 │
│  ┌──                                                                                               │
│  │ PackageID: ORIGINAL-PACKAGE-ID                                                                  │
│  │ Version: 1                                                                                      │
│  │ Digest: 4ZvhnDgehkRmzo3mtHjCc6aQkEz1SA87rDpDS6pGarFR                                            │
│  │ Modules: example                                                                                │
│  └──                                                                                               │
╰────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Balance Changes                                                                                   │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                              │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                        │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: -10319880                                                                              │
│  └──                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

The result includes an **Object changes** section with two pieces of information you need for upgrading, an `UpgradeCap` ID and your package ID.

You can identify the different objects using the `Object.objectType` value in the response. The `UpgradeCap` entry has a value of `String("0x2::package::UpgradeCap")` and the `objectType` for the package reads `String("<PACKAGE-ID>::sui_package::<MODULE-NAME>")`

<Tabs>

<TabItem value="automated-address-management" label="Automated Addresses">

:::info

Beginning with the Sui `v1.29.0` release, published addresses are automatically managed in the `Move.lock` file and you do not need to take further action.

If the package was published or upgraded with a Sui version prior to `v1.29.0`, you can follow [the guide for adopting automated address management](automated-address-management#adopting-automated-address-management-for-published-packages). Alternatively, refer to the `Manual Addresses` tab above for further steps.

:::

After a while, you decide to upgrade your `sui_package` to include some requested features.

</TabItem>

<TabItem value="manual-address-management" label="Manual Addresses">

If your package has not [adopted automated address management](automated-address-management#adopting-automated-address-management-for-published-packages) you'll need to take the following manual steps.

To make sure your other packages can use this package as a dependency, you must update the `Move.toml` manifest file for your package to include published information.

Update the alias address and add a new `published-at` entry in the `[package]` section, both pointing to the value of the on-chain ID:

```toml
[package]
name = "sui_package"
version = "0.0.0"
published-at = "<ORIGINAL-PACKAGE-ID>"

[addresses]
sui_package = "<ORIGINAL-PACKAGE-ID>"
```

After a while, you decide to upgrade your `sui_package` to include some requested features. Before running the `upgrade` command, you need to edit the manifest again.

In the `[addresses]` section, you update the `sui_package` address value to `0x0` again so the validator issues a new address for the upgrade package. You can leave the `published-at` value the same, because it is only read by the toolchain when publishing a dependent package. The saved manifest now resembles the following:

```toml
[package]
name = "sui_package"
version = "0.0.1"
published-at = "<ORIGINAL-PACKAGE-ID>"

[addresses]
sui_package = "0x0"
```

With the new manifest and code in place, you can proceed.

</TabItem>

</Tabs>

Run `sui client upgrade` command to upgrade your package. Pass the `UpgradeCap` ID (the `<UPGRADE-CAP-ID>` value from the example) to the `--upgrade-capability` flag.

```sh
$ sui client upgrade --upgrade-capability <UPGRADE-CAP-ID>
```

The console alerts you if the new package doesn't satisfy [requirements](#requirements), otherwise the compiler publishes the upgraded package to the network and returns its result:

```sh
Transaction Digest: 3NnJGryz2k2BJzjpndDVqVcdZmmefNMB8SJ9bCEQct22
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                                                                             │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: PUBLISHER-ID                                                                                                                                         │
│ Gas Owner: PUBLISHER-ID                                                                                                                                      │
│ Gas Budget: 9684740 MIST                                                                                                                                     │
│ Gas Price: 1000 MIST                                                                                                                                         │
│ Gas Payment:                                                                                                                                                 │
│  ┌──                                                                                                                                                         │
│  │ ID: GAS-COIN-ID                                                                                                                                           │
│  │ Version: 3                                                                                                                                                │
│  │ Digest: D2rpccs7eSw8gtb4T1K2bSVzF5eApC68xiHDtNGQEcEb                                                                                                      │
│  └──                                                                                                                                                         │
│                                                                                                                                                              │
│ Transaction Kind: Programmable                                                                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Input Objects                                                                                                                                            │ │
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │
│ │ 0   Imm/Owned Object ID: UPGRAD-CAP-ID                                                                                                                   │ │
│ │ 1   Pure Arg: Type: u8, Value: 0                                                                                                                         │ │
│ │ 2   Pure Arg: Type: vector<u8>, Value: [49,208,61,255,107,134,136,221,231,35,60,2,248,17,234,236,64,76,71,188,57,104,46,113,67,94,232,236,64,59,144,112] │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│ ╭───────────────────────────────────────────────────────────────────────────────────────────╮                                                                │
│ │ Commands                                                                                  │                                                                │
│ ├───────────────────────────────────────────────────────────────────────────────────────────┤                                                                │
│ │ 0  MoveCall:                                                                              │                                                                │
│ │  ┌                                                                                        │                                                                │
│ │  │ Function:  authorize_upgrade                                                           │                                                                │
│ │  │ Module:    package                                                                     │                                                                │
│ │  │ Package:   0x0000000000000000000000000000000000000000000000000000000000000002          │                                                                │
│ │  │ Arguments:                                                                             │                                                                │
│ │  │   Input  0                                                                             │                                                                │
│ │  │   Input  1                                                                             │                                                                │
│ │  │   Input  2                                                                             │                                                                │
│ │  └                                                                                        │                                                                │
│ │                                                                                           │                                                                │
│ │ 1  Upgrade:                                                                               │                                                                │
│ │  ┌                                                                                        │                                                                │
│ │  │ Dependencies:                                                                          │                                                                │
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000001                   │                                                                │
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000002                   │                                                                │
│ │  │ Current Package ID: ORIGINAL-PACKAGE-ID                                                │                                                                │
│ │  │ Ticket: Result 0                                                                       │                                                                │
│ │  └                                                                                        │                                                                │
│ │                                                                                           │                                                                │
│ │ 2  MoveCall:                                                                              │                                                                │
│ │  ┌                                                                                        │                                                                │
│ │  │ Function:  commit_upgrade                                                              │                                                                │
│ │  │ Module:    package                                                                     │                                                                │
│ │  │ Package:   0x0000000000000000000000000000000000000000000000000000000000000002          │                                                                │
│ │  │ Arguments:                                                                             │                                                                │
│ │  │   Input  0                                                                             │                                                                │
│ │  │   Result 1                                                                             │                                                                │
│ │  └                                                                                        │                                                                │
│ ╰───────────────────────────────────────────────────────────────────────────────────────────╯                                                                │
│                                                                                                                                                              │
│ Signatures:                                                                                                                                                  │
│    nNJ8AiSAeV+NB3ayRTwcfaJHx3AzFHlZysbwda5e2jFBz5W9Z5EnzXV09xZMQYctUtW33jWpUFdK8hOJ9hZzDg==                                                                  │
│                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: 3NnJGryz2k2BJzjpndDVqVcdZmmefNMB8SJ9bCEQct22                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 1                                                                                 │
│                                                                                                   │
│ Created Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x5d49966433ebb423f5b40bfcd0ecfdc67f1527e3b9e3a433c4ec87ae63d54ed4                         │
│  │ Owner: Immutable                                                                               │
│  │ Version: 2                                                                                     │
│  │ Digest: 6GmLYmCszFxbaLRLTyZdxTTfXG99iq8uVabfi2NaB5fQ                                           │
│  └──                                                                                              │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: GAS-COIN-ID                                                                                │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                        │
│  │ Version: 4                                                                                     │
│  │ Digest: G5PBJjLKJWL2J3rb8ZR4uLNgFPpyJNNXfXNoh3FDo1zK                                           │
│  └──                                                                                              │
│  ┌──                                                                                              │
│  │ ID: 0x562408a381f3f2fce9c5ea27da42953e001760aa35dbadb273dca24166657516                         │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                        │
│  │ Version: 4                                                                                     │
│  │ Digest: 6B4pA1EcYek2pvrRoBv9jKhPmUGxhH1zZD3UcqPmxwDM                                           │
│  └──                                                                                              │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: GAS-COIN-ID                                                                                │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                        │
│  │ Version: 4                                                                                     │
│  │ Digest: G5PBJjLKJWL2J3rb8ZR4uLNgFPpyJNNXfXNoh3FDo1zK                                           │
│  └──                                                                                              │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 9302400 MIST                                                                     │
│    Computation Cost: 1000000 MIST                                                                 │
│    Storage Rebate: 2595780 MIST                                                                   │
│    Non-refundable Storage Fee: 26220 MIST                                                         │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    7MdLdLYBhP6LKGf6gvuona2EQJZ1W7k3kRisrapmzQ5m                                                   │
│    8etH8jq78aKDHwL9ZnmAMhra62Q9vcPfyAcKJyXNPWvi                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────╮
│ No transaction block events │
╰─────────────────────────────╯

╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                   │
├──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Mutated Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: GAS-COIN-ID                                                                         │
│  │ Sender: PUBLISHER-ID                                                                          │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                       │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 4                                                                                    │
│  │ Digest: G5PBJjLKJWL2J3rb8ZR4uLNgFPpyJNNXfXNoh3FDo1zK                                          │
│  └──                                                                                             │
│  ┌──                                                                                             │
│  │ ObjectID: 0x562408a381f3f2fce9c5ea27da42953e001760aa35dbadb273dca24166657516                  │
│  │ Sender: PUBLISHER-ID                                                                          │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                       │
│  │ ObjectType: 0x2::package::UpgradeCap                                                          │
│  │ Version: 4                                                                                    │
│  │ Digest: 6B4pA1EcYek2pvrRoBv9jKhPmUGxhH1zZD3UcqPmxwDM                                          │
│  └──                                                                                             │
│ Published Objects:                                                                               │
│  ┌──                                                                                             │
│  │ PackageID: 0x5d49966433ebb423f5b40bfcd0ecfdc67f1527e3b9e3a433c4ec87ae63d54ed4                 │
│  │ Version: 2                                                                                    │
│  │ Digest: 6GmLYmCszFxbaLRLTyZdxTTfXG99iq8uVabfi2NaB5fQ                                          │
│  │ Modules: example                                                                              │
│  └──                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Balance Changes                                                                                   │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                              │
│  │ Owner: Account Address ( PUBLISHER-ID )                                                        │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: -7706620                                                                               │
│  └──                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

The result provides a new ID for the upgraded package.

<Tabs>

<TabItem value="automated-address-management" label="Automated Addresses">

:::info

Beginning with the Sui `v1.29.0` release, upgraded addresses are automatically managed in the `Move.lock` file and you do not need to take further action.

If the package was published or upgraded with a Sui version prior to `v1.29.0`, you may follow [the guide for adopting automated address management](automated-address-management#adopting-automated-address-management-for-published-packages). Alternatively, refer to the `Manual Addresses` tab above for further steps.

:::

</TabItem>

<TabItem value="manual-address-management" label="Manual Addresses">

So that packages that depend on your `sui_package` know where to find the on-chain bytecode for verification, edit your manifest again. Provide the upgraded package ID for the `published-at` value and return the original `sui_package` ID value in the `[addresses]` section:

```toml
[package]
name = "sui_package"
version = "0.0.1"
published-at = "<UPGRADED-PACKAGE-ID>"

[addresses]
sui_package = "<ORIGINAL-PACKAGE-ID>"
```

Note the `published-at` value changes with every upgrade and needs to be updated after every upgrade.

The ID for the `sui_package` in the `[addresses]` section always points to the original package ID after upgrading. You must always change that value back to `0x0`, however, before running the `upgrade` command so the validator knows to create a new ID for the upgrade.

</TabItem>

</Tabs>

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/tokenomics/sui-bridging.mdx
```
---
title: SUI Bridging
---

Bridging is the process of moving tokens from one blockchain to another. When you use a bridge to move tokens between blockchains that are incompatible, the tokens are "wrapped" by the bridge, which means that they get converted to a derivative token for the target blockchain. You can transfer tokens in from other blockchains to SUI, or transfer SUI tokens out to other blockchains.

Sui supports bridging through [Sui Bridge](#sui-bridge), [Wormhole Connect](#wormhole-connect), and [Wormhole Portal Bridge](#wormhole-portal-bridge).

## Sui Bridge

Sui Bridge is the native bridge for the Sui network. Sui Bridge is built into the core architecture of the Sui blockchain, which provides optimal integration and operation. Sui Bridge enables the movement of digital assets between the Sui block chain and others, preserving security and maintaining interoperability between diverse ecosystems. Sui Bridge provides secure and efficient transfer of native and wrapped ETH to and from Sui. Sui Bridge leverages the unique capabilities of the Sui network to offer fast transaction speeds, lower transaction costs, and a decentralized architecture.

You can bridge tokens in the official Sui Bridge website: https://bridge.sui.io/.

### Operation and governance

Sui Bridge is operated and governed by Sui network validators, the same set of validators that secure the Sui network. Bridge transfers and other actions require validator signatures with a minimal threshold of voting power.

Similar to the Sui network, all governance related to the Sui Bridge is done through validator voting.

To learn more about how to set up a Sui Bridge Full Node, see [Sui Bridge Validator Node Configuration](../../guides/operator/bridge-node-configuration.mdx).

### Supported chains and tokens

You can transfer supported assets both to and from the Sui network. Sui Bridge supports token bridging between Sui and other networks with the following supported assets:

| Asset | Description |
| --- | --- |
| Wrapped Bitcoin |  Tokenized representation of the native cryptocurrency of the Bitcoin network. |
| Lightning Bitcoin (LBTC) | Fully decentralized Internet-of-value protocol for global payments. |
| Ethereum (ETH) | The native cryptocurrency of the Ethereum network, widely used for transactions and smart contract interactions. |
| Wrapped Ethereum (WETH) | Tokenized representation of native ETH. |
| Tether (USDT) | A stablecoin pegged to the US dollar. |

### Package IDs and contract addresses

The following package IDs and addresses are reserved for the Sui Bridge.

| Asset | Address/ID |
| --- | --- |
| Sui Bridge package on Sui | [`0xb`](https://suiscan.xyz/mainnet/object/0x000000000000000000000000000000000000000000000000000000000000000b/txs) |
| Sui Bridge object on Sui | [`0x9`](https://suiscan.xyz/mainnet/object/0x0000000000000000000000000000000000000000000000000000000000000009) |
| Sui Bridge contract on Ethereum Mainnet | [`0xda3bD1fE1973470312db04551B65f401Bc8a92fD`](https://etherscan.io/address/0xda3bd1fe1973470312db04551b65f401bc8a92fd) |
| ETH on Sui | [`0xd0e89b2af5e4910726fbcd8b8dd37bb79b29e5f83f7491bca830e94f7f226d29::eth::ETH`](https://suiscan.xyz/mainnet/coin/0xd0e89b2af5e4910726fbcd8b8dd37bb79b29e5f83f7491bca830e94f7f226d29::eth::ETH/txs) |
| ETH on Ethereum | Native Ether |
| WETH on Ethereum | [`0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2`](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2) |

### Source code

The source code for Sui Bridge is open-source and found in the following locations:

- Move: https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/bridge
- Solidity: https://github.com/MystenLabs/sui/tree/main/bridge/evm
- Bridged ETH (Move): https://github.com/MystenLabs/sui/tree/main/bridge/move/tokens/eth
- Bridge Node: https://github.com/MystenLabs/sui/tree/main/crates/sui-bridge
- Bridge Indexer: https://github.com/MystenLabs/sui/tree/main/crates/sui-bridge-indexer

### Audits

There are two audit reports available for Sui Bridge:
- [OtterSec](https://github.com/sui-foundation/security-audits/blob/main/docs/Sui_bridge_v1_OtterSec.pdf)
- [Zellic](https://github.com/sui-foundation/security-audits/blob/main/docs/Sui_Bridge_v1_Zellic.pdf)

### Global limiter {#global-limiter}

A limiter protects the user's funds by constraining the total value of assets leaving Sui Bridge in any 24-hour window. It tracks total value hourly and aggregates values from the previous 24 hours. Therefore, when the limiter cools down, it refreshes every hour.

The limit applies globally and varies per direction. For example, the amount might be different between Ethereum to Sui and Sui to Ethereum.

The limit also impacts the maximal amount of single transfer. In one bridge transfer, you cannot move assets worth more than the limit. The bridge frontend might apply stricter restrictions to protect user assets.

The limit per route is governed by the validator committee through voting. The limit value is captured in the `approved-governance-actions` attribute of Bridge node configurations, which is announced in the [mn-validator-announcements channel](https://discord.com/channels/916379725201563759/1093852827627040768) on Discord when it updates.

The global limit is currently &dollar;16 million from Ethereum to Sui and &dollar;7 million from Sui to Etheruem every 24 hours.

### Asset price

Sui Bridge v1 uses static pricing to calculate limits. The price for ETH is configured at &dollar;2,600.00. Namely, bridging one ETH consumes &dollar;2,600 USD in limit calculation.

The validator committee governs the pricing through voting. It works together with the global limiter to protect user funds.

### Transfer limit

There is no minimal limit for transfer, but a tiny fraction might be rounded down. Particularly for native Ethereum (ETH) and wrapped Ethereum (WETH) because of reduced precision of eight decimal places, the value of 10.0000000000000001 (W)ETH is rounded down to 10 (W)ETH.

| Token | Minimal value | 
| --- | --- |
| ETH | 0.00000001 ETH (eight decimal places of precision) |
| WETH | 0.00000001 ETH (eight decimal places of precision) |

The maximum limit per transfer is the global limit in USD value. Namely a user cannot claim assets on the destination chain if the USD value is higher than the global limit. See the [Global limiter section](#global-limiter) for details.

## Wormhole Connect {#wormhole-connect}

Use Wormhole Connect to bridge tokens from any Wormhole supported chain into Sui and get dropped off with extra Sui to pay gas fees. Developers can also embed the Connect Token Bridge directly into their own websites and dApps.

:::tip

Wormhole provides a tutorial for cross-chain transfers of Sui using a Wormhole Connect integration. Visit [Cross-Chain Token Transfers with Wormhole Connect](https://wormhole.com/docs/tutorials/messaging/sui-connect/) on the Wormhole website to get started.

:::

### Wormhole Connect asset support {#asset-support}

Initially, Wormhole Connect supports only lock-and-mint bridging for ETH, WETH, USDC, MATIC, WMATIC, BNB, WBNB, AVAX, WAVAX, FTM, WFTM, CELO, GLMR, WGLRM, AND SOL across Ethereum, Polygon, BSC, Avalanche, Celo, Moonbeam, Solana and Sui. This means that any native token bridged through Wormhole Connect and the underlying Wormhole Token Bridge are received as a Wormhole-minted token on the destination chain. In some cases, Wormhole-minted tokens are the canonical representation on the chain. See the [Wormhole token list](https://github.com/wormhole-foundation/wormhole-token-list) on GitHub. Some Wormhole-minted tokens support swapping on the destination chain's DEX(s) for whichever assets you need.

### Wormhole Connect automatic relay {#automatic-relay}

On EVM-based chains and Sui, Wormhole Connect lets you bridge assets while having to pay gas only on the source chain. The automatic relaying feature pays gas on behalf of users on the destination chain.

### Wormhole Connect gas drop-off {#gas-drop-off}

The gas drop-off feature enables users to pay an additional fee on the source chain to request a small amount of native gas on the destination chain. For example, a user bridging USDC from Ethereum to Sui can pay a fee denominated in USDC from their sending wallet to receive some native SUI in their receiving wallet. This is in addition to the USDC they are bridging over. Gas drop-off is currently supported on EVM-based chains and Sui.

To learn more about Wormhole Connect, see their [FAQ](https://docs.wormhole.com/wormhole/faqs) page.

## Wormhole Portal Bridge

The Wormhole powered [Portal Bridge](https://www.portalbridge.com/sui) supports bridging any asset from any of the [22 supported Wormhole chains](https://www.wormhole.com/network).

## Token address list {#token-address-list}

The following table lists the address associated with each token type. You can confirm the legitimacy of tokens when you bridge them by confirming that the address used matches the address for the token type.

| Token   | Address                                                            |
| ------- | ------------------------------------------------------------------ |
| CELO    | 0xa198f3be41cda8c07b3bf3fee02263526e535d682499806979a111e88a5a8d0f |
| WMATIC  | 0xdbe380b13a6d0f5cdedd58de8f04625263f113b3f9db32b3e1983f49e2841676 |
| WBNB    | 0xb848cce11ef3a8f62eccea6eb5b35a12c4c2b1ee1af7755d02d7bd6218e8226f |
| WETH    | 0xaf8cd5edc19c4512f4259f0bee101a40d41ebed738ade5874359610ef8eeced5 |
| USDC    | 0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf |
| USDT    | 0xc060006111016b8a020ad5b33834984a437aaa7d3c74c18e09a95d48aceab08c |
| WBTC    | 0x027792d9fed7f9844eb4839566001bb6f6cb4804f66aa2da6fe1ee242d896881 |
| WAVAX   | 0x1e8b532cca6569cab9f9b9ebc73f8c13885012ade714729aa3b450e0339ac766 |
| WFTM    | 0x6081300950a4f1e2081580e919c210436a1bed49080502834950d31ee55a2396 |
| WGLMR   | 0x66f87084e49c38f76502d17f87d17f943f183bb94117561eb573e075fdc5ff75 |
| WSOL    | 0xb7844e289a8410e50fb3ca48d69eb9cf29e27d223ef90353fe1bd8e27ff8f3f8 |
| USDCsol | 0xb231fcda8bbddb31f2ef02e6161444aec64a514e2c89279584ac9806ce9cf037 |

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/tokenomics/gas-pricing.mdx
```
---
title: Sui Gas Pricing
---

The Sui gas-pricing mechanism achieves three outcomes: delivering low, predictable transaction fees, incentivizing validators to optimize their transaction processing operations, and preventing denial of service attacks.

This enables you to focus on using the Sui network to provide the best user experience without needing to forecast the current market price of gas fees. Since validators agree on a network-wide reference price at the start of each epoch, you can use the reference price as a credible anchor when submitting transactions. Moreover, the price setting mechanism rewards good validator behavior, thus aligning incentives between SUI token holders, the network's operators (validators), and its users.

A unique feature of the Sui gas price mechanism is that users pay separate fees for transaction execution and for storing the data associated with each transaction. The gas fees associated with an arbitrary transaction $\tau$ equal:

$$
GasFees[\tau] \ = \ ComputationUnits[\tau] \times ComputationPrice[\tau] \ + \ StorageUnits[\tau] \times StoragePrice
$$

The gas functions $ComputationUnits[\tau]$ and $StorageUnits[\tau]$ measure the amount of computation and storage resources, respectively, required to process and store the data associated with $\tau$. The gas prices $ComputationPrice[\tau]$ and $StoragePrice$ translate the cost of computation and storage, respectively, into SUI units. The decoupling between gas units and gas prices is useful since SUI market price will fluctuate over time in accordance with supply and demand.

## Computation gas prices {#computation}

The computation gas price $ComputationPrice[\tau]$ captures the cost of one unit of computation in SUI units. This price is set at the transaction level and submitted by the user as the transaction's gas price. Conceptually, it is useful to think about this gas price in two parts:

$$
ComputationPrice[\tau] \ = \ ReferencePrice \ + \ Tip[\tau]
$$

On the Sui network, a single $ReferencePrice$ exists throughout each epoch, with Sui validators updating the $ReferencePrice$ at each epoch boundary. Hence, in practice, when a user submits a gas price above the $ReferencePrice$, it is useful to think of the difference as a tip paid to the network in order to get higher priority. During moments of regular network operations, users are not expected to pay tips and the vast majority of transactions have gas prices equal to $ReferencePrice$.

More generally, the Sui gas price mechanism makes the $ReferencePrice$ a credible anchor for you to reference when submitting transactions to the network. Providing reasonable confidence that transactions submitted with gas prices at or close to the reference price are executed in a timely manner. This is achieved through three core steps:

- **Gas price survey:** All validators are surveyed at the start of each epoch, and every validator submits their reservation price. That is, each validator states the minimum gas price at which they are willing to process transactions. The protocol orders these quotes and chooses the 2/3 percentile by stake as the reference price. The gas price survey goal is to set a reference price under which a [quorum](../../guides/operator/validator-committee.mdx#quorums) of validators are willing to promptly process transactions.
- **Tallying rule:** Throughout the epoch, validators obtain signals over the operations of other validators. Each validator uses these signals to build a (subjective) evaluation over the performance of every other validator. Specifically, each validator constructs a multiplier for the stake rewards of every other validator such that validators who behave well receive boosted rewards, and validators who do not receive reduced rewards. The tallying rule goal is to create a community-enforced mechanism for encouraging validators to honor the reference gas price.
- **Incentivized stake reward distribution rule:** At the end of the epoch, the distribution of stake rewards across validators is adjusted using information from the tallying rule. Specifically, a global multiplier is built for every validator using the median value (weighted by stake) out of the set of individual multipliers constructed during the tallying rule. All else equal, validators that operated performantly receive their regular stake rewards, whereas validators who did not operate performantly at the reference gas price receive slashed rewards. Since stake rewards are influenced by the amount of stake each validator owns, validators are encouraged to obtain more stake by lowering gas fees and pricing out inefficient validators. This benefits Sui end users since the stake reward distribution rule incentivizes validators to deliver a more cost-efficient network.

In sum, the gas price mechanism has two main forces: the tallying rule incentivizes validators to honor the quotes submitted during the gas survey, while the distribution rule incentivizes validators to submit low reservations prices. The interaction of these two forces delivers a mechanism encouraging validators to set a low network-level reference gas price - but not too low, because they face penalties if they cannot honor their quotes. In other words, the gas price mechanism encourages a healthy competition for fair prices.

## Storage gas prices {#storage}

The storage gas price $StoragePrice$ captures the costs of covering one unit of storage in perpetuity, in SUI units. This price is set through governance proposals and is updated infrequently. The goal is to ensure Sui users pay for their use of on-chain data storage by depositing these fees into the storage fund and then redistributing these fees to future validators. In contrast to the computation gas price, storage prices are fixed and common for all transactions both within an epoch and across epochs until the storage price is updated.

The $StoragePrice$ is set exogenously through the governance proposal with the goal of targeting the off-chain dollar cost of data storage. In the long run, as the costs of storage fall due to technological improvements and the dollar price of the SUI token evolves, governance proposals will update the price in order to reflect the new dollar target price.

## Gas prices as a coordination mechanism {#coordination-mechanism}

Overall, when you submit transactions with computation gas prices at or close to the current epoch $ReferencePrice$ and storage gas prices at the targeted $StoragePrice$, you have the best user experience. The Sui gas price mechanism provides you with credible reference prices for submitting your transactions. By incentivizing validators to elicit their true reservation prices and honor these quotes, you can credibly assume your transactions are processed in a timely manner.

After Sui enables horizontal scaling, validators can add more workers as demand for on-chain activity scales. This increases their costs linearly at the same pace of network activity and lets them process more transactions at the same low gas prices. In cases of extreme network congestion where validators cannot scale fast enough, the tip presence provides a market-based congestion pricing mechanism that discourages further demand spikes by increasing the cost of transacting on the Sui platform.

In the long run, the Sui gas price mechanism creates incentives for validators to optimize their hardware and operations. Validators that invest in becoming more efficient are able to honor lower gas prices and obtain a stake reward boost. Sui validators are thus encouraged to innovate and improve the experience of end users.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/tokenomics/staking-unstaking.mdx
```
---
title: Staking and Unstaking
description: Staking and unstaking SUI with validators earns a percentage of rewards they receive from gas fees.
---

Sui uses a Delegated-Proof-of-Stake (DPoS) system to secure and operate the network, meaning that the voting power of a validator in the network is determined by the amount of stake delegated to them by SUI token holders. The more stake delegated to a validator, the more voting power they have. In exchange for processing transactions and performing consensus, validators earn rewards based on the amount of gas fees collected. These rewards are then shared among stakers as staking rewards.

## Staking

You stake your SUI tokens by sending a transaction to the network that calls the staking function implemented as part of the system Move package. This transaction wraps the SUI tokens in a self-custodial stake object. This stake object contains information including the validator staking pool ID and the activation epoch of the stake. With the introduction of [SIP-6](https://blog.sui.io/liquid-staking-coming-sui/), you can participate in liquid staking protocols using your staked objects.

Sui-compatible crypto wallets typically have functionality to initiate staking and unstaking from your Sui address. See the respective documentation for these tools to begin staking your SUI.

## Unstaking

Similar to staking, a user withdraws stake from a validator by sending a transaction that calls the unstaking function in the system Move package. This transaction unwraps the stake object, and sends both the principal and the accumulated rewards to the user as SUI tokens. You accrue rewards only during epochs where the stake is active for the entire epoch. The rewards withdrawn from the validator's rewards pool are calculated based on the activation epoch and unstaking epoch of the stake.

## Choosing a validator for staking

When you stake on Sui, you have to choose a specific validator you would like to stake with. The choice of validator can potentially impact the amount of staking rewards you receive. The factors determining this amount include, but are not limited to:

- Validator commission rate: a validator can choose to set a non-zero commission rate specifying the percentage of staking rewards they are taking from the stakers. For example, if a validator has a commission rate of 10%, then 10% of every staker's staking rewards is given to the validator. Understand that a validator can choose its commission at a future moment in time without prior notice.
- Validator performance: a validator with bad performance might be punished according to the [tallying rule](./gas-pricing.mdx#tallying-rule). Punished validators do not receive any staking rewards for the epoch during which they are punished, and you also do not receive that epoch's rewards when you withdraw your stake from that validator. 

Sui-compatible crypto wallets and explorers typically provide validator information such as commission and APY. See the respective documentation for these tools for information on how to retrieve this data.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/tokenomics/vesting-strategies.mdx
```
---
title: Token Vesting Strategies
description: If you plan to launch a token on Sui, then you might consider implementing a vesting strategy to strengthen the long-term outlook of your token.
---

If you plan to launch a token on Sui, then you might consider implementing a vesting strategy to strengthen the long-term outlook of your token. A vesting strategy typically releases your tokens to team members, investors, or other early stakeholders over time, rather than releasing them all at once.

Implementing and publishing the details of your vesting strategy helps to:
  - Ensure long-term commitment of your token.
  - Prevent market dumps.
  - Allay fears of rug pulls (immediate withdraw of a large amount of early tokens that hurts token value).
  - Align stakeholder incentives with the project's success.

## Vesting options

There are different vesting strategies available for your token launch. The best option for your project depends on a number of factors unique to your project and its goals.

The following sections highlight some available options to consider when launching a token on the Sui network.

### Cliff vesting

Cliff vesting refers to a situation where the entire amount of tokens or assets becomes available after a specific period (the “cliff”). Until the cliff period is met, no tokens are released.

:::info Example scenario

Each of the ten employees of a project are granted 1,000 tokens with a one-year cliff. After one year, they receive the full 1,000 tokens. Before the year is up, they have no access to the tokens.

:::

The following smart contract implements a cliff vesting schedule for token releases. The module includes a `new_wallet` function that you pass the total sum of coins to vest and the cliff date as a timestamp. You can then call the `claim` function to retrieve the tokens from the wallet if the cliff date is in the past. 

Considering the example scenario, you would call `new_wallet` ten times so that a separate wallet existed for each employee. You would include 1,000 tokens in each call to load the wallet with the necessary funds. Subsequent calls to `claim` using the relevant wallet would compare the cliff time (`cliff_time` in the `Wallet` object) against the current time, returning tokens from the wallet if the cliff time is later than the current time. 

<details>
<summary> 
`cliff.move`
</summary>
{@inject: examples/vesting/sources/cliff.move}
</details>

### Graded vesting

Graded vesting allows tokens to be gradually released over time, often in equal portions, during the vesting period.

:::info Example scenario

An employee receives 1,200 tokens, with 300 tokens vesting every year over four years. At the end of each year, 300 tokens become available.

:::

The following [Hybrid vesting](#hybrid-vesting) section includes a smart contract that demonstrates how to perform graded vesting. 

### Hybrid vesting

Hybrid vesting combines different vesting models, such as cliff and graded vesting. This allows flexibility in how tokens are released over time.

:::info Example scenario

50% of tokens are released after a one-year cliff, and the rest are distributed linearly over the next three years.

:::

The following smart contract creates a hybrid vesting model. Like the cliff vesting smart contract, the hybrid model defines a `Wallet` struct to hold all the tokens for each stakeholder. This wallet, however, actually contains two different wallets that each follow a different set of vesting rules. When you call the `new_wallet` method for this contract, you provide the cliff cutoff timestamp, the timestamp for when the linear schedule begins, and a timestamp for when the linear vesting should end. Calls to `claim` then return the sum of tokens that fall within those parameters.

<details>
<summary>
`hybrid.move`
</summary>
{@inject: examples/vesting/sources/hybrid.move}
</details>

### Backloaded vesting

Backloaded vesting distributes the majority of tokens near the end of the vesting period, rather than evenly over time. This approach can help an ecosystem become more mature before large amounts of tokens become unlocked. Team members and stakeholders can be rewarded early but save the biggest rewards for those that remain with the project for a greater length of time.

:::info Example scenario

An employee's tokens release under the following schedule: 
  - 10% in the first three years 
  - 90% in the fourth year

:::

The smart contract for backloaded vesting creates two `Wallet` objects inside a parent wallet, which contains all the tokens to be vested. Each of the child wallets is responsible for its own vesting schedule. You call `new_wallet` with the coins to vest and `start_front`, `start_back`, `duration`, and `back_percentage` values. Based on the values you provide, the contract determines how many tokens to return when the wallet owner calls the `claim` function.

For the example scenario, you could pass the start timestamp for the frontload and the start timestamp for the backload (three years after the frontload start). You would also pass the duration of four years (`126230400000`) and `90` for the `back_percentage` value. 

<details>
<summary>
`backloaded.move`
</summary>
{@inject: examples/vesting/sources/backloaded.move}
</details>

### Milestone- or performance-based vesting {#milestone}

With performance-based vesting, achieving specific goals or metrics trigger vest events, such as hitting revenue targets or progressing through project stages.

:::info Example scenario

A team's tokens vest in relation to the number of monthly active users (MAUs). All tokens become vested after the platform reaches its goal of 10 million MAUs.

:::

Similarly, milestone-based vesting creates vest events when specific project or personal milestones are achieved, rather than being tied to time-based conditions.

:::info Example scenario

Tokens unlock when the mainnet of a blockchain project launches.

:::

Like the other examples, the following smart contract creates a wallet to hold the coins to be distributed. Unlike the others, however, this `Wallet` object includes a `milestone_controller` field that you set to the address of the account that has the authority to update the milestone progress. The call to the `new_wallet` function aborts with an error if the wallet has the same address as the entity with milestone update privileges as an integrity check. 

The milestone update authority can call `update_milestone_percentage` to update the percentage-to-complete value. The owner of the vested token wallet can call `claim` to retrieve the tokens that are unlocked based on the current percentage-to-complete value. Considering the first example scenario, you could update the milestone value by ten percent for every million MAUs the project achieves. You could use the same contract for the second scenario, updating the percentage one time to 100 only after mainnet launches.

<details>
<summary>
`milestone.move` 
</summary>
{@inject: examples/vesting/sources/milestone.move}
</details>

### Linear vesting

With linear vesting, tokens are released gradually over a set time period. 

:::info Example scenario

An employee is granted 1,000 tokens to be gradually released over a one-year period.

:::

The linear vesting smart contract creates a `Wallet` object with `start` and `duration` fields. The contract uses those values along with the current time to determine the number of tokens that are vested. The current time, in this case, is the time at which the wallet owner calls the `claim` function.

For the example scenario, you create the wallet (call `new_wallet`) with 1,000 tokens, the timestamp for the employee start date, and one year (`31557600000`) as the duration.

<details>
<summary>
`linear.move`
</summary>
{@inject: examples/vesting/sources/linear.move}
</details>

### Immediate vesting

All tokens vest immediately, meaning they are fully available as soon as they are allocated.

:::info Example scenario

An early investor receives their full allocation of tokens at the time of purchase.

:::

With immediate investing, you could always just transfer tokens to an address. Opting for a smart contract approach provides several advantages over a manual transfer, however.
   - Enhanced transparency and accountability because the transaction is stored on chain for any interested parties to verify. The smart contract logic identifies the exact purpose of the transaction.
   - Possible to enforce specific conditions. For example, you could create a [milestone-based vesting](#milestone) contract that you update to 100% complete only after some conditions are met, like accepting terms of an agreement.
   - Provides an auditable record for compliance and reporting.
   - Allows flexibility to perform other actions as the terms of an agreement change, like conversion to another token before claiming.

The following test leverages the [linear vesting](#linear-vesting) smart contract example to demonstrate how to use one of the other vesting strategy smart contracts to support immediate vesting. The test uses the `Wallet` object and `new_wallet` function from `vesting::linear` to perform (or test) an immediate vest scenario. The test accomplishes this by setting the `duration` value to 0.

<details>
<summary>
`immediate_tests.move`
</summary>
{@inject: examples/vesting/tests/immediate_tests.move}
</details>

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/tokenomics/gas-in-sui.mdx
```
---
title: Gas in Sui
description: A Sui transaction must pay for both the computational cost of execution and the long-term cost of storing the objects a transaction creates or mutates.
---

A Sui transaction must pay for both the computational cost of execution and the long-term cost of storing the objects a transaction creates or mutates. Specifically, [Sui Gas Pricing](gas-pricing.mdx) is such that any transaction pays the following gas fees:

`total_gas_fees = computation_units * reference_gas_price + storage_units * storage_price`

While computation and storage fees are separate, they are conceptually similar in that they each translate computation or storage into SUI terms by multiplying computation or storage units by the relevant price.

Finally, Sui storage mechanics provide storage fee rebates whenever a transaction deletes previously stored objects. Hence, the net fees that a user pays equals gas fees minus the rebates associated with data deletion:

`net_gas_fees = computation_gas_fee + storage_gas_fee - storage_rebate`

The information on net gas fees is displayed in a Sui network explorer for each transaction block:

![Gas Fees displayed on a Sui network explorer](images/gas-fees-explorer.png "The Gas Fees section displayed on a Sui network explorer")
_The Gas Fees section for a transaction block displayed on a Sui network explorer_

## Gas prices {#gas-prices}

The [reference gas price](gas-pricing.mdx#computation-gas-prices) translates the real-time cost of executing a transaction into SUI units and the validator set updates it at each epoch boundary. Similarly, the [storage price](gas-pricing.mdx#storage-gas-prices) translates the long-term cost of storing data on chain into SUI units and updates infrequently; often remaining constant for various consecutive epochs. During regular network operations, all Sui users can expect to pay the reference gas price and storage price for computation and storage, respectively.

## Gas units {#gas-units}

Gas units include both

- [Computation units](#computation)
- [Storage units](#storage)

### Computation units {#computation}

Different Sui transactions require varying amounts of computational time for processing and execution. Sui translates these varying operational loads into transaction fees by measuring each transaction in terms of computation units. In general, more complex transactions require more computation units.

Importantly, though, Sui computation gas schedule is built coarsely with a bucketing approach. Two relatively similar transactions translate into the exact same amount of computation units if they are in the same bucket, whereas two relatively different transactions translate into different amounts of computation units if they fall in separate buckets. The smallest bucket maps into 1,000 computation units, meaning that all transactions that fall into the smallest bucket cost 1,000 computation units. The largest bucket maps into 5,000,000 computation units; if a transaction requires more computation units, it aborts.

Using coarse bucketing accomplishes two important goals:

    - Frees you from optimizing your smart contracts to deliver marginal gains in gas costs via "gas golfing" — instead, you can focus on step-function improvements in your products and services.
    - Gives you the freedom to adjust per-instruction gas costs and experiment with new gas metering schemes without creating significant development disruption. This can happen frequently, so it's important that you do not rely on per-instruction gas costs remaining stable over time.

| Bucket Lower Threshold | Bucket Upper Threshold | Computation Units      |
| ---------------------- | ---------------------- | ---------------------- |
| 0                      | 1,000                  | 1,000                  |
| 1,001                  | 5,000                  | 5,000                  |
| 5,001                  | 10,000                 | 10,000                 |
| 10,001                 | 20,000                 | 20,000                 |
| 20,001                 | 50,000                 | 50,000                 |
| 50,001                 | 200,000                | 200,000                |
| 200,001                | 1,000,000              | 1,000,000              |
| 1,000,001              | 5,000,000              | 5,000,000              |
| 5,000,001              | Infinity               | transaction will abort |

### Storage units {#storage}

Similarly, Sui transactions vary depending on the amount of new data written into on-chain storage. The variable storage units capture these differences by mapping the amount of bytes held in storage into storage units. The current Sui schedule is linear and maps each byte into 100 storage units. So, for example, a transaction that stores 25 bytes costs 2,500 storage units, while a transaction that stores 75 bytes costs 7,500 units.

Importantly, in the Sui [storage fund](../tokenomics.mdx#storage-fund) model users pay up front for the cost of storing data in perpetuity but can also get a partial rebate on previously stored data, if that data is deleted. Hence, the amount of storage fees that you pay can be split into a rebateable and non-rebateable amount. Initially, the rebateable amount equals 99% of the storage fees, while the non-rebateable amount equals the remaining 1%.

### Gas budgets {#gas-budgets}

You must submit all transactions need together with a gas budget. This provides a cap to the amount of gas fees you pay, especially because sometimes it might be hard to perfectly forecast how much a transaction costs before you submit it to the Sui network.

The gas budget for a Sui transaction is defined in SUI units and transactions are successfully executed if:

`gas_budget >= max{computation_fees,total_gas_fees}`

If the gas budget does not fulfill this condition, then the transaction fails and a portion of the gas budget is charged. In cases where the `gas_budget` is insufficient for covering `computation_fees`, then the entirety of the `gas_budget` is charged. In cases where `gas_budget` is sufficient for covering `computation_fees` but not the `total_gas_fees`, then a portion of the `gas_budget` corresponding to `computation_fees` and the fees associated with mutating the transaction's input objects are charged.

Ultimately, a successful transaction requires the end user to pay the transaction's `total_gas_fees`. However, since it is challenging to perfectly forecast computation time before the transaction is processed, the `gas_budget` condition also requires the `gas_budget` to be at least as large as the transaction's `computation_fees` in case the transaction aborts. In some cases -- especially in the presence of high storage rebates, and, thus negative net storage fees -- the gas budget might be higher than the total gas fees you pay.

Importantly, the minimum gas budget is 2,000 MIST (.000002 SUI). This ensures validators are compensated with at least 2,000 MIST even if the gas budget is incorrectly specified and the transaction aborts. Additionally, this protects the Sui network from being spammed with a large number of transactions with minimal gas budgets. The maximum gas budget is 50 billion MIST or 50 SUI. This protects the network against overflow of internal multiplications and gas limits for denial of service attacks.

As mentioned previously, the storage rebate currently equals 99% of the originally paid storage fees. Because the gas budget applies to the totality of gas fees, it is often the case that a transaction only goes through if the gas budget is considerably higher than the net gas fees that a user ultimately pays.

### Gas budget examples {#gas-budget-examples}

The following table provides some examples of gas accounting on the Sui network. Within the first two and last two rows, computation units are the same because transactions fall within the same bucket. However, the last two transactions are more complex than the first two and thus fall in a higher bucket. Finally, in the last transaction the storage rebate is large enough to fully offset the transaction gas fees and actually pays the user back a positive amount of SUI.

These examples showcase the importance of the gas budget. The minimum gas budget is the smallest amount a transaction can specify to successfully execute. Importantly, when there is a storage rebate, the minimum gas budget is larger than the amount of net gas fees a user ultimately pays — this is especially stark in the last example where the user receives a positive amount back for executing the transaction. This is because the minimum gas budget must be higher than a transaction's computation fees.

|                                                         | Reference Gas Price | Computation Units | Storage Price | Storage Units | Storage Rebate | Minimum Gas Budget | Net Gas Fees   |
| ------------------------------------------------------- | ------------------- | ----------------- | ------------- | ------------- | -------------- | ------------------ | -------------- |
| Simple transaction storing 10 bytes                     | 1,000 MIST          | 1,000             | 75 MIST       | 1,000         | 0 MIST         | 1,075,000 MIST     | 1,075,000 MIST |
| Simple transaction storing 10 bytes and deleting data   | 500 MIST            | 1,000             | 75 MIST       | 1,000         | 100,000 MIST   | 500,000 MIST       | 475,000 MIST   |
| Complex transaction storing 120 bytes                   | 1,000 MIST          | 5,000             | 200 MIST      | 12,000        | 0 MIST         | 7,400,000 MIST     | 7,400,000 MIST |
| Complex transaction storing 120 bytes and deleting data | 500 MIST            | 5,000             | 200 MIST      | 12,000        | 5,000,000 MIST | 2,500,000 MIST     | -100,000 MIST  |

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture/sui-security.mdx
```
---
title: Understand Sui Security
description: Sui is designed to provide very high security guarantees to asset owners. Assets on Sui can be used only by their owners, according to the logic pre-defined by smart contracts that can be audited, and that the network will be available to process them correctly despite some of the validators operating Sui not following the protocol correctly (fault tolerance).
---

This page provides an overview of the major guarantees Sui provides in terms of security.

Sui asset owners and smart contract designers can start learning here about the mechanisms available to secure their assets, and the assurances Sui provides for them. Smart contract designers can also learn about the overall Sui security architecture to ensure the asset types they design leverage Sui to provide a secure experience to the asset holders.

## Security features {#security-features}

Sui is designed to provide very high security guarantees to asset owners. Assets on Sui can be used only by their owners, according to the logic pre-defined by smart contracts that can be audited, and that the network will be available to process them correctly despite some of the validators operating Sui not following the protocol correctly (fault tolerance).

The security features of the Sui system ensure a number of properties:

- Only the owner of an owned asset can authorize a transaction that operates on this asset. Authorization is performed through the use of a private signature key that is known only to the asset owner.
- Everyone can operate on shared assets or immutable assets, but additional access control logic can be implemented by the smart contract.
- Transactions operate on assets according to predefined rules set by the smart contract creator that defined the asset type. These are expressed using the Move language.
- Once a transaction is finalized, its effects - namely changes to the assets it operates on or new assets created - will be persisted, and the resulting assets will be available for further processing.
- The Sui system operates through a protocol between a set of independent validators. Yet all its security properties are preserved when a small subset of the validators do not follow the protocol.
- All operations in Sui can be audited to ensure any assets have been correctly processed. This implies all operations on Sui are visible to all, and users may wish to use multiple different addresses to protect their privacy.
- Validators are determined periodically through users of Sui locking and delegating SUI tokens to one or more validators.

## Security architecture {#security-architecture}

The Sui system is operated by a set of validators that process transactions. They implement the Sui protocol that allows them to reach agreement on valid transactions submitted and processed in the system.

The agreement protocols Sui uses tolerate a fraction of validators not following the Sui protocol correctly, through the use of Byzantine fault tolerant broadcast and consensus. Specifically, each validator has some voting power, assigned to it through the process of users staking / voting for them using their SUI tokens. Sui maintains all its security properties if over 2/3 of the stake is assigned to validators that follow the protocol. However, a number of auditing properties are maintained even if more validators are faulty.

### Addresses and ownership {#addresses-and-ownership}

A Sui transaction is valid and can proceed only if the owner of all owned assets it operates on digitally signs it with their private signature key. This signature key can be kept private by the user and not be shared with anyone else. As a result, it is not feasible for any other party to operate on an owned asset of a user undetected, even if all validators do not follow the protocol.

A private signature key also corresponds to a public address on the Sui network that can be used to send a user assets or allow smart contracts to define custom access control logic. A user may have one or more addresses corresponding to multiple signature keys for convenience or privacy reasons. An address does not need any pre-registration, and sending an asset to an address automatically creates this address on the network. However, this means that users should be careful to check the recipient address of transfers, or parties involved in any other operations, as sending assets to an incorrect address may have irrevocable effects.

### Smart contracts define asset types and their logic {#smart-contracts}

All assets have a type that is defined within a Sui Smart Contract. Sui provides a few system contracts, such as those used to manage the SUI native token, yet also allows anyone to write and submit custom smart contracts. A transaction on an asset type can call operations defined in only the smart contract that defined the asset type, and is constrained by the logic in the contract.

For this reason, users are encouraged to operate on their assets using smart contracts they trust, that they or others they trust have audited, and understand the logic they define for operations on their assets. Sui smart contracts are defined as immutable assets to allow third parties to audit them and also prevent their modification to increase assurance.

The Move smart contract language is designed with ease of audit and verification in mind. You may be interested in our introduction to Smart Contracts in Move.

Shared assets allow multiple users to operate on them through transactions; that may include some of their owned assets as well as one or more shared assets. These shared assets represent data and logic used to implement protocols that mediate between different users in a safe way, according to the smart contract that defined the type of the shared asset. Sui allows all users to create transactions involving shared assets. But the smart contract type may define additional restrictions on which address and how the shared assets may be used.

### Transaction finality {#transaction-finality}

A valid transaction submitted to all validators has to be certified and its certificate also has to be submitted to all validators to be finalized. Even if a subset of validators do not follow the protocol, the transaction can be finalized through the remaining validators that correctly follow the Sui protocol. This is achieved through the use of cryptographic Byzantine fault tolerant agreement protocols for broadcast and consensus defined by the Sui protocol. These protocols ensure both safety, meaning that the incorrect validators cannot convince correct clients of incorrect state, and liveness, meaning that incorrect validators cannot prevent transaction processing.

All transactions in Sui have to be associated with a gas asset to cover the cost of processing by Sui. A valid transaction may result in successful execution or an aborted execution. An execution may abort due to a condition within the smart contract defining the asset, or because it has ran out of sufficient gas to pay for the cost of execution. In cases of success, the effects of the operation will be finalized; otherwise, the state of assets in the transaction is not changed. However, the gas asset is always charged some amount of gas, to alleviate denial-of-service attacks on the system as a whole.

A user client can perform the process of submitting the transaction and certificate itself or rely on third party services to submit the transaction and interact with validators. Such third parties need not have user private signature keys and cannot forge transactions on the users' behalf. They can reassure a user client a transaction has been finalized through a set of signatures from validators attesting to the transactions finality and its effects. After that point, the users can be assured that changes the transaction resulted in will persist on the state of Sui.

### Auditing and privacy {#auditing-and-privacy}

Sui validators provide facilities for users to read all assets they store, as well as the historical record of transactions they have processed that led to these assets. Validators also provide cryptographic evidence of the full chain of transactions that contributed to an asset state. User clients can request and validate this chain of evidence to ensure all operations were correct and the result of the collective agreement between validators. Services that operate full replicas, mirroring the state of one or more validators, perform such audits routinely.

The public auditability of Sui also implies that all transactions and assets within Sui are publicly visible. Users that are mindful of their privacy may use multiple addresses to benefit from some degree of pseudonymity, or third-party custodial or non-custodial services. Specific smart contracts with additional cryptographic privacy protections can also be provided by third parties.

### Censorship-resistance and openness {#censorship-resistance-openness}

Sui uses the established Delegated Proof-of Stake model to periodically determine its set of validators. Users can lock and delegate their SUI tokens in each epoch to determine the committee of validators that operate the Sui network in the next epoch. Anyone with over a minimum amount of delegated stake can operate a Sui validator.

Validators operate the network and provide rewards to users that stake their Sui to support them as validators, through gas fee income. Validators with poor reliability, and in turn the users that delegated their stake to them, may receive a lower reward. But user stake cannot be confiscated away either by malicious validators or anyone in the network.

This mechanism ensures that validators are accountable to Sui users and can be rotated out at the first sign of unreliability or misbehavior, including noticed attempts to censor valid transactions. Through choices of validators, and the protocol they are willing to operate, Sui users also have a meaningful say on the future evolution of the Sui system.

## Further reading {#further-reading}

If you are looking for an in-depth technical explanation of the computer science behind Sui security, you may have a look at our white paper on the [Sui Smart Contracts Platform](/doc/sui.pdf).

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture/epochs.mdx
```
---
title: Epochs and Reconfiguration
draft: true
---

In a simplified view, epochs are to the Sui network what individual days are to a calendar. Reconfiguration, then, is a process at the end of each epoch where that day's activity is tallied and the next day's parameters are set.

## Epoch

An epoch is a duration of time where the Sui validator set and their stakes remain unchanged. On both Mainnet and Testnet, an epoch is about 24 hours. This timeframe allows validators to process transactions efficiently without worrying about ad hoc validator changes during the middle of an epoch.

Epoch values are included in the metadata of transactions on the Sui network, but the average user is unaffected by its value. The only time a user might need to know about epochs is in the case of expiring transactions, where a transaction is only valid if executed before a set epoch. See [Transactions](../transactions.mdx) for more information about transactions on Sui.

## Reconfiguration

Reconfiguration is a critical process occurring at the end of each epoch. It involves several key steps to adjust the network for the upcoming epoch:

1. **Finalizing transactions and checkpoints**
    - The network reaches consensus on the final set of transactions and checkpoints for the current epoch. This ensures all validators have an identical state at epoch conclusion.
    - **Synchronous moment:** This is the only fully synchronous event in the network, crucial for maintaining consistency.
1. **Distribution of gas rewards**
    - Computation gas fees are distributed to the validator staking reward pool, from which stakers can withdraw.
    - Storage fees are allocated to a storage fund, playing a vital role in the Sui tokenomics, as explained in [Tokenomics](../tokenomics.mdx).
1. **Validator set change**
    - Any pending staking and unstaking requests during the epoch are finalized and reflected in validators stake distribution.
    - Any pending validator change requests are also processed, including adding new validators and removing existing validators. This is the sole opportunity for altering the validator set and stake distribution.
1. **Protocol upgrade**
    - If agreed upon by 2f+1 validators, the network might upgrade to a new protocol version, encompassing new features, bug fixes, and updates to Move framework libraries.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture/indexer-functions.mdx
```
---
title: Sui Indexer
description: Sui Indexer is an off-Full node data service that serves data from the Sui protocol, including both data directly generated from chain and derivative data.
---

{@include: ../../snippets/data-serving-msg.mdx}
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture/protocol-upgrades.mdx
```
---
title: Protocol Upgrades
description: The Sui protocol, framework, and execution engine are frequently extended to include new functionality and bug fixes. The process to upgrade the network ensures clients use the same source.
---

The Sui protocol, framework, and execution engine are frequently extended to include new functionality and bug fixes. This functionality is added in the form of new code which is released to validator operators as part of our regular software releases. The Sui protocol, however, requires that all Sui validators agree about the results of executing each transaction. 

This poses the following challenge: How do we release code that changes transaction execution, given that it is not possible to ensure that all operators upgrade their software at the same instant? Further, how do we ensure that all Sui transaction history can be replayed even after functionality has changed?

To solve this problem, Sui uses a process called protocol upgrades.

# Protocol upgrade process

An outline of the process used for protocol upgrades includes the following steps:

1. A Sui developer codes the new feature, but restricts access to the feature using a "feature flag"  - a boolean config variable that is initially set to false.
1. The value of the feature flag is retrieved from a struct called `ProtocolConfig`.
1. The developer creates a new version of the `ProtocolConfig` struct where the new feature flag is set to true.
1. A new release of the Sui validator software is built and released to validator and Full node operators.
1. When the validator process starts up, it continues to use the previous version of `ProtocolConfig` (in which the flag is false). This way, all validators continue behaving identically regardless of whether they have the new software or not.
1. As validators are upgraded, they signal to the rest of the validator committee that they are prepared to switch to the new version of the configuration (in which the flag is enabled).
1. If enough validators vote to switch to the new protocol version, then the new version takes effect at the beginning of the next epoch.
1. The new feature now comes into effect.

Full nodes follow a similar process, however, they do not participate in voting. Instead, they follow the actions that validators recorded. 

When validators switch to a new protocol version, they do so by recording the new version number in the special end-of-epoch transaction. Full nodes execute this transaction as they are replaying the chain history, and are thus able to switch to the new protocol version at the right time.

# Framework upgrades

Not all new Sui functionality comes in the form of changes to the validator code. There are also changes to the Sui framework. For instance, Sui developers periodically add new native functions to the framework to expose new functionality to smart contracts. The process for framework updates is similar to protocol upgrades.

Instead of using feature flags, however, Sui objects are used to coordinate framework changes. The Sui framework is a special object with id `0x2`.
The Move source code for the framework is built into the validator binary.

If the validator notices that its built-in framework is different from the framework in object `0x2`, it signals to the other validators that it would like to upgrade the framework to a new version. Just as with changes to `ProtocolConfig`, if enough validators agree to perform the upgrade, the new framework object is written at the end of the current epoch. Then, transactions that are executed in the new epoch use the new version of the framework.


```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture/consensus.mdx
```
---
title: Consensus
sidebar_label: Consensus 
description: Overview of the Sui consensus.
---

The basic purpose of consensus in blockchains is to agree on a consistent order and ensure the availability of transactions.

On Sui, consensus has a simple API: validators submit different user transactions to consensus concurrently, and the consensus outputs a consistent stream of transactions across all well-behaving validators.

Sui uses the Mysticeti protocol to optimize for both low latency and high throughput. The benefits of Mysticeti include:

- Supports multiple validators proposing blocks in parallel, utilizing the full bandwidth of the network and providing censorship resistance. These are features of the DAG-based consensus protocols.
- requires only three rounds of messages to commit blocks from the DAGs, same as practical Byzantine Fault Tolerance and matches the theoretical minimum.
- The commit rule allows voting and certifying leaders on blocks in parallel, further reducing the median and tail latencies.
- The commit rule also tolerates unavailable leaders without significantly increasing the commit latencies.

## Transaction throughput

Compared to other state-of-the-art consensus protocols, Mysticeti is theoretically capable of handling over twice as many transactions with half the observed latency as other protocols. In a controlled environment using 10 nodes, Mysticeti is capable of handling 300,000 transactions per second (TPS) before latency crosses the one-second marker. Increased to 50 nodes, test results show 400,000 TPS before surpassing a one-second latency. In the same tests, the other top performing consensus mechanisms do not reach 150,000 TPS and observed latency _begins_ at around two seconds.

On average, testing shows Mysticeti can achieve consensus commitment in about **0.5 seconds** with a sustained throughput of **200,000 TPS**.

![Throughput and latency graph](./images/thruput_latency.png)

## Decision rule

The novel decision rule at the heart of Mysticeti optimizes its operational efficiency. Traditional consensus engine decision rules require explicit block validation and certification. This process necessitates greater communication overhead as validators sign and broadcast votes to reach consensus. By contrast, Mysticeti provides implicit commitment, which reduces this inter-node communication, significantly lowering bandwidth usage.

## Finality

Finality is the guarantee that a transaction or block, after confirmation, is permanently added to the network and cannot be altered or reversed. In traditional blockchain consensus, confirming transactions can take time because they rely on other transactions to “reference” them repeatedly before they are considered final. This process can slow down if the network activity decreases or if there are many competing transactions. In contrast, Mysticeti simplifies this process by finalizing transactions immediately upon inclusion in the structure. Consequently, there's no waiting for additional confirmations or network activity, making Mysticeti faster and more reliable for confirming transactions, even in less active or challenging network conditions.

For more details, including correctness proofs, see the [MYSTICETI: Reaching the Latency Limits with
Uncertified DAGs](/paper/mysticeti.pdf) whitepaper.

## Related links

- [Life of a Transaction](./transaction-lifecycle.mdx): The life of a transaction on the Sui network has some differences compared to those from other blockchains.
- [Sui Security](./sui-security.mdx): Sui is designed to provide very high security guarantees to asset owners.
- [MYSTICETI: Reaching the Latency Limits with Uncertified DAGs](/paper/mysticeti.pdf): Whitepaper documenting the Mysticeti protocol.
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture/high-level.mdx
```
---
title: High Level Diagram
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture/staking-rewards.mdx
```
---
title: Validator Staking and Rewards
draft: true
---

Sui is a Delegated-Proof-of-Stake (DPoS) system, where the voting power of validators is granted by stakes delegated to them from SUI token holders. When rewards are distributed at the end of each epoch, validators receive their share of the rewards based on their performance and their commission rate. The rewards auto-compound as validators staking pools receive new delegated stakes.

## Staking on Sui versus other blockchains

The Sui staking mechanism has a few features that might be different from staking on other blockchains:

- Staking is self-custodial on Sui: stakers keep their staked SUI tokens in an owned object.
- Staking rewards auto-compound on Sui due to its liquidity-pool-inspired design.
- When a user requests to stake with a validator, their stake starts counting towards the voting power of that validator for the epoch after the current epoch. Similarly, when a user withdraws their stake, their stake stops counting the epoch after the current epoch.

{@include: ../../snippets/staking-pool-reqs.mdx}

## Rewards distribution

At the end of each epoch, gas fees collected, together with stake subsidies, are distributed among validators and stakers as staking rewards. The amount of rewards a validator gets depends on the following factors:

- Performance. If a validator does not operate performantly, other validators may choose to report them via the tallying rule. The entire staking rewards of the reported validator are slashed for the epoch.
- Commission rate. Commission rate determines the cut of staking rewards a validator is taking from their stakers. For example, if a validator has commission rate at 10%, then 10% of all staking rewards of stakers with this validator are given to the validator each epoch as new stake objects owned by the validator.

## Rewards withdrawal

Because validator rewards are distributed to them as regular stake objects, staking rewards withdrawal works exactly the same for validators as for stakers. More precisely, a validator can call the  [`0x3::sui_system::request_withdraw_stake`](https://github.com/MystenLabs/sui/blob/6234ae2cc8137f3a2a34cd0aa1ac4fd5f31260e2/crates/sui-framework/packages/sui-system/sources/sui_system.move#L272) function to withdraw their stake and receive their rewards.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture/data-management-things.mdx
```
---
title: Archival, Snapshots, Pruning Policies, Indexing
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture/transaction-lifecycle.mdx
```
---
title: Life of a Transaction
description: The life of a transaction on the Sui network has some differences compared to those from other blockchains. 
---

A transaction on the Sui network goes through many different steps during its life cycle.

## Life cycle overview

At a high level, the following figure outlines the life cycle of a transaction on the Sui blockchain.

![Transaction life cycle](./images/txn-lifecycle.png)

The following steps align with those in the preceding image. 

1. The first step of the process is the creation of a transaction. A user with a private key creates and signs a user transaction to either mutate objects they own, or a mix of objects they own and [shared objects](../object-ownership/shared.mdx).

1. Sui sends the transaction to each validator (often through a Full node). Validators perform a series of validity and safety checks, sign it, and return the signed transaction to the client. 

1. The client then collects the responses from a set of validators that account for at least 2/3 stake on Sui (a supermajority) to form a transaction certificate. As a result, unlike consensus-based blockchains, Sui validators do not need to propagate signatures on a best-effort basis (gossip signatures) or aggregate certificates. This effort is now the responsibility of the client or gateway.

1. After assembling the certificate, the client sends it back to all validators, who check its validity and acknowledge its receipt to the client. If the transaction involves owned objects exclusively, Sui can process the transaction certificate immediately and execute it without waiting for the [consensus engine](./consensus.mdx) (**direct fast path**). All certificates are forwarded to the Sui DAG-based consensus protocol (also operated by the Sui validators). 

1. Consensus eventually outputs a total order of certificates; the validators check and execute those that contain shared objects. 

1. Clients can collect a supermajority of validator responses, assemble them into an effect certificate, and use it as proof of the settlement of the transaction. 

1. Subsequently, Sui forms checkpoints for every consensus commit, which it also uses to drive the reconfiguration protocol.

The complete [Sui Lutris](https://docs.sui.io/paper/sui-lutris.pdf) paper provides additional detail on how the safety and liveness protocols operate, as well as proofs of security for them in the standard distributed systems model with Byzantine participants in partial synchrony. The following sections provide more detail on the various stages in the life of a transaction.

## Submission

All transactions on Sui begin when they are submitted to the network. For example, imagine you want to transfer an NFT that you own in your wallet to your friend. First, you would create a transaction using a wallet or some other app. The transaction includes your gas payment object and a command to transfer the NFT object to your friend's address. Before the wallet or app submits the transaction to the network, it must also sign it.

After the transaction is signed, the wallet or app submits the transaction to a Sui Full node on behalf of the user.

## Certification

Certification happens after a transaction gets submitted to a Full node. Upon submission, the Full node begins the process of certifying the transaction. The Full node cannot certify the transaction on its own because it does not have a complete view of transactions across the network. Consequently, the Full node must send the transaction to a validator. The validator performs a validity check on the transaction and signs it if it passes. To be considered valid, the transaction must pass the following checks:

   - The transaction has a valid user signature.
   - The initiator of the transaction must have access to all the owned input objects the transaction uses. In the previous NFT example, the validity check makes sure you own the NFT you're trying to send to a friend.
   - All the shared input objects used by the transaction exist.
   - The gas coin is a `Coin<SUI>` object, and it contains at least as much gas as specified in the transaction's gas budget.

If all the validity checks pass, the validator then attempts to lock all the owned input objects to the given transaction digest. This ensures each owned input object can only be used by one transaction at a time and is the way that Sui prevents double-spending. In other words, this makes sure that you send your NFT to only one friend instead of trying to send the same NFT to all your friends.

If the locking succeeds, the validator signs the transaction using its BLS private key and returns the signature to the Full node. A single validator signature is not enough, though. The Full node must collect signatures from enough validators to form a supermajority.

:::info

Full nodes collect signatures from validators in parallel to minimize latency. 

:::

After the Full node collects a supermajority, or quorum, of validator signatures, the transaction is considered certified. To be precise, the Full node has formed a _transaction certificate_.

Because of the locking step described previously, it is impossible to concurrently form certificates for two different transactions that attempt to use the same owned object. This is true even if there are some dishonest validators that illegally sign both transactions, because of a principle in distributed computing called "quorum intersection".

If fewer than 1/3rd of the validators are dishonest (Byzantine), then the set of signers for any two certificates must have an overlap that includes at least one honest validator. And, crucially, because that validator is honest, it never signs two transactions that attempt to access the same input object at the same version. After the transaction completes, the input object version changes and can be accessed again by subsequent transactions. 

## Execution

Full nodes send transactions that have a certificate to validators for execution. Each validator verifies the signatures on the certificate.
If the certificate signatures are valid, then the validator can be sure that the transaction is valid and is not attempting to double-spend any objects.

Then, each validator does the following, based on whether the transaction:
- Does not access any shared input objects, in which case it executes it immediately.
- Does access shared input objects, in which case it submits the object to Sui's consensus layer, which orders the transaction with respect to other transactions using the same shared objects and then executes it.

## Certified Effects

After the transaction executes, the validator signs the effects of the transaction and returns them to the Full node.
The transaction effects are essentially a list of all the actions that the transaction took, which mainly include:
- All the objects that were mutated, created, wrapped, unwrapped, or deleted.
- The gas that was spent.
- The execution status (Success or an error code) of the transaction.

Eventually, the Full node collects effects signatures from a supermajority of validators. This collection of signatures, plus the effects themselves, is called an _effects certificate_.

:::tip

An effects certificate is a guarantee of transaction finality.

:::

After you or a Full node observes an effects certificate, you are guaranteed that the transaction is going to be included in a checkpoint, which means that the transaction cannot be reverted.

If you wanted, you could present the effects certificate to your friend to prove that you sent them the NFT. The presence of the validator signatures means that an effects certificate cannot be forged.

## Checkpoints

Inclusion in a checkpoint is the final stage in the life of a transaction. As validators execute transactions, they submit them to consensus.

While transactions that use shared input objects must be sent to consensus before they are executed, owned-input-only transactions are also sent to consensus. The difference is that owned-input-only transactions are executed first.

The consensus layer produces a universally agreed-upon ordering of transactions. This ordering is the starting point for the creation of checkpoints. 

The validators take chunks of ordered transactions from the consensus layer and use them to form a checkpoint. Each chunk of transactions is first made causally complete and causally ordered - this means that the validators add any missing dependencies to the list of transactions and order them so that dependencies always appear before dependents in checkpoints.

Then the validator constructs a checkpoint, which (among other data) contains a list of transaction digests as well as the digests of the transaction effects of each transaction. Because checkpoints must be complete, the network sometimes has to wait for the availability of all transactions to form the checkpoints, which may take a couple of commits to process. This process typically completes in the order of a few seconds.

At this point, the transaction has reached the end of its life cycle and is included in the permanent record of transaction activity on the Sui network.

## Transaction finality

Transaction finality is the point at which the execution of a transaction becomes irreversible and its details cannot be altered or changed. 

The network round trip of sending a transaction and receiving a validator signature takes less than half a second to complete. At this point the sender knows the transaction is irrevocable and is going to be processed within the epoch, no matter what. The transaction has reached finality; honest validators deem invalid any subsequent transactions using the same owned input objects during the same epoch.

## Settlement finality

After a validator executes a transaction, it returns signed effects from that transaction to the network.

After the supermajority of validators have executed the transaction, and an effects certificate exists, the effects of the transaction (transfers, newly minted objects, and so on) have been implemented. At this point, the network can process transactions that depend on those effects. 

For transactions that involve owned objects only, this happens before consensus in under half a second. If a transaction includes shared objects, it happens shortly after consensus, which can take a few seconds. At this point, the transaction reached settlement finality because now you can process more transactions on the same input objects. See [Object Ownership](../../concepts/object-ownership.mdx) for more information.

## An example path to an effects certificate

As a real-world example, suppose you want to pay the local coffee shop 10 SUI for your morning coffee. How can the coffee shop be sure that the payment is complete and allow you to take your coffee?

Step 1: Transaction creation

You open the wallet app on your phone, scan the coffee shop's QR code that contains the recipient on-chain address. The wallet app constructs a transaction that transfers 10 Sui from your Sui address to the coffee shop's address. You review the transaction details and approve it. The wallet app then signs the transaction with your private key. Now you have a signed transaction.

Step 2: Transaction broadcast

Your wallet app submits the signed transaction to a Full node. The Full node broadcasts the transaction to all validators in the network.

Step 3: Transaction certification

Validators receive the transaction from the Full node. After examining its validity, a validator locks the referenced owned objects, and returns its signature of the transaction to the Full node.

After the Full node collects a quorum of signatures, it forms a transaction certificate. The transaction certificate contains the transaction and signatures from the supermajority of validators.

Step 4: Transaction finalization

The Full node broadcasts the transaction certificate to all validators. Validators receive the transaction certificate, verify its validity (for example, there are indeed enough signatures), execute the transaction, and unlock the previously locked owned objects. Transaction effects are the output of an executed transaction. Validators sign the transaction effects and return them to the Full node, along with their signatures.

The Full node verifies that effects returned from validators are identical. After it collects a supermajority of signatures, it forms an `EffectsCertificate` object. The effects certificate contains the transaction effects and signatures from a supermajority of validators.

At this point, as your wallet app gets back the effects certificate from the Full node, you can share this effect certified transaction with the coffee shop. The coffee shop can then be sure that the transaction is executed and irreversible.

### Checkpoint processing

The process in the previous section demonstrates a finalized transaction through an effects certificate. As the process shows, the Full node plays the quorum driving role.

What if the Full node goes offline before it collects a quorum of validator-signed effects? Your wallet app will probably retry the process with a different Full node. Unfortunately, your phone runs out of battery before it sends the signed transaction to a new Full node.

No worries. The coffee shop shortly notices your payment arrive in its terminal, connected to a different Full node. This Full node learns about your transaction through checkpoints.

As mentioned, a checkpoint contains a list of transactions. If a transaction appears in a certified checkpoint (a checkpoint that has been signed by a supermajority of validators), it is considered finalized.

The Full node that the coffee shop's terminal connects to knows about your transaction through state sync. In this case, as long as one validator receives the transaction certificate from your original Full node, the transaction will highly likely finalize even without an effects certificate. The coffee shop is assured of payment and can give you your coffee.

### Local execution on Full node

Before the Full node sends back an effects certificate to your wallet app, it may try to execute the transaction locally, if the request asks it to.

The purpose of this extra step is to keep the Full node up to date as much as possible, especially when the wallet app frequently hits the same Full node. In this coffee shop example, this might be trivial, but for a high frequency application, such as gaming, it could be important.

When an app constructs a transaction, it typically requests that the Full node choose a gas object for it. Gas objects are owned objects, meaning that if the Full node is stale and not aware of the right version of the object, it could lead to invalid transactions, or worse, client equivocation if the client software does not handle it properly. Executing on Full node before returning `EffectsCertificate` is one way to avoid this situation. A request can ask for such behavior by using the `WaitForLocalExecution` parameter. See [Sponsored Transactions](../transactions/sponsored-transactions.mdx) for more on client equivocation.

Using `WaitForLocalExecution` is not always the best choice, however. For example, with this coffee payment it adds a layer of end-to-end latency without significant benefits. In this case, using the `WaitForEffects` parameter instead to have a slightly shorter user-perceived latency.

### Epoch change

Periodically (~24 hours), the Sui network enters the process of epoch change. During epoch change, the network calculates and distributes staking rewards, validators metadata take effect, and other network processes are performed. All user transactions are delayed until the new epoch begins.

If your transaction is submitted at epoch boundary, in rare perfect timing, it is possible that a quorum of validators already decided to not accept any new transaction certificates in the current epoch. Of course, this means your coffee purchase is not be checkpointed either. For any transactions that are certified but not finalized, they are reverted if executed, or its owned objects are unlocked and not yet executed. In this case, the transaction certificate does not guarantee finality. In the new epoch, this transaction certificate will become void because validator signatures are signed over epoch ID. To continue this transaction, a new transaction certificate is necessary with the new epoch ID. The standard Full node implementation handles this automatically.

### Verifying finality

Assume your wallet app crashed during the original transaction. If the app stores the signed transaction locally before sending it to the Full node, which is best practice, then when the app restarts it tries to verify if the transaction has been finalized first. If it has, then no other steps are necessary. If it hasn't, then the app needs to resubmit the transaction.

The wallet app can query the Full node with the `getTransactionBlock` method. Assuming the Full node is honest:
- If the response contains transaction details, the transaction must have been finalized. It is either executed with `WaitForLocalExecution`, or executed as a checkpointed transaction.
- If the response is `None`, it could mean the transaction was dropped in some step, or is already finalized but this Full node does not know yet. In this scenario, the safer option is to resubmit the transaction.

Before a transaction is locally executed, its effects are not reflected on the Full node. The same idea applies to the coffee shop's Full node. Your transaction was not submitted through this Full node, hence it does not have a chance to locally execute it before it's included in a checkpoint. This Full node must wait for the transaction to be checkpointed and state synced, which normally takes a few seconds. After the Full node receives this transaction in a checkpoint, it is executed and has effects updated locally, for example the coffee shop's balance increases.

## Summary

Hopefully, you now have a better understanding of how a transaction gets certified and finalized.

1. A transaction certificate does not always guaranteed finality, even though it's highly likely. Specifically, a transaction certificate might become void after an epoch change.

2. An effects certificate guarantees finality - it takes a supermajority of validators to execute the transaction and commit to the effects.

3. An inclusion in a certified checkpoint guarantees finality - it takes a supermajority of validators to certify the checkpoint, in which every transaction is executed and effects-committed.




```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/sui-architecture/sui-storage.mdx
```
---
title: Sui Storage Cost
description: Historical data and the pricing of your storage solutions provide insights into the cost of your operations on the Sui network.
---

The cost of operating on any blockchain boils down to two major components: compute, the cost of the power needed to process programming logic, and storage, the amount of digital space necessary to store that logic and its results.

Compute is a relatively fixed cost for Sui, with hundreds of validators running 24 Core, 128GB RAM machines.

Because Sui is capable of such high throughput compared to other blockchains, the storage costs of running the Sui network aren't as precise.

There are several components that contribute to storage costs:

| Storage category    | Storage type         | Usage description                                                                                                                                                            | Mainnet storage needs (as of May, 2024) |
| ------------------- | -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| Validators          | Rocksdb, SSD storage | Validators store latest consensus data on high-performance NVMe disks.                                                                                                       | ~200GB                                               |
| Pruning Full nodes  | Rocksdb, SSD storage | Pruning Full nodes maintain unpruned RocksDB indexes for efficient querying.                                                                                                 | ~1.6TB                                               |
| Unpruned Full nodes | Rocksdb, SSD storage | Unpruned full nodes retain full object and transaction history for complete archival.                                                                                        | ~4.9TB                                               |
| Full node snapshots | Cloud storage        | Snapshots of full node data are stored in cloud storage for validator or full node backup and recovery.                                                                      | ~1.6TB                                               |
| State-sync archival | Cloud storage        | State-sync archival involves storing blockchain state data in cloud storage to facilitate syncing historical objects in the event they have been pruned from a node's peers. | ~1.3TB                                               |

## Validators

Validators are advised to enable pruning to limit the amount of growth occurring in validator databases. Increases in transaction per second (TPS) rates contribute to validator data growth, but the paths storing full transaction and object history are the major growth factors. An additional factor to consider is the type of transaction, which also influences data growth.

![Storage](./images/storage.png)

The preceding image examines a slice of time on Mainnet in 2024. Reviewing data from a 90 day range in the early part of the year, Mainnet averaged ~18 TPS. Over that period, disk usage went from 203GB to 215GB. Average growth per day was just over 130MB.

During a two-week range in the middle of the year, Mainnet averaged ~183 TPS. Over that period disk usage increased from 215GB to 271GB. Average growth per day was just over 4GB.

These results show the data growth increase relative to the increase in TPS rates.

## Pruning Full nodes

Pruning Full nodes are very similar in disk usage to validators, as the pruning configurations are essentially identical. There are two notable exceptions:

1. Full nodes do keep a `consensus_db`, this makes up about half of validator disk usage.
1. If you serve RPC queries from your Full node, the `indexes/` in Mainnet takes up a substantial amount of data. Today the mainnet `indexes/` are 1.5TB, growing in relation to TPS.

The total disk usage of a pruned Full node with indexes in Mainnet is 1.6TB. With indexing disabled, the total disk usage would be ~100GB.

## Unpruned Full nodes

Most implementations do not use unpruned Full nodes because the benefits of maintaining them apply to only a few specific use cases:

1. You want the entire chain state on a single machine.
1. Enabling state-sync without the need for a cloud archival fallback. In other words, if you use a fully unpruned node as a state sync peer, you don't have to specify the archival fallback in your node config.

Examining the same 90-day period of time mentioned previously, where Mainnet averaged ~18 TPS, disk usage on an unpruned node went from 3.4TB to 4.34TB. Average growth per day was just over 10GB.

In the two-week period mid year, where Mainnet averaged ~183 TPS, disk usage increased from 4.34TB to 4.92TB. Average growth per day was just over 40GB.

## Full node snapshots

There are two types of [snapshots](../../guides/operator/snapshots.mdx), database snapshots and formal snapshots.

Database snapshot size is equal to the database size of the Full node that produces it, as its a 1:1 copy of the database. 

Formal snapshot size is very lightweight, ~30GB for the latest Mainnet epochs as of May of 2024.

## State-sync archival

This is a cloud storage bucket, that a Full node (or data-ingestion daemon) writes to. 

Examining the same 90-day period of time mentioned previously, disk usage went from 867GB to 1.18TB. Average growth per day was just over 3GB.

In the two-week period mid year, disk usage went from 1.18TB to 1.32TB. Average growth per day was 10GB.

## Related links

- [Custom Indexers](../../guides/developer/advanced/custom-indexer.mdx): Build custom indexers using the Sui micro-data ingestion framework.
- [Snapshots](../../guides/operator/snapshots.mdx): Bootstrap a Full node without having to execute all the transactions that occurred after genesis.
- [Sui Archives](../../guides/operator/archives.mdx): Enable archiving on your Full nodes for a historical record of all transactions on Sui.
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/system.mdx
```
---
title: System
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/zklogin.mdx
```
---
title: zkLogin
description: zkLogin is a Sui primitive that enables you to send transactions from a Sui address using an OAuth credential, without publicly linking the two.
---

zkLogin is a Sui primitive that provides the ability for you to send transactions from a Sui address using an OAuth credential, without publicly linking the two.

zkLogin is designed with the following goals in mind:

- **Streamlined onboarding:** zkLogin enables you to transact on Sui using the familiar OAuth login flow, eliminating the friction of handling cryptographic keys or remembering mnemonics.
- **Self-custody:** A zkLogin transaction requires user approval via the standard OAuth login process--the OAuth provider cannot transact on the user's behalf.
- **Security:** zkLogin is a two-factor authentication scheme; sending a transaction requires both a credential from a recent OAuth login and a salt not managed by the OAuth provider. An attacker who compromises an OAuth account cannot transact from the user's corresponding Sui address unless they separately compromise the salt.
- **Privacy:** Zero-knowledge proofs prevent third parties from linking a Sui address with its corresponding OAuth identifier.
- **Optional verified identity:** A user can opt in to verify the OAuth identifier that was used to derive a particular Sui address. This serves as the foundation for a verifiable on-chain identity layer.
- **Accessibility:** zkLogin is one of several native Sui signature schemes thanks to Sui's [cryptography agility](./transaction-auth/signatures.mdx). It integrates with other Sui primitives, like sponsored transactions and multisig.
- **Rigorousness:** The code for zkLogin has been independently [audited](https://github.com/sui-foundation/security-audits/blob/main/docs/zksecurity_zklogin-circuits.pdf) by two firms specializing in zero knowledge. The public zkLogin ceremony for creating the common reference string attracted contributions from more than 100 participants.

Are you a builder who wants to integrate zkLogin into your application or wallet? Dive into the [zkLogin Integration Guide](../../guides/developer/cryptography/zklogin-integration.mdx).

If you want to understand how zkLogin works, including how the zero-knowledge proof is generated, and how Sui verifies a zkLogin transaction, see [this section](#how-zklogin-works).

If you are curious about the security model and the privacy considerations of zkLogin, visit this [page](#security-and-privacy).

More questions? See [the FAQ section](#faq).

## OpenID providers

{@include: ../../snippets/openid-providers.mdx}

## How zkLogin works {#how-zklogin-works}

In rough sketches, the zkLogin protocol relies on the following:

1. A JWT is a signed payload from OAuth providers, including a user-defined field named nonce. zkLogin leverages [the OpenID Connect OAuth flow](https://openid.net/developers/how-connect-works/) by defining the nonce as a public key and an expiry epoch.
1. The wallet stores an ephemeral KeyPair, where the ephemeral public key is defined in the nonce. The ephemeral private key signs transactions for a brief session, eliminating the need for user memorization.
   The Groth16 zero-knowledge proof is generated based on the JWT, concealing privacy-sensitive fields.
1. A transaction is submitted on-chain with the ephemeral signature and the ZK proof. Sui authorities execute the transaction after verifying the ephemeral signature and the proof.
1. Instead of deriving the Sui address based on a public key, the zkLogin address is derived from `sub` (that uniquely identifies the user per provider), `iss` (identifies the provider), `aud` (identifies the application) and `user_salt` (a value that unlinks the OAuth identifier with the on-chain address).

## The complete zkLogin flow

![1](images/zklogin-flow.png 'zkLogin Complete Flow')

(Step 0) We use Groth16 for our protocol's zkSNARK instantiation, requiring a singular generation of a structured common reference string (CRS) linked to the circuit. A ceremony is conducted to generate the CRS, which is used to produce the proving key in the ZK Proving Service, the verifying key in Sui Authority. See [the Ceremony section](#ceremony) for more details.

(Step 1-3) The user begins by logging into an OpenID Provider (OP) to obtain a JWT containing a defined nonce. In particular, the user generates an _ephemeral_ KeyPair `(eph_sk, eph_pk)` and embed `eph_pk`, along with expiry times (`max_epoch`) and randomness (`jwt_randomness`), into the nonce (see [definition](#notations)). After the user completes the OAuth login flow, an JWT can be found in the redirect URL in the application.

(Step 4-5) The application frontend then sends the JWT to a salt service. The salt service returns the unique `user_salt` based on `iss, aud, sub` upon validation of the JWT.

(Step 6-7) The user sends the ZK proving service the JWT, user salt, ephemeral public key, jwt randomness, key claim name (i.e. `sub`). The proving service generates a Zero-Knowledge Proof that takes these as private inputs and does the following: (a) Checks the nonce is derived correctly [as defined](#notations) (b) Checks that key claim value matches the corresponding field in the JWT, (c) Verifies the RSA signature from OP on the JWT, and (d) the address is consistent with the key claim value and user salt.

(Step 8): The application computes the user address based on iss, aud, sub, aud. This step can be done independently as long as the application has a valid JWT.

(Step 9-10) A transaction is signed using the ephemeral private key to generate an ephemeral signature. Finally, the user submits the transaction along with the ephemeral signature, ZK proof and other inputs to Sui.

(After Step 10) After submitted on chain, Sui Authorities verify the ZK proof against the provider JWKs from storage (agreed upon in consensus) and also the ephemeral signature.

## Entities

1. Application frontend: This describes the wallet or frontend application that supports zkLogin. This frontend is responsible for storing the ephemeral private key, directing users to complete the OAuth login flow, creating and signing a zkLogin transaction.

2. Salt Backup Service: This is a backend service responsible for returning a salt per unique user. See [zkLogin Integration Guide](../../guides/developer/cryptography/zklogin-integration.mdx) for other strategies to maintain salt.

3. ZK Proving Service: This is a backend service responsible for generating ZK proofs based on JWT, JWT randomness, user salt and max epoch. This proof is submitted on-chain along with the ephemeral signature for a zkLogin transaction.

## Address definition

The address is computed on the following inputs:

1. The address flag: `zk_login_flag = 0x05` for zkLogin address. This serves as a domain separator as a signature scheme defined in [crypto agility](./transaction-auth/signatures.mdx).

1. `kc_name_F = hashBytesToField(kc_name, maxKCNameLen)`: Name of the key claim, e.g., `sub`. The sequence of bytes is mapped to a field element in BN254 using `hashBytesToField` (defined below).

1. `kc_value_F = hashBytesToField(kc_value, maxKCValueLen)`: The value of the key claim mapped using `hashBytesToField`.

1. `aud_F = hashBytesToField(aud, maxAudValueLen)`: The relying party (RP) identifier. See [definition](#terminology-and-notations).

1. `iss`: The OpenID Provider (OP) identifier. See [definition](#terminology-and-notations).

1. `user_salt`: A value introduced to unlink the OAuth identifier with the on-chain address.

Finally, we derive `zk_login_address = Blake2b_256(zk_login_flag, iss_L, iss, addr_seed)` where `addr_seed = Poseidon_BN254(kc_name_F, kc_value_F, aud_F, Poseidon_BN254(user_salt)`.

## Terminology and notations

See below for all relevant OpenID terminology defined in [spec](https://openid.net/specs/openid-connect-core-1_0.html#Terminology) and how they are used in zkLogin, along with definitions for protocol details.

### OpenID provider (OP)

OAuth 2.0 authorization server that is capable of authenticating the end-user and providing claims to an RP about the authentication event and the end-user. This is identified in the `iss` field in JWT payload. Check the [table of available OPs](#openid-providers) for the entities zkLogin currently supports.

### Relying party (RP) or client

OAuth 2.0 client application requiring end-user authentication and claims from an OpenID provider. This is assigned by OP when the developer creates the application. This is identified in the `aud` field in JWT payload. This refers to any zkLogin enabled wallet or application.

### Subject identifier (sub)

Locally unique and never reassigned identifier within the issuer for the end user, which the RP is intended to consume. Sui uses this as the key claim to derive user address.

### JSON Web Key (JWK)

A JSON data structure that represents a set of public keys for an OP. A public endpoint (as in https://www.googleapis.com/oauth2/v3/certs) can be queried to retrieve the valid public keys corresponding to `kid` for the provider. Upon matching with the `kid` in the header of a JWT, the JWT can be verified against the payload and its corresponding JWK. In Sui, all authorities call the JWK endpoints independently, and update the latest view of JWKs for all supported providers during protocol upgrades. The correctness of JWKs is guaranteed by the quorum (2f+1) of validator stake.

### JSON Web Token (JWT)

JWT is in the redirect URI to RP after the user completes the OAuth login flow (as in `https://redirect.com?id_token=$JWT_TOKEN`). The JWT contains a `header`, `payload`, and a `signature`. The signature is an RSA signature verified against `jwt_message = header + . + payload` and its JWK identified by `kid`. The `payload` contains a JSON of many claims that is a name-value pair. See below for the specific claims that are relevant to the zkLogin protocol.

**Header**

| Name | Example Value                            | Usage                                                     |
| ---- | ---------------------------------------- | --------------------------------------------------------- |
| alg  | RS256                                    | zkLogin only supports `RS256` (RSA + SHA-256).            |
| kid  | c3afe7a9bda46bae6ef97e46c95cda48912e5979 | Identifies the JWK that should be used to verify the JWT. |
| typ  | JWT                                      | zkLogin only supports `JWT`.                              |

**Payload**

| Name  | Example Value                                                            | Usage                                                                                                                                                      |
| ----- | ------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| iss   | https://accounts.google.com                                              | A unique identifier assigned to the OAuth provider.                                                                                                        |
| aud   | 575519200000-msop9ep45u2uo98hapqmngv8d8000000.apps.googleusercontent.com | A unique identifier assigned to the relying party by the OAuth provider.                                                                                   |
| nonce | hTPpgF7XAKbW37rEUS6pEVZqmoI                                              | A value set by the relying party. The zkLogin enabled wallet is required to set this to the hash of ephemeral public key, an expiry time and a randomness. |
| sub   | 110463452167303000000                                                    | A unique identifier assigned to the user.                                                                                                                  |

For a zkLogin transaction, the `iat` and `exp` claims (timestamp) are not used. Instead, the `nonce` specifies expiry times.

### Key claim

The claim used to derive a users' address is termed the "key claim", such as sub or email. Naturally, it's ideal to use claims that are fixed once and never changed again. zkLogin currently supports sub as the key claim because OpenID spec mandates that providers do not change this identifier. In the future, this can be extended to use email, username, and so on.

### Notations

1. `(eph_sk, eph_pk)`: Ephemeral key pair refers to the private and public key pair used to produce ephemeral signatures. The signing mechanism is the same as traditional transaction signing, but it is ephemeral because it is only stored for a short session and can be refreshed upon new OAuth sessions. The ephemeral public key is used to compute nonce.
2. `nonce`: An application-defined field embedded in the JWT payload, computed as the hash of the ephemeral public key, JWT randomness, and the maximum epoch (Sui's defined expiry epoch). Specifically, a zkLogin compatible nonce is required to passed in as `nonce = ToBase64URL(Poseidon_BN254([ext_eph_pk_bigint / 2^128, ext_eph_pk_bigint % 2^128, max_epoch, jwt_randomness]).to_bytes()[len - 20..])` where `ext_eph_pk_bigint` is the BigInt representation of `ext_eph_pk`.
3. `ext_eph_pk`: The byte representation of an ephemeral public key (`flag || eph_pk`). Size varies depending on the choice of the signature scheme (denoted by the flag, defined in [Signatures](./transaction-auth/signatures.mdx)).
4. `user_salt`: A value introduced to unlink the OAuth identifier with the on-chain address.
5. `max_epoch`: The epoch at which the JWT expires. This is u64 used in Sui.
6. `kc_name`: The key claim name, e.g. `sub`.
7. `kc_value`: The key claim value, e.g. `110463452167303000000`.
8. `hashBytesToField(str, maxLen)`: Hashes the ASCII string to a field element using the Poseidon hash.

## Ceremony

To preserve privacy of the OAuth artifacts, a zero-knowledge proof of possession of the artifacts is provided. zkLogin employs the Groth16 zkSNARK to instantiate the zero-knowledge proofs, as it is the most efficient general-purpose zkSNARK in terms of proof size and verification efficiency.

However, Groth16 needs a computation-specific common reference string (CRS) to be setup by a trusted party. With zkLogin expected to ensure the safe-keeping of high value transactions and the integrity of critical smart contracts, we cannot base the security of the system on the honesty of a single entity. Hence, to generate the CRS for the zkLogin circuit, it is vital to run a protocol which bases its security on the assumed honesty of a small fraction of a large number of parties.

### What is the ceremony?

The Sui zkLogin ceremony is essentially a cryptographic multi-party computation (MPC) performed by a diverse group of participants to generate this CRS. We follow the MPC protocol [MMORPG](https://eprint.iacr.org/2017/1050.pdf) described by Bowe, Gabizon and Miers. The protocol roughly proceeds in 2 phases. The first phase results in a series of powers of a secret quantity tau in the exponent of an elliptic curve element. Since this phase is circuit-agnostic, we adopted the result of the existing community contributed [perpetual powers of tau](https://github.com/privacy-scaling-explorations/perpetualpowersoftau/tree/master). Our ceremony was the second phase, which is specific to the zkLogin circuit.

The MMORPG protocol is a sequential protocol, which allows an indefinite number of parties to participate in sequence, without the need of any prior synchronization or ordering. Each party needs to download the output of the previous party, generate entropy of its own and then layer it on top of the received result, producing its own contribution, which is then relayed to the next party. The protocol guarantees security, if at least one of the participants follows the protocol faithfully, generates strong entropy and discards it reliably.

### How was the ceremony performed?

We sent invitations to 100+ people with diverse backgrounds and affiliations: Sui validators, cryptographers, web3 experts, world-renowned academicians, and business leaders. We planned the ceremony to take place on the dates September 12-18, 2023, but allowed participants to join when they wanted with no fixed slots.

Since the MPC is sequential, each contributor needed to wait till the previous contributor finished in order to receive the previous contribution, follow the MPC steps and produce their own contribution. Due to this structure, we provisioned a queue where participants waited, while those who joined before them finished. To authenticate participants, we sent a unique activation code to each of them. The activation code was the secret key of a signing key pair, which had a dual purpose: it allowed the coordination server to associate the participant's email with the contribution, and to verify the contribution with the corresponding public key.

Participants had two options to contribute: through a browser or a docker. The browser option was more user-friendly for contributors to participate as everything happens in the browser. The Docker option required Docker setup but is more transparent—the Dockerfile and contributor source code are open-sourced and the whole process is verifiable. Moreover, the browser option utilizes [snarkjs](https://github.com/iden3/snarkjs) while the Docker option utilizes [Kobi's implementation](https://github.com/iseriohn/phase2-bn254). This provided software variety and contributors could choose to contribute by whichever method they trust. In addition, participants could generate entropy via entering random text or making random cursor movements.

The zkLogin circuit and the ceremony client [code](https://github.com/sui-foundation/zk-ceremony-client) were made open source and the links were made available to the participants to review before the ceremony. In addition, we also posted these developer docs and an [audit report](https://github.com/sui-foundation/security-audits/blob/main/docs/zksecurity_zklogin-circuits.pdf) on the circuit from zkSecurity. We adopted [challenge #0081](https://pse-trusted-setup-ppot.s3.eu-central-1.amazonaws.com/challenge_0081) (resulting from 80 community contributions) from [perpetual powers of tau](https://github.com/privacy-scaling-explorations/perpetualpowersoftau/tree/master/0080_carter_response) in phase 1, which is circuit agnostic. We applied the output of the [Drand](http://drand.love) random beacon at epoch #3298000 to remove bias. For phase 2, our ceremony had 111 contributions, 82 from browser and 29 from docker. Finally, we applied the output of the Drand random beacon at epoch #3320606 to remove bias from contributions. All intermediate files can be reproduced following instructions [here](https://github.com/sui-foundation/zklogin-ceremony-contributions/blob/main/phase1/README.md) for phase 1 and [here](https://github.com/sui-foundation/zklogin-ceremony-contributions/blob/main/phase2/README.md) for phase 2.

## Finalization

The final CRS along with the transcript of contribution of every participant is available in a public repository. Contributors received both the hash of the previous contribution they were working on and the resulting hash after their contribution, displayed on-screen and sent via email. They can compare these hashes with the transcripts publicly available on the ceremony site. In addition, anyone is able to check that the hashes are computed correctly and each contribution is properly incorporated in the finalized parameters.

Eventually, the final CRS was used to generate the proving key and verifying key. The proving key is used to generate zero knowledge proof for zkLogin, stored with the ZK proving service. The verifying key was [deployed](https://github.com/MystenLabs/sui/pull/13822) as part of the validator software (protocol version 25 in [release 1.10.1](https://github.com/MystenLabs/sui/releases/tag/mainnet-v1.10.1)) that is used to verify the zkLogin transaction on Sui.

## Security and privacy

The following sections walk through all zkLogin artifacts, their security assumptions, and the consequences of loss or exposure.

### JWT

The JWT's validity is scoped on the client ID (`aud`) to prevent phishing attacks. The same origin policy for the proof prevents the JWT obtained for a malicious application from being used for zkLogin. The JWT for the client ID is sent directly to the application frontend through the redirect URL. A leaked JWT for the specific client ID can compromise user privacy, as these tokens frequently hold sensitive information like usernames and emails. Furthermore, if a backend salt server is responsible for user salt management, the JWT could potentially be exploited to retrieve the user's salt, which introduces additional risks.

However, a JWT leak does not mean loss of funds as long as the corresponding ephemeral private key is safe.

### User salt

The user salt is required to get access to the zkLogin wallet. This value is essential for both ZK proof generation and zkLogin address derivation.

The leak of user salt does not mean loss of funds, but it enables the attacker to associate the user's subject identifier (i.e. `sub`) with the Sui address. This can be problematic depending on whether pairwise or public subject identifiers are in use. In particular, there is no problem if pairwise IDs are used (e.g., Facebook) as the subject identifier is unique per RP. However, with public reusable IDs (e.g., Google and Twitch), the globally unique sub value can be used to identify users.

### Ephemeral private key

The ephemeral private key's lifespan is tied to the maximum epoch specified in nonce for creating a valid ZK proof. Should it be misplaced, a new ephemeral private key can be generated for transaction signing, accompanied by a freshly generated ZK proof using a new nonce. However, if the ephemeral private key is compromised, acquiring the user salt and the valid ZK proof would be necessary to move funds.

### Proof

Obtaining the proof itself cannot create a valid zkLogin transaction because an ephemeral signature over the transaction is also needed.

### Privacy

By default, there is no linking between the OAuth subject identifier (i.e. `sub`) and a Sui address. This is the purpose of the user salt.
The JWT is not published on-chain by default. The revealed values include `iss`, `aud` and `kid` so that the public input hash can be computed, any sensitive fields such as `sub` are used as private inputs when generating the proof.

The ZK proving service and the salt service (if maintained) can link the user identity since the user salt and JWT are known, but the two services are stateless by design.

In the future, the user can opt in to verify their OAuth identity associated with an Sui address on-chain.

## FAQ

### What providers is zkLogin compatible with?

zkLogin can support providers that work with OpenID Connect built on top of the OAuth 2.0 framework. This is a subset of OAuth 2.0 compatible providers. See [latest table](#openid-providers) for all enabled providers. Other compatible providers will be enabled via protocol upgrades in the future.

### How is a zkLogin Wallet different from a traditional private key wallet?

Traditional private key wallets demand users to consistently recall mnemonics and passphrases, necessitating secure storage to prevent fund loss from private key compromise.

On the other hand, a zkLogin wallet only requires an ephemeral private key storage with session expiry and the OAuth login flow with expiry. Forgetting an ephemeral key does not result in loss of funds, because a user can always sign in again to generate a new ephemeral key and a new ZK proof.

### How is zkLogin different from MPC or Multisig wallets?

Multi-Party Computation (MPC) and Multisig wallets rely on multiple keys or distributing multiple key shares and then defining a threshold value for accepting a signature.

zkLogin does not split any individual private keys, but ephemeral private keys are registered using a fresh nonce when the user authenticates with the OAuth provider. The primary advantage of zkLogin is that the user does not need to manage any persistent private key anywhere, not even with any private keys management techniques like MPC or Multisig.

You can think of zkLogin as a 2FA scheme for an address, where the first part is user's OAuth account and the second is the user's salt.

Furthermore, because Sui native supports Multisig wallets, one can always include one or more zkLogin signers inside a Multisig wallet for additional security, such as using the zkLogin part as 2FA in k-of-N settings.

### If my OAuth account is compromised, what happens to my zkLogin address?

Because zkLogin is a 2FA system, an attacker that has compromised your OAuth account cannot access your zkLogin address unless they have separately compromised your salt.

### If I lose access to my OAuth account, do I lose access to my zkLogin address?

Yes. You must be able to log into your OAuth account and produce a current JWT in order to use zkLogin.

### Does losing my OAuth credential mean the loss of funds in the zkLogin wallet?

A forgotten OAuth credential can typically be recovered by resetting the password in that provider.
In the unfortunate event where user's OAuth credentials get compromised, an adversary will still require to obtain `user_salt`, but also learn which wallet is used in order to take over that account. Note that modern `user_salt` providers may have additional 2FA security measures in place to prevent provision of user's salt even to entities that present a valid, non-expired JWT.

It's also important to highlight that due to the fact that zkLogin addresses do not expose any information about the user's identity or wallet used, targeted attacks by just monitoring the blockchain are more difficult.
Finally, on the unfortunate event where one loses access to their OAuth account permanently, access to that wallet is lost. But if recovery from a lost OAuth account is desired, a good suggestion for wallet providers is to support the native Sui Multisig functionality and add a backup method. Note that it's even possible to have a Multisig wallet that all signers are using zkLogin, i.e. an 1-of-2 Multisig zkLogin wallet where the first part is Google and the second Facebook OAuth, respectively.

### Can I convert or merge a traditional private key wallet into a zkLogin one, or vice versa?

No. The zkLogin wallet address is derived differently compared to a private key address.

### Will my zkLogin address ever change?

zkLogin address is derived from `sub`, `iss`, `aud` and `user_salt`.

The address will not change if the user logs in to the same wallet with the same OAuth provider, since `sub`, `iss`, `aud` and `user_salt` (see definitions) will remain unchanged in the JWT, even though the JWT itself may look different every time the user logs in.

However, if the user logs in with different OAuth providers, your address will change because the `iss` and `aud` are defined distinctly per provider.

In addition, each wallet or application maintains its own `user_salt`, so logging with the same provider for different wallets may also result in different addresses.

See more on address [definition](#address-definition).

### Can I have multiple addresses with the same OAuth provider?

Yes, this is possible by using a different wallet provider or different `user_salt` for each account. This is useful for separating funds between different accounts.

### Is a zkLogin Wallet custodial?

A zkLogin wallet is a non-custodial or unhosted wallet.

A custodial or hosted wallet is where a third party (the custodian) controls the private keys on behalf of a wallet user. No such third-party exists for zkLogin wallets.

Instead, a zkLogin wallet can be viewed as a 2-out-of-2 Multisig where the two credentials are the user's OAuth credentials (maintained by the user) and the salt. In other words, neither the OAuth provider, the wallet vendor, the ZK proving service or the salt service provider is a custodian.

### Generating a ZK proof is expensive, is a new proof required to be generated for every transaction?

No. Proof generation is only required when ephemeral KeyPair expires. Since the nonce is defined by the ephemeral public key (`eph_pk`) and expiry (`max_epoch`), the ZK proof is valid until what the expiry is committed to nonce in the JWT. The ZK proof can be cached and the same ephemeral key can be used to sign transactions till it expires.

### Does zkLogin work on mobile?

zkLogin is a Sui native primitive and not a feature of a particular application or wallet. It can be used by any Sui developer, including on mobile.

### Is account recovery possible if the user loses the OAuth credentials?

Yes, the user can follow the OAuth providers' recovery flow. The ephemeral private key can be refreshed and after completing a new OAuth login flow, the user can obtain new ZK proof and sign transactions with the refreshed key.

### What are some assumptions for the zkLogin circuit?

Due to the way Groth16 works, we impose length restrictions on several fields in the JWT. Some of the fields that are length-restricted include aud, iss, the JWT's header and payload. For example, zkLogin can currently only work with aud values of up to length 120 (this value is not yet final). In general, we tried to make sure that the restrictions are as generous as possible. We have decided on these values after looking at as many JWTs that we could get our hands on.

### How is zkLogin different from other solutions that support social login?

While providing social login with Web2 credentials for Web3 wallet is not a new concept, the existing solutions have one or more of the trust assumptions:

1. Trust a different network or parties to verify Web2 credentials other than the Blockchain itself, usually involving a JWK oracle posted on-chain by a trusted party.
1. Trust some parties to manage a persistent private key, whether it uses MPC, threshold cryptography or secure enclaves.
1. Relying on smart contracts (account abstraction) to verify the JWT on chain with revealing privacy fields, or to verify ZK proofs on-chain which can be expensive.

Some of the existing deployed solutions rely on some of these assumptions. Web3Auth and DAuth social login requires deployment of custom OAuth verifiers to Web3auth Auth Network nodes to verify the JWT. Magic Wallet and Privy also require custom OAuth identity issuer and verifiers to adopt the DID standard. All of the solutions still require persistent private keys management, either with trusted parties like AWS via delegation, Shamir Secret Sharing or MPC.

The key differentiators that zkLogin brings to Sui are:

1. Native Support in Sui: Unlike other solutions that are blockchain agnostic, zkLogin is deployed just for Sui. This means a zkLogin transaction can be combined with Multisig and sponsored transactions seamlessly.

1. Self-Custodial without additional trust: We leverage the nonce field in JWT to commit to ephemeral public key, so no persistent private key management is required with any trusted parties. In addition, the JWK itself is an oracle agreed upon by the quorum of stakes by the validators with trusting any source of authority.

1. Full privacy: Nothing is required to submit on-chain except the ZK proof and the ephemeral signature.

1. Compatible with Existing Identity Providers: zkLogin is compatible with providers that adopt OpenID Connect. No need to trust any intermediate identity issuers or verifiers other than the OAuth providers themselves.

### How to verify a zkLogin signature off chain?

The following options support a zkLogin signature over either transaction data or personal message using the JWK state on Sui and current epoch. 

1. Use Sui Typescript SDK. This initializes a GraphQL client and calls the endpoint under the hood.

1. Use the GraphQL endpoint directly: `https://sui-[network].mystenlabs.com/graphql`, changing `[network]` to the appropriate value. See the <a href="/references/sui-api/sui-graphql/reference/api/queries/verify-zklogin-signature" data-noBrokenLinkCheck="true">GraphQL documentation</a> for more details. This is recommended if you do not plan to run any servers or handle any JWK rotations. 

1. Use the [Sui Keytool CLI](../../references/cli/keytool.mdx). This is recommended for debug usage. 

   ```sh
   $ sui keytool zk-login-sig-verify --sig $ZKLOGIN_SIG --bytes $BYTES --intent-scope 3 --network devnet --curr-epoch 3
   ```

1. Use a self-hosted server endpoint and call this endpoint, as described in [zklogin-verifier](https://github.com/MystenLabs/zklogin-verifier). This provides logic flexibility.

### Can I use zkLogin inside a multisig wallet? 

Yes. See the [Multisig Guide](https://sdk.mystenlabs.com/typescript/cryptography/multisig#multisig-with-zklogin) for more details.

## Related links

- [zkLogin Implementation Guide](../../guides/developer/cryptography/zklogin-integration.mdx)
- [zkLogin Example](../../guides/developer/cryptography/zklogin-integration/zklogin-example.mdx)

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/transaction-auth.mdx
```
---
title: Transaction Authentication
description: Transaction security is arguably the most important feature of a blockchain. Sui provides multiple features to secure your transactions, whether on chain or off.
---

Transaction authentication features on Sui provide security against unauthorized access to on-chain data. 

## Keys and Addresses 

Sui adheres to widely accepted wallet specifications in the cryptocurrency industry, including BIP-32 (and its variation, SLIP-0010), BIP-44, and BIP-39, to facilitate key management for users. At present, Sui supports pure Ed25519, ECDSA Secp256k1, ECDSA Secp256r1, and multisig for signed transactions. 

Go to [Keys and Addresses](./transaction-auth/keys-addresses.mdx).

## Signatures

Cryptographic agility is core to Sui. The system supports multiple cryptography algorithms and primitives and can switch between them rapidly. With Sui, you can choose the right cryptography solution for your system and implement the latest algorithms as they become available. 

Go to [Signatures](./transaction-auth/signatures.mdx).

## Multisig

Sui supports multi-signature (multisig) transactions, which require multiple keys for authorization rather than a single, one-key signature. 

Go to [Multisig](./transaction-auth/multisig.mdx).

## Offline Signing

Sui supports offline signing, which is signing transactions using a device not connected to a Sui network, or in a wallet implemented in a different programming language without relying on the Sui key store. 

Go to [Offline Signing](./transaction-auth/offline-signing.mdx).

## Intent Signing

In Sui, an intent is a compact struct that serves as the domain separator for a message that a signature commits to. The data that the signature commits to is an intent message. All signatures in Sui must commit to an intent message, instead of the message itself. 

Go to [Intent Signing](./transaction-auth/intent-signing.mdx).
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/passkeys.mdx
```
---
title: Passkey
description: Sui supports the passkey signature scheme that enables you to sign-in to apps and sign transactions for Sui using a private key securely stored on a passkey authenticator. It uses the WebAuthn standard.
---

Passkey provides a secure and user-friendly alternative for submitting transactions to Sui. Built on the **WebAuthn standard**, passkey lets users authenticate and sign transactions using:

- Hardware security keys, such as YubiKeys
- Mobile devices, such as smartphones and tablets
- Platform-based authenticators, such as Face ID and Touch ID

Passkey simplifies authentication by removing the need to manage seed phrases or private keys manually. Instead, they rely on device-based authentication and cloud synchronization, allowing seamless, phishing-resistant access across multiple devices.

By supporting the passkey signature scheme, Sui improves security and accessibility, making it easier for users to manage their accounts with hardened security. Passkey-based wallets are also tied to the origin, meaning they can’t be phished or used on a different site, which makes it a more secure authentication option.

Refer to the [Typescript SDK support](https://sdk.mystenlabs.com/typescript/cryptography/passkey) on how to add passkey support to your application. For product specification, refer to [SIP-9](https://github.com/sui-foundation/sips/blob/main/sips/sip-9.md).

:::info
Passkey support is available in beta in Sui Devnet and Testnet. The Mainnet release is yet to be scheduled.  
:::

## Benefits of using passkey

**Sign transactions seamlessly**

Users can sign transactions in Sui using passkey, where the passkey private key stays securely stored within the authenticator, reducing the risk of key extraction attacks.

**Authenticate across devices**

Users can approve transactions on their mobile phones by scanning a QR code from a desktop browser. Cloud-synchronized passkey (such as those stored in Apple iCloud or Google Password Manager) lets users authenticate across multiple devices without manual key transfers.

**Use hardware security keys**

Users can sign transactions with external security keys, such as YubiKeys, to add an extra layer of protection against phishing and unauthorized access.

**Authenticate with platform-based security**

Users can sign transactions directly on devices with built-in authenticators (such as Face ID on iPhones or Windows Hello on Windows PCs). This approach lets users sign transactions natively without needing an external security key.

**Recover access and secure accounts with cloud-synced passkey**

Cloud-synced passkey helps users recover access if they lose a device.

## Limitations of passkey

**Passkey functionality varies by authenticator**

Some security keys do not support biometric authentication, requiring users to enter a PIN instead. Also, because WebAuthn does not provide access to private keys, users must store their passkey securely or enable cloud synchronization for recovery.

**Cloud synchronization introduces potential risks**

Cloud-synced passkey improves accessibility but also create risks if a cloud provider is compromised or if a user loses access to their cloud account. Users who prefer full self-custody can rely on hardware-based passkey that does not use cloud synchronization.

**Passkey cannot be exported**

Users cannot transfer a passkey between different authenticators. For example, a passkey created on a security key cannot move to another device unless it syncs through a cloud provider. To avoid losing access, users should set up authentication on multiple devices.
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/nautilus.mdx
```
---
title: Nautilus
description: Run secure, off-chain logic in trusted execution environments (TEEs), and verify it on chain to trigger safe smart contract workflows.
---

Nautilus is a framework for secure and verifiable off chain computation on Sui. It enables builders to delegate sensitive or resource-intensive tasks to a self-managed [trusted execution environment (TEE)](https://en.wikipedia.org/wiki/Trusted_execution_environment) while preserving trust on chain through smart contract-based verification.

Nautilus is designed for hybrid decentralized applications (dApps) that require private data handling, complex computation, or integration with external (Web2) systems. It ensures that off-chain computations are tamper resistant, isolated, and cryptographically verifiable. 

It currently supports self-managed [AWS Nitro Enclave TEEs](https://aws.amazon.com/ec2/nitro/nitro-enclaves/). Developers can verify AWS-signed enclave attestations on chain using Sui smart contracts written in Move. Refer to the [Github repo](https://github.com/MystenLabs/nautilus) for the reproducible build template.

## Features

A Nautilus application consists of two components:

- Off-chain server: Runs inside a TEE, like AWS Nitro Enclaves, and performs the actual computation, such as processing user input or executing a scheduled task.
- On-chain smart contract: Written in Move, this contract receives the output and verifies the TEE's attestation before trusting or acting on the data.

:::info

Initial support for AWS Nitro Enclaves is due to its maturity and reproducibility. Additional TEE providers might become available in the future.

::::

### How it works

- Deploy the off-chain server to a self-managed TEE, such as AWS Nitro Enclaves. You have the option of using the [available reproducible build template](https://github.com/MystenLabs/nautilus).
- The TEE generates a cryptographic attestation that proves the integrity of the execution environment.
- Sui smart contracts verify the attestation on chain before accepting the TEE output.
- The integrity of the TEE is auditable and anchored by the provider’s root of trust.

Refer to [Nautilus Design](./nautilus/nautilus-design.mdx) and [Using Nautilus](./nautilus/using-nautilus.mdx) for details.

:::important

The [provided reproducible build template](https://github.com/MystenLabs/nautilus) is intended as a starting point for building your own enclave. It is not feature complete, has not undergone a security audit, and is offered as a modification-friendly reference licensed under the Apache 2.0 license. THE TEMPLATE AND ITS RELATED DOCUMENTATION ARE PROVIDED `AS IS` WITHOUT WARRANTY OF ANY KIND FOR EVALUATION PURPOSES ONLY.
You can adapt and extend it to fit your specific use case.

:::

## Use cases

Nautilus supports several Web3 use cases for trustworthy and verifiable off-chain computation. Some examples include:

- **Trusted oracles:** Nautilus could ensure that oracles fetch and process off-chain data in a tamper-resistant manner before providing results to a smart contract. The source of external data could be a Web2 service (like weather, sports, betting, asset prices, and so on) or a decentralized storage platform like [Walrus](https://walrus.xyz).
- **AI agents:** Nautilus is ideal for securely running AI models for inference or to execute agentic workflows to produce actionable outcomes, while providing data and model provenance on chain.
- **DePIN solutions:** DePIN (Decentralized Physical Infrastructure) can leverage Nautilus for private data computation in IoT and supply chain networks.
- **Fraud prevention in multi-party systems:** Decentralized exchanges (DEXs) could use Nautilus for order matching and settlement, or layer-2 solutions could prevent collision and fraud by securely running computations between untrusted parties.
- **Identity management:** Nautilus can provide solutions in the identity management space that require on-chain verifiability for decentralized governance and proof of tamper resistance.

When used together, Nautilus and [Seal](https://github.com/MystenLabs/seal) enable powerful privacy-preserving use cases by combining secure and verifiable computation with secure key access. A common challenge with TEEs is persisting secret keys across restarts and different machines. Seal can address this by securely storing long-term keys and granting access only to properly attested TEEs. In this model, Nautilus handles computation over the encrypted data, while Seal controls key access. Applications that require a shared encrypted state can use both tools to privately process user requests and update encrypted data on public networks.

## Future plans and non-goals

Nautilus will support additional TEE providers in the future, such as [Intel TDX](https://www.intel.com/content/www/us/en/developer/tools/trust-domain-extensions/overview.html) and [AMD SEV](https://www.amd.com/en/developer/sev.html) possibly. Your suggestions on which platforms to prioritize or support is greatly appreciated.

{@include: ../../snippets/contact-nautilus.mdx}

Nautilus does not have a native, readily usable TEE network. Nautilus partners might provide such TEE networks, however. Apart from such networks, you are encouraged to deploy and manage your own TEEs for running off-chain Nautilus servers.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/nautilus/using-nautilus.mdx
```
---
title: Using Nautilus
description: Details on how to use Nautilus using the provided reproducible build template.
---

The [Nautilus framework](https://github.com/MystenLabs/nautilus) helps you deploy an AWS Nitro Enclave with all the necessary scaffolding, such as reproducible builds, signature formatting, and HTTPS traffic forwarding, so you can focus on implementing the off-chain computation logic inside the enclave.

In addition, the framework provides an on-chain template that includes the minimal smart contract code required to register a Nautilus instance and its public key. These are the steps you take to use Nautilus in your dApp:

1. Implement the enclave in Rust with the desired computation logic.
2. Deploy a Move smart contract that stores the expected platform configuration registers (PCRs) and allows updates by the contract deployer.
3. Deploy the enclave instance on AWS and register it on chain using its attestation document.
4. Upload signed responses from the registered enclave, verify them on chain, and consume the results in your smart contract.

## Purpose of this guide

This guide walks you through the following steps:

1. Writing and deploying a basic Nautilus off-chain instance using AWS Nitro Enclaves. The example instance runs a server that fetches weather data for a specific location.
2. Writing a Move smart contract that registers the enclave by verifying its attestation and public key, then verifies the Nautilus response (signature and payload) on chain and mints an NFT containing the location and temperature data.

The setup script performs the following actions:

- Launches a preconfigured EC2 instance and allocates a Nitro Enclave.
- Builds the Rust-based template application into an enclave image format (EIF) binary and runs it inside the enclave.
- Configures required HTTP domains so the enclave can access external APIs via the parent EC2 instance (as the enclave itself has no internet access).
- Exposes three endpoints to allow client-side communication with the enclave.

When the enclave starts, it generates a fresh enclave key pair and exposes the following three endpoints:

- `health_check`: Probes all allowed domains inside the enclave. This logic is built into the template and does not require modification.
- `get_attestation`: Returns a signed attestation document over the enclave public key. Use this during on-chain registration. This logic is built into the template and doesn't require modification.
- `process_data`: Fetches weather data from an external API, signs it with the enclave key, and returns the result. This logic is customizable and you must implement it.

## Code structure

Refer to the [Github repo](https://github.com/MystenLabs/nautilus) for the code structure and related usage instructions that follow.

```sh
/move
  /enclave          Utility functions to create an enclave config and register public key by providing a valid attestation document.
  /app              Application logic, uses functions in enclave directory. Replace this with your Nautilus application on-chain logic.
/src
  /aws              AWS boilerplate
  /init             AWS boilerplate
  /system           AWS boilerplate
  /nautilus-server  Nautilus server that runs inside the enclave.
    run.sh          Configures all necessary domains and traffic forwarder, then runs the Rust server inside the enclave.
    app.rs          Replace this with your off-chain computation logic.
    common.rs       Common code for getting attestation.
    allowed_endpoints.yaml  This file lists all endpoints the enclave is allowed to access. By default, the enclave has no internet access unless the parent EC2 instance explicitly forwards traffic. During the configuration step, this file is used to generate the necessary code to enable limited traffic forwarding from the enclave. 
```

Focus on implementing the Move code in `move/app` and the Rust code in `src/nautilus-server/app.rs`, along with the frontend logic that interacts with the deployed smart contract. You’ll also need to edit `allowed_endpoints.yaml` to include all domains the enclave must access. 

The rest of the template can remain largely unmodified. 

:::info

Frontend code is not included in this guide. The Move call is demonstrated using the CLI.

:::

## Run the example enclave

1. Set up an AWS developer account and install the AWS CLI. For detailed instructions, see the [AWS Nitro Enclaves getting started guide](https://docs.aws.amazon.com/enclaves/latest/user/getting-started.html#launch-instance).

1. Run the following script and follow the prompts. The script prompts you to enter some values - see the next step if you want to run this example as-is. If the script completes successfully, it generates code locally that you need to commit. If you encounter issues, refer to the info box that follows, as instructions might vary depending on your AWS account settings.

    ```sh
    $ export KEY_PAIR=<your-key-pair-name>
    ```
    ```sh
    $ export AWS_ACCESS_KEY_ID=<your-access-key>
    ```
    ```sh
    $ export AWS_SECRET_ACCESS_KEY=<your-secret-key>
    ```
    ```sh
    $ export AWS_SESSION_TOKEN=<your-session-token>
    ```
    ```sh
    $ sh configure_enclave.sh
    ```

    :::info

    - Run `sh configure_enclave.sh -h` to view additional instructions.
    - If your AWS account is not in `us-east-1`, you might need to configure `REGION` and `AMI_ID` values specific to your region. Refer to this [guide](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html) to find a suitable Amazon Linux image ID. 

        ```sh
        $ export REGION=<your-region>
        ```
        ```sh
        $ export AMI_ID=<find-an-amazon-linux-ami-for-your-region>
        ```
    - To find the values for `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY` and `AWS_SESSION_TOKEN`, refer to this [AWS guide](https://docs.aws.amazon.com/streams/latest/dev/setting-up.html).
    - Set `KEY_PAIR` to the name of your existing AWS key pair or one you create. To create a key pair, refer to this [AWS guide](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/create-key-pairs.html).
    - You might need to create a vpc with a public subnet. Refer to this [AWS guide](https://000058.awsstudygroup.com/2-prerequiste/2.1-createec2/2.1.2-createpublicsubnet/) for instructions.

    :::

1. To run this example as-is, you don't need to modify `allowed_endpoints.yaml` because it already includes `api.weatherapi.com`. Follow the prompts to enter the required values. This step demonstrates how to store a secret (an API key) using AWS Secrets Manager, so you can avoid including the secret in the public application code.

    ```sh
    Enter EC2 instance base name: weather # anything you like
    Do you want to use a secret? (y/n): y
    Do you want to create a new secret or use an existing secret ARN? (new/existing): new
    Enter secret name: weather-api-key # anything you like
    Enter secret value: 045a27812dbe456392913223221306 # this is an example api key, you can get your own at weatherapi.com
    ```

1. If completed successfully, changes are generated in `/src/nautilus-server/run.sh` and `expose_enclave.sh`. Commit these changes, as they are required when building the enclave image.

    :::info

    - You can modify `src/nautilus-server/allowed_endpoints.yaml` to add any external domains the enclave needs access to. If you update this file, you need to create a new instance using `configure_enclave.sh`, as the generated code also changes.
    - You can optionally create a secret to store any sensitive value you don’t want included in the codebase. The secret is passed to the enclave as an environment variable. You can verify newly created secrets or find existing ARNs in the [AWS Secrets Manager console](https://us-east-1.console.aws.amazon.com/secretsmanager/listsecrets?region=<REGION>).

    :::

1. Connect to your instance and clone the repository. For detailed instructions, see [Connect to your Linux instance using SSH](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/connect-linux-inst-ssh.html#connect-linux-inst-sshClient) in the AWS documentation.

1. You should now be inside the directory containing the server code, including the committed file changes from the previous step. Next, build the enclave image, run it, and expose the HTTP endpoint on port 3000. 

    ```sh
    $ cd nautilus/
    ```
    ```sh
    $ make && make run # this builds the enclave and run it
    ```
    ```sh
    $ sh expose_enclave.sh # this exposes port 3000 to the Internet for traffic
    ```

    :::info

    Use `make run-debug` instead of `make run` to run the enclave in debug mode. This prints all logs, where the production build does not. In debug mode, the PCR values are all zeros and are not valid for production use.

    :::

1. Congratulations! You can now interact with the enclave from the outside world. You can find the `PUBLIC_IP` in the AWS console.

    ```sh
    $ curl -H 'Content-Type: application/json' -X GET http://<PUBLIC_IP>:3000/health_check
    ```
    ```sh
    $ curl -H 'Content-Type: application/json' -X GET http://<PUBLIC_IP>:3000/get_attestation
    ```
    ```sh
    $ curl -H 'Content-Type: application/json' -d '{"payload": { "location": "San Francisco"}}' -X POST http://<PUBLIC_IP>:3000/process_data
    ```

1. Optionally, you can set up an application load balancer (ALB) for the EC2 instance with an SSL/TLS certificate from AWS Certificate Manager (ACM), and configure Amazon Route 53 for DNS routing. For more information, see the [ACM User Guide](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) and the [ALB Guide](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html).

## Develop your own Nautilus server

The Nautilus server logic is located in `src/nautilus-server`. To customize the application:

- Update `allowed_endpoints.yaml` for any domains your application requires.
- Modify `app.rs` to update the `process_data` endpoint and add new endpoints as needed.

The following files typically do not require modification:

- `common.rs` handles the `get_attestation` endpoint.
- `main.rs` initializes the ephemeral key pair and sets up the HTTP server.

You can test most functionality by running the server locally. However, the `get_attestation` endpoint doesn't work locally because it requires access to the Nitro Secure Module (NSM) driver, which is only available when running the code inside the configured EC2 instance. This endpoint functions correctly when the server runs within the enclave as described in the setup steps.

To test the `process_data` endpoint locally, run the following:

```sh
$ cd src/nautilus-server/
```
```sh
$ RUST_LOG=debug API_KEY=045a27812dbe456392913223221306 cargo run
```
```sh
$ curl -H 'Content-Type: application/json' -d '{"payload": { "location": "San Francisco"}}' -X POST http://localhost:3000/process_data
```
```json
{
  "response":
    {
      "intent":0,
      "timestamp_ms":1744041600000,
      "data":
        {
          "location":"San Francisco",
          "temperature":13
        }
    },
  "signature":"b75d2d44c4a6b3c676fe087465c0e85206b101e21be6cda4c9ab2fd4ba5c0d8c623bf0166e274c5491a66001d254ce4c8c345b78411fdee7225111960cff250a"
}
```

### Troubleshooting

- **Traffic forwarder error:** Ensure all targeted domains are listed in the `allowed_endpoints.yaml`. Use the following command to test enclave connectivities to all domains.

```sh
$ curl -H 'Content-Type: application/json' -X GET http://<PUBLIC_IP>:3000/health_check
```
```json
{
  "pk":"f343dae1df7f2c4676612368e40bf42878e522349e4135c2caa52bc79f0fc6e2",
  "endpoints_status":
    {
      "api.weatherapi.com":true
    }
}
```

- **Docker is not running:** The EC2 instance might still be starting up. Wait a few moments, then try again.

- **Cannot connect to enclave:** This might be due to a VSOCK communication issue. Verify that the enclave is running and properly exposed with `sh expose_enclave.sh`.

### Reset

```sh
$ cd nautilus/
```
```sh
$ sh reset_enclave.sh
```
Then repeat the image build step.

## Build locally to check reproducibility

Every enclave built from the same source code (everything in `/src`) can produce identical PCRs through reproducible builds. This includes any traffic forwarding changes made in `run.sh` (see branch `example-configuration`).

```sh
$ cd nautilus/
```
```sh
$ make
```
```sh
$ cat out/nitro.pcrs
```
```sh
3a929ea8b96d4076da25e53e740300947e350a72a775735f63f8b0f8112d3ff04d8ccae53f5ec13dd3c05b865ba7b610 PCR0
3a929ea8b96d4076da25e53e740300947e350a72a775735f63f8b0f8112d3ff04d8ccae53f5ec13dd3c05b865ba7b610 PCR1
21b9efbc184807662e966d34f390821309eeac6802309798826296bf3e8bec7c10edb30948c90ba67310f7b964fc500a PCR2
```
```sh
# Add env var that will be used later when registering the enclave.
$ PCR0=3a929ea8b96d4076da25e53e740300947e350a72a775735f63f8b0f8112d3ff04d8ccae53f5ec13dd3c05b865ba7b610
$ PCR1=3a929ea8b96d4076da25e53e740300947e350a72a775735f63f8b0f8112d3ff04d8ccae53f5ec13dd3c05b865ba7b610
$ PCR2=21b9efbc184807662e966d34f390821309eeac6802309798826296bf3e8bec7c10edb30948c90ba67310f7b964fc500a
```

## Register the enclave on chain

After finalizing the Rust code, the dApp administrator can register the enclave with the corresponding PCRs and public key.

```sh
# optionally
$ sui client switch --env testnet # or appropriate network
$ sui client faucet
$ sui client gas
# deploy the enclave package
$ cd move/enclave
$ sui move build
$ sui client publish

# record ENCLAVE_PACKAGE_ID as env var from publish output
$ ENCLAVE_PACKAGE_ID=0x14e8b4d8b28ee9aa5ea604f3f33969b3d0f03247b51837f27e17bcf875d3582c

# deploy your dapp logic
$ cd ../app
$ sui move build
$ sui client publish

# record CAP_OBJECT_ID (owned object of type Cap), ENCLAVE_CONFIG_OBJECT_ID (shared object), EXAMPLES_PACKAGE_ID (package containing weather module) as env var from publish output

$ CAP_OBJECT_ID=0xb157d241cc00b7a9b8b0f11d0b4c3e11d8334be95f7e50240962611bd802abff
$ ENCLAVE_CONFIG_OBJECT_ID=0x58a6a284aaea8c8e71151e4ae0de2350ae877f0bd94adc2b2d0266cf23b6b41d
$ EXAMPLES_PACKAGE_ID=0x7e712fd9e5e57d87137440cfea77dc7970575a5c3229d78bb7176ab984d94adf

# record the deployed enclave url, e.g. http://<PUBLIC_IP>:3000
$ ENCLAVE_URL=<DEPLOYED_URL>

# the module name and otw name used to create the dapp, defined in your Move code `fun init`
$ MODULE_NAME=weather
$ OTW_NAME=WEATHER

# make sure all env vars are populated
$ echo $EXAMPLES_PACKAGE_ID
$ echo $ENCLAVE_PACKAGE_ID
$ echo $CAP_OBJECT_ID
$ echo $ENCLAVE_CONFIG_OBJECT_ID
$ echo 0x$PCR0
$ echo 0x$PCR1
$ echo 0x$PCR2
$ echo $MODULE_NAME
$ echo $OTW_NAME
$ echo $ENCLAVE_URL

# =======
# the two steps that follow (update pcrs, register enclave) can be reused if enclave server is updated
# =======

# this calls the update_pcrs onchain with the enclave cap and built PCRs, this can be reused to update PCRs if Rust server code is updated
$ sui client call --function update_pcrs --module enclave --package $ENCLAVE_PACKAGE_ID --type-args "$EXAMPLES_PACKAGE_ID::$MODULE_NAME::$OTW_NAME" --args $ENCLAVE_CONFIG_OBJECT_ID $CAP_OBJECT_ID 0x$PCR0 0x$PCR1 0x$PCR2

# optional, give it a name you like
$ sui client call --function update_name --module enclave --package $ENCLAVE_PACKAGE_ID --type-args "$EXAMPLES_PACKAGE_ID::$MODULE_NAME::$OTW_NAME" --args $ENCLAVE_CONFIG_OBJECT_ID $CAP_OBJECT_ID "weather enclave, updated 2025-05-13"

# this script calls the get_attestation endpoint from your enclave url and use it to calls register_enclave onchain to register the public key, results in the created enclave object
$ sh ../../register_enclave.sh $ENCLAVE_PACKAGE_ID $EXAMPLES_PACKAGE_ID $ENCLAVE_CONFIG_OBJECT_ID $ENCLAVE_URL $MODULE_NAME $OTW_NAME

# record the created shared object ENCLAVE_OBJECT_ID as env var from register output
$ ENCLAVE_OBJECT_ID=0xe0e70df5347560a1b43e5954267cadd1386a562095cb4285f2581bf2974c838d
```

You can view an example of an enclave config object containing PCRs [on SuiScan](https://testnet.suivision.xyz/object/0x58a6a284aaea8c8e71151e4ae0de2350ae877f0bd94adc2b2d0266cf23b6b41d). You can also view an [example of an enclave object](https://testnet.suivision.xyz/object/0xe0e70df5347560a1b43e5954267cadd1386a562095cb4285f2581bf2974c838d) containing the enclave public key.

### Enclave management

The template allows the admin to register multiple `Enclave` objects associated with one `EnclaveConfig` that defines PCRs. Each `Enclave` object represents a specific enclave instance with a unique public key, while the `EnclaveConfig` tracks the PCR values and their associated version. You can register all new `Enclave` instances with the latest `config_version` to ensure consistency. 

This design allows the admin to run multiple instances of the same enclave with different public keys, where `config_version` is set to the latest version when creating an `Enclave` object. The admin can register or destroy their `Enclave` objects. 

### Update PCRs

The deployer of the smart contract holds the `EnclaveCap`, which allows for updating the PCRs and enclave public key if the Nautilus server code has been modified. You can retrieve the new PCRs using `make && cat out/nitro.pcrs`. To update the PCRs or register the enclave again, reuse the steps outlined in the previous section.

## Using the verified computation in Move

You can now write your frontend code to interact with the enclave for computation, and then send the resulting data to the Move contract for use. For the weather example, you can request the enclave to retrieve weather data for a specific location:

```sh
$ curl -H 'Content-Type: application/json' -d '{"payload": { "location": "San Francisco"}}' -X POST http://<PUBLIC_IP>:3000/process_data
```
```json
{
  "response":
    {
      "intent":0,
      "timestamp_ms":1744683300000,
      "data":
        {
          "location":"San Francisco",
          "temperature":13
        }
    },
  "signature":"77b6d8be225440d00f3d6eb52e91076a8927cebfb520e58c19daf31ecf06b3798ec3d3ce9630a9eceee46d24f057794a60dd781657cb06d952269cfc5ae19500"
}
```

Then use the values from the enclave response - `signature`, `timestamp`, `location`, and `temperature` - to call `update_weather` in the Move contract. In this example, the call is demonstrated using a script, but it should be integrated into your dApp frontend.

```shell
$ sh ../../update_weather.sh \
    $EXAMPLES_PACKAGE_ID \
    $MODULE_NAME \
    $OTW_NAME \
    $ENCLAVE_OBJECT_ID \
    "77b6d8be225440d00f3d6eb52e91076a8927cebfb520e58c19daf31ecf06b3798ec3d3ce9630a9eceee46d24f057794a60dd781657cb06d952269cfc5ae19500" \
    1744683300000 \
    "San Francisco" \
    13
```

An example of a [created weather NFT](https://testnet.suivision.xyz/object/0xa78e166630c0ed004b3115b474fed15d71f27fc80b68e37d451494c6e815931e) is available on network scanners.

### Signing payload

Signing payloads in Move are constructed using Binary Canonical Serialization (BCS). These must match the structure specified in the enclave’s Rust code when generating the signature; otherwise, signature verification in `enclave.move` might fail.

Write unit tests in both Move and Rust to ensure consistency. See `test_serde()` in `src/nautilus-server/src/app.rs` and the examples in `move/enclave/enclave.move`.

## FAQs

Some questions the community often asks about are answered in the following sections.

### Why did Sui choose AWS Nitro Enclaves initially?

There are many TEE providers available, but initial support for AWS Nitro Enclaves is due to their maturity and support for reproducible builds. Support for additional TEE providers might be considered in the future.

{@include: ../../../snippets/contact-nautilus.mdx}

### Where is the root of trust of AWS?

It is stored as part of the Sui framework and used to verify AWS attestation documents. You can verify its hash by following the steps outlined on [AWS](https://docs.aws.amazon.com/enclaves/latest/user/verify-root.html#validation-process).

```sh
$ curl https://raw.githubusercontent.com/MystenLabs/sui/refs/heads/main/crates/sui-types/src/nitro_root_certificate.pem -o cert_sui.pem
$ sha256sum cert_sui.pem

6eb9688305e4bbca67f44b59c29a0661ae930f09b5945b5d1d9ae01125c8d6c0

$ curl https://aws-nitro-enclaves.amazonaws.com/AWS_NitroEnclaves_Root-G1.zip -o cert_aws.zip
$ unzip cert_aws.zip
$ sha256sum root.pem

6eb9688305e4bbca67f44b59c29a0661ae930f09b5945b5d1d9ae01125c8d6c0 # check it matches from the one downloaded from the Sui repo
```

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/nautilus/nautilus-design.mdx
```
---
title: Nautilus Design
description: Overview of the design aspects of Nautilus, including its trust model.
---

![image](../images/flows.png)

## dApp developer actions

1. Create a Nautilus off-chain server with a reproducible build. You have the option of using the [provided template](https://github.com/MystenLabs/nautilus).
2. Publish the server code to a public repository (such as GitHub) to ensure transparency and verifiability.
3. Register the instance’s platform configuration registers (PCRs) using a Sui smart contract.
4. Deploy the server to an AWS Nitro Enclave.
5. Register the deployed enclave using a Sui smart contract and the attestation document. This step also includes registering the enclave’s public key, which is an ephemeral key securely generated within the enclave for signing the enclave responses.

To reduce the trusted computing base, you should route access to the enclave through backend services that handle load balancing, rate limiting, and other related aspects.

:::tip

Verifying an attestation document on chain is a relatively expensive operation that you should perform only during enclave registration. After registration, use the enclave key to more efficiently verify messages from the enclave.

:::

## dApp user / client actions

1. (Optional) Verify the Nautilus off-chain server code by building it locally and confirming that the generated PCRs match the onchain records.
2. Send a request to the deployed enclave and receive a signed response.
3. Submit the signed response on chain for verification before executing the corresponding application logic.

## Trust model

The attestation document from an AWS Nitro Enclave includes a certificate chain that can be verified on chain using AWS as the root certificate authority. This verification confirms the following:

- The enclave instance is running unmodified software, as validated by its PCR values.
- Users can independently verify that the instance’s computation aligns with the published source code, ensuring transparency and trust.

Reproducible builds allow builders and users to optionally verify that the binary running inside an enclave instance matches a specific version of the source code. This approach provides the following benefits:

- Anyone can build and compare the binary to confirm consistency with the published source code.
- Any changes to the software result in different PCR values, making unauthorized modifications detectable.
- Reproducible builds shift the trust from runtime to build time, strengthening the overall security posture of the dApp.

:::important

Reproducible builds might not apply to all use cases, such as when the source code is not public.

:::

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/system/validator-signatures.mdx
```
---
title: Validator Signatures
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/system/intents-for-validation.mdx
```
---
title: Intents for Validation
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/system/checkpoint-verification.mdx
```
---
title: Checkpoint Verification
description: On the Sui network, checkpoints define the history of the blockchain. Checkpoint verification is how Full nodes and other clients guarantee their state is exactly the same as the Sui network.
---

On the Sui network, checkpoints define the history of the blockchain. They are quite similar to the concept of blocks used by traditional blockchains like Bitcoin or Ethereum. The Sui blockchain, however, forms checkpoints after transaction execution has already happened to provide a certified history of the chain, instead of being formed before execution.

Checkpoints contain:

- The cryptographic hash of the previous checkpoint.
- A list of all the transaction digests (and the corresponding transaction effects digests) that are included in the checkpoint.
- A set of signatures from a quorum (more than 2/3rds) of the validators that formed the committee at the time the checkpoint was created.

Both validators and Full nodes consume checkpoints to remain synchronized with the network.

## Checkpoint verification

For Full nodes and validators to trust a checkpoint, they must first verify it. Verification ensures that the checkpoint is a true checkpoint that the Sui validator committee created.

Checkpoint verification requires two interdependent pieces:

1. Assuming that the Full node (or other client) has the public keys of the validator committee that created the checkpoint, it can check the signatures on the checkpoint for validity.

    Checkpoints are signed by the aggregated BLS signatures of a quorum of the committee.
    If the signatures are valid, the client now knows that the checkpoint was created by the validator committee, and not by some other party.

1. By validating checkpoints, the client can determine the make-up of the committee, because the final checkpoint of each epoch contains the validator committee (including the public keys) of the next epoch.

These pieces seem to create a circular dependency issue. The client needs to know the committee to verify checkpoints, which in turn allows it to learn what the committee is for each epoch. To solve this problem, the process is bootstrapped by starting from the genesis checkpoint, which is the earliest checkpoint in a Sui network. The genesis checkpoint contains the initial validator committee, which allows a client to verify all checkpoints in the history by using the following process:

1. The client obtains the genesis checkpoint from some trusted source.
1. The client loads the initial committee from the genesis checkpoint.
1. The client uses the state sync network or Sui archive to obtain the next checkpoint.
1. The client verifies the signatures on the checkpoint using the current committee's public keys, and verifies that the checkpoint's previous checkpoint hash is equal to the hash of the previous checkpoint that the client validated.
1. If the checkpoint is invalid, an error is raised.
1. Otherwise, the client checks if the checkpoint is the last one of the current epoch.
    - If so, load the next committee from it, and use that committee as the current committee.
    - If not, return to step 3 and continue.

This allows the client to eventually verify all checkpoints up to the present time.

## What do checkpoints commit to?

After a client verifies a checkpoint, what can it do with that information?

As mentioned earlier, a checkpoint contains a list of transactions so a Full node, for instance, can begin fetching and executing those transactions. Because the transactions are identified by their digest (a cryptographic hash), the client can be sure that the transactions it executes have not been altered.

Additionally, the checkpoint contains the effects digests of each transaction. The effects digest is the cryptographic hash of the `TransactionEffects`, which is itself a structure that lists all of the inputs and outputs of a transaction. It includes the digests of all objects that were written by the transaction.
This allows a Full node to verify that it has obtained the same execution results as those that the validators attested to when signing the checkpoint.

By executing checkpoints, and verifying transaction outputs, a Full node can build up the entire state of the Sui network (that is, the collection of objects in the network) and trust that every byte of every object is correct.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/transaction-auth/keys-addresses.mdx
```
---
title: Keys and Addresses
---

Sui adheres to widely accepted wallet specifications in the cryptocurrency industry, including BIP-32 and its variation SLIP-0010, BIP-44, and BIP-39, to facilitate key management for users. At present, Sui supports pure Ed25519, ECDSA Secp256k1, ECDSA Secp256r1, and multisig for signed transactions.

Follow the relevant link for more information on each wallet specification:

- [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
- [BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
- [BIP-44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki)
- [SLIP-0010](https://github.com/satoshilabs/slips/blob/master/slip-0010)

## Key derivation scheme

Sui follows SLIP-0010 for managing wallets that support the Ed25519 (EdDSA) signing scheme.

For managing wallets that support the Ed25519 (EdDSA) signing scheme, Sui follows SLIP-0010, which enforces wallets to always derive child private keys from parent private keys using the hardened key path.

Sui follows BIP-32 for managing wallets that support the ECDSA Secp256k1 and ECDSA Secp256r1 signing scheme.

BIP-32 defines the hierarchical deterministic wallet structure to logically associate a set of keys. Grouping keys in this manner reduces the overhead of keeping track of a large number of private keys for a user. This method also lets custodians issue distinct managed addresses for each user account under one source of control. Using BIP-32 decouples the private key derivation from the public key derivation, enabling the watch-only wallet use case, where a chain of public keys and its addresses can be derived, while the private key can be kept offline for signing.

## Key derivation path

BIP-44 further defines the five levels of the derivation path with their exact meanings:
`m / purpose' / coin_type' / account' / change / address_index`. In this structure, the slashes indicate new levels, or children, in the hierarchy.

The `purpose` level is generally set to 44, corresponding to the BIP number. In Sui, however, the purpose level distinguishes different signing schemes: 44 is set for Ed25519, 54 for ECDSA Secp256k1 and 74 for Secp256r1. While it is non-standard to set the purpose level to a value that is not 44, it is common to use the purpose field to distinguish different signing schemes. BIP-49 and BIP-84, for example, are used to identify script types in Bitcoin. Sui chose 54 to indicate ECDSA Secp256k1 because there is no existing BIP under 54, avoiding confusion with any Bitcoin standard.

The `coin_type` value is managed with a repository of all other cryptocurrencies. Both signature schemes use Sui's registered coin_type, 784 (SUI on a telephone keypad).

The `account` level is usually used for logically separating user accounts and creating specific account categories.

It is generally accepted that, while account-based currencies define only the first three levels, UTXO-based currencies add change and address level definitions. Because Sui's object-oriented data model is neither UTXO nor account-based (it in fact combines both), it employs all five levels for maximum compatibility.

| Scheme          | Path                                         | Comments                                       |
| --------------- | -------------------------------------------- | ---------------------------------------------- |
| Ed25519         | `m/44'/784'/{account}'/{change}'/{address}'` | Each level of the derivation path is hardened. |
| ECDSA Secp256k1 | `m/54'/784'/{account}'/{change}/{address}`   | The first three levels are hardened.           |
| ECDSA Secp256r1 | `m/74'/784'/{account}'/{change}/{address}`   | The first three levels are hardened.           |

## Mnemonics support

After Sui defines the deterministic way to derive the master key from a seed, BIP-39 is introduced to make the seed more human-readable and memorizable using mnemonics. Sui accepts 12, 15, 18, 21, and 24 words from the BIP-39 word list that is properly checksummed, corresponding to 128, 160, 192, 224, and 256 bits of entropy. Sui Wallet and SDKs provide a flexible interface to sign transactions with various signing schemes.

## Address format

For deriving a 32-byte Sui address, Sui hashes the signature scheme flag 1-byte concatenated with public key bytes using the [BLAKE2b](https://www.blake2.net/) (256 bits output) hashing function. Sui address currently supports pure Ed25519, Secp256k1, Secp256r1, and MultiSig with corresponding flag bytes of 0x00, 0x01, 0x02, and 0x03, respectively.

## Example

Sui Wallet and SDKs provide a flexible interface to sign transactions with various signing schemes.

<Tabs>
<TabItem value="typescript" label="TypeScript">

```typescript
const keypair = Ed25519Keypair.deriveKeypair(TEST_MNEMONIC, `m/44'/784'/0'/0'/0'`);
const address = keypair.getPublicKey().toSuiAddress();
```

</TabItem>
<TabItem value="cli" label="CLI">

```sh
$ sui keytool import "TEST_MNEMONIC" ed25519 "m/44'/784'/0'/0'/0'"
```
```sh
$ sui client new-address ed25519 "m/44'/784'/0'/0'/0'"
```

</TabItem>
</Tabs>

See more test vectors for [pure Ed25519](https://github.com/MystenLabs/sui/blob/f3b5fdd73da64a0df65fb4323471512b0f57ec4d/sdk/typescript/test/unit/cryptography/ed25519-keypair.test.ts) or [ECDSA Secp256k1](https://github.com/MystenLabs/sui/blob/199f06d25ce85f0270a1a5a0396156bb2b83122c/sdk/typescript/test/unit/cryptography/secp256k1-keypair.test.ts).

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/transaction-auth/multisig.mdx
```
---
title: Multisig
---

Sui supports multi-signature (multisig) transactions, which require multiple keys for authorization rather than a single, one-key signature. In technical terms, Sui supports `k` out of `n` multisig transactions, where `k` is the threshold and `n` is the total weights of all participating parties. The maximum number of parties is 10. To learn more about the single key signatures that Sui supports, see [Signatures](./signatures.mdx).

Valid participating keys for multisig are Pure Ed25519, ECDSA Secp256k1, and ECDSA Secp256r1. A ([u8](https://doc.rust-lang.org/std/primitive.u8.html)) weight is set for each participating keys and the threshold can be set as [u16](https://doc.rust-lang.org/std/primitive.u16.html). If the serialized multisig contains enough valid signatures of which the sum of weights passes the threshold, Sui considers the multisig valid and the transaction executes.

## Applications of multisig

Sui allows you to mix and match key schemes in a single multisig account. For example, you can pick a single Ed25519 mnemonic-based key and two ECDSA secp256r1 keys to create a multisig account that always requires the Ed25519 key, but also one of the ECDSA secp256r1 keys to sign. You could use this structure for mobile secure enclave stored keys as two-factor authentication.

:::info

Currently, iPhone and high-end Android devices support only ECDSA secp256r1 enclave-stored keys.

:::

Compared to threshold signatures, a multisig account is generally more flexible and straightforward to implement and use,
without requiring complex multi-party computation (MPC) account setup ceremonies and related software, and any
dependency in threshold crypto providers. Additionally, apart from the ability to mix and match key schemes and setting
different weights for each key (which is complex in threshold cryptography), multisig accounts are
"accountable" and "transparent" by design because both participating parties and observers can see who signed each
transaction. On the other hand, threshold signatures provide the benefits of hiding the threshold policy, but also
resulting in a single signature payload, making it indistinguishable from a single-key account.

![Supported structures in Sui multisig](images/sui_multisig_structures.png 'Supported structures in Sui multisig')
_Multisig structures supported in Sui._

## Related links

- [Multisig Authentication](../../../guides/developer/cryptography/multisig.mdx): Guide on how to create a multisig transaction.
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/transaction-auth/intent-signing.mdx
```
---
title: Intent Signing
---

In Sui, an intent is a compact struct that serves as the domain separator for a message that a signature commits to. The data that the signature commits to is an intent message. All signatures in Sui must commit to an intent message, instead of the message itself.

## Motivation

In previous releases, Sui used a special `Signable` trait that attached the Rust struct name as a prefix to the serialized data. This is not ideal because it's:

- **Not compact:** The prefix `TransactionData::` is significantly larger than 1 byte.
- **Not user-friendly:** Non-Rust applications need to maintain a list of Rust-struct names.

The intent signing standard provides a compact domain separator to the data being signed for both user signatures and authority signatures. It has several benefits, including:

- The intent scope is replaced by a u8 representation instead of a Rust struct tag name string.
- In addition to the intent scope, other important domain separators can be committed as well (such as intent version and app id).
- The data itself no longer needs to implement the `Signable` trait, it just needs to implement `Serialize`.
- All signatures can adopt the same intent message structure, including both user signatures (only to commit to `TransactionData`) and authority signature (commits to all internal intent scopes such as `TransactionEffects`, `ProofOfPossession`, and `SenderSignedTransaction`).

## Structs

The `IntentMessage` struct consists of the intent and the serialized data value.

```rust
pub struct IntentMessage<T> {
  pub intent: Intent,
  pub value: T,
}
```

To create an intent struct, include the `IntentScope` (what the type of the message is), `IntentVersion` (what version the network supports), and `AppId` (what application that the signature refers to).

```rust
pub struct Intent {
  scope: IntentScope,
  version: IntentVersion,
  app_id: AppId,
}
```

To see a detailed definition for each field, see each enum definition [in the source code](https://github.com/MystenLabs/sui/blob/0dc1a38f800fc2d8fabe11477fdef702058cf00d/crates/sui-types/src/intent.rs).

The serialization of an `Intent` is a 3-byte array where each field is represented by a byte.

The serialization of an `IntentMessage<T>` is the 3 bytes of the intent concatenated with the BCS serialized message.

## User Signature

To create a user signature, construct an intent message first, and create the signature over the 32-byte Blake2b hash of the BCS serialized value of the intent message of the transaction data (`intent || message`).

Here is an example in Rust:

```rust
let intent = Intent::default();
let intent_msg = IntentMessage::new(intent, data);
let signature = Signature::new_secure(&intent_msg, signer);
```

Here is an example in TypeScript:

```typescript
const intentMessage = messageWithIntent('TransactionData', transactionBytes);
const signature = await this.sign(intentMessage);
```

Under the hood, the `new_secure` method in Rust and the `signData` method in TypesScript does the following:

1.  Serializes the intent message as the 3-byte intent concatenated with the BCS serialized bytes of the transaction data.
1.  Applies Blake2b hash to get the 32-byte digest
1.  Passes the digest to the signing API for each corresponding scheme of the signer. The supported signature schemes are pure Ed25519, ECDSA Secp256k1 and ECDSA Secp256r1. See [Sui Signatures](./signatures.mdx#signature-requirements) for requirements of each scheme.

## Authority Signature

The authority signature is created using the protocol key. The data that it commits to is also an intent message `intent || message`. See all available intent scopes [in the source code](https://github.com/MystenLabs/sui/blob/0dc1a38f800fc2d8fabe11477fdef702058cf00d/crates/sui-types/src/intent.rs#L66)

### How to Generate Proof of Possession for an Authority

When an authority request to join the network, the protocol public key and its proof of possession (PoP) are required to be submitted. PoP is required to prevent [rogue key attack](https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html).

The proof of possession is a BLS signature created using the authority's protocol private key, committed over the following message: `intent || pubkey || address || epoch`. Here `intent` is serialized to `[5, 0, 0]` representing an intent with scope as "Proof of Possession", version as "V0" and app_id as "Sui". `pubkey` is the serialized public key bytes of the authority's BLS protocol key. `address` is the account address associated with the authority's account key. `epoch` is serialized to `[0, 0, 0, 0, 0, 0, 0, 0]`.

To generate a proof of possession in Rust, see implementation at `fn generate_proof_of_possession`. For test vectors, see `fn test_proof_of_possession`.

# Implementation

1. [Struct and enum definitions](https://github.com/MystenLabs/sui/blob/0dc1a38f800fc2d8fabe11477fdef702058cf00d/crates/sui-types/src/intent.rs)
2. [Test](https://github.com/MystenLabs/sui/blob/d009e82fa35bda4f2b3e7a86a9529d36c32a8159/crates/sui-types/src/unit_tests/intent_tests.rs)
3. User transaction intent signing [PR 1](https://github.com/MystenLabs/sui/pull/6445), [PR 2](https://github.com/MystenLabs/sui/pull/8321)
4. Authority intent signing [PR 1](https://github.com/MystenLabs/sui/pull/8154), [PR 2](https://github.com/MystenLabs/sui/pull/8726)

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/transaction-auth/signatures.mdx
```
---
title: Signatures
description: Sui supports multiple cryptography algorithms and primitives and can switch between them rapidly.
---

When a user submits a signed transaction, a serialized signature and a serialized transaction data is submitted. The serialized transaction data is the BCS serialized bytes of the struct `TransactionData` and the serialized signature is defined as a concatenation of bytes of `flag || sig || pk`.

The `flag` is a 1-byte representation corresponding to the signature scheme that the signer chooses. The following table lists each signing scheme and its corresponding flag:

| Scheme          | Flag |
| --------------- | ---- |
| Ed25519 Pure    | 0x00 |
| ECDSA Secp256k1 | 0x01 |
| ECDSA Secp256r1 | 0x02 |
| multisig        | 0x03 |
| zkLogin         | 0x05 |
| passkey         | 0x06 |

The `sig` bytes are the compressed bytes representation of the signature instead of DER encoding. The following table lists the expected size of each format:

| Scheme          | Signature                                                                                      |
| --------------- | -----------------------------------------------------------------------------------------------|
| Pure Ed25519    | Compressed, 64 bytes                                                                           |
| ECDSA Secp256k1 | Non-recoverable, compressed, 64 bytes                                                          |
| ECDSA Secp256r1 | Non-recoverable, compressed, 64 bytes                                                          |
| multisig        | BCS serialized all signatures, size varies                                                     |
| zkLogin         | BCS serialized zkLogin inputs, max epoch and ephemeral signature, size varies                  |
| passkey         | BCS serialized passkey inputs (authenticatorData, clientDataJson, userSignature), size varies  |

The `pk` bytes are the bytes representation of the public key corresponding to the signature.

| Scheme          | Public key                                                                           |
| --------------- | ------------------------------------------------------------------------------------ |
| Pure Ed25519    | Compressed, 32 bytes                                                                 |
| ECDSA Secp256k1 | Compressed, 33 bytes                                                                 |
| ECDSA Secp256r1 | Compressed, 33 bytes                                                                 |
| multisig        | BCS serialized all participating public keys, size varies                            |
| zkLogin         | Concatenation of iss length, iss bytes, address seed padded to 32-bytes, size varies |
| passkey         | Compressed, 33 bytes                                                                 |

## Signature requirements {#signature-requirements}

The signature must commit to the hash of the intent message of the transaction data, which you can construct by appending the 3-byte intent before the BCS serialized transaction data. To learn more on what an intent is and how to construct an intent message, see [Sui Intent Signing](intent-signing.mdx).

When invoking the signing API, you must first hash the intent message of the transaction data to 32 bytes using Blake2b. This external hashing is distinct from the hashing performed inside the signing API. To be compatible with existing standards and hardware secure modules (HSMs), the signing algorithms perform additional hashing internally. For ECDSA Secp256k1 and Secp256r1, you must use SHA-2 SHA256 as the internal hash function. For pure Ed25519, you must use SHA-512.

An accepted ECDSA secp256k1 and secp256r1 signature must follow:

1. The internal hash used by ECDSA must be SHA256 [SHA-2](https://en.wikipedia.org/wiki/SHA-2) hash of the transaction data. Sui uses SHA256 because it is supported by [Apple](https://developer.apple.com/forums/thread/89619), HSMs, and [cloud](https://developer.apple.com/forums/thread/89619), and it is widely adopted by [Bitcoin](https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm).
1. The signature must be of length 64 bytes in the form of `[r, s]` where the first 32 bytes are `r`, the second 32 bytes are `s`.
1. The `r` value can be between `0x1` and `0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364140` (inclusive).
1. The `s` value must be in the lower half of the curve order. If the signature is too high, convert it to a lower `s` according to [BIP-0062](https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#low-s-values-in-signatures) with the corresponding curve orders using `order - s`. For secp256k1, the curve order is `0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141`. For secp256r1, the curve order is `0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551` defined in [Standards for Efficient Cryptography](https://secg.org/SEC2-Ver-1.0.pdf).
1. Ideally, the signature must be generated with deterministic nonce according to [RFC6979](https://www.rfc-editor.org/rfc/rfc6979).

An accepted pure Ed25519 signature must follow:

1. The signature must be produced according to [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html#section-5.1.6). The internal hash used is SHA-512.
1. The signature must be valid according to [ZIP215](https://github.com/zcash/zips/blob/main/zip-0215.rst).

See a concrete example for offline signing using CLI in the [Offline Signing](../transaction-auth/offline-signing.mdx) topic.

For more on zkLogin signature, see [zkLogin](../zklogin.mdx).

For more on passkey signature, see [SIP-8](https://github.com/sui-foundation/sips/blob/main/sips/sip-9.md).

## Authority signature

The Authority on Sui (collection of validators) holds three distinctive keypairs:

1.  [Protocol key pair](#protocol-pair)
1.  [Account key pair](#account-pair)
1.  [Network key pair](#network-pair)

### Protocol key pair {#protocol-pair}

The protocol key pair provides authority signatures on user-signed transactions if they are verified. When a stake of the authorities that provide signatures on user transactions passes the required two-thirds threshold, Sui executes the transaction. Sui uses the BLS12381 scheme for its fast verification on aggregated signatures for a given number of authorities. In particular, Sui uses the minSig BLS mode, where each individual public key is 96 bytes, while the signature is 48 bytes. The latter is important as typically validators register their keys once at the beginning of each epoch and then they continuously sign transactions; thus, we optimize on minimum signature size.

As with the BLS scheme, you can aggregate independent signatures resulting in a single BLS signature payload. Sui also accompanies the aggregated signature with a bitmap to denote which of the validators signed. This effectively reduces the authorities' signature size from (2f + 1) × `BLS_sig` size to just one `BLS_sig` payload, which in turn has significant network cost benefits resulting in compressed transaction certificates independently on the validators set size.

To counter potential rogue key attacks on BLS12381 aggregated signatures, proof of knowledge of the secret key (KOSK) is used during authority registration. When an authority requests to be added to the validator set, a proof of possession is submitted and verified. See [Intent Signing](../transaction-auth/intent-signing.mdx) on how to create a proof of possession. Unlike most standards, the Sui proof of knowledge scheme commits to the address as well, which offers an extra protection against adversarial reuse of a validator's BLS key from another malicious validator.

### Account key pair {#account-pair}

The account that the authority uses to receive payments on staking rewards is secured by the account key pair. Sui uses pure Ed25519 as the signing scheme.

### Network key pair {#network-pair}

The private key is used to perform the TLS handshake required for consensus networking. The public key is used for validator identity. Pure Ed25519 is used as the scheme.

See more authority key toolings in [Validator Tool](https://github.com/MystenLabs/sui/blob/f8b5ad9aaecc3c4b30a060ec5e00bdad9ba75a93/nre/validator_tool.md).

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/cryptography/transaction-auth/offline-signing.mdx
```
---
title: Offline Signing
---

Sui supports offline signing, which is signing transactions using a device not connected to a Sui network, or in a wallet implemented in a different programming language without relying on the Sui key store. The steps to implement offline signing include:

1. Serialize the data for signing.
1. Sign the serialized data. Put the serialized data in a location to sign (such as the wallet of your choice, or tools in other programming languages) and to produce a signature with the corresponding public key.
1. Execute the signed transaction.

## Serialize data for a transfer {#serialize}

You must serialize transaction data following [Binary Canonical Serialization](https://crates.io/crates/bcs) (BCS). It is supported in other languages.

The following example demonstrates how to serialize data for a transfer using the [Sui CLI](/references/cli.mdx). This returns serialized transaction data in Base64. Submit the raw transaction to execute as `tx_bytes`.

{@include: ../../../snippets/info-gas-budget.mdx}

```sh
$ sui client transfer-sui --to <SUI-ADDRESS> --sui-coin-object-id <COIN-OBJECT-ID> --gas-budget <GAS-AMOUNT> --serialize-unsigned-transaction
```

The console responds with the resulting `<TX_BYTES>` value.


:::tip

All other CLI commands that craft a transaction (such as `sui client publish` and `sui client call`) also accept the `--serialize-unsigned-transaction` flag used in the same way.

:::

## Sign the serialized data {#sign}

You can sign the data using the device and programming language you choose. Sui accepts signatures for pure Ed25519, ECDSA secp256k1, ECDSA secp256r1 and native multisig. To learn more about the requirements of the signatures, see [Sui Signatures](./signatures.mdx).

This example uses the `sui keytool` command to sign, using the Ed25519 key corresponding to the provided address stored in `sui.keystore`. This command outputs the signature, the public key, and the flag encoded in Base64. This command is backed by fastcrypto.
`sui keytool sign --address <SUI-ADDRESS> --data <TX_BYTES>`

You receive the following response:

```sh
Signer address: <SUI-ADDRESS>
Raw tx_bytes to execute: <TX_BYTES>
Intent: Intent { scope: TransactionData, version: V0, app_id: Sui }
Raw intent message: <INTENT-MESSAGE>
Digest to sign: <DIGEST>
Serialized signature (`flag || sig || pk` in Base64): <SERIALIZED-SIGNATURE>
```

To ensure the signature produced offline matches with Sui validity rules for testing purposes, you can import the mnemonics to `sui.keystore` using `sui keytool import`. You can then sign with it using `sui keytool sign` and then compare the signature results. Additionally, you can find test vectors in `~/sui/sdk/typescript/test/e2e/raw-signer.test.ts`.

To verify a signature against the cryptography library backing Sui when debugging, see [sigs-cli](https://github.com/MystenLabs/fastcrypto/blob/4cf71bd8b3a373495beeb77ce81c27827516c218/fastcrypto-cli/src/sigs_cli.rs).

## Execute the signed transaction {#execute}

After you obtain the serialized signature, you can submit it using the execution transaction command. This command takes `--tx-bytes` as the raw transaction bytes to execute (see output of the previous `sui client transfer` command) and the serialized signature (Base64 encoded `flag || sig || pk`, see output of `sui keytool sign`). This executes the signed transaction and returns the certificate and transaction effects if successful.

```sh
$ sui client execute-signed-tx --tx-bytes <TX_BYTES> --signatures <SERIALIZED-SIGNATURE>
```

You get the following response:

```sh
----- Certificate ----
Transaction Hash: <TRANSACTION-ID>
Transaction Signature: <SIGNATURE>
Signed Authorities Bitmap: RoaringBitmap<[0, 1, 3]>
Transaction Kind : Transfer SUI
Recipient : <SUI-ADDRESS>
Amount: Full Balance

----- Transaction Effects ----
Status : Success
Mutated Objects:
 - ID: <OBJECT_ID> , Owner: Account Address ( <SUI-ADDRESS> )
```

## Alternative: Sign with Sui Keystore and Execute Transaction

Alternatively, you can use the active key in Sui Keystore to sign and output a Base64-encoded sender signed data with flag `--serialize-signed-transaction`. 

```sh
$ sui client transfer-sui --to <SUI-ADDRESS> --sui-coin-object-id <COIN-OBJECT-ID> --gas-budget <GAS-AMOUNT> --serialize-signed-transaction
```

The console responds with the resulting `<SIGNED-TX-BYTES>` value.

After you obtain the signed transaction bytes, you can submit it using the `execute-combined-signed-tx` command. This command takes `--signed-tx-bytes` as the signed transaction bytes to execute (see output of the previous `sui client transfer-sui` command). This executes the signed transaction and returns the certificate and transaction effects if successful.

```sh
$ sui client execute-combined-signed-tx --signed-tx-bytes <SIGNED-TX-BYTES>
```
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/dynamic-fields/tables-bags.mdx
```
---
title: Table and Bag
description: Sui provides `Table` and `Bag` collections built using dynamic fields, but with additional support to count the number of entries they contain to protect against accidental deletion when non-empty.
---

You can extend existing objects using [dynamic fields](../dynamic-fields.mdx). Note that it's possible to delete an object that still has (potentially non-drop) dynamic fields. This might not be a concern when adding a small number of statically known additional fields to an object, but is particularly undesirable for on-chain collection types that could be holding unboundedly many key-value pairs as dynamic fields.

This topic describes two such collections -- Table and Bag -- built using dynamic fields, but with additional support to count the number of entries they contain, and protect against accidental deletion when non-empty.

The types and function discussed in this section are built into the Sui framework in modules [`table`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/table.move) and [`bag`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/bag.move). As with dynamic fields, there is also an `object_` variant of both: `ObjectTable` in [`object_table`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/object_table.move) and `ObjectBag` in [`object_bag`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/object_bag.move). The relationship between `Table` and `ObjectTable`, and `Bag` and `ObjectBag` is the same as between a field and an object field: The former can hold any `store` type as a value, but objects stored as values are hidden when viewed from external storage. The latter can only store objects as values, but keeps those objects visible at their ID in external storage.


### Tables

```move
module sui::table;

public struct Table<K: copy + drop + store, V: store> has key, store { /* ... */ }

public fun new<K: copy + drop + store, V: store>(
    ctx: &mut TxContext,
): Table<K, V>;
```

`Table<K, V>` is a *homogeneous* map, meaning that all its keys have the same type as each other (`K`), and all its values have the same type as each other as well (`V`). It is created with `sui::table::new`, which requires access to a `&mut TxContext` because `Table`s are objects themselves, which can be transferred, shared, wrapped, or unwrapped, just like any other object.

See `sui::object_table::ObjectTable` for the object-preserving version of `Table`.

### Bags

```move
module sui::bag;

public struct Bag has key, store { /* ... */ }

public fun new(ctx: &mut TxContext): Bag;
```

`Bag` is a *heterogeneous* map, so it can hold key-value pairs of arbitrary types (they don't need to match each other). Note that the `Bag` type does not have any type parameters for this reason. Like `Table`, `Bag` is also an object, so creating one with `sui::bag::new` requires supplying a `&mut TxContext` to generate an ID.

See `sui::bag::ObjectBag` for the object-preserving version of `Bag`.

---

The following sections explain the collection APIs. They use `sui::table` as the basis for code examples, with explanations where other modules differ.

### Interacting with collections

All collection types come with the following functions, defined in their respective modules:

```move
module sui::table;

public fun add<K: copy + drop + store, V: store>(
    table: &mut Table<K, V>,
    k: K,
    v: V,
);

public fun borrow<K: copy + drop + store, V: store>(
    table: &Table<K, V>,
    k: K
): &V;

public fun borrow_mut<K: copy + drop + store, V: store>(
    table: &mut Table<K, V>,
    k: K
): &mut V;

public fun remove<K: copy + drop + store, V: store>(
    table: &mut Table<K, V>,
    k: K,
): V;
```

These functions add, read, write, and remove entries from the collection, respectively, and all accept keys by value. `Table` has type parameters for `K` and `V` so it is not possible to call these functions with different instantiations of `K` and `V` on the same instance of `Table`, however `Bag` does not have these type parameters, and so does permit calls with different instantiations on the same instance.

:::info

Like with dynamic fields, it is an error to attempt to overwrite an existing key, or access or remove a non-existent key.

:::

The extra flexibility of `Bag`'s heterogeneity means the type system doesn't statically prevent attempts to add a value with one type, and then borrow or remove it at another type. This pattern fails at runtime, similar to the behavior for dynamic fields.

### Querying length

It is possible to query all collection types for their length and check whether they are empty using the following family of functions:

```move
module sui::table;

public fun length<K: copy + drop + store, V: store>(
    table: &Table<K, V>,
): u64;

public fun is_empty<K: copy + drop + store, V: store>(
    table: &Table<K, V>
): bool;
```

`Bag` has these functions, but they are not generic on `K` and `V` because `Bag` does not have these type parameters.

### Querying for containment

Tables can be queried for key containment with:

```move
module sui::table;

public fun contains<K: copy + drop + store, V: store>(
    table: &Table<K, V>
    k: K
): bool;
```

The equivalent functions for `Bag` are:

```move
module sui::bag;

public fun contains<K: copy + drop + store>(bag: &Bag, k: K): bool;

public fun contains_with_type<K: copy + drop + store, V: store>(
    bag: &Bag,
    k: K
): bool;
```

The first function tests whether `bag` contains a key-value pair with key `k: K`, and the second function additionally tests whether its value has type `V`.

### Clean-up

Collection types protect against accidental deletion when they might not be empty. This protection comes from the fact that they do not have `drop`, so must be explicitly deleted, using this API:

```move
module sui::table;

public fun destroy_empty<K: copy + drop + store, V: store>(
    table: Table<K, V>,
);
```

This function takes the collection by value. If it contains no entries, it is deleted, otherwise the call fails. `sui::table::Table` also has a convenience function:

```move
module sui::table;

public fun drop<K: copy + drop + store, V: drop + store>(
    table: Table<K, V>,
);
```

You can call the convenience function only for tables where the value type also has `drop` ability, which allows it to delete tables whether they are empty or not.

Note that `drop` is not called implicitly on eligible tables before they go out of scope. It must be called explicitly, but it is guaranteed to succeed at runtime.

`Bag` and `ObjectBag` cannot support `drop` because they could be holding a variety of types, some of which may have `drop` and some which may not.

`ObjectTable` does not support `drop` because its values must be objects, which cannot be dropped (because they must contain an `id: UID` field and `UID` does not have `drop`).

### Equality

Equality on collections is based on identity, for example, an instance of a collection type is only considered equal to itself and not to all collections that hold the same entries:

```move
use sui::table;

let t1 = table::new<u64, u64>(ctx);
let t2 = table::new<u64, u64>(ctx);

assert!(&t1 == &t1, 0);
assert!(&t1 != &t2, 1);
```

This is unlikely to be the definition of equality that you want.

## Related links

- [Dynamic Collections](https://move-book.com/programmability/dynamic-collections.html) in The Move Book: The Move Book is a comprehensive guide to the Move programming language and the Sui blockchain. This page explores using dynamic collections, including tables and bags, in your Move development.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/transfers/transfer-to-object.mdx
```
---
title: Transfer to Object
description: On Sui, you can transfer objects to objects in the same way you can transfer objects to addresses.
---

You can transfer objects to an object ID in the same way you transfer objects to an address, using the same functions. This is because Sui does not distinguish between the 32-byte ID of an address and the 32-byte ID of an object (which are guaranteed not to overlap). The transfer to object operation takes advantage of this feature, allowing you to provide an object ID as the address input of a transfer operation.

Because of the identical ID structure, you can use an object ID for the address field when transferring an object. In fact, all functionality around address-owned objects works the same for objects owned by other objects, you just replace the address with the object ID.

When you transfer an object to another object, you're basically establishing a form of parent-child authentication relationship. Objects that you have transferred to another object can be received by the (possibly transitive) owner of the parent object. The module that defines the type of the parent (receiving) object also defines the access control for receiving a child object.

These restrictions for accessing sent child objects are enforced dynamically by providing mutable access to the parent object's `UID` during the execution of the transaction. Because of this, you can transfer objects to and receive them from owned objects, dynamic field objects, wrapped objects, and shared objects.

One of the benefits of the transfer to object operation is the ability to have a stable ID for an on-chain wallet or account, for example. The transfer of the object doesn't affect its ID, regardless of the state of the object that you send it to. When you transfer an object, all of that object's child objects move with it, and the object's address remains the same whether you transfer it, wrap it, or hold it as a dynamic field.

## Transferring to object

Just like with normal object transfers, you must make sure that the object ID exists that you are transferring the object to. Additionally, make sure that the object that you are transferring to is not immutable. You can't access an object transferred to an immutable object.

Be aware of both the type of the object you are transferring to and the object that is being transferred. The object that is transferred to (parent) can _always_:

- Define predicates that can be dynamically checked to access the sent object.
- Lack support for accessing objects that have been sent to it. Future versions of that package might support this functionality, but it's up to the package author to include it.

If the object being transferred has the `key` ability only, then:

- The module that defines the object that is being transferred must implement a custom receive function for it, similar to custom transfer functions. Just as with custom transfer functions, a custom receivership function might have arbitrary restrictions they can enforce and that you should be aware of, or they may not exist.
- After sending, you can't access or use the object unless the parent object's (object being sent to) module has defined a function to receive objects _and_ the child object's (object you're sending) module has defined a function to receive the object, and the restrictions that _both_ functions define are met.

```move
// 0xADD is an address
// 0x0B is an object ID
// b and c are objects

// Transfers the object `b` to the address 0xADD
transfer::public_transfer(b, @0xADD);

// Transfers the object `c` to the object with object ID 0x0B
transfer::public_transfer(c, @0x0B);
```

Transferring an object to an object ID results in the same result as if you transferred the object to an address - the object's owner is the 32-byte address or object ID provided. Additionally, because there is no difference in the result of the object transfer, you can use existing RPC methods such as `getOwnedObjects` on the 32-byte ID. If the ID represents an address, then the method returns the objects owned by that address. If the ID is an object ID, then the method returns the objects the object ID owns (transferred objects).

```json
// Get the objects owned by the address 0xADD. Returns `b`.
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_getOwnedObjects",
  "params": [
    "0xADD"
  ]
}

// Get the objects owned by the object with object ID 0x0B. Returns `c`
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_getOwnedObjects",
  "params": [
    "0x0B"
  ]
}
```

## Receiving objects

After an object `c` has been sent to another object `p`, `p` must then receive `c` to do anything with it. To receive the object `c`, a `Receiving(o: ObjectRef)` argument type for programmable transaction blocks (PTBs) is used that takes an object reference containing the to-be-received object's `ObjectID`, `Version`, and `Digest` (just as owned object arguments for PTBs do). However, `Receiving` PTB arguments are not passed as an owned value or mutable reference within the transaction.

To explain further, look at the core of the receiving interface in Move, which is defined in the `transfer` module in the Sui framework:

```move
module sui::transfer;

/// Represents the ability to receive an object of type `T`. Cannot be stored.
public struct Receiving<phantom T: key> has drop { ... }

/// Given mutable (i.e., locked) access to the `parent` and a `Receiving`
/// object referencing an object owned by `parent` use the `Receiving` ticket
/// and return the corresponding object.
///
/// This function has custom rules that the Sui Move bytecode verifier enforces to ensure
/// that `T` is an object defined in the module where `receive` is invoked. Use
/// `public_receive` to receive an object with `store` outside of its defining module.
///
/// NB: &mut UID here allows the defining module of the parent type to
/// define custom access/permission policies around receiving objects sent
/// to objects of a type that it defines. You can see this more in the examples.
public native fun receive<T: key>(parent: &mut UID, object: Receiving<T>): T;

/// Given mutable (locked) access to the `parent` and a `Receiving` argument
/// referencing an object of type `T` owned by `parent` use the `object`
/// argument to receive and return the referenced owned object of type `T`.
/// The object `T` must have `store` to be received by this function, and
/// this can be called outside of the module that defines `T`.
public native fun public_receive<T: key + store>(parent: &mut UID, object: Receiving<T>): T;

...
```

Each Receiving argument referring to a sent object of type `T` in a PTB results in exactly one argument with a Move type of `sui::transfer::Receiving<T>`. You can then use this argument to receive the sent object of type `T` with the `transfer::receive` function.

When you call the `transfer::receive` function, you must pass a mutable reference to the parent object's `UID`. You can't get a mutable reference to the `UID` of an object, though, unless the defining module of the object exposes it. Consequently, the module that defines the type of the parent object that is receiving the child object defines access control policies and other restrictions on receiving objects that are sent to it. See the [authorization example](#receive-shared-example) for a demonstration of this pattern. The fact that the passed-in `UID` actually owns the object referenced by the `Receiving` parameter is dynamically checked and enforced. This allows access to objects that have been sent to, for example, dynamic fields where the ownership chain can only be established dynamically.

Because `sui::transfer::Receiving` has only the `drop` ability, the existence of a `Receiving<T>` argument represents the ability, but not the obligation to receive the object of type `T` specified by the object reference in the PTB `Receiving` argument during that transaction. You can use some, none, or all `Receiving` arguments in a PTB without issue. Any object that corresponds to a `Receiving` argument remains untouched (in particular, its object reference remain the same) unless it is received.

## Custom receiving rules

Just like with [custom transfer policies](./custom-rules.mdx), Sui allows for the definition of custom receivership rules for `key`-only objects. In particular, you can use the `transfer::receive` function only on objects defined in the same module as the call to `transfer::receive`--just like you can use the `transfer::transfer` function only on objects defined in the module where it's being used.

Similarly for objects that also have the `store` ability, anyone can use the `transfer::public_receive` function to receive them--just like `transfer::public_transfer` can transfer any objects that have the `store` ability on them.

This coupled with the fact that the parent object can always define custom rules around receivership means that you must consider the following matrix of permissions around receiving objects and the abilities of the object being sent based on the child object's abilities:

| Child abilities | Parent can restrict access | Child can restrict access |
| --------------- | -------------------------- | ------------------------- |
| `key`           | Yes                        | Yes                       |
| `key` + `store` | Yes                        | No                        |

Just like with custom transfer policies, you can use and couple these restrictions to create powerful expressions. For example, you can implement [soul-bound objects](#soul-bound-example) using both custom transfer and receivership rules.

## Using SDKs

When creating transactions, you interact with `Receiving` transaction inputs almost exactly as you would with other object arguments in the Sui TypeScript SDK. For example, if in the [Simple Account](#simple-account) example that follows you want to send a transaction that receives a coin object with ID `0xc0ffee` that was sent to your account at `0xcafe`, you can do the following using either the Sui TypeScript SDK or Sui Rust SDK:

<Tabs groupId="code-language">

<TabItem label="TypeScript" value="typescript">

```ts
... // Setup Typescript SDK as normal.
const tx = new Transaction();
tx.moveCall({
  target: `${examplePackageId}::account::accept_payment`,
  arguments: [tx.object("0xcafe"), tx.object("0xc0ffee")]
});
const result = await client.signAndExecuteTransaction({
      transaction: tx,
  });
...
```

</TabItem>

<TabItem label="Rust" value="rust">

```rust
... // setup Rust SDK client as normal
client
  .transaction_builder()
  .move_call(
     sending_account,
     example_package_id,
     "account",
     "accept_payment",
     vec!["0x2::sui::SUI"],
     vec![
       SuiJsonValue::from_object_id("0xcafe"),
       SuiJsonValue::from_object_id("0xc0ffee") // 0xcoffee is turned into the `Receiving<...>` argument of `accept_payment` by the SDK
     ])
  ...
```

</TabItem>

</Tabs>

Additionally, just as with object arguments that also have an `ObjectRef` constructor where you can provide an explicit object ID, version, and digest, there is also a `ReceivingRef` constructor that takes the same arguments corresponding to a receiving argument.

## Examples

The following examples demonstrate receiving previously sent objects.

### Receiving objects from shared objects {#receive-shared-example}

Generally, if you want to allow receiving sent objects from shared objects that are defined in the module, add dynamic authorization checks; otherwise, anyone could receive sent objects. In this example, a shared object (`SharedObject`) holds a counter that anyone can increment, but only the address `0xB0B` can receive objects from the shared object.

Because the `receive_object` function is generic over the object being received, it can only receive objects that are both `key` and `store`. `receive_object` must also use the `transfer::public_receive` function to receive the object and not `transfer::receive` because you can only use `receive` on objects defined in the current module.

```move
module examples::shared_object_auth;

use transfer::Receiving;

const EAccessDenied: u64 = 0;
const AuthorizedReceiverAddr: address = @0xB0B;

public struct SharedObject has key {
    id: UID,
    counter: u64,
}

public fun create(ctx: &mut TxContext) {
    let s = SharedObject {
        id: object::new(ctx),
        counter: 0,
    };
    transfer::share_object(s);
}

/// Anyone can increment the counter in the shared object.
public fun increment(obj: &mut SharedObject) {
    obj.counter = obj.counter + 1;
}

/// Objects can only be received from the `SharedObject` by the
/// `AuthorizedReceiverAddr` otherwise the transaction aborts.
public fun receive_object<T: key + store>(
    obj: &mut SharedObject,
    sent: Receiving<T>,
    ctx: &TxContext
): T {
    assert!(ctx.sender() == AuthorizedReceiverAddr, EAccessDenied);
    transfer::public_receive(&mut obj.id, sent)
}
```

### Receiving objects and adding them as dynamic fields {#simple-account}

This example defines a basic account-type model where an `Account` object holds its coin balances in different dynamic fields. This `Account` is also transferable to a different address or object.

Importantly, the address that coins are to be sent with this `Account` object remains the same regardless of whether the `Account` object is transferred, wrapped (for example, in an escrow account), or moved into a dynamic field. In particular, there is a stable ID for a given `Account` object across the object's lifecycle, regardless of any ownership changes.

```move
module examples::account;

use sui::dynamic_field as df;
use sui::coin::{Self, Coin};
use transfer::Receiving;

const EBalanceDONE: u64 = 1;

/// Account object that `Coin`s can be sent to. Balances of different types
/// are held as dynamic fields indexed by the `Coin` type's `type_name`.
public struct Account has key {
    id: UID,
}

/// Dynamic field key representing a balance of a particular coin type.
public struct AccountBalance<phantom T> has copy, drop, store { }

/// This function will receive a coin sent to the `Account` object and then
/// join it to the balance for each coin type.
/// Dynamic fields are used to index the balances by their coin type.
public fun accept_payment<T>(account: &mut Account, sent: Receiving<Coin<T>>) {
    // Receive the coin that was sent to the `account` object
    // Since `Coin` is not defined in this module, and since it has the `store`
    // ability we receive the coin object using the `transfer::public_receive` function.
    let coin = transfer::public_receive(&mut account.id, sent);
    let account_balance_type = AccountBalance<T>{};
    let account_uid = &mut account.id;

    // Check if a balance of that coin type already exists.
    // If it does then merge the coin we just received into it,
    // otherwise create new balance.
    if (df::exists_(account_uid, account_balance_type)) {
        let balance: &mut Coin<T> = df::borrow_mut(account_uid, account_balance_type);
        balance.join(coin);
    } else {
        df::add(account_uid, account_balance_type, coin);
    }
}

/// Withdraw `amount` of coins of type `T` from `account`.
public fun withdraw<T>(account: &mut Account, amount: u64, ctx: &mut TxContext): Coin<T> {
    let account_balance_type = AccountBalance<T>{};
    let account_uid = &mut account.id;
    // Make sure what we are withdrawing exists
    assert!(df::exists_(account_uid, account_balance_type), EBalanceDONE);
    let balance: &mut Coin<T> = df::borrow_mut(account_uid, account_balance_type);
    balance.split(amount, ctx)
}

/// Can transfer this account to a different address
/// (e.g., to an object or address).
public fun transfer_account(account: Account, to: address, _ctx: &mut TxContext) {
    // Perform some authorization checks here and if they pass then transfer the account
    // ...
    transfer::transfer(account, to);
}
```

### Soul-bound objects {#soul-bound-example}

The ability to control the rules about how and when an object can be received, and how and when it can be transferred allows us to define a type of "soul-bound" object that can be used by value in a transaction, but it must always stay in the same place, or be returned to the same object.

You can implement a simple version of this with the following module where the `get_object` function receives the soul-bound object and creates a receipt that must be destroyed in the transaction in order for it to execute successfully. However, in order to destroy the receipt, the object that was received must be transferred back to the object it was received from in the transaction using the `return_object` function.

```move
module examples::soul_bound;

use transfer::{Self, Receiving};

/// Tried to return the wrong object.
const EWrongObject: u64 = 0;

/// This object has `key` only  -- if this had `store` we would not be
/// able to ensure it is bound to whatever address we sent it to
public struct SoulBound has key {
    id: UID,
}

/// A non-store, non-drop, non-copy struct. When you receive a `SoulBound`
/// object, we'll also give you one of these. In order to successfully
/// execute the transaction you need to destroy this `ReturnReceipt` and
/// the only way to do that is to transfer it back to the same object you
/// received it from in the transaction using the `return_object` function.
public struct ReturnReceipt {
    /// The object ID of the object that needs to be returned.
    /// This field is required to prevent swapping of soul bound objects if
    /// multiple are present in the same transaction.
    object_id: ID,
    /// The address (object ID) it needs to be returned to.
    return_to: address,
}

/// Takes the object UID that owns the `SoulBound` object and a `SoulBound`
/// receiving ticket. It then receives the `SoulBound` object and returns a
/// `ReturnReceipt` that must be destroyed in the transaction by calling `return_object`.
public fun get_object(parent: &mut UID, soul_bound_ticket: Receiving<SoulBound>): (SoulBound, ReturnReceipt) {
    let soul_bound = transfer::receive(parent, soul_bound_ticket);
    let return_receipt = ReturnReceipt {
        return_to: parent.to_address(),
        object_id: object::id(&soul_bound),
    };
    (soul_bound, return_receipt)
}

/// Given a `SoulBound` object and a return receipt returns it to the
/// object it was received from. Verifies that the `receipt`
/// is for the given `soul_bound` object before returning it.
public fun return_object(soul_bound: SoulBound, receipt: ReturnReceipt) {
    let ReturnReceipt { return_to, object_id }  = receipt;
    assert!(object::id(&soul_bound) == object_id, EWrongObject);
    transfer::transfer(soul_bound, return_to);
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/transfers/custom-rules.mdx
```
---
title: Custom Transfer Rules
description: Custom transfer rules enable you to define a set of rules that must be met before Sui considers a transfer operation valid.
---

Every Sui object must have the `key` ability. The `store` ability, on the other hand, is an optional ability you can add to Sui objects. Objects with the `store` ability:

- are transferable by anyone using the `transfer::public_transfer` function; and
- are able to be wrapped in other objects.

Importantly for custom transfer rules, if the Sui object `Object` does not have the `store` ability, you cannot call the `sui::transfer::public_transfer` function to transfer it. The Move module that defines `Object` is the only entity that can transfer objects of that type using the `sui::transfer::transfer` function. Consequently, the module that defines the object `Object` can define a custom transfer function for `Object` that can take any number of arguments, and enforce any restrictions desired for performing a transfer operation (for example, a fee must be paid in order to transfer the object).

## The store ability and transfer rules

Custom transfer rules for objects enable you to define the transfer conditions that must be met for a valid transfer operation. You should be intentional about adding the `store` ability to an object because you are providing unrestricted access to that object without having to go through the module that defines it. After you enable public transfers on an object, there is no way of re-enabling custom transfer rules or any type of restrictions regarding the transfer of the object.

## Example

This example creates an object type `Object` that is transferrable only if the `unlocked` flag inside of it is set to `true`:

```move
public struct Object has key {
    id: UID,
    // An `Object` object can only be transferred if this field is `true`
    unlocked: bool,
}
```

Within the same module that defines the object `Object`, you can then define a custom transfer rule `transfer_unlocked` for `Object` that takes the object to transfer and the address to transfer it to, and verifies that the object is unlocked before transferring it to the specified address.

```move
module examples::custom_transfer;

// Error code for trying to transfer a locked object
const EObjectLocked: u64 = 0;

public struct Object has key {
    id: UID,
    // An `Object` object can only be transferred if this field is `true`
    unlocked: bool,
}

// Check that `Object` is unlocked before transferring it
public fun transfer_unlocked(object: Object, to: address) {
    assert!(object.unlocked, EObjectLocked);
    transfer::transfer(object, to)
}
```

With custom transfer rules, you can define multiple different transfer rules for the same object. Each of these rules might have different restrictions that execution of the transaction can dynamically enforce. So, if you wanted to allow only locked objects to be transferred to a specific address you could add the following function to the previous module:

```move
const EObjectNotLocked: u64 = 1;
const HOME_ADDRESS = @0xCAFE;

public fun transfer_locked(object: Object) {
    assert!(!object.unlocked, EObjectNotLocked);
    transfer::transfer(object, HOME_ADDRESS)
}
```

With these rules in place, there are two different custom transfer rules for any object `Object`: either it's unlocked and anyone can transfer it, or it's locked, and it can only be transferred to `0xCAFE`. Importantly, these two ways of transferring `Object` are the only ways of transferring any object of type `Object`. In particular, because `Object` does not have the `store` ability, you cannot transfer it using the `sui::transfer::public_transfer` function. In fact, the only ways of transferring `Object` are using `examples::custom_transfer::transfer_unlocked` and `examples::custom_transfer::transfer_locked`.

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/transactions/sponsored-transactions.mdx
```
---
title: Sponsored Transactions
---

A Sui sponsored transaction is one where a Sui address (the sponsor's) pays the gas fees for a transaction that another address (the user's) initializes. You can use sponsored transactions to cover the fees for users on your site or app so that they don't get charged for them. This removes a significant obstacle that web 2.0 users encounter when entering web3, as they often have to purchase tokens to perform a transaction on chain. For example, you could sponsor gamers' early transactions to increase conversion rates.

Sponsored transactions also facilitate asset management as you don't need to maintain multiple accounts with SUI tokens to transfer funds.

You can use Sui sponsored transactions to:
- Sponsor (pay gas fees for) a transaction a user initiates.
- Sponsor transactions you initiate as the sponsor.
- Provide a wildcard `GasData` object to users. The object covers the gas fees for a user transaction. The `GasData` object covers any fee amount determined for the transaction as long as the budget is sufficient.

## Potential risks using sponsored transactions

The most significant potential risk when using sponsored transactions is [equivocation](/references/sui-glossary.mdx#equivocation). In some cases under certain conditions, a sponsored transaction can result in all associated owned objects, including gas in a locked state when examined by Sui validators. To avoid double spending, validators lock objects as they validate transactions. An equivocation occurs when an owned object's pair (`ObjectID`, `SequenceNumber`) is concurrently used in multiple non-finalized transactions.

To equivocate, either the user or the sponsor signs and submits another transaction that attempts to manipulate an owned object in the original transaction. Because only the object owner can use an owned object, only the user and sponsor can cause this condition.

## Create a user-initiated sponsored transaction

A user-initiated sponsored transaction involves the following steps:

 1. A user initializes a `GasLessTransactionData` transaction.
 1. The user sends `GasLessTransactionData` to the sponsor.
 1. The sponsor validates the transaction, constructs `TransactionData` with gas fees, and then signs `TransactionData`.
 1. The sponsor sends the signed `TransactionData` and the sponsor `Signature` back to the user.
 1. The user verifies and then signs `TransactionData` and sends the dual-signed transaction to Sui network through a Full node or the sponsor.

### GasLessTransactionData

`GasLessTransactionData` is basically `TransactionData` without `GasData`. It is not a `sui-core` data structure, but it is only an interface between user and sponsor.

The following example constructs a `GasLessTransactionData`  object.

```rust
pub struct GasLessTransactionData {
    pub kind: TransactionKind,
    sender: SuiAddress,
    …
}
```

## Create a sponsor-initiated sponsored transaction  

A sponsor-initiated sponsored transaction involves the following steps:
 1. A sponsor constructs a `TransactionData` object that contains the transaction details and associated gas fee data. The sponsor signs it to generate a `Signature` before sending it to a user. You can send the unsigned `TransactionData` via email, SMS, or an application interface.
 1. The user checks the transaction and signs it to generate the second `Signature` for the transaction.
 1. The user submits the dual-signed transaction to a Sui Full node or sponsor to execute it.

You can use a sponsor-initiated sponsored transaction as an advertiser, or to incentivize specific user actions without requiring the user to pay for gas fees.

## Create sponsored transactions using a GasData object

To use a `GasData` object to sponsor the gas fees for a transaction, create a `GasData` object that covers the fees determined for the transaction. This is similar to providing a blank check to a user that can be used only to cover gas fees. The user doesn't need to know how much the fee is or approve it.

 A sponsor transaction using a `GasData` object involves the following steps:
 1. The sponsor provides a `GasData` object to a user.
 1. The user constructs `TransactionData` and signs it to generate a `Signature`.
 1. The user sends the `TransactionData` and the `Signature` to the sponsor.
 1. The sponsor confirms the `TransactionData` and then signs it.
 1. The sponsor submits the dual-signed `TransactionData` to a Full node to execute the transaction.

## Create a Sui gas station

On Sui, a gas station is a concept to describe where you set up processes to sponsor user transactions. You can customize a Sui gas station to support the specific user-facing functionality you need. Some example use cases for a Sui gas station include:

- Monitor real-time gas prices on the network to determine the gas price that the station provides.
- Track usage of gas provided to users on the network.
- Gas pool management, such as using specific gas objects to minimize costs or reduce the risk of a large amount of locked objects that remain illiquid while locked.

### Authorization and rate limiting

Depending on the nature of your gas station, you can apply different authorization rules to avoid being spammed by bad actors. Possible policies include:

- Rate limit gas requests per account or per IP address
- Only accept requests with a valid authorization header, which has separate rate limits

### Abuse detection

For all gas objects that you provide as a sponsor, you should track if users ever try to equivocate and lock objects. If you detect such behavior, block the user or requester accordingly.

## Code examples to create a Sui gas station

The following Rust SDK code examples demonstrate how to implement a Sui gas station that supports each of the sponsored transaction types described previously.

### User-initiated sponsored transactions

Use the API endpoint to receive `GaslessTransaction` transactions and return a sole-signed `SenderSignedData` object.

```rust
pub fn request_gas_and_signature(gasless_tx: GaslessTransaction) -> Result<SenderSignedData, Error>;
```

### Sponsored transactions with GasData objects

Use the API endpoint to receive sole-signed `SenderSignedData` and return the result of the transaction.

```rust
pub fn submit_sole_signed_transaction(sole_signed_data: SenderSignedData) -> Result<(Transaction, CertifiedTransactionEffects), Error>;
```

Alternatively, use the API endpoint to return a GasData object.

```rust
pub fn request_gas(/*requirement data*/) -> Result<GasData, Error>;
```

### User and sponsor-initiated transaction

Use the API endpoint to receive dual-signed `SenderSignedData` and return the result of the transaction.

```rust
pub fn submit_dual_signed_transaction(dual_signed_data: SenderSignedData) -> Result<(Transaction, CertifiedTransactionEffects), Error>;
```

For user and sponsor-initiated transactions, users can submit the dual-signed transaction via either a sponsor or a Full node.

## Sponsored transaction data structure

The following code block describes the `TransactionData` structure for sponsored transactions and `GasObject`. You can view the [source code](https://github.com/MystenLabs/sui/blob/224a28ed9dece21a952547896bd5d794bdf8b562/crates/sui-types/src/transaction.rs) in the Sui GitHub repository.

**`TransactionData` Structure**
```rust
#[derive(Debug, PartialEq, Eq, Hash, Clone, Serialize, Deserialize)]
pub struct TransactionDataV1 {
    pub kind: TransactionKind,
    pub sender: SuiAddress,
    pub gas_data: GasData,
    pub expiration: TransactionExpiration,
}
```

**`GasData` Structure**
```rust
#[derive(Debug, PartialEq, Eq, Hash, Clone, Serialize, Deserialize)]
pub struct GasData {
    pub payment: Vec<ObjectRef>,
    pub owner: SuiAddress,
    pub price: u64,
    pub budget: u64,
}
```

To learn more about transactions in Sui, see [Transactions](../transactions.mdx).

```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/transactions/gas-smashing.mdx
```
---
title: Gas Smashing
description: Sui optimizes coin management by combining multiple coins into a single object to pay for gas fees.
---

Every transaction on Sui has a gas fee associated with its execution that must be paid to successfully execute the transaction. Gas smashing enables you to pay for this gas fee using multiple coins instead of just one. This mechanism is especially helpful in scenarios where you might have a number of coins with smaller denominations, or if you simply want to minimize the number of SUI coins under your account. Gas smashing is generally a useful tool for coin management, especially when coupled with the `GasCoin` programmable transaction block (PTB) argument. 

## Smashing gas

Gas smashing happens automatically in a transaction if you provide multiple coins to pay for the gas fee. When Sui executes a transaction, Sui combines, or "smashes", all of the coins you provide to pay for the gas into a single coin. The smashing occurs regardless of coin amounts or the gas budget provided with the transaction (as long as it is within the minimum and maximum gas budgets). Sui deducts the gas fee from the single coin regardless of the execution status of the transaction. In particular, this means that even if the transaction fails to execute for some reason (such as an execution error) the coins that you provided as gas coins remain smashed after the transaction's execution.

Gas smashing is an efficient way to perform coin management, and to combine many smaller coins into one single coin that you can use to not only pay for gas fees, but also for other operations in the transaction that smashes the coins. In particular, you can use gas smashing to combine multiple coins to pay for the gas fee of the PTB, and then that same PTB can withdraw from the `GasCoin`. A special argument is available in PTBs that references the coin used to pay gas after Sui deducts the gas fee from it, which you can use to transfer the remaining SUI to another address. Because gas smashing happens automatically in a transaction if you provide multiple gas coins, you can combine multiple coins as part of other transactions to perform coin management in parallel with non-coin-management specific transactions.

Sui has a maximum of 256 coins that you can smash in a single PTB - the transaction is not processed if the number of gas coins exceeds this amount. Additionally, when you smash gas coins, Sui deletes all but the first coin. Because of this, there is often a storage rebate associated with the deletion of these coins. As with other storage rebates, you can't use the resulting refund to pay for the gas fee of the transaction (and isn't credited to the coin until after the execution of the transaction), but it might result in a refund after the execution of the transaction. This refund, along with the remaining balance after the transaction's gas fee, resides in the first gas coin you provide in the transaction after execution. 

## Running out of gas with a refund

Because coins are smashed regardless of the execution status, storage rebates can lead to seemingly odd cases where a transaction can both run out of gas and end up with a negative gas and storage fee (you get a refund from the transaction). As an example of how this might happen, take a transaction `T` that has a gas budget of `5000`, and you provide coins `C1`, `C2`, `C3`, `C4`, `C5` with values of `1000`, `2000`, `3000`, `4000`, and `5000` to pay for gas. If the storage rebate for a coin object is `2000`, and the gas fee for `T` execution is more than the provided gas budget of `5000` (so, `T` runs out of gas), this results in an execution status of `OutOfGas`. The `C1` coin has a balance of `1000` + `2000` + `3000` + `4000` + `5000` - `5000` + `2000` * `4` = `15000` - `5000` + `8000` = `18000` and `T` ends up with a negative gas and storage fee (a refund) of `3000`. 
```

../../Downloads/sui-stuff/sui-main/docs/content/concepts/transactions/prog-txn-blocks.mdx
```
---
title: Programmable Transaction Blocks
description: Programmable transaction blocks are a group of commands that complete a transaction on Sui.
---

On Sui, a transaction is more than a basic record of the flow of assets. Transactions on Sui are composed of a number of commands that execute on inputs to define the result of the transaction. Termed programmable transaction blocks (PTBs), these groups of commands define all user transactions on Sui. PTBs allow a user to call multiple Move functions, manage their objects, and manage their coins in a single transaction--without publishing a new Move package. Designed with automation and transaction builders in mind, PTBs are a lightweight and flexible way of generating transactions. More intricate programming patterns, such as loops, are not supported, however, and in those cases you must publish a new Move package.

As mentioned, each PTB is comprised of individual transaction commands (sometimes referred to simply as transactions or commands). Each transaction command executes in order, and you can use the results from one transaction command in any subsequent transaction command. The effects, specifically object modifications or transfers, of all transaction commands in a block are applied atomically at the end of the transaction. If one transaction command fails, the entire block fails and no effects from the commands are applied.

A PTB can perform up to 1,024 unique operations in a single execution, whereas transactions on traditional blockchains would require 1,024 individual executions to accomplish the same result. The structure also promotes cheaper gas fees. The cost of facilitating individual transactions is always more than the cost of those same transactions blocked together in a PTB.

The remainder of this topic covers the semantics of the execution of the transaction commands. It assumes familiarity with the Sui object model and the Move language. For more information on those topics, see the following documents:

- [Object model](../object-model.mdx)
- [Move Concepts](../sui-move-concepts.mdx)

## Transaction type

There are two parts of a PTB that are relevant to execution semantics. Other transaction information, such as the transaction sender or the gas limit, might be referenced but are out of scope. The structure of a PTB is:

```rust
{
    inputs: [Input],
    commands: [Command],
}
```

Looking closer at the two main components:

- The `inputs` value is a vector of arguments, `[Input]`. These arguments are either objects or pure values that you can use in the commands. The objects are either owned by the sender or are shared/immutable objects. The pure values represent simple Move values, such as `u64` or `String` values, which you can be construct purely from their bytes. For historical reasons, `Input` is `CallArg` in the Rust implementation.
- The `commands` value is a vector of commands, `[Command]`. The possible commands are:
  - `TransferObjects` sends multiple (one or more) objects to a specified address.
  - `SplitCoins` splits off multiple (one or more) coins from a single coin. It can be any `sui::coin::Coin<_>` object.
  - `MergeCoins` merges multiple (one or more) coins into a single coin. Any `sui::coin::Coin<_>` objects can be merged, as long as they are all of the same type.
  - `MakeMoveVec` creates a vector (potentially empty) of Move values. This is used primarily to construct vectors of Move values to be used as arguments to `MoveCall`.
  - `MoveCall` invokes either an `entry` or a `public` Move function in a published package.
  - `Publish` creates a new package and calls the `init` function of each module in the package.
  - `Upgrade` upgrades an existing package. The upgrade is gated by the `sui::package::UpgradeCap` for that package.

## Inputs and results

Inputs and results are the two types of values you can use in transaction commands. Inputs are the values that are provided to the PTB, and results are the values that are produced by the PTB commands. The inputs are either objects or simple Move values, and the results are arbitrary Move values (including objects).

The inputs and results can be seen as populating an array of values. For inputs, there is a single array, but for results, there is an array for each individual transaction command, creating a 2D-array of result values. You can access these values by borrowing (mutably or immutably), by copying (if the type permits), or by moving (which takes the value out of the array without re-indexing).

### Inputs

Input arguments to a PTB are broadly categorized as either objects or pure values. The direct implementation of these arguments is often obscured by transaction builders or SDKs. This section describes information or data the Sui network needs when specifying the list of inputs, `[Input]`. Each `Input` is either an object, `Input::Object(ObjectArg)`, which contains the necessary metadata to specify to object being used, or a pure value, `Input::Pure(PureArg)`, which contains the bytes of the value.

For object inputs, the metadata needed differs depending on the type of [ownership of the object](../object-ownership.mdx). The data for the `ObjectArg` enum follows:

If the object is owned by an address (or it is immutable), then use `ObjectArg::ImmOrOwnedObject(ObjectID, SequenceNumber, ObjectDigest)`. The triple respectively specifies the object's ID, its sequence number (also known as its version), and the digest of the object's data.

If an object is shared, then use `Object::SharedObject { id: ObjectID, initial_shared_version: SequenceNumber, mutable: bool }`. Unlike `ImmOrOwnedObject`, a shared objects version and digest are determined by the network's consensus protocol. The `initial_shared_version` is the version of the object when it was first shared, which is used by consensus when it has not yet seen a transaction with that object. While all shared objects _can_ be mutated, the `mutable` flag indicates whether the object is to be used mutably in this transaction. In the case where the `mutable` flag is set to `false`, the object is read-only, and the system can schedule other read-only transactions in parallel.

If the object is owned by another object, as in it was sent to an object's ID via the `TransferObjects` command or the `sui::transfer::transfer` function, then use `ObjectArg::Receiving(ObjectID, SequenceNumber, ObjectDigest)`. The object data is the same as for the `ImmOrOwnedObject` case.

For pure inputs, the only data provided is the [BCS](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/std/bcs.md) bytes, which are deserialized to construct Move values. Not all Move values can be constructed from BCS bytes. This means that even if the bytes match the expected layout for a given Move type, they cannot be deserialized into a value of that type unless the type is one of the types permitted for `Pure` values. The following types are allowed to be used with pure values:

- All primitive types:
  - `u8`
  - `u16`
  - `u32`
  - `u64`
  - `u128`
  - `u256`
  - `bool`
  - `address`
- A string, either an ASCII string (`std::ascii::String`) or UTF8 string (`std::string::String`). In either case, the bytes are validated to be a valid string with the respective encoding.
- An object ID `sui::object::ID`.
- A vector, `vector<T>`, where `T` is a valid type for a pure input, checked recursively.
- An option, `std::option::Option<T>`, where `T` is a valid type for a pure input, checked recursively.

Interestingly, the bytes are not validated until the type is specified in a command, for example in `MoveCall` or `MakeMoveVec`. This means that a given pure input could be used to instantiate Move values of several types. See the [Arguments section](#arguments) for more details.

### Results

Each transaction command produces a (possibly empty) array of values. The type of the value can be any arbitrary Move type, so unlike inputs, the values are not limited to objects or pure values. The number of results generated and their types are specific to each transaction command. The specifics for each command can be found in the section for that command, but in summary:

- `MoveCall`: the number of results and their types are determined by the Move function being called. Move functions that return references are not supported at this time.
- `SplitCoins`: produces (one or more) coins from a single coin. The type of each coin is `sui::coin::Coin<T>` where the specific coin type `T` matches the coin being split.
- `Publish`: returns the upgrade capability, `sui::package::UpgradeCap`, for the newly published package.
- `Upgrade`: returns the upgrade receipt, `sui::package::UpgradeReceipt`, for the upgraded package.
- `TransferObjects` and `MergeCoins` do not produce any results (an empty result vector).

### Argument structure and usage

Each command takes `Argument`s that specify the input or result being used. The usage (by-reference or by-value) is inferred based on the type of the argument and the expected argument of the command. First, examine the structure of the `Argument` enum.

- `Input(u16)` is an input argument, where the `u16` is the index of the input in the input vector. For example, given an input vector of `[Object1, Object2, Pure1, Object3]`, `Object1` is accessed with `Input(0)` and `Pure1` is accessed with `Input(2)`.
- `GasCoin` is a special input argument representing the object for the `SUI` coin used to pay for gas. It is kept separate from the other inputs because the gas coin is always present in each transaction and has special restrictions (see below) not present for other inputs. Additionally, the gas coin being separate makes its usage explicit, which is helpful for sponsored transactions where the sponsor might not want the sender to use the gas coin for anything other than gas.

  The gas coin cannot be taken by-value except with the `TransferObjects` command. If you need an owned version of the gas coin, you can first use `SplitCoins` to split off a single coin.

  This limitation exists to make it easy for the remaining gas to be returned to the coin at the end of execution. In other words, if the gas coin was wrapped or deleted, then there would not be an obvious spot for the excess gas to be returned. See the [Execution section](#execution) for more details.

- `NestedResult(u16, u16)` uses the value from a previous command. The first `u16` is the index of the command in the command vector, and the second `u16` is the index of the result in the result vector of that command. For example, given a command vector of `[MoveCall1, MoveCall2, TransferObjects]` where `MoveCall2` has a result vector of `[Value1, Value2]`, `Value1` would be accessed with `NestedResult(1, 0)` and `Value2` would be accessed with `NestedResult(1, 1)`.
- `Result(u16)` is a special form of `NestedResult` where `Result(i)` is roughly equivalent to `NestedResult(i, 0)`. Unlike `NestedResult(i, 0)`, `Result(i)`, however, this errors if the result array at index `i` is empty or has more than one value. The ultimate intention of `Result` is to allow accessing the entire result array, but that is not yet supported. So in its current state, `NestedResult` can be used instead of `Result` in all circumstances.

## Execution {#execution}

For the execution of PTBs, the input vector is populated by the input objects or pure value bytes. The transaction commands are then executed in order, and the results are stored in the result vector. Finally, the effects of the transaction are applied atomically. The following sections describe each aspect of execution in greater detail.

### Start of execution

At the beginning of execution, the PTB runtime takes the already loaded input objects and loads them into the input array. The objects are already verified by the network, checking rules like existence and valid ownership. The pure value bytes are also loaded into the array but not validated until usage.

The most important thing to note at this stage is the effects on the gas coin. At the beginning of execution, the maximum gas budget (in terms of `SUI`) is withdrawn from the gas coin. Any unused gas is returned to the gas coin at the end of execution, even if the coin has changed owners.

### Executing a transaction command

Each transaction command is then executed in order. First, examine the rules around arguments, which are shared by all commands.

#### Arguments {#arguments}

You can use each argument by-reference or by-value. The usage is based on the type of the argument and the type signature of the command.

- If the signature expects an `&mut T`, the runtime checks the argument has type `T` and it is then mutably borrowed.
- If the signature expects an `&T`, the runtime checks the argument has type `T` and it is then immutably borrowed.
- If the signature expects a `T`, the runtime checks the argument has type `T` and it is copied if `T: copy` and moved otherwise. No object in Sui has `copy` because the unique ID field `sui::object::UID` present in all objects does not have the `copy` ability.

The transaction fails if an argument is used in any form after being moved. There is no way to restore an argument to its position (its input or result index) after it is moved.

If an argument is copied but does not have the `drop` ability, then the last usage is inferred to be a move. As a result, if an argument has `copy` and does not have `drop`, the last usage _must_ be by value. Otherwise, the transaction will fail because a value without `drop` has not been used.

The borrowing of arguments has other rules to ensure unique safe usage of an argument by reference. If an argument is:

- Mutably borrowed, there must be no outstanding borrows. Duplicate borrows with an outstanding mutable borrow could lead to dangling references (references that point to invalid memory).
- Immutably borrowed, there must be no outstanding mutable borrows. Duplicate immutable borrows are allowed.
- Moved, there must be no outstanding borrows. Moving a borrowed value would dangle those outstanding borrows, making them unsafe.
- Copied, there can be outstanding borrows, mutable or immutable. While it might lead to some unexpected results in some cases, there is no safety concern.

Object inputs have the type of their object `T` as you might expect. However, for `ObjectArg::Receiving` inputs, the object type `T` is instead wrapped as `sui::transfer::Receiving<T>`. This is because the object is not owned by the sender, but instead by another object. And to prove ownership with that parent object, you call the `sui::transfer::receive` function to remove the wrapper.

The `GasCoin` has special restrictions on being used by-value (moved). You can only use it by-value with the `TransferObjects` command.

Shared objects also have restrictions on being used by-value. These restrictions exist to ensure that at the end of the transaction the shared object is either still shared or deleted. A shared object cannot be unshared (having the owner changed) and it cannot be wrapped. A shared object:

- Marked as not `mutable` (being used read-only) cannot be used by value.
- Cannot be transferred or frozen. These checks are not done dynamically, however, but rather at the end of the transaction only. For example, `TransferObjects` succeeds if passed a shared object, but at the end of execution the transaction fails.
- Can be wrapped and can become a dynamic field transiently, but by the end of the transaction it must be re-shared or deleted.

Pure values are not type checked until their usage. When checking if a pure value has type `T`, it is checked whether `T` is a valid type for a pure value (see the previous list). If it is, the bytes are then validated. You can use a pure value with multiple types as long as the bytes are valid for each type. For example, you can use a string as an ASCII string `std::ascii::String` and as a UTF8 string `std::string::String`. However, after you mutably borrow the pure value, the type becomes fixed, and all future usages must be with that type.

#### `TransferObjects`

The command has the form `TransferObjects(ObjectArgs, AddressArg)` where `ObjectArgs` is a vector of objects and `AddressArg` is the address the objects are sent to.

- Each argument `ObjectArgs: [Argument]` must be an object, however, the objects do not need to have the same type.
- The address argument `AddressArg: Argument` must be an address, which could come from a `Pure` input or a result.
- All arguments, objects and address, are taken by value.
- The command does not produce any results (an empty result vector).
- While the signature of this command cannot be expressed in Move, you can think of it roughly as having the signature `(vector<forall T: key + store. T>, address): ()` where `forall T: key + store. T` is indicating that the `vector` is a heterogeneous vector of objects.

#### `SplitCoins`

The command has the form `SplitCoins(CoinArg, AmountArgs)` where `CoinArg` is the coin being split and `AmountArgs` is a vector of amounts to split off.

- When the transaction is signed, the network verifies that the `AmountArgs` is non-empty.
- The coin argument `CoinArg: Argument` must be a coin of type `sui::coin::Coin<T>` where `T` is the type of the coin being split. It can be any coin type and is not limited to `SUI` coins.
- The amount arguments `AmountArgs: [Argument]` must be `u64` values, which could come from a `Pure` input or a result.
- The coin argument `CoinArg` is taken by mutable reference.
- The amount arguments `AmountArgs` are taken by value (copied).
- The result of the command is a vector of coins, `sui::coin::Coin<T>`. The coin type `T` is the same as the coin being split, and the number of results matches the number of arguments
- For a rough signature expressed in Move, it is similar to a function `<T: key + store>(coin: &mut sui::coin::Coin<T>, amounts: vector<u64>): vector<sui::coin::Coin<T>>` where the result `vector` is guaranteed to have the same length as the `amounts` vector.

#### `MergeCoins`

The command has the form `MergeCoins(CoinArg, ToMergeArgs)` where the `CoinArg` is the target coin in which the `ToMergeArgs` coins are merged into. In other words, you merge multiple coins (`ToMergeArgs`) into a single coin (`CoinArg`).

- When the transaction is signed, the network verifies that the `ToMergeArgs` is non-empty.
- The coin argument `CoinArg: Argument` must be a coin of type `sui::coin::Coin<T>` where `T` is the type of the coin being merged. It can be any coin type and is not limited to `SUI` coins.
- The coin arguments `ToMergeArgs: [Argument]` must be `sui::coin::Coin<T>` values where the `T` is the same type as the `CoinArg`.
- The coin argument `CoinArg` is taken by mutable reference.
- The merge arguments `ToMergeArgs` are taken by value (moved).
- The command does not produce any results (an empty result vector).
- For a rough signature expressed in Move, it is similar to a function `<T: key + store>(coin: &mut sui::coin::Coin<T>, to_merge: vector<sui::coin::Coin<T>>): ()`

#### `MakeMoveVec`

The command has the form `MakeMoveVec(VecTypeOption, Args)` where `VecTypeOption` is an optional argument specifying the type of the elements in the vector being constructed and `Args` is a vector of arguments to be used as elements in the vector.

- When the transaction is signed, the network verifies that if that the type must be specified for an empty vector of `Args`.
- The type `VecTypeOption: Option<TypeTag>` is an optional argument specifying the type of the elements in the vector being constructed. The `TypeTag` is a Move type for the elements in the vector, i.e. the `T` in the produced `vector<T>`.
  - The type does not have to be specified for an object vector--when `T: key`.
  - The type _must_ be specified if the type is not an object type or when the vector is empty.
- The arguments `Args: [Argument]` are the elements of the vector. The arguments can be any type, including objects, pure values, or results from previous commands.
- The arguments `Args` are taken by value. Copied if `T: copy` and moved otherwise.
- The command produces a _single_ result of type `vector<T>`. The elements of the vector cannot then be accessed individually using `NestedResult`. Instead, the entire vector must be used as an argument to another command. If you wish to access the elements individually, you can use the `MoveCall` command and do so inside of Move code.
- While the signature of this command cannot be expressed in Move, you can think of it roughly as having the signature `(T...): vector<T>` where `T...` indicates a variadic number of arguments of type `T`.

#### `MoveCall`

This command has the form `MoveCall(Package, Module, Function, TypeArgs, Args)` where `Package::Module::Function` combine to specify the Move function being called, `TypeArgs` is a vector of type arguments to that function, and `Args` is a vector of arguments for the Move function.

- The package `Package: ObjectID` is the Object ID of the package containing the module being called.
- The module `Module: String` is the name of the module containing the function being called.
- The function `Function: String` is the name of the function being called.
- The type arguments `TypeArgs: [TypeTag]` are the type arguments to the function being called. They must satisfy the constraints of the type parameters for the function.
- The arguments `Args: [Argument]` are the arguments to the function being called. The arguments must be valid for the parameters as specified in the function's signature.
- Unlike the other commands, the usage of the arguments and the number of results are dynamic in that they both depend on the signature of the Move function being called.

#### `Publish` {#publish}

The command has the form `Publish(ModuleBytes, TransitiveDependencies)` where `ModuleBytes` are the bytes of the module being published and `TransitiveDependencies` is a vector of package Object ID dependencies to link against.

When the transaction is signed, the network verifies that the `ModuleBytes` are not empty. The module bytes `ModuleBytes: [[u8]]` contain the bytes of the modules being published with each `[u8]` element is a module.

The transitive dependencies `TransitiveDependencies: [ObjectID]` are the Object IDs of the packages that the new package depends on. While each module indicates the packages used as dependencies, the transitive object IDs must be provided to select the version of those packages. In other words, these object IDs are used to select the version of the packages marked as dependencies in the modules.

After the modules in the package are verified, the `init` function of each module is called in same order as the module byte vector `ModuleBytes`.

The command produces a single result of type `sui::package::UpgradeCap`, which is the upgrade capability for the newly published package.

#### `Upgrade`

The command has the form `Upgrade(ModuleBytes, TransitiveDependencies, Package, UpgradeTicket)`, where the `Package` indicates the object ID of the package being upgraded. The `ModuleBytes` and `TransitiveDependencies` work similarly as the `Publish` command.

For details on the `ModuleBytes` and `TransitiveDependencies`, see the [`Publish` command](#publish). Note though, that no `init` functions are called for the upgraded modules.

The `Package: ObjectID` is the Object ID of the package being upgraded. The package must exist and be the latest version.

The `UpgradeTicket: sui::package::UpgradeTicket` is the upgrade ticket for the package being upgraded and is generated from the `sui::package::UpgradeCap`. The ticket is taken by value (moved).

The command produces a single result type `sui::package::UpgradeReceipt` which provides proof for that upgrade. For more details on upgrades, see [Upgrading Packages](../sui-move-concepts/packages/upgrade.mdx).

### End of execution

At the end of execution, the remaining values are checked and effects for the transaction are calculated.

For inputs, the following checks are performed:

- Any remaining immutable or readonly input objects are skipped since no modifications have been made to them.
- Any remaining mutable input objects are returned to their original owners--if they were shared they remain shared, if they were owned they remain owned.
- Any remaining pure input values are dropped. Note that pure input values must have `copy` and `drop` since all permissible types for those values have `copy` and `drop`.
- For any shared object you must also check that it has only been deleted or re-shared. Any other operation (wrap, transfer, freezing, and so on) results in an error.

For results, the following checks are performed:

- Any remaining result with the `drop` ability is dropped.
- If the value has `copy` but not `drop`, it's last usage must have been by-value. In that way, it's last usage is treated as a move.
- Otherwise, an error is given because there is an unused value without `drop`.

Any remaining SUI deducted from the gas coin at the beginning of execution is returned to the coin, even if the owner has changed. In other words, the maximum possible gas is deducted at the beginning of execution, and then the unused gas is returned at the end of execution (all in SUI). Because you can take the gas coin only by-value with `TransferObjects`, it will not have been wrapped or deleted.

The total effects (which contain the created, mutated, and deleted objects) are then passed out of the execution layer and are applied by the Sui network.

## Example

Let's walk through an example of a PTB's execution. While this example is not exhaustive in demonstrating all the rules, it does show the general flow of execution.

Suppose you want to buy two items from a marketplace costing `100 MIST`. You keep one for yourself, and then send the object and the remaining coin to a friend at address `0x808`. You can do that all in one PTB:

```rust
{
  inputs: [
    Pure(/* @0x808 BCS bytes */ ...),
    Object(SharedObject { /* Marketplace shared object */ id: market_id, ... }),
    Pure(/* 100u64 BCS bytes */ ...),
  ]
  commands: [
    SplitCoins(GasCoin, [Input(2)]),
    MoveCall("some_package", "some_marketplace", "buy_two", [], [Input(1), NestedResult(0, 0)]),
    TransferObjects([GasCoin, NestedResult(1, 0)], Input(0)),
    MoveCall("sui", "tx_context", "sender", [], []),
    TransferObjects([NestedResult(1, 1)], NestedResult(3, 0)),
  ]
}
```

The inputs include the friend's address, the marketplace object, and the value for the coin split. For the commands, split off the coin, call the market place function, send the gas coin and one object, grab your address (via `sui::tx_context::sender`), and then send the remaining object to yourself. For simplicity, the documentation refers to the package names by name, but note that in practice they are referenced by the package's Object ID.

To walk through this, first look at the memory locations, for the gas object, inputs, and results

```rust
Gas Coin: sui::coin::Coin<SUI> { id: gas_coin, balance: sui::balance::Balance<SUI> { value: 1_000_000u64 } }
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  some_package::some_marketplace::Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: []
```

Here you have two objects loaded so far, the gas coin with a value of `1_000_000u64` and the marketplace object of type `some_package::some_marketplace::Marketplace` (these names and representations are shortened for simplicity going forward). The pure arguments are not loaded, and are present as BCS bytes.

Note that while gas is deducted at each command, that aspect of execution is not demonstrated in detail.

### Before commands: start of execution

Before execution, remove the gas budget from the gas coin. Assume a gas budget of `500_000` so the gas coin now has a value of `500_000u64`.

```rust
Gas Coin: Coin<SUI> { id: gas_coin, ... value: 500_000u64 ... } // The maximum gas is deducted
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: []
```

Now you can execute the commands.

### Command 0: `SplitCoins`

The first command `SplitCoins(GasCoin, [Input(2)])` accesses the gas coin by mutable reference and loads the pure argument at `Input(2)` as a `u64` value of `100u64`. Because `u64` has the `copy` ability, you do not move the `Pure` input at `Input(2)`. Instead, the bytes are copied out.

For the result, a new coin object is made.

This gives us updated memory locations of

```rust
Gas Coin: Coin<SUI> { id: gas_coin, ... value: 499_900u64 ... }
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: [
  [Coin<SUI> { id: new_coin, value: 100u64 ... }], // The result of SplitCoins
],
```

### Command 1: `MoveCall`

Now the command, `MoveCall("some_package", "some_marketplace", "buy_two", [], [Input(1), NestedResult(0, 0)])`. Call the function `some_package::some_marketplace::buy_two` with the arguments `Input(1)` and `NestedResult(0, 0)`. To determine how they are used, you need to look at the function's signature. For this example, assume the signature is

```move
entry fun buy_two(
    marketplace: &mut Marketplace,
    coin: Coin<Sui>,
    ctx: &mut TxContext,
): (Item, Item)
```

where `Item` is the type of the two objects being sold.

Since the `marketplace` parameter has type `&mut Marketplace`, use `Input(1)` by mutable reference. Assume some modifications are being made into the value of the `Marketplace` object. However, the `coin` parameter has type `Coin<Sui>`, so use `NestedResult(0, 0)` by value. The `TxContext` input is automatically provided by the runtime.

This gives updated memory locations, where `_` indicates the object has been moved.

```rust
Gas Coin: Coin<SUI> { id: gas_coin, ... value: 499_900u64 ... }
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ...  }, // Any mutations are applied
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: [
  [ _ ], // The coin was moved
  [Item { id: id1 }, Item { id: id2 }], // The results from the Move call
],
```

Assume that `buy_two` deletes its `Coin<SUI>` object argument and transfers the `Balance<SUI>` into the `Marketplace` object.

### Command 2: `TransferObjects`

`TransferObjects([GasCoin, NestedResult(1, 0)], Input(0))` transfers the gas coin and first item to the address at `Input(0)`. All inputs are by value, and the objects do not have `copy` so they are moved. While no results are given, the ownership of the objects is changed. This cannot be seen in the memory locations, but rather in the transaction effects.

You now have updated memory locations of

```rust
Gas Coin: _ // The gas coin is moved
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: [
  [ _ ],
  [ _ , Item { id: id2 }], // One item was moved
  [], // No results from TransferObjects
],
```

### Command 3: `MoveCall`

Make another Move call, this one to `sui::tx_context::sender` with the signature

```move
public fun sender(ctx: &TxContext): address
```

While you could have just passed in the sender's address as a `Pure` input, this example demonstrates calling some of the additional utility of PTBs; while this function is not an `entry` function, you can call the `public` function, too, because you can provide all of the arguments. In this case, the only argument, the `TxContext`, is provided by the runtime. The result of the function is the sender's address. Note that this value is not treated like the `Pure` inputs--the type is fixed to `address` and it cannot be deserialized into a different type, even if it has a compatible BCS representation.

You now have updated memory locations of

```rust
Gas Coin: _
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: [
  [ _ ],
  [ _ , Item { id: id2 }],
  [],
  [/* senders address */ ...], // The result of the Move call
],
```

### Command 4: `TransferObjects`

Finally, transfer the remaining item to yourself. This is similar to the previous `TransferObjects` command. You are using the last `Item` by-value and the sender's address by-value. The item is moved because `Item` does not have `copy`, and the address is copied because `address` does have `copy`.

The final memory locations are

```rust
Gas Coin: _
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: [
  [ _ ],
  [ _ , _ ],
  [],
  [/* senders address */ ...],
  [], // No results from TransferObjects
],
```

### After commands: end of execution

At the end of execution, the runtime checks the remaining values, which are the three inputs and
the sender's address. The following summarizes the checks performed before effects are given:

- Any remaining input objects are marked as being returned to their original owners.
  - The gas coin has been Moved. And the `Marketplace` keeps the same owner, which is shared.
- All remaining values must have `drop`.
  - The Pure inputs have `drop` because any type they can instantiate has `drop`.
  - The sender's address has `drop` because the primitive type `address` has `drop`.
  - All other results have been moved.
- Any remaining shared objects must have been deleted or re-shared.
  - The `Marketplace` object was not moved, so the owner remains as shared.

After these checks are performed, generate the effects.

- The coin split off from the gas coin, `new_coin`, does not appear in the effects because it was created and deleted in the same transaction.
- The gas coin and the item with `id1` are transferred to `0x808`.
  - The gas coin is mutated to update its balance. The remaining gas of the maximum budget of `500_000` is returned to the gas coin even though the owner has changed.
  - The `Item` with `id1` is a newly created object.
- The item with `id2` is transferred to the sender's address.
  - The `Item` with `id2` is a newly created object.
- The `Marketplace` object is returned, remains shared, and it's mutated.
  - The object remains shared but its contents are mutated.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer.mdx
```
---
title: Developer Guides
description: Guides for developers on the Sui network. Whether you're just learning how to create smart contracts or are a Move expert, these guides help to fast-track your Sui development. 
---

The developer guides are meant to introduce you to the Move programming language and its implementation on the Sui network through examples, tasks, and conceptual content.  

## Get started

If you are completely new to Move, you should start with the aptly named Getting Started section. Topics in that section introduce you to the Sui monorepo, guide you through installing Sui binaries, and introduce you to some key core concepts of blockchain technology, particularly how they relate to Sui. 

Go to [Getting Started](./developer/getting-started.mdx).

## Your first dApp

If you prefer to jump right in to coding (after installing Sui, of course), then the Your First dApp is the place for you. These topics show you how to work with Move packages and get them published on-chain. 

Go to [Your First Sui dApp](./developer/first-app.mdx).

## Sui 101

The Sui 101 section introduces the basics of Sui that help you create smart contracts. These topics assume you are familiar with Move and the Sui blockchain.

Go to [Sui 101](./developer/sui-101.mdx).

## Coins, tokens, and NFTs

Minting coins, tokens, and NFTs on Sui provides the opportunity to build communities on the Sui network around these objects or to promote and support off-chain businesses. Refer to the appropriate guide to get started.

Go to
- [Coins and Tokens](./developer/coin.mdx)
- [NFTs](./developer/nft.mdx)
- [Stablecoins](./developer/stablecoins.mdx)

## Cryptography

The Cryptography section demonstrates how to secure your smart contracts with cryptography to ensure authentication for access to sensitive data.

Go to [Cryptography](./developer/cryptography.mdx).

## Advanced Topics

The Advanced Topics section includes guides for advanced solutions rather than advanced users (like migrating to GraphQL or asset tokenization). These topics assume you are familiar with Move and the Sui blockchain.

Go to [Advanced Topics](./developer/advanced.mdx).

## App Examples

The App Examples section is for anyone who learns best from reverse engineering code written by Sui and Move experts. These examples demonstrate concepts and tasks documented throughout this site and typically include detailed explanations through code comments and specific documentation. Check back often as the available examples continue to grow.

Go to [App Examples](./developer/app-examples.mdx).

## Sui developer cheat sheet

The cheat sheet collects notes from Sui and Move developers into a single location. This document surfaces important information that might get lost in the quantity of content available. Use this often-updated page to see around corners when starting a Move project or to refresh your memory on important concepts to be mindful of. 

Go to [Sui Developer Cheat Sheet](./developer/dev-cheat-sheet.mdx).

## References

If you're familiar with both Move and Sui and just need some reference material to refresh your memory on that function you haven't used in a while, then the References section of the documentation should surface the information you need.

Go to [References](references.mdx).
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator.mdx
```
---
title: Operator Guides
description: Guides for operators on the Sui network. Whether you are running a Full node for your dApp or operating as a validator on the Sui network, these guides help you set up your environment and operate your network.
---

Operator guides demonstrate how to run Full nodes on Sui, whether as a validator or operator of a Full node to support your dApp, as well as how to integrate SUI into an exchange. 

## Sui Full node operators

Guides that inform Full node operators include:

- [Sui Full Node Configuration](./operator/sui-full-node.mdx)  

## Sui validators

Guides that inform validators how to operate on Sui include:

- [Validator Committee](./operator/validator-committee.mdx)
- [Validator Configuration](./operator/validator-config.mdx)
- [Validator Tasks](./operator/validator-tasks.mdx)

## Sui Full node operators and validators

Guides that benefit both Full node operators and validators include:

- [Data Management](./operator/data-management.mdx)
- [Genesis](./operator/genesis.mdx)
- [Monitoring](./operator/monitoring.mdx)
- [Snapshots](./operator/snapshots.mdx)
- [Archives](./operator/archives.mdx)

## Exchange integration guide

The [Sui Exchange Integration Guide](./operator/exchange-integration.mdx) provides step-by-step instructions on how to integrate SUI into a cryptocurrency exchange.

## Sui Bridge Node validators

Guides that inform validators how to operate Sui Bridge include:
- [Sui Bridge Node Configuration](./operator/bridge-node-configuration.mdx)

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/data-management.mdx
```
---
title: Data Management
description: A high-level description of data management on the Sui network that you can use to optimize your Sui Full node configuration. 
---

Managing the data on your Sui Full node is critical to ensuring a healthy Sui network. This topic provides a high-level description of data management on Sui Full nodes that you can use to optimize your Full node configuration. For more information about Sui Full nodes, such as pruning policies and archival settings, see [Run a Sui Full Node](./sui-full-node.mdx).

## Basic Sui Full node functionality

The minimal version of a Sui Full node executes all of the transactions Sui validators commit. Sui Full nodes also orchestrate the submitting of new transactions to the system:

![Basic Sui Full node functionality](./images/fn-basic-functionality.png "A diagram that shows the operations of a basic Sui Full node.")

The preceding image shows how data flows through a Full node:

1. **`State sync` protocol:** A Sui Full node performs the following to achieve state synchronization:
   - Retrieves the information about the committed checkpoints via the p2p gossip-like protocol
   - Executes the transactions locally to verify that effects match the effects certified by the quorum of the validators
   - Updates the local state with the latest object values accordingly.
2. **RPCs:** A Sui Full node exposes Sui RPC endpoints for querying the latest state of the system, including both the latest state metadata (such as, `sui_getProtocolConfig`), and the latest state object data (`sui_getObject)`.
3. **Transaction submission:** Each Sui Full node orchestrates transaction submission to the quorum of the Sui Validators, and, optionally if configured, locally executes the finalized transactions (called fast path execution), which circumvents the wait for checkpoint synchronization.

## Sui Full node Data and RPC types

A Sui Full Node stores multiple categories of data in its permanent store.

:::info

The per-epoch Sui store is beyond the scope of this topic. Sui uses the per-epoch store (resets at the start of each epoch) internally for authority and consensus operations.

:::

Sui Full nodes store the following types of data:

1. **Transactions with associated effects and events:** Sui uses a unique transaction digest to retrieve information about a transaction, including its effects and emitted events. Sui Full nodes don't require the historic transaction information for basic Full node operations. To conserve drive space, you can enable pruning to remove this historical data.
2. **Checkpoints:** Sui groups committed transactions in checkpoints, and then uses those checkpoints to achieve state synchronization. Checkpoints keep transaction digests that contain additional integrity metadata.
Sui Full nodes don't require data from checkpoints to  execute and submit transactions, so you can configure pruning for this data as well.
3. **Objects:** Transactions that mutate objects create new object versions. Each object has a unique pair of `(objectId, version)` used to identify the object. Sui Full nodes don't require historic object versions to  execute and submit transactions, so you can configure your Full node to also prune this data. 
4. **Indexing information:** A Full node default configuration is to post-process the committed transactions: it indexes the committed information to enable efficient aggregation and filtering queries. For example, the indexing can be useful for retrieving all the historic transactions of a given sender, or finding all the objects owned by an address. 

Sui Full nodes support more than 40 RPC types that includes the following categories:

* **General metadata**, such as `sui_getProtocolConfig` and `sui_getChainIdentier`. These requests don't depend on additional indexing and don't require historic data to process.
* **Direct lookups**, such as `sui_getObject`, `sui_getEvents`. These requests don't depend on additional indexing, but require historic data in some cases, such as `sui_tryGetPastObject` and `sui_getTransactionBlock`.
* **Accumulation and filtering queries**,such as `suix_getOwnedObjects` and `suix_getCoins`. These requests depend on additional indexing, and require historic data in some cases, such as `suix_queryTransactionBlocks`.

:::info

{@include: ../../snippets/data-serving-msg.mdx}

:::

## Sui Archival data

A Sui archive instance stores the full Sui transaction history since genesis in a database agnostic format. This includes information about transactions (with client authentication), effects, events, and checkpoints. As such, archival storage can be used for data auditing and for replaying historic transactions.

A Full node that starts from scratch can replay (and thus re-verify) transactions that occurred since Sui genesis from the given archive via [configuring Archival Fallback](./archives.mdx#set-up-archival-fallback) in the `fullnode.yaml` configuration file to point to the cloud bucket that stores the archive.

A Sui Full node that fails to retrieve checkpoints from its peers via state sync protocol falls back to downloading the missing checkpoints from its pre-configured archive. This fallback enables a Full node to catch up with the rest of the system regardless of the pruning policies of its peers.

## Sui Full node pruning policies

As described previously, sustainable disk usage requires Sui Full nodes to prune the information about historic object versions as well as historic transactions with the corresponding effects and events, including old checkpoint data.

Both transaction and object pruners run in the background. The logical deletion of entries from RocksDB ultimately triggers the physical compaction of data on disk, which is governed by RocksDB background jobs: the pruning effect on disk usage is not immediate and might take multiple days.

To learn more about object pruning policies, see [Object pruning](#object-pruning). You can configure the pruner in two modes:
* **moderate pruning** (`num-epochs-to-retain: 5`): Preferred option. Sui retains object versions for 5 epochs.
* **epoch-based pruning** (`num-epochs-to-retain: X`): Sui prunes old object versions after X epochs.

:::tip 
Keeping some history (5 epochs) provides better RPC performance as it allows more lookups to happen from local disk rather than from remote storage.
:::

To learn more about transaction pruning policies, see [Transaction pruning](#transaction-pruning). To configure transaction pruning, specify the `num-epochs-to-retain-for-checkpoints: X` config option. The checkpoints, including their transactions, effects and events are pruned up to X epochs ago. We suggest setting transaction pruning to 2 epochs.

## Sui Full node key-value store backup

To enable historic data queries for the Sui Full nodes that prune old transactional data, Full node RPC implementation is configured to fallback for querying missing transactional data from a remote store.

If the information about the transaction digest, effects, events, or checkpoints is not available locally, a Full node automatically retrieves the historical data from a cloud-based key-value store (currently managed by MystenLabs). Note that the current key-value store implementation keeps historic transactional data only: we plan to provide support for a similar setup for retrieving the historic object versions in a future release.

## Object pruning {#object-pruning}

Sui adds new object versions to the database as part of transaction execution. This makes previous versions ready for 
garbage collection. However, without pruning, this can result in database performance degradation and requires large 
amounts of storage space. Sui identifies the objects that are eligible for pruning in each checkpoint, and then performs
the pruning in the background.

You can enable pruning for a Sui node by adding the `authority-store-pruning-config` config to `fullnode.yaml` file:
```yaml
authority-store-pruning-config:
  # Number of epoch dbs to keep 
  # Not relevant for object pruning
  num-latest-epoch-dbs-to-retain: 3
  # The amount of time, in seconds, between running the object pruning task.
  # Not relevant for object pruning
  epoch-db-pruning-period-secs: 3600
  # Number of epochs to wait before performing object pruning.
  # When set to 0, Sui prunes old object versions as soon
  # as possible. This is also called *aggressive pruning*, and results in the most effective
  # garbage collection method with the lowest disk usage possible. 
  # This is the recommended setting for Sui Validator nodes since older object versions aren't
  # necessary to execute transactions.
  # When set to 1, Sui prunes only object versions from transaction checkpoints
  # previous to the current epoch. In general, when set to N (where N >= 1), Sui prunes  
  # only object versions from checkpoints up to `current - N` epoch. 
  # It is therefore possible to have multiple versions of an object present 
  # in the database. This setting is recommended for Sui Full nodes as they might need to serve 
  # RPC requests that require looking up objects by ID and Version (rather than just latest
  # version). However, if your Full node does not serve RPC requests you should then also enable  
  # aggressive pruning.
  num-epochs-to-retain: 1
  # Advanced setting: Maximum number of checkpoints to prune in a batch. The default
  # settings are appropriate for most use cases.
  max-checkpoints-in-batch: 10
  # Advanced setting: Maximum number of transactions in one batch of pruning run. The default
  # settings are appropriate for most use cases.
  max-transactions-in-batch: 1000
```
## Transaction pruning {#transaction-pruning}

Transaction pruning removes previous transactions and effects from the database.
Sui periodically creates checkpoints. Each checkpoint contains the transactions that occurred during the checkpoint and their associated effects.

Sui performs transaction pruning in the background after checkpoints complete.

You can enable transaction pruning for your Full node or Validator node by adding  `num-epochs-to-retain-for-checkpoints`
to the `authority-store-pruning-config` config for the node:

```yaml
authority-store-pruning-config:
  num-latest-epoch-dbs-to-retain: 3
  epoch-db-pruning-period-secs: 3600
  num-epochs-to-retain: 0
  max-checkpoints-in-batch: 10
  max-transactions-in-batch: 1000
  # Number of epochs to wait before performing transaction pruning.
  # When this is N (where N >= 2), Sui prunes transactions and effects from 
  # checkpoints up to the `current - N` epoch. Sui never prunes transactions and effects from the current and
  # immediately prior epoch. N = 2 is a recommended setting for Sui Validator nodes and Sui Full nodes that don't 
  # serve RPC requests.
  num-epochs-to-retain-for-checkpoints: 2
  # Ensures that individual database files periodically go through the compaction process.
  # This helps reclaim disk space and avoid fragmentation issues
  periodic-compaction-threshold-days: 1
```

:::info

If you prune transactions, Archival nodes can help ensure lagging peer nodes don't lose any information. For more information, see [Sui Archives](./archives.mdx).

:::


## Pruning policy examples

Use the examples in this section to configure your Sui Full node. You can copy the examples, and then, optionally, modify the values as appropriate for your environment. 

### Validator and minimal Full node

This configuration keeps disk usage to a minimum. It is suitable for most validators. A Full node with this configuration cannot answer queries that require indexing or historic data.

```yaml
# Do not generate or maintain indexing of Sui data on the node
enable-index-processing: false

authority-store-pruning-config:
  # Retain 5 epochs of object versions for better RPC performance
  num-epochs-to-retain: 5
  # Prune historic transactions of the past epochs
  num-epochs-to-retain-for-checkpoints: 2
```

### Full node with indexing but no history

This setup manages secondary indexing in addition to the latest state, but aggressively prunes historic data. A Full node with this configuration:

- Answers RPC queries that require indexing, like `suix_getBalance()`.
- Answers RPC queries that require historic transactions via a fallback to retrieve the data from a remote key-value store: `sui_getTransactionBlock()`.
- Cannot answer RPC queries that require historic object versions: `sui_tryGetPastObject()`.
  - The `showBalanceChanges` filter of `sui_getTransactionBlock()` query relies on historic object versions, so it can't work with this configuration.

```yaml
authority-store-pruning-config:
  # Retain 5 epochs of object versions for better RPC performance
  num-epochs-to-retain: 5
  # Prune historic transactions of the past epochs
  num-epochs-to-retain-for-checkpoints: 2
```

### Full node with full object history but pruned transaction history

This configuration manages the full object history while still pruning historic transactions. A Full node with this configuration can answer all historic and indexing queries (using the transaction query fallback for transactional data), including the ones that require historic objects such as the `showBalanceChanges` filter of `sui_getTransactionBlock()`.

The main caveat is that the current setup enables **transaction pruner** to go ahead of **object pruner**. The object pruner might not be able to properly clean up the objects modified by the transactions that have been already pruned. You should closely monitor the disk space growth on a Full node with this configuration.

In addition to the regular (pruned) snapshots, Mysten Labs also maintains special RocksDB snapshots with full history of object versions available for the operators using this configuration.

```yaml
authority-store-pruning-config:
  # No pruning of object versions with u64::max for num of epochs.
  # Set a lower value for a smaller objects history.
  num-epochs-to-retain: 18446744073709551615
  # Prune historic transactions of the past epochs
  num-epochs-to-retain-for-checkpoints: 2
```

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/monitoring.mdx
```
---
title: Sui Node Monitoring
description: Monitor Sui node metrics to ensure the health and performance of your node.
---

:::info

These instructions are for advanced users. If you just need a local development environment, you should instead follow the instructions in [Create a Local Sui Network](../developer/getting-started/local-network.mdx) to create a local Full node, validators, and faucet.

:::

Nodes expose on `localhost:9184/metrics` by default.

You can view the metrics in the metrics UI, or you can use a tool like `curl` to get the metrics in a format that is easy to parse.

```sh
$ curl -s http://localhost:9184/metrics | grep -E 'sui_validator|sui_fullnode'
```

## Production monitoring

For production monitoring, we recommend using [Prometheus](https://prometheus.io/) and [Grafana](https://grafana.com/).

You can use grafana agent, grafana alloy, or another tool to scrape the metrics from your node.


```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/validator-config.mdx
```
---
title: Sui Validator Node Configuration
description: Learn how to set up, configure, and manage a Sui Validator node, including staking, reference gas price, and tallying rules.
---

Validators on the Sui network run special nodes and have additional tasks and responsibilities beyond those of Full node operators.

## Requirements to run a validator on Sui 

To run a Sui validator, you must set up and configure a Sui Validator node. After you have a running node, you must have a minimum of 30 million SUI in your staking pool to join the validator set on the Sui network.

To learn how to set up and configure a Sui Validator node, see [Sui for Node Operators](https://github.com/MystenLabs/sui/blob/main/nre/sui_for_node_operators.md) on GitHub. The guide includes all of the information you need to configure your Validator node. It also provides guidance on the tasks you must perform after you join the validator set.

Specific steps you must take include:

- Install and configure Sui
- Configure Port and Protocol settings
- Key management
- Storage configuration
- Software updates
- On-chain commands
- Update the Gas Price Survey
- Reporting other validators

{@include: ../../snippets/staking-pool-reqs.mdx}

## Hardware requirements to run a Validator node

Suggested minimum hardware specifications to run a Sui Validator node:

- CPU: 24 physical cores (or 48 virtual cores)
- Memory: 128 GB
- Storage: 4 TB NVME
- Network: 1 Gbps

## Validator consensus and voting power 

The total voting power on Sui is always 10,000, regardless of the amount staked. Therefore, the quorum threshold is 6,667. There is no limit to the amount of SUI users can stake with a validator. Each validator has consensus voting power proportional to SUI in its staking pool, with one exception: the voting power of an individual validator is capped at 1,000 (10% of the total). If a validator accumulates more than 10% of total stake, the validator's voting power remains fixed at 10%, and the remaining voting power is spread across the rest of the validator set.

### User staking and withdrawals

When users stake SUI tokens, these SUI objects are wrapped into StakedSUI objects. The calculation to determine each user's relative ownership of the staking pool is done directly with the timestamp of the StakedSUI object (which determines the moment at which the deposit took place) and the change in the exchange rates between the deposit epoch and the withdrawal epoch. Each staking pool's data structure contains a time series with that pool's exchange rates. These exchange rates can be used to determine the withdrawals of any of the pool's stakers.

Stake withdrawals are processed immediately with the exchange rate prevailing at the previous epoch's exchange rate. Withdrawals do not have to wait for the current epoch to close. Withdrawals include both the original stake the user deposited and all the stake rewards accumulated up to the previous epoch. Stakers do not earn the rewards accruing to their stake during the epoch at which they withdraw. Since there is no way to know how many stake rewards will be accumulated during the current epoch until the epoch closes, these cannot be included in the withdrawal. Hence, any user can withdraw their stake immediately and receive:

SUI withdrawn at E' = ( SUI deposited at E ) * ( Exchange Rate at E'-1 / Exchange Rate at E )

### Find the exchange rate 

Each epoch change emits a `0x2::validator_set::ValidatorEpochInfo` event per validator with the exchange rate information. You can use the Events API to query events.

## Staking rewards 

Within a given validator staking pool, all stakers receive the same proportion of rewards through the pool's exchange rate appreciation. In addition, since validators earn commissions over the stake they manage, validators receive additional `StakedSUI` objects at the end of each epoch in proportion to the amount of commissions their staking pool earns.

Staking rewards are funded by transaction gas fees collected during the current epoch and by stake subsidies released at the end of the epoch.

StakeRewards = StakeSubsidies + GasFees

Stake subsidies are intended to subsidize the network during its early phases and are funded by a 10% allocation of SUI tokens. After this allocation depletes, the entirety of stake rewards will be made up of gas fees collected through regular network operations.

Stake rewards are made up of gas fees and stake subsidies. The total amount distributed throughout each epoch is determined as follows:

- **Stake Subsidies:** The amount distributed in each epoch is determined prior to the beginning of the epoch according to a predefined schedule.
- **Gas Fees:** Each epoch's amount depends on the total gas fees collected throughout the epoch. Each Sui transaction pays gas fees depending on two variables, the amount of executed gas units and the gas price:
_GasFee = GasPrice _ GasUnits*

The total amount of gas fees collected corresponds to the sum of gas fees across all transactions processed in the epoch. During regular market conditions, the vast majority of transactions should have a `GasPrice` equal to the `ReferenceGasPrice`.

### User staking and rewards 

A stake deposit request goes into a pending state immediately in the staking pool as soon as it is made. Sui Wallet reflects any pending stake deposit requests for the user's account. However, pending stake deposit requests do not take effect until the end of the epoch during which the request is made.

A withdrawal (un-stake) request is processed immediately as soon as it is received. The staker obtains the originally deposited SUI together with all accrued stake rewards up to the previous epoch boundary – in other words, they do not include stake rewards for the current epoch.

Users can't withdraw a portion of their active stake. They must withdraw all staked SUI at the same time. Users can, however, stake using multiple `StakedSui` objects by splitting their SUI into multiple coins. They can then perform a partial withdrawal from a validator by un-staking only some of the `StakedSUI` objects.

## Reference gas price 

Sui is designed such that end-users can expect the gas price to be stable and predictable during regular network operations. This is achieved by having validators set the network's reference gas price at the beginning of each epoch.

Operationally this is achieved through a gas price survey that occurs as follows:

- During each epoch E, each validator submits what they think the optimal reference gas price should be for the next epoch E+1.
- At the epoch boundary, when Sui transitions from epoch E to epoch E+1, the network observes the gas price quotes across the validator set and sets the 2/3 percentile weighted by stake as the epoch's reference gas price. Hence the reference gas price is constant throughout each epoch and is only updated when the epoch changes.

For example, assume that there are seven validators with equal stake, and the price quotes they submit are `{15, 1, 4, 2, 8, 3, 23}`. The protocol sets the reference gas price at 8.

In practice, the process for submitting a gas price quote for the Gas Price Survey is a straightforward one. Each validator owns an object that contains their quote for the reference gas price. To change their response, they must update the value in that object.

For example, to set the price quote for the next epoch to 42, run:

{@include: ../../snippets/info-gas-budget.mdx}

```sh
$ sui client call --package <PACKAGE-ID> --module sui_system --function request_set_gas_price --args 0x5 \"42\" --gas-budget <GAS-AMOUNT>
```

Importantly, the gas object's value persists across epochs so that a validator who does not update and submit a new quote uses the same quote from the previous epoch. Hence, a validator seeking to optimize its own operations should update its quote every epoch in response to changes in network operations and market conditions.

## Validator slashing and tallying rule 

Sui is designed to encourage and enforce community monitoring of the validator set. This is done through the Tallying Rule by which each validator monitors and scores every other validator in order to ensure that everyone is operating efficiently and in the network's best interest. Validators that receive a low score can be penalized with slashed stake rewards.

The protocol only computes the global Tallying Rule score at the epoch boundary and so relies on validators monitoring actively and changing their individual scores whenever they detect changes in other validator behavior. In general, the Tallying Rule default option should always be a score of one for all validators and only be changed to zero upon determining bad operations. In practice, the Tallying Rule consists of a set of objects each validator owns that default to scores of one and thus a validator will generally be passive and only update the object corresponding to another validator's score whenever needed.

For example, to report a validator whose Sui address is `0x44840a79dd5cf1f5efeff1379f5eece04c72db13512a2e31e8750f5176285446` as bad or non-performant, run:

```sh
$ sui client call --package <PACKAGE-ID> --module sui_system --function report_validator --args 0x5 0x44840a79dd5cf1f5efeff1379f5eece04c72db13512a2e31e8750f5176285446 --gas-budget <GAS-AMOUNT>
```

The Tallying Rule should be implemented through a social equilibrium. The validator set should actively monitor itself and if one validator is clearly non-performant, then the other validators should score that validator with a 0 and slash its rewards. Community members can launch public dashboards tracking validator performance and that can be used as further signal into a validator's operations. There is no limit on the number of validators that can receive a 0 tallying score in an epoch.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/bridge-node-configuration.mdx
```
---
title: Sui Bridge Validator Node Configuration
sidebar_label: Sui Bridge Node Configuration
description: Correct configuration of your node ensures optimal performance and valid metrics data.
---

Running a Bridge Validator Node (Bridge Node) requires registering your node with the bridge committee. Correct configuration of your node ensures optimal performance and valid metrics data. Follow this topic to make sure your Bridge Node is set up properly.

## Prerequisites

To set up and run a Bridge Node, you need to install `sui` and `sui-bridge-cli`. You can install them using one of the following options: 

Install from tip of `main`:
```sh
$ cargo install --locked --git "https://github.com/MystenLabs/sui.git" sui sui-bridge-cli
```
Install with a commit sha:
```sh
$ cargo install --locked --git "https://github.com/MystenLabs/sui.git" --rev {SHA} sui sui-bridge-cli
```

## Committee registration

To join the network you must first register with the bridge validator committee.

### Prepare for metadata

The required metadata includes two things:

- `BridgeAuthorityKey`, an ECDSA key to sign messages. Because this is a hot key that is kept in memory, it’s fine to use the following tool to generate one and write it to file.
- A REST API URL where the Bridge Node listens to and serves requests. Example: `https://bridge.example-sui-validator.io:443`. Make sure the port is correct and the URL does not contain any invalid characters, like quotes for example.

To create a `BridgeAuthorityKey`, run
```sh
$ sui-bridge-cli create-bridge-validator-key <PATH-TO-WRITE>
```
where `<PATH-TO-WRITE>` is the location to write the key pair to.

:::info

It's highly recommended you create a new key pair in a secure environment (for example, in the same machine where your node runs) to avoid key compromise.

:::

### Registration

After you have both authority key file and REST API URL ready, you can register them by using Sui CLI:

```sh
$ sui validator register-bridge-committee --bridge-authority-key-path <BRIDGE-AUTHORITY-KEY-PATH> --bridge-authority-url <BRIDGE-AUTHORITY-URL>
```

#### Offline signing {#offline-signing}

If you keep your validator account key in cold storage or you want to perform offline signing, use flags `--print-only` and `--validator-address` (with the value for the validator address). This prints serialized unsigned transaction bytes, then you can use your preferred signing process to produce signed bytes. 

Run the following command to execute it:

```sh
$ sui client execute-signed-tx
```

#### Update metadata (before committee is finalized)

Both key and URL are changeable **before the committee is finalized**. If you wish to update metadata, simply rerun `sui validator register-bridge-committee`.

#### View registered metadata

To double check you registered the correct metadata on chain, run

```sh
$ sui-bridge-cli view-bridge-registration --sui-rpc-url {SUI-FULLNODE-URL}
```

## Update metadata (after committee is finalized)

Use the following command to update bridge node URL:
```sh
$ sui validator update-bridge-committee-node-url
```
Refer to [offline signing section](#offline-signing) in this page for how to sign the transaction offline.

Authoritiy key rotation is not supported yet.


## Bridge Node

You have several options when configuring your Bridge Node for performance and metrics monitoring. Follow the instructions that follow to configure your node for best results in your environment.  

### Bridge Node hardware requirements

Suggested hardware requirements:

- CPU: 6 physical cores
- Memory: 16GB
- Storage: 200GB
- Network: 100Mbps

### WAF protection for Bridge Node

To protect against distributed denial of service (DDoS) attacks and similar attacks intended to expend validator resources, you must provide rate limit protection for the bridge server. 

In addition to protection, this gives node operators fine-grained control over the rate of requests they receive, and observability into those requests.

The currently recommended rate limit is `50 requests/second per unique IP`.

#### Web application firewall (WAF) options

You can use a managed cloud service, for example:

- [Cloudflare WAF](https://www.cloudflare.com/en-ca/application-services/products/waf/)
- [AWS WAF](https://aws.amazon.com/waf/)
- [GCP Cloud Armor](https://cloud.google.com/security/products/armor)

It's also possible to use an open source load balancer, such as [HAProxy](https://www.haproxy.org/) for a practical, IP-based rate limit.

A shortened example HAProxy configuration looks like the following:

```
frontend http-in
    bind *:80
    # Define an ACL to count requests per IP and block if over limit
    acl too_many_requests src_http_req_rate() gt 50
    # Track the request rate per IP
    stick-table type ip size 1m expire 1m store http_req_rate(1s)
    # Check request rate and deny if the limit is exceeded
    http-request track-sc0 src
    http-request deny if too_many_requests

    default_backend bridgevalidator

backend bridgevalidator
    # Note the port needs to match the value in Bridge Node config, default is 9191
    server bridgevalidator 0.0.0.0:9191
```

If choosing to use an open source load balancing option, make sure to set up metrics collection and alerting on the service.

### Bridge Node config

Use `sui-bridge-cli` command to create a template. If you want to run `BridgeClient` (see the following section), pass `--run-client` as a parameter.

```sh
$ sui-bridge-cli create-bridge-node-config-template {PATH}
$ sui-bridge-cli create-bridge-node-config-template --run-client {PATH}
```

The generated configuration includes the following parameters:

| Parameter | Description |
| --- | --- |
| `server-listen-port` | The port that Bridge Node listens to for handling requests. |
| `metrics-port` | Port to export Prometheus metrics. |
| `bridge-authority-key-path` | The path to the Bridge Validator key, generated from `sui-bridge-cli create-bridge-validator-key` command referenced previously. |
| `run-client` | Whether Bridge Client should be enabled in Bridge Node (more instructions follow). |
| `approved-governance-actions` | A list of governance actions that you want to support. |
| `sui:sui-rpc-url` | Sui RPC URL. |
| `sui:sui-bridge-chain-id` | `0` for Sui Mainnet, `1` for Sui Testnet. |
| `eth:eth-rpc-url` | Ethereum RPC URL. |
| `eth:eth-bridge-proxy-address` | The proxy address for Bridge Solidity contracts on Ethereum. |
| `eth:eth-bridge-chain-id` | `10` for Ethereum Mainnet, `11` for Sepolia Testnet. |
| `eth:eth-contracts-start-block-fallback` | The starting block BridgeNodes queries for from Ethereum FullNode. This number should be the block where Solidity contracts are deployed or slightly before. |
| `metrics:push-url` | The url of the remote Sui metrics pipeline (for example, `https://metrics-proxy.[testnet_OR_mainnet].sui.io:8443/publish/metrics`). See the [metrics push section](#metrics-push) that follows for more details. | 

With `run-client: true`, you can find these additional fields in the generated config:

| Parameter | Description |
| --- | --- |
| `db-path` | Path of BridgeClient database, for BridgeClient. |
| `sui:bridge-client-key-path` | The file path of Bridge Client key. This key can be generated with `sui-bridge-cli create-bridge-client-key` as previously shown. When `run-client` is true but you do not provide `sui:bridge-client-key-path`, it defaults to use the Bridge Validator key to submit transactions on Sui. This is not recommended for the sake of key separation. | 

### Bridge Client

`BridgeClient` orchestrates bridge transfer requests. It is **optional** to run for a `BridgeNode`. `BridgeClient` submits transaction on the Sui network. Thus when it's enabled, you need a Sui account key with enough SUI balance.

To enable `bridge_client` feature on a `BridgeNode`, set the following parameters in `BridgeNodeConfig`:

```yaml
run-client: true
db-path: <PATH-TO-DB>
sui:
    bridge-client-key-path: <PATH-TO-BRIDGE-CLIENT-KEY>
```

To create a `BridgeClient` key pair, run

```sh
$ sui-bridge-cli create-bridge-client-key <PATH_TO_BRIDGE_CLIENT_KEY>
```
This prints the newly created Sui Address. Then we need to fund this address with some SUI for operations.


### Build Bridge Node

Build or install Bridge Node in one of the following ways:

- Use `cargo install`.
    ```sh
    $ cargo install --locked --git "https://github.com/MystenLabs/sui.git" --branch {BRANCH-NAME} sui-bridge
    ```
    Or
    ```sh
    $ cargo install --locked --git "https://github.com/MystenLabs/sui.git" --rev {SHA-NAME} sui-bridge
    ```
- Compile from source code
    ```sh
    $ git clone https://github.com/MystenLabs/sui.git
    ```
    ```sh
    $ cd sui
    ```
    ```sh
    $ git fetch origin {BRANCH-NAME|SHA}
    ```
    ```sh
    $ git checkout {BRANCH-NAME|SHA}
    ```
    ```sh
    $ cargo build --release --bin sui-bridge
    ```
- Use `curl`/`wget` pre-built binaries (for Linux/AMD64 only).
    ```sh
    $ curl https://sui-releases.s3.us-east-1.amazonaws.com/{SHA}/sui-bridge -o sui-bridge
    ```
- Use pre-built Docker image. Pull from Docker Hub: `mysten/sui-tools:{SHA}`


### Run Bridge Node

Running Bridge Node is similar to running a Sui node using systemd or Ansible. The command to start the Bridge Node is:

```sh
$ RUST_LOG=info,sui_bridge=debug sui-bridge --config-path {BRIDGE-NODE-CONFIG-PATH}
```

### Ingress

Bridge Node listens for TCP connections over port `9191` (or the preferred port in the configuration file). You must allow incoming connections for that port on the host that is running Bridge Node.

Test ingress with `curl` on a remote machine and expect a `200` response:

```sh
$ curl -v {YOUR_BRIDGE_URL}
```

### Bridge Node monitoring

Use `uptime` to check if the node is running.

You can find a full list of Bridge Node metrics and their descriptions in the [`sui-bridge` crate](https://github.com/MystenLabs/sui/blob/main/crates/sui-bridge/src/metrics.rs).

#### When `run-client: false`

In this case Bridge Node runs as a passive observer and does not proactively poll on-chain activities. Important metrics to monitor in this case are the request handling metrics, such as:

- `bridge_requests_received`
- `bridge_requests_ok`
- `bridge_err_requests`
- `bridge_requests_inflight`
- `bridge_eth_rpc_queries`
- `bridge_eth_rpc_queries_latency`
- `bridge_signer_with_cache_hit`
- `bridge_signer_with_cache_miss`
- `bridge_sui_rpc_errors`

#### When `run-client: true`

In this case, Bridge Client is toggled on and syncs with blockchains proactively. The best metrics to track progress are:

- `bridge_last_synced_sui_checkpoints`
- `bridge_last_synced_eth_blocks`
- `bridge_last_finalized_eth_block`
- `bridge_sui_watcher_received_events`
- `bridge_eth_watcher_received_events`
- `bridge_sui_watcher_received_actions`
- `bridge_eth_watcher_received_actions`

`bridge_gas_coin_balance` is also a critical metric to track the balance of your client gas coin, and top up after it dips below a certain threshold.

### Metrics push {#metrics-push}

The Bridge Nodes can push metrics to the remote proxy for network-level observability.

To enable metrics push, set the following parameters in `BridgeNodeConfig`:

```yaml
metrics:
    push-url: https://metrics-proxy.[testnet|mainnet].sui.io:8443/publish/metrics
```

The proxy authenticates pushed metrics by using the metrics key pair. It is similar to `sui-node` pushing metrics with `NetworkKey`. Unlike `NetworkKey`, the Bridge Node metrics key is not recorded on chain and can be ephemeral. The metrics key is loaded from the `metrics-key-pair` field in `BridgeNodeConfig` if provided, otherwise a new key pair is generated on the fly. The proxy queries node public keys periodically by hitting the metrics public API key of each node.

When Bridge Node starts, it might log this line once:

```
unable to push metrics: error sending request for url (xyz); new client will be created
```

This is okay to ignore as long as it does not persist. Otherwise, try:

```sh
$ curl -i  {your-bridge-node-url-onchain}/metrics_pub_key
```

and make sure the public key is correctly returned.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/observability.mdx
```
---
title: Logging, Tracing, Metrics, and Observability
sidebar_label: Observability
draft: true
---

Good observability capabilities are key to the development and growth of Sui. This is made more challenging by the distributed and asynchronous nature of Sui, with multiple client and validator processes distributed over a potentially global network.

The observability stack in Sui is based on the [Tokio tracing](https://tokio.rs/blog/2019-08-tracing) library. The rest of this document highlights specific aspects of achieving good observability through structured logging and metrics in Sui.

:::info

The output here is largely for the consumption of Sui operators, administrators, and developers. The content of logs and traces do not represent the authoritative, certified output of validators and are subject to potentially byzantine behavior.

:::

## Contexts, scopes, and tracing transaction flow {#context-scope-trace}

In a distributed and asynchronous system like Sui, one cannot rely on looking at individual logs over time in a single thread. To solve this problem, use the approach of structured logging. Structured logging offers a way to tie together logs, events, and blocks of functionality across threads and process boundaries.

### Spans and events {#spans-and-events}

In the [Tokio tracing](https://tokio.rs/blog/2019-08-tracing) library, structured logging is implemented using [spans and events](https://docs.rs/tracing/0.1.31/tracing/index.html#core-concepts).
Spans cover a whole block of functionality - like one function call, a future or asynchronous task, etc. They can be nested, and key-value pairs in spans give context to events or logs inside the function.

- spans and their key-value pairs add essential context to enclosed logs, such as a transaction ID.
- spans also track time spent in different sections of code, enabling distributed tracing functionality.
- individual logs can also add key-value pairs to aid in parsing, filtering and aggregation.

Here is a list of context information of interest:

- TX Digest
- Object references/ID, when applicable
- Address
- Certificate digest, if applicable
- For Client HTTP endpoint: route, method, status
- Epoch
- Host information, for both clients and validators

In the digest, `process_tx` is a span that covers handling the initial transaction request, and "Checked locks" is a single log message within the transaction handling method in the validator.

Every log message that occurs within the span inherits the key-value properties defined in the span, including the `tx_digest` and any other fields that are added. Log messages can set their own keys and values. The fact that logs inherit the span properties allows you to trace, for example, the flow of a transaction across thread and process boundaries.

## Key-value pairs schema {#key-value-pairs-schema}

Spans capture not a single event but an entire block of time; so start, end, duration, etc. can be captured and analyzed for tracing, performance analysis, and so on.

### Tags - keys {#tags-keys}

The idea is that every event and span would get tagged with key-value pairs. Events that log within any context or nested contexts would also inherit the context-level tags.

These tags represent _fields_ that can be analyzed and filtered by. For example, one could filter out broadcasts and see the errors for all instances where the bad stake exceeded a certain amount, but not enough for an error.

## Logging levels {#logging-levels}

This is always tricky, to balance the right amount of verbosity especially by default -- while keeping in mind this is a high performance system.

| Level | Type of Messages                                                                                           |
| ----- | ---------------------------------------------------------------------------------------------------------- |
| Error | Process-level faults (not transaction-level errors, there could be a ton of those)                         |
| Warn  | Unusual or byzantine activity                                                                              |
| Info  | High level aggregate stats, major events related to data sync, epoch changes.                              |
| Debug | High level tracing for individual transactions, eg Gateway/client side -> validator -> Move execution etc. |
| Trace | Extremely detailed tracing for individual transactions                                                     |
|       |                                                                                                            |

Going from info to debug results in a much larger spew of messages.

Use the `RUST_LOG` environment variable to set both the overall logging level as well as the level for individual components. Filtering down to specific spans or tags within spans is even possible.

For more details, see the [EnvFilter](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html) topic.

## Metrics {#metrics}

Sui includes Prometheus-based metrics:

- `rpc_requests_by_route` and related for RPC Server API metrics and latencies (see `rpc-server.rs`)
- Validator transaction metrics (see `AuthorityMetrics` in `authority.rs`)

## Viewing logs, traces, metrics {#viewing-logs-traces-metrics}

The tracing architecture is based on the idea of [subscribers](https://github.com/tokio-rs/tracing#project-layout) which can be plugged into the tracing library to process and forward output to different sinks for viewing. Multiple subscribers can be active at the same time.

You can feed JSON logs, for example, through a local sidecar log forwarder such as [Vector](https://vector.dev), and then onwards to destinations such as ElasticSearch.

The use of a log and metrics aggregator such as Vector allows for easy reconfiguration without interrupting the validator server, as well as offloading observability traffic.

Metrics: served with a Prometheus scrape endpoint, by default at `<host>:9184/metrics`.

### Stdout (default) {#stdout-default}

By default, logs (but not spans) are formatted for human readability and output to stdout, with key-value tags at the end of every line.

You can configure `RUST_LOG` for custom logging output, including filtering - see the [Logging levels](#logging-levels) section earlier in this topic.

### Tracing and span output {#tracing-and-span-output}

To generate detailed span start and end logs, define the `SUI_JSON_SPAN_LOGS` environment variable. This causes all output to be in JSON format, which is not as human-readable, so it is not enabled by default.

You can send this output to a tool or service for indexing, alerts, aggregation, and analysis.

The following example output shows certificate processing in the authority with span logging. Note the `START` and `END` annotations, and notice how `DB_UPDATE_STATE` which is nested is embedded within `PROCESS_CERT`. Also notice `elapsed_milliseconds`, which logs the duration of each span.

```sh
{"v":0,"name":"sui","msg":"[PROCESS_CERT - START]","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.241421Z","target":"sui_core::authority_server","line":67,"file":"sui_core/src/authority_server.rs","tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493"}
{"v":0,"name":"sui","msg":"[PROCESS_CERT - EVENT] Read inputs for transaction from DB","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.246688Z","target":"sui_core::authority","line":393,"file":"sui_core/src/authority.rs","num_inputs":2,"tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493"}
{"v":0,"name":"sui","msg":"[PROCESS_CERT - EVENT] Finished execution of transaction with status Success { gas_used: 18 }","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.246759Z","target":"sui_core::authority","line":409,"file":"sui_core/src/authority.rs","gas_used":18,"tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493"}
{"v":0,"name":"sui","msg":"[DB_UPDATE_STATE - START]","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.247888Z","target":"sui_core::authority","line":430,"file":"sui_core/src/authority.rs","tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493"}
{"v":0,"name":"sui","msg":"[DB_UPDATE_STATE - END]","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.248114Z","target":"sui_core::authority","line":430,"file":"sui_core/src/authority.rs","tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493","elapsed_milliseconds":0}
{"v":0,"name":"sui","msg":"[PROCESS_CERT - END]","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.248688Z","target":"sui_core::authority_server","line":67,"file":"sui_core/src/authority_server.rs","tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493","elapsed_milliseconds":2}
```

### Jaeger (seeing distributed traces) {#jaeger}

To see nested spans visualized with [Jaeger](https://www.jaegertracing.io), do the following:

1.  Run this to get a local Jaeger container:

```sh
$ docker run -d -p6831:6831/udp -p6832:6832/udp -p16686:16686 jaegertracing/all-in-one:latest
```

1.  Run Sui like this (trace enables the most detailed spans):

```sh
$ SUI_TRACING_ENABLE=1 RUST_LOG="info,sui_core=trace" ./sui start
```

1.  Run some transfers with Sui CLI client, or run the benchmarking tool.
1.  Browse to `http://localhost:16686/` and select Sui as the service.

:::info

Separate spans (that are not nested) are not connected as a single trace for now.

:::

### Live async inspection / Tokio Console {#tokio-console}

[Tokio-console](https://github.com/tokio-rs/console) is an awesome CLI tool designed to analyze and help debug Rust apps using Tokio, in real time! It relies on a special subscriber.

1.  Build Sui using a special flag: `RUSTFLAGS="--cfg tokio_unstable" cargo build`.
1.  Start Sui with `SUI_TOKIO_CONSOLE` set to 1.
1.  Clone the console repo and `cargo run` to launch the console.

:::tip

Adding Tokio-console support might significantly slow down Sui validators/gateways.

:::

### Memory profiling {#memory-profiling}

Sui uses the [jemalloc memory allocator](https://jemalloc.net/) by default on most platforms, and there is code that enables automatic memory profiling using jemalloc's sampling profiler, which is very lightweight and designed for production use. The profiling code spits out profiles at most every 5 minutes, and only when total memory has increased by a default 20%. Profiling files are named `jeprof.<TIMESTAMP>.<memorysize>MB.prof` so that it is easy to
correlate to metrics and incidents, for ease of debugging.

For the memory profiling to work, you need to set the environment variable `_RJEM_MALLOC_CONF=prof:true`. If you use the [Docker image](https://hub.docker.com/r/mysten/sui-node) they are set automatically.

Running some allocator-based heap profilers such as [Bytehound](https://github.com/koute/bytehound) will essentially disable automatic jemalloc profiling, because they interfere with or don't implement `jemalloc_ctl` stats APIs.

To view the profile files, one needs to do the following, on the same platform as where the profiles were gathered:

1.  Install `libunwind`, the `dot` utility from graphviz, and jeprof. On Debian: `apt-get install libjemalloc-dev libunwind-dev graphviz`.
1.  Build with debug symbols: `cargo build --profile bench-profiling`
1.  cd to `$SUI_REPO/target/bench-profiling`
1.  Run `jeprof --svg sui-node jeprof.xxyyzz.heap` - select the heap profile based on
    timestamp and memory size in the filename.

:::tip

With automatic memory profiling, it is no longer necessary to configure environment variables beyond those previously listed. It is possible to configure custom profiling options:

- [Heap Profiling](https://github.com/jemalloc/jemalloc/wiki/Use-Case%3A-Heap-Profiling)
- [heap profiling with jemallocator](https://gist.github.com/ordian/928dc2bd45022cddd547528f64db9174)

For example, set `_RJEM_MALLOC_CONF` to:
`prof:true,lg_prof_interval:24,lg_prof_sample:19`

The preceding setting means: turn on profiling, sample every 2^19 or 512KB bytes allocated, and dump out the profile every 2^24 or 16MB of memory allocated. However, the automatic profiling is designed to produce files that are better named and at less intervals, so overriding the default configuration is not usually recommended.

:::

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/updates.mdx
```
---
title: Updating a Full Node
description: Update your Sui Full node to the latest version to remain in sync with the network.
---

## Sui release process

Each Sui network is deployed on a consistent schedule. There are extenuating circumstances that might delay releases occasionally, but these delays are rare and communicated through [official channels](#communication).

- `devnet`: Deployed every week on Mondays.
- `testnet`: Deployed every week on Tuesdays.
- `mainnet`: Deployed every two weeks on Wednesdays.

:::info

For additional details, see each network's [release schedule and configuration](https://sui.io/networkinfo).

:::

Whenever Sui releases a new version, you must update your Full node with the release to ensure compatibility with the network it connects to. For example, if you use Sui Testnet you should install the version of Sui running on Sui Testnet.

Any release that contains a protocol change will need to be followed before the protocol upgrade takes place (when enough stake within the validator set upgrades, the new protocol version is enacted in the next epoch).
If you do not update your Full node, you will not be able to connect to the network after the protocol upgrade takes place.

## Communication

Releases are announced on [Sui Discord server](https://discord.com/invite/sui) and [node-operators](https://groups.google.com/a/groups.sui.io/g/node-operators) Google group.

### Discord channels
- `devnet`: [`#devnet-updates`](https://discord.com/channels/916379725201563759/1004638487078772736)
- `testnet`: [`#tn-validator-announcements`](https://discord.com/channels/916379725201563759/1003660994381353101), [`#testnet-updates`](https://discord.com/channels/916379725201563759/1095151359642304612), ⁠and [`#node-announcements`](https://discord.com/channels/916379725201563759/1002231298888306718) channels.
- `mainnet`: [`⁠#mn-validator-announcements`](https://discord.com/channels/916379725201563759/1093852827627040768), [`#mainnet-updates`](https://discord.com/channels/916379725201563759/1103082453792464906), and [`#node-announcements`](https://discord.com/channels/916379725201563759/1002231298888306718) channels.

## Update your Full node 

You can track the latest version of Sui on the [Sui Releases](https://github.com/MystenLabs/sui/releases) page on GitHub.
The schedule for each network is available in the [Network Release Schedule](https://sui.io/networkinfo) page.

It is reasonable to have to shut down your Full node to perform an update, whether that be a rolling restart in Kubernetes, or a systemctl stop on a Linux machine to replace the sui-node binary.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/sui-full-node.mdx
```
---
title: Sui Full Node Configuration
description: Operate a Sui Full node to validate blockchain activities, like transactions, checkpoints, and epoch changes.  
---

:::info

These instructions are for advanced users. If you just need a local development environment, you should instead follow the instructions in [Create a Local Sui Network](../developer/getting-started/local-network.mdx) to create a local Full node, validators, and faucet.

:::

Sui Full nodes validate blockchain activities, including transactions, checkpoints, and epoch changes. Each Full node stores and services the queries for the blockchain state and history.

This role enables validators to focus on servicing and processing transactions. When a validator commits a new set of transactions (or a block of transactions), the validator pushes that block to all connected Full nodes that then service the queries from clients.

## Features 

Sui Full nodes:
- Track and verify the state of the blockchain, independently and locally.
- Serve read requests from clients.

## State synchronization 
Sui Full nodes sync with validators to receive new transactions on the network.

A transaction requires a few round trips to 2f+1 validators to form a transaction certificate (TxCert).

This synchronization process includes:

1. Following 2f+1 validators and listening for newly committed transactions.
1. Making sure that 2f+1 validators recognize the transaction and that it reaches finality.
1. Executing the transaction locally and updating the local DB.

This synchronization process requires listening to at a minimum 2f+1 validators to ensure that a Full node has properly processed all new transactions. Sui will improve the synchronization process with the introduction of checkpoints and the ability to synchronize with other Full nodes.

## Architecture 

A Sui Full node is essentially a read-only view of the network state. Unlike validator nodes, Full nodes cannot sign transactions, although they can validate the integrity of the chain by re-executing transactions that a quorum of validators previously committed.

Today, a Sui Full node maintains the full history of the chain.

Validator nodes store only the latest transactions on the frontier of the object graph (for example, transactions with >0 unspent output objects).

## Full node setup 

Follow the instructions here to run your own Sui Full node. Sui Full nodes run using the `sui-node` binary.

### Hardware requirements 

Suggested minimum hardware to run a Sui Full node:

- CPUs: 8 physical cores / 16 vCPUs
- RAM: 128 GB
- Storage (SSD): 4 TB NVMe drive

### Software requirements 

Sui recommends running Sui Full nodes on Linux. Sui supports the Ubuntu and Debian distributions. You can run a Sui Full node on macOS,
but this is only recommended for development and not for production use.

Make sure to [update Rust](https://doc.rust-lang.org/book/ch01-01-installation.html#updating-and-uninstalling).

Use the following command to install additional Linux dependencies.

```sh
$ sudo apt-get update \
&& sudo apt-get install -y --no-install-recommends \
tzdata \
libprotobuf-dev \
ca-certificates \
build-essential \
libssl-dev \
libclang-dev \
libpq-dev \
pkg-config \
openssl \
protobuf-compiler \
git \
clang \
cmake
```

## Running a Full node {#running-a-full-node}

Instructions for building, installing, or downloading the `sui-node` binary are available at [Sui Install](../developer/getting-started/sui-install.mdx). 
These install instructions are specific to the `sui` cli, but apply to the `sui-node` binary as well.

There are many ways to run a Sui Full node (bare metal, virtual machine, Kubernetes statefulset, and so on), and the solution that you choose depends on your specific needs as well as the infrastructure that you have available.

There are some specific considerations to keep in mind when running a Sui Full node that apply to all environments:

* [Genesis](./genesis.mdx): You must download the genesis blob for the network that you want to connect to, and make it available to the `sui-node`.
* [Data Storage](./data-management.mdx): Sui Full nodes _can_ require a significant amount of disk space to store the blockchain history. If you plan to use your Full node to serve RPC requests, you must also plan for the storage of index files, which requires a significant amount of disk space.
* [Monitoring](./monitoring.mdx): Sui Full nodes expose metrics about the node's health and the state of the Sui network.
* [Updates](./updates.mdx): Sui Full nodes must be updated to the latest version to remain in sync with the network.
* [Archival Fallback](./archives.mdx): The archival fallback allows you to sync checkpoints from any point in the chain's history. The network `seed-peers` below only keep a few epochs of history.


### Using Docker Compose 

There's a guide in the Sui repository on running a Full node via [Docker Compose](https://github.com/MystenLabs/sui/tree/main/docker/fullnode#readme). 
This alone is not suitable for a production environment, but can be used to get a Full node up and running quickly on a virtual machine or local machine for development purposes.
Refer to [Running a Full node](#running-a-full-node) for instructions relevant to production use cases.


### Setting up a Full node

When you are ready to run `sui-node` in your production environment, you can set up your Full node by completing the following steps:

1. Make a copy of the [Full node YAML template](https://github.com/MystenLabs/sui/blob/main/crates/sui-config/data/fullnode-template.yaml):
    ```sh
    $ cp crates/sui-config/data/fullnode-template.yaml fullnode.yaml
    ```
1. Download the genesis blob for the network to use:
    - [Devnet genesis blob](https://github.com/MystenLabs/sui-genesis/raw/main/devnet/genesis.blob):
        ```sh
        $ curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/devnet/genesis.blob
        ```
    - [Testnet genesis blob](https://github.com/MystenLabs/sui-genesis/raw/main/testnet/genesis.blob):
        ```sh
        $ curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/testnet/genesis.blob
        ```
    - [Mainnet genesis blob](https://github.com/MystenLabs/sui-genesis/raw/main/mainnet/genesis.blob):
        ```sh
        $ curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/mainnet/genesis.blob
        ```
1. For Testnet or Mainnet: Edit the `fullnode.yaml` file to include peer nodes for state synchronization. Append the following to the end of the current configuration:

    <Tabs groupId="network">

    <TabItem label="Mainnet" value="mainnet">

    ```sh
    p2p-config:
      seed-peers:
        - address: /dns/mel-00.mainnet.sui.io/udp/8084
          peer-id: d32b55bdf1737ec415df8c88b3bf91e194b59ee3127e3f38ea46fd88ba2e7849
        - address: /dns/ewr-00.mainnet.sui.io/udp/8084
          peer-id: c7bf6cb93ca8fdda655c47ebb85ace28e6931464564332bf63e27e90199c50ee
        - address: /dns/ewr-01.mainnet.sui.io/udp/8084
          peer-id: 3227f8a05f0faa1a197c075d31135a366a1c6f3d4872cb8af66c14dea3e0eb66
        - address: /dns/lhr-00.mainnet.sui.io/udp/8084
          peer-id: c619a5e0f8f36eac45118c1f8bda28f0f508e2839042781f1d4a9818043f732c
        - address: /dns/sui-mainnet-ssfn-1.nodeinfra.com/udp/8084
          peer-id: 0c52ca8d2b9f51be4a50eb44ace863c05aadc940a7bd15d4d3f498deb81d7fc6
        - address: /dns/sui-mainnet-ssfn-2.nodeinfra.com/udp/8084
          peer-id: 1dbc28c105aa7eb9d1d3ac07ae663ea638d91f2b99c076a52bbded296bd3ed5c
        - address: /dns/sui-mainnet-ssfn-ashburn-na.overclock.run/udp/8084
          peer-id: 5ff8461ab527a8f241767b268c7aaf24d0312c7b923913dd3c11ee67ef181e45
        - address: /dns/sui-mainnet-ssfn-dallas-na.overclock.run/udp/8084
          peer-id: e1a4f40d66f1c89559a195352ba9ff84aec28abab1d3aa1c491901a252acefa6
        - address: /dns/ssn01.mainnet.sui.rpcpool.com/udp/8084
          peer-id: fadb7ccb0b7fc99223419176e707f5122fef4ea686eb8e80d1778588bf5a0bcd
        - address: /dns/ssn02.mainnet.sui.rpcpool.com/udp/8084
          peer-id: 13783584a90025b87d4604f1991252221e5fd88cab40001642f4b00111ae9b7e
    ```

    </TabItem>
    <TabItem label="Testnet" value="testnet">

    ```sh
    p2p-config:
      seed-peers:
        - address: /dns/yto-tnt-ssfn-01.testnet.sui.io/udp/8084
          peer-id: 2ed53564d5581ded9b6773970ac2f1c84d39f9edf01308ff5a1ffe09b1add7b3
        - address: /dns/yto-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: 6563732e5ab33b4ae09c73a98fd37499b71b8f03c27b5cc51acc26934974aff2
        - address: /dns/nrt-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: 23a1f7cd901b6277cbedaa986b3fc183f171d800cabba863d48f698f518967e1
        - address: /dns/ewr-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: df8a8d128051c249e224f95fcc463f518a0ebed8986bbdcc11ed751181fecd38
        - address: /dns/lax-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: f9a72a0a6c17eed09c27898eab389add704777c03e135846da2428f516a0c11d
        - address: /dns/lhr-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: 9393d6056bb9c9d8475a3cf3525c747257f17c6a698a7062cbbd1875bc6ef71e
        - address: /dns/mel-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: c88742f46e66a11cb8c84aca488065661401ef66f726cb9afeb8a5786d83456e
    ```

    </TabItem>

    </Tabs>
1. Optional: Set up the [Archival Fallback](./archives.mdx), which allows you to sync checkpoints if you fall behind the network's `seed-peers`.
1. Optional: Skip this step to accept the default paths to resources. Edit the fullnode.yaml file to use custom paths.
1. Update the `db-path` field with the path to the Full node database.
    `db-path: "/db-files/sui-fullnode"`
1. Update the `genesis-file-location` with the path to genesis.blob.
    ```sh
    genesis:
        genesis-file-location: "/sui-fullnode/genesis.blob"
    ```

### Starting your Full node {#starting-a-full-node}

You should not start syncing your Full node from the start of the genesis. This will take a very long time and consume a lot of resources (including likely filling up your disk).

Instead, start your Full node from a recent snapshot. You can find details on how to obtain a snapshot from the [Sui Snapshots guide](./snapshots.mdx).

Now that you have your Full node config file set up, and you've obtained a snapshot, you can start your Full node by running the `sui-node` binary with your `fullnode.yaml` configuration file:

```sh
$ sui-node --config-path fullnode.yaml
```

It's a good idea to use something like systemd to manage your Full node in a production environment.

### Troubleshooting 
If you receive a `cannot find -lpq` error, you are missing the `libpq` library. Use `sudo apt-get install libpq-dev` to install on Linux, or `brew install libpq` on MacOS. After you install on MacOS, create a Homebrew link using `brew link --force libpq`. For further context, reference the [issue on Stack Overflow](https://stackoverflow.com/questions/70313347/ld-library-not-found-for-lpq-when-build-rust-in-macos?rq=1).

If you receive the following error:

```sh
panicked at error binding to 0.0.0.0:9184: error creating server listener: Address already in use (os error 98)
```

Then update the metrics address in your fullnode.yaml file to use port `9180`.

```sh
metrics-address: "0.0.0.0:9180"
```

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/exchange-integration.mdx
```
---
title: Sui Exchange Integration Guide
description: Learn the primary tasks necessary to integrate SUI, the token native to the Sui network, into a cryptocurrency exchange.
---

This topic describes how to integrate SUI, the token native to the Sui network, into a cryptocurrency exchange. The specific requirements and processes to implement an integration vary between exchanges. Rather than provide a step-by-step guide, this topic provides information about the primary tasks necessary to complete an integration. After the guidance about how to configure an integration, you can also find information and code samples related to staking on the Sui network.

## Requirements to configure a SUI integration

The requirements to configure a SUI integration include:
 - A Sui Full node. You can operate your own Sui Full node or use a Full node from a node operator.
 - Suggested hardware requirements to run a Sui Full node:
    - CPU: 8 physical cores / 16 vCPUs
    - RAM: 128 GB
    - Storage (SSD): 4 TB NVMe drive

For best results, run Sui Full nodes on Linux. Sui supports the Ubuntu and Debian distributions. You can also fun a Full node on macOS.

## Configure a Sui Full node

You can set up and configure a [Sui Full node](./sui-full-node.mdx) using Docker or directly from source code in the Sui GitHub repository.

## Set up Sui addresses

Sui addresses do not require on-chain initialization, you can spend from an address if it corresponds to your private key. You can derive a 32-byte Sui address by hashing the signature scheme flag byte concatenated with public key bytes `flag || pubkey` using the [BLAKE2b](https://www.blake2.net/) (256 bits output) hashing function.

Currently, Sui address supports these signature schemes: pure Ed25519, Secp256k1, Secp256r1 and multisig. The corresponding flag bytes are 0x00, 0x01, 0x02, 0x03 respectively.

The following code sample demonstrates how to derive a Sui address in Rust:

```rust
let flag = 0x00; // 0x00 = ED25519, 0x01 = Secp256k1, 0x02 = Secp256r1, 0x03 = multiSig
// Hash the [flag, public key] bytearray using Blake2b
let mut hasher = DefaultHash::default();
hasher.update([flag]);
hasher.update(pk);
let arr = hasher.finalize();
let sui_address_string = hex::encode(arr);
```

## Displaying addresses

Sui supports both addresses with and without a `0x` prefix. Sui recommends that you always include the `0x` prefix in API calls and when you display user addresses.

## Track balance changes for an address

You can track balance changes by calling `sui_getBalance` at predefined intervals. This call returns the total balance for an address. The total includes any coin or token type, but this document focuses on SUI. You can track changes in the total balance for an address between subsequent `sui_getBalance` requests.

The following bash example demonstrates how to use `sui_getBalance` for address `0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3`. If you use a network other than Devnet, replace the value for `rpc` with the URL to the appropriate Full node.

```sh
rpc="https://fullnode.devnet.sui.io:443"
address="0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3"
data="{\"jsonrpc\": \"2.0\", \"method\": \"sui_getBalance\", \"id\": 1, \"params\": [\"$address\"]}"
curl -X POST -H 'Content-type: application/json' --data-raw "$data" $rpc
```

The response is a JSON object that includes the `totalBalance` for the address:
```json
{
  "jsonrpc":"2.0",
  "result":{
     "coinType":"0x2::sui::SUI",
     "coinObjectCount":40,
     "totalBalance":10000000000,
     "lockedBalance":{

     }
  },
  "id":1
}
```

The following example demonstrates using `sui_getBalance` in Rust:
```rust
use std::str::FromStr;
use sui_sdk::types::base_types::SuiAddress;
use sui_sdk::{SuiClient, SuiClientBuilder};


#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
   let sui = SuiClientBuilder::default().build(
      "https://fullnode.devnet.sui.io:443",
   ).await.unwrap();
   let address = SuiAddress::from_str("0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3")?;
   let objects = sui.read_api().get_balance(address).await?;
   println!("{:?}", objects);
   Ok(())
}
```

## Use events to track balance changes for an address

You can also track the balance for an address by subscribing to all of the events emitted from it. Use a filter to include only the events related to SUI coins, such as when the address acquires a coin or pays for a gas fee.
The following example demonstrates how to filter events for an address using bash and cURL:

```sh
rpc="https://fullnode.devnet.sui.io:443"
address="0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3"
data="{\"jsonrpc\": \"2.0\", \"id\":1, \"method\": \"sui_getEvents\", \"params\": [{\"Recipient\": {\"AddressOwner\": \"0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3\"}}, null, null, true ]}"
curl -X POST -H 'Content-type: application/json' --data-raw "$data" $rpc
```

The response can include a large number of events. Add pagination to the response using the `nextCursor` key in the request. You can determine the corresponding `txDigest` and `eventSeq` from the `id` field of a transaction.

You can add the `txDigest` value instead of the first `null` within the `params`. The second `null` is an integer that defines how many results (up to 1000) to return and the `true` means ascending order. You can use the `nextCursor` so the response starts from a desired point.

The `id` field of any transaction looks like:

```sh
"id": {
    "txDigest": "GZQN9pE3Zr9ZfLzBK1BfVCXtbjx5xKMxPSEKaHDvL3E2",
    "eventSeq": 6019
}
```

With this data, create a `nextCursor` as follows:

```sh
nextCursor : {"txDigest": "GZQN9pE3Zr9ZfLzBK1BfVCXtbjx5xKMxPSEKaHDvL3E2","eventSeq": 6019}
```

## Blocks vs checkpoints

Sui is a DAG-based blockchain and uses checkpoints for node synchronization and global transaction ordering. Checkpoints differ from blocks in the following ways:
 - Sui creates checkpoints and adds finalized transactions. Note that transactions are finalized even before they are included in a checkpoint
 - Checkpoints do not fork, roll back, or reorganize.
 - Sui creates about four checkpoints every second. Find the most up-to-date statistic on the [Sui public dashboard](https://metrics.sui.io/public-dashboards/4ceb11cc210d4025b122294586961169).

### Checkpoint API operations

Sui Checkpoint API operations include:
 - [sui_getCheckpoint](/sui-api-ref#sui_getCheckpoint) - Retrieves the specified checkpoint.
 - [sui_getLatestCheckpointSequenceNumber](/sui-api-ref#sui_getLatestCheckpointSequenceNumber) - Retrieves the sequence number of the most recently executed checkpoint.
 - [sui_getCheckpoints](/sui-api-ref#sui_getCheckpoints) - Retrieves a paginated list of checkpoints that occurred during the specified interval. Pending a future release.

## SUI balance transfer

To transfer a specific amount of SUI between addresses, you need a SUI token object with that specific value. In Sui, everything is an object, including SUI tokens. The amount of SUI in each SUI token object varies. For example, an address could own 3 SUI tokens with different values: one of 0.1 SUI, a second of 1.0 SUI, and a third with 0.005 SUI. The total balance for the address equals the sum of the values of the individual SUI token objects, in this case, 1.105 SUI.

You can merge and split SUI token objects to create token objects with specific values. To create a SUI token worth .6 SUI, split the token worth 1 SUI into two token objects worth .6 SUI and .4 SUI.

To transfer a specific amount of SUI, you need a SUI token worth that specific amount. To get a SUI token with that specific value, you might need to split or merge existing SUI tokens. Sui supports several methods to accomplish this, including some that do not require you to manually split or merge coins.

## Sui API operations for transfers

Sui supports the following API operations related to transferring SUI between addresses:

 - [sui_transferObject](/sui-api-ref#sui_transferObject)
   Because SUI tokens are objects, you can transfer SUI tokens just like any other object. This method requires a gas token, and is useful in niche cases only.

 - [sui_payAllSui](/sui-api-ref#sui_payAllSui)
   This method accepts an array of SUI token IDs. It merges all existing tokens into one, deducts the gas fee, then sends the merged token to the recipient address.

   The method is especially useful if you want to transfer all SUI from an address. To merge together all coins for an address, set the recipient as the same address. This is a native Sui method so is not considered a transaction in Sui.

 - [sui_paySui](/sui-api-ref#sui_paySui)
   This operation accepts an array of SUI token IDs, an array of amounts, and an array of recipient addresses.

   The amounts and recipients array map one to one. Even if you use only one recipient address, you must include it for each amount in the amount array.

   The operation merges all of the tokens provided into one token object and settles the gas fees. It then splits the token according to the amounts in the amounts array and sends the first token to the first recipient, the second token to the second recipient, and so on. Any remaining SUI on the token stays in the source address.

   The benefits of this method include: no gas fees for merging or splitting tokens, and the abstracted token merge and split. The `sui_paySui` operation is a native function, so the merge and split operations are not considered Sui transactions. The gas fees for them match typical transactions on Sui.You can use this operation to split coins in your own address by setting the recipient as your own address. Note that the total value of the input coins must be greater than the total value of the amounts to send.

 - [sui_pay](/sui-api-ref#sui_pay)
   This method is similar to sui_paySui, but it accepts any kind of coin or token instead of only SUI. You must include a gas token, and all of the coins or tokens must be the same type.

 - [sui_transferSui](/sui-api-ref#sui_transferSui)
    This method accepts only one SUI token object and an amount to send to the recipient. It uses the same token for gas fees, so the amount to transfer must be strictly less than the value of the SUI token used.

## Signing transactions

Refer to [Sui Signatures](/concepts/cryptography/transaction-auth/signatures.mdx) for more details on signature validity requirements.

## SUI Staking

The Sui blockchain uses a Delegated Proof-of-Stake mechanism (DPoS). This allows SUI token holders to stake their SUI tokens to any validator of their choice. When someone stakes their SUI tokens, it means those tokens are locked for the entire epoch. Users can withdraw their stake at any time, but new staking requests become active only at the start of the next epoch.

SUI holders who stake their tokens to validators earn rewards for helping secure the Sui network. Sui determines rewards for staking based on stake rewards on the network, and distributes them at the end of each epoch.

The total voting power in the Sui Network is always 10,000. The voting power of each individual validator is similar to basis points. For example, a voting power of 101 = 1.01%. Sui's quorum threshold (number of votes needed to confirm a transaction) is 6,667 (which is greater than 2/3). The voting power for a single validator is capped at 1,000 (10%) regardless of how much stake the validator has.

## Staking functions

Sui supports the following API operations related to staking. You can find the source code in the [sui_system](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-system/sources/sui_system.move) module.

 - `request_add_stake`
 Add user stake to a validator's staking pool.

```move
public fun request_add_stake(
   self: &mut SuiSystemState,
   stake: Coin<SUI>,
   validator_address: address,
   ctx: &mut TxContext,
) {
   validator_set::request_add_stake(
       &mut self.validators,
       validator_address,
       coin::into_balance(stake),
       option::none(),
       ctx,
   );
}
```

 - `request_add_stake_mul_coin`
 Add user stake to a validator's staking pool using multiple coins.

```move
public fun request_add_stake_mul_coin(
   self: &mut SuiSystemState,
   delegate_stakes: vector<Coin<SUI>>,
   stake_amount: option::Option<u64>,
   validator_address: address,
   ctx: &mut TxContext,
) {
   let balance = extract_coin_balance(delegate_stakes, stake_amount, ctx);
   validator_set::request_add_stake(&mut self.validators, validator_address, balance, option::none(), ctx);
}
```

 - `request_add_stake_with_locked_coin`
 Add user stake to a validator's staking pool using a locked SUI coin.

```move
public fun request_add_stake_with_locked_coin(
   self: &mut SuiSystemState,
   stake: LockedCoin<SUI>,
   validator_address: address,
   ctx: &mut TxContext,
) {
   let (balance, lock) = locked_coin::into_balance(stake);
   validator_set::request_add_stake(&mut self.validators, validator_address, balance, option::some(lock), ctx);
}
```

 - `request_withdraw_stake`
 Withdraw some portion of a user stake from a validator's staking pool.

```move
public fun request_withdraw_stake(
   self: &mut SuiSystemState,
   delegation: &mut Delegation,
   staked_sui: &mut StakedSui,
   principal_withdraw_amount: u64,
   ctx: &mut TxContext,
) {
   validator_set::request_withdraw_stake(
       &mut self.validators,
       delegation,
       staked_sui,
       principal_withdraw_amount,
       ctx,
   );
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/validator-committee.mdx
```
---
title: Validator Committee
description: Sui has a committee of validators to verify on-chain transactions. Epochs, quorums, transactions, certificates, and consensus are touch points for this committee.
---

A set of independent validators participate on the Sui network, each running its own instance of the Sui software on a separate machine (or a sharded cluster of machines the same entity operates). Each validator handles read and write requests sent by clients, verifying transactions and updating on-chain information.

To learn how to set up and run a Sui Validator node, including how staking and rewards work, see [Sui Validator Node Configuration](./validator-config.mdx).

> **Important Update**: Sui is implementing SIP-39 to significantly lower the barrier to entry for validators. The minimum stake requirement will soon change from 30M SUI to a voting power-based threshold, reducing the required SUI to around 3M. If you're interested in becoming a validator, please [fill out this form](https://docs.google.com/forms/d/e/1FAIpQLSf6ZngRJ6Q5RdEiBfnbpUq4Htj8ShL58I6JRkmRTwTVSzeNtQ/viewform) to join validator communications.

Sui uses Delegated Proof-of-Stake (DPoS) to determine which validators operate the network and their voting power. Validators are incentivized to participate in good faith via a share of transaction fees, staking rewards, and slashing stake and staking rewards in case of misbehavior.

## Epochs 

Operation of the Sui network is temporally partitioned into non-overlapping, approximate fixed-duration (~24-hour) epochs. During a particular epoch, the set of validators participating in the network and their voting power is fixed. At an epoch boundary, reconfiguration might occur and can change the set of validators participating in the network and their voting power. Conceptually, reconfiguration starts a new instance of the Sui protocol with the previous epoch's final state as [genesis](./genesis.mdx) and the new set of validators as the operators. Besides validator set changes, tokenomics operations such as staking/un-staking, and distribution of staking rewards are also processed at epoch boundaries.

## Quorums 

A quorum is a set of validators whose combined voting power is greater than two-thirds (>2/3) of the total during a particular epoch. For example, in a Sui instance operated by four validators that all have the same voting power, any group containing three validators is a quorum.

The quorum size of >2/3 ensures Byzantine fault tolerance (BFT). A validator commits a transaction (durably store the transaction and update its internal state with the effects of the transaction) only if it is accompanied by cryptographic signatures from a quorum. Sui calls the combination of the transaction and the quorum signatures on its bytes a *certificate*. The policy of committing only certificates ensures Byzantine fault tolerance: if >2/3 of the validators faithfully follow the protocol, they are guaranteed to eventually agree on both the set of committed certificates and their effects.

## Write requests 

A validator can handle two types of write requests: transactions and certificates. At a high level, a client:

- Communicates a transaction to a quorum of validators to collect the signatures required to form a certificate.
- Submits a certificate to a validator to commit state changes on that validator.

### Transactions 

When a validator receives a transaction from a client, it first performs transaction validity checks (validity of the sender's signature). If the checks pass, the validator locks all owned-objects and signs the transaction bytes, then returns the signature to the client. The client repeats this process with multiple validators until it has collected signatures on its transaction from a quorum, thereby forming a certificate.

The process of collecting validator signatures on a transaction into a certificate and the process of submitting certificates can be performed in parallel. The client can simultaneously multicast transactions/certificates to an arbitrary number of validators. Alternatively, a client can outsource either or both of these tasks to a third-party service provider. This provider must be trusted for liveness (it can refuse to form a certificate), but not for safety (it cannot change the effects of the transaction, and does not need the user's secret key).

### Certificates / certified transactions {#certificates}

After the client forms a certificate, it submits it to the validators, which perform certificate validity checks. These checks ensure the signers are validators in the current epoch, and the signatures are cryptographically valid. If the checks pass, the validators execute the transaction inside the certificate. Execution of a transaction either succeeds and commits all of its effects or aborts and has no effect other than debiting the transaction's gas input. Some reasons a transaction might abort include an explicit abort instruction, a runtime error such as division by zero, or exceeding the maximum gas budget. Whether it succeeds or aborts, the validator durably stores the certificate indexed by the hash of its inner transaction.

If a client collects a quorum of signatures on the effects of the transaction, then the client has a promise of finality. This means that transaction effects persist on the shared database and are actually committed and visible to everyone by the end of the epoch. This does not mean that the latency is a full epoch, because you can use the effects certificate to convince anyone of the transactions finality, as well as to access the effects and issue new transactions. As with transactions, you can parallelize the process of sharing a certificate with validators and (if desired) outsource to a third-party service provider.

## The role of consensus

Sui uses a high-throughput DAG-based consensus engine implementing the Mysticeti algorithm to sequence certified transactions. Consensus produces a series of commits. In each commit, there is a sequence of certified transactions.

The order of transactions in consensus output determines the relative order they can operate on each shared object. Note that executions of transactions touching different shared objects are parallelized on multiple cores.

If total execution cost of transactions in a consensus commit is over a threshold, transactions can be cancelled post consensus to avoid overloading the system.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/genesis.mdx
```
---
title: Genesis
---

Genesis is the initial state of the Sui blockchain. To launch a network, the initial committee of validators collaborate by providing their validator information (public keys, network addresses, and so on) to a shared workspace. After all of the initial validators have contributed their information, Sui generates the initial, unsigned genesis checkpoint (checkpoint with sequence number 0) and each validator provides their signature. Sui aggregates these signatures to form a certificate on the genesis checkpoint. Sui bundles this checkpoint, as well as the initial objects, together into a single genesis.blob file that is used to initialize the state when running the `sui-node` binary for both validators and Full nodes.

## Genesis blob locations

The genesis.blob files for each network are in the [sui-genesis](https://github.com/mystenlabs/sui-genesis) repository.

See [Sui Full Node](./sui-full-node.mdx#set-up-from-source) for how to get the genesis.blob file for each network.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/validator-tasks.mdx
```
---
title: Validator Tasks
description: As a validator on Sui, there are some processes you need to perform to ensure your nodes are always optimized.
---

This guide focuses on running the Sui node software as a validator.

## Requirements

To run a Sui Validator a machine with the following is required:
- CPU: 24 physical cores (or 48 virtual cores)
- Memory: 128 GB
- Storage: 4 TB NVME
- Network: 1 Gbps

## Deployment

You can deploy Sui node in a number of ways.

There are pre-built container images available in [Docker Hub](https://hub.docker.com/r/mysten/sui-node/tags).

And pre built `linux/amd64` binaries available in S3 that you can fetch using one of the following methods:

```sh
$ wget https://releases.sui.io/$SUI_SHA/sui-node
```

```sh
$ curl https://releases.sui.io/$SUI_SHA/sui-node -o sui-node
```

To build directly from source:

```sh
$ git clone https://github.com/MystenLabs/sui.git && cd sui
```
```sh
$ git checkout [SHA|BRANCH|TAG]
```
```sh
$ cargo build --release --bin sui-node
```

Configuration and guides are available for the following deployment options:

- [Systemd](https://github.com/MystenLabs/sui/blob/main/nre/systemd/README.md)
- [Ansible](https://github.com/MystenLabs/sui/blob/main/nre/ansible/README.md)
- [Docker Compose](https://github.com/MystenLabs/sui/blob/main/nre/docker/README.md)

## Configuration

Sui node runs with a single configuration file provided as an argument, example:

`./sui-node --config-path /opt/sui/config/validator.yaml`.

See [Validator](https://github.com/MystenLabs/sui/blob/main/nre/config/validator.yaml) for configuration templates.

## Connectivity

Sui node uses the following ports by default:

| protocol/port | reachability     | purpose                           |
| ------------- | ---------------- | --------------------------------- |
| TCP/8080      | inbound          | validator/transaction interface   |
| TCP/8081      | inbound/outbound | consensus interface               |
| UDP/8084      | inbound/outbound | peer to peer state sync interface |
| TCP/8443      | outbound         | metrics pushing                   |
| TCP/9184      | localhost        | metrics scraping                  |

To run a validator successfully, it is critical that ports 8080-8084 are open as outlined, including the specific protocol (TCP/UDP).

## Network Buffer
From load testing Sui validator networks, it has been determined that the default Linux network buffer sizes are too small.
We recommend increasing them using one of the following two methods:

### Option 1: With /etc/sysctl.d/
These settings can be added to a new sysctl file specifically for the sui-node, or appended to an existing file.
Modifications made in this way will persist across system restarts.

Create a new sysctl file for the sui-node:

```sh
$ sudo nano /etc/sysctl.d/100-sui-node.conf
```

Add these lines to the file, overwriting existing settings if necessary.

```sh 
net.core.rmem_max = 104857600
net.core.wmem_max = 104857600
net.ipv4.tcp_rmem = 8192 262144 104857600
net.ipv4.tcp_wmem = 8192 262144 104857600
```

Apply the settings immediately, before the next restart
```sh
$ sudo sysctl --system
```

### Option 2: With sysctl command
These modifications do not persist across system restarts. Therefore, the commands should be run each time the host restarts.
```sh
$ sudo sysctl -w net.core.wmem_max=104857600
```
```sh
$ sudo sysctl -w net.core.rmem_max=104857600
```
```sh
$ sudo sysctl -w net.ipv4.tcp_rmem="8192 262144 104857600"
```
```sh
$ sudo sysctl -w net.ipv4.tcp_wmem="8192 262144 104857600"
```

### Verification
To verify that the system settings have indeed been updated, check the output of the following command:
```sh
$ sudo sysctl -a | egrep [rw]mem
```

## Storage

All Sui node related data is stored by default under `/opt/sui/db/`. This is controlled in the Sui node configuration file.

```sh
$ cat /opt/sui/config/validator.yaml | grep db-path
  db-path: /opt/sui/db/authorities_db
  db-path: /opt/sui/db/consensus_db
```

Ensure that you have an appropriately sized disk mounted for the database to write to.

- To check the size of the local Sui node databases:

```sh
$ du -sh /opt/sui/db/
```
```sh
$ du -sh /opt/sui/db/authorities_db
```
```sh
$ du -sh /opt/sui/db/consensus_db
```

- To delete the local Sui node databases:

```sh
$ sudo systemctl stop sui-node
```
```sh
$ sudo rm -rf /opt/sui/db/authorities_db /opt/sui/db/consensus_db
```

## Key management

The following keys are used by Sui node:

| key          | scheme   | purpose                         |
| ------------ | -------- | ------------------------------- |
| protocol.key | bls12381 | transactions                    |
| account.key  | ed25519  | controls assets for staking     |
| network.key  | ed25519  | state sync                      |
| worker.key   | ed25519  | consensus (to be migrated)      |

These are configured in the [Sui node configuration file](#configuration).

## Monitoring

### Metrics

Sui node exposes metrics via a local HTTP interface. These can be scraped for use in a central monitoring system as well as viewed directly from the node.

- View all metrics:

```sh
$ curl -s http://localhost:9184/metrics
```

- Search for a particular metric:

```sh
$ curl http://localhost:9184/metrics | grep <METRIC>
```

Sui node also pushes metrics to a central Sui metrics proxy.

### Logs

Logs are controlled using the `RUST_LOG` environment variable.

The `RUST_LOG_JSON=1` environment variable can optionally be set to enable logging in JSON structured format.

Depending on your deployment method, these are configured in the following places:

- [Ansible](https://github.com/MystenLabs/sui/blob/main/nre/ansible/roles/sui-node/files/sui-node.service)
- [Native systemd](https://github.com/MystenLabs/sui/blob/main/nre/systemd/sui-node.service)
- [Docker Compose](https://github.com/MystenLabs/sui/blob/main/nre/docker/docker-compose.yaml)

To view and follow the Sui node logs:

```sh
$ journalctl -u sui-node -f
```

To search for a particular match

```sh
$ journalctl -u sui-node -g <SEARCH_TERM>
```

- If using Docker Compose, look at the examples in the [README](https://github.com/MystenLabs/sui/blob/main/nre/docker/README.md#logs).

It is possible to change the logging configuration while a node is running using the admin interface.

To view the currently configured logging values:

```sh
$ curl localhost:1337/logging
```

To change the currently configured logging values:

```sh
$ curl localhost:1337/logging -d "info"
```

### Dashboards

Public dashboard for network wide visibility:

- [Sui Testnet Validators](https://metrics.sui.io/public-dashboards/9b841d63c9bf43fe8acec4f0fa991f5e)

## Software updates

When an update is required to the Sui node software the following process can be used. Follow the relevant Systemd or Docker Compose runbook depending on your deployment type. It is highly unlikely that you will want to restart with a clean database.

- [Systemd](https://github.com/MystenLabs/sui/blob/main/nre/systemd/README.md#updates)
- [Docker Compose](https://github.com/MystenLabs/sui/blob/main/nre/docker/README.md#updates)

## State sync

Checkpoints in Sui contain the permanent history of the network. They are comparable to blocks in other blockchains with one big difference being that they are lagging instead of leading. All transactions are final and executed prior to being included in a checkpoint.

These checkpoints are synchronized between validators and fullnodes via a dedicated peer to peer state sync interface.

Inter-validator state sync is always permitted however there are controls available to limit what fullnodes are allowed to sync from a specific validator.

The default and recommended `max-concurrent-connections: 0` configuration does not affect inter-validator state sync, but will restrict all fullnodes from syncing. The Sui node [configuration](#configuration) can be modified to allow a known fullnode to sync from a validator:

```sh
p2p-config:
  anemo-config:
    max-concurrent-connections: 0
  seed-peers:
    - address: <multiaddr>  # The p2p address of the fullnode
      peer-id: <peer-id>    # hex encoded network public key of the node
    - address: ...          # another permitted peer
      peer-id: ...
```

## Chain operations

The following chain operations are executed using the `sui` CLI. This binary is built and provided as a release similar to `sui-node`, examples:

```sh
$ wget https://releases.sui.io/$SUI_SHA/sui
```
```sh
$ chmod +x sui
```

```sh
$ curl https://releases.sui.io/$SUI_SHA/sui -o sui
```
```sh
$ chmod +x sui
```

It is recommended and often required that the `sui` binary release/version matches that of the deployed network.

### Updating on-chain metadata

You can leverage [Validator Tool](https://github.com/MystenLabs/sui/blob/main/nre/validator_tool.md) to perform majority of the following tasks.

An active/pending validator can update its on-chain metadata by submitting a transaction. Some metadata changes take effect immediately, including:

- name
- description
- image url
- project url

Other metadata (keys, addresses, and so on) only come into effect at the next epoch.

To update metadata, a validator makes a MoveCall transaction that interacts with the System Object. For example:

1. to update name to `new_validator_name`, use the Sui Client CLI to call `sui_system::update_validator_name`:

{@include: ../../snippets/info-gas-budget.mdx}

```sh
$ sui client call --package 0x3 --module sui_system --function update_validator_name --args 0x5 \"new_validator_name\" --gas-budget 10000
```

2. to update p2p address starting from next epoch to `/ip4/192.168.1.1`, use the Sui Client CLI to call `sui_system::update_validator_next_epoch_p2p_address`:

```sh
$ sui client call --package 0x3 --module sui_system --function update_validator_next_epoch_p2p_address --args 0x5 "[4, 192, 168, 1, 1]" --gas-budget 10000
```

See the [full list of metadata update functions here](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-system/sources/sui_system.move#L267-L444).

### Operation cap

To avoid touching account keys too often and allowing them to be stored off-line, validators can delegate the operation ability to another address. This address can then update the reference gas price and tallying rule on behalf of the validator.

Upon creating a `Validator`, an `UnverifiedValidatorOperationCap` is created as well and transferred to the validator address. The holder of this `Cap` object (short for "Capability") therefore could perform operational actions for this validator. To authorize another address to conduct these operations, a validator transfers the object to another address that they control. The transfer can be done by using Sui Client CLI: `sui client transfer`.

To rotate the delegatee address or revoke the authorization, the current holder of `Cap` transfers it to another address. In the event of compromised or lost keys, the validator could create a new `Cap` object to invalidate the incumbent one. This is done by calling `sui_system::rotate_operation_cap`:

```sh
$ sui client call --package 0x3 --module sui_system --function rotate_operation_cap --args 0x5 --gas-budget 10000
```

By default the new `Cap` object is transferred to the validator address, which then could be transferred to the new delegatee address. At this point, the old `Cap` becomes invalidated and no longer represents eligibility.

To get the current valid `Cap` object's ID of a validator, use the Sui Client CLI `sui client objects` command after setting the holder as the active address.

### Updating the gas price survey quote

To update the gas price survey quote of a validator, which is used to calculate the reference gas price at the end of the epoch, the sender needs to hold a valid [`UnverifiedValidatorOperationCap`](#operation-cap). The sender could be the validator itself, or a trusted delegatee. To do so, call `sui_system::request_set_gas_price`:

```sh
$ sui client call --package 0x3 --module sui_system --function request_set_gas_price --args 0x5 {cap_object_id} {new_gas_price} --gas-budget 10000
```

### Reporting/un-reporting validators

To report a validator or undo an existing reporting, the sender needs to hold a valid [`UnverifiedValidatorOperationCap`](#operation-cap). The sender could be the validator itself, or a trusted delegatee. To do so, call `sui_system::report_validator/undo_report_validator`:

```sh
$ sui client call --package 0x3 --module sui_system --function report_validator/undo_report_validator --args 0x5 {cap_object_id} {reportee_address} --gas-budget 10000
```

After a validator is reported by `2f + 1` other validators by voting power, their staking rewards will be slashed.

### Joining the validator set

In order for a Sui address to join the validator set, they need to first sign up as a validator candidate by calling `sui_system::request_add_validator_candidate` with their metadata and initial configs:

```sh
$ sui client call --package 0x3 --module sui_system --function request_add_validator_candidate --args 0x5 {protocol_pubkey_bytes} {network_pubkey_bytes} {worker_pubkey_bytes} {proof_of_possession} {name} {description} {image_url} {project_url} {net_address} {p2p_address} {primary_address} {worker_address} {gas_price} {commission_rate} --gas-budget 10000
```

After an address becomes a validator candidate, any address (including the candidate address itself) can start staking with the candidate's staking pool. Refer to our dedicated staking FAQ on how staking works. Once a candidate's staking pool has accumulated at least `sui_system::MIN_VALIDATOR_JOINING_STAKE` amount of stake, the candidate can call `sui_system::request_add_validator` to officially add themselves to next epoch's active validator set:

```sh
$ sui client call --package 0x3 --module sui_system --function request_add_validator --args 0x5 --gas-budget 10000000
```

### Leaving the validator set

To leave the validator set starting next epoch, the sender needs to be an active validator in the current epoch and should call `sui_system::request_remove_validator`:

```sh
$ sui client call --package 0x3 --module sui_system --function request_remove_validator --args 0x5 --gas-budget 10000
```

After the validator is removed at the next epoch change, the staking pool will become inactive and stakes can only be withdrawn from an inactive pool.

## Private security fixes

There might be instances where urgent security fixes need to be rolled out before publicly announcing it's presence (issues affecting liveliness, invariants such as SUI supply, governance, and so on). To not be actively exploited, Mysten Labs will release signed security binaries incorporating such fixes with a delay in publishing the source code until a large percentage of our validators have patched the vulnerability.

This release process is different and we expect us to announce the directory for such binaries out of band.
Our public key to verify these binaries would be stored [here](https://sui-private.s3.us-west-2.amazonaws.com/sui_security_release.pem)

There is also a script available that downloads all the necessary signed binaries and docker artifacts incorporating the security fixes.

Usage
`./download_private.sh <directory-name>`

You can also download and verify specific binaries that may not be included by the above script using the `download_and_verify_private_binary.sh` script.

Usage:
`./download_and_verify_private_binary.sh <directory-name> <binary-name>`

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/snapshots.mdx
```
---
title: Database Snapshots
description: Database snapshots of the Sui network enable Full node operators a way to bootstrap a Full node without having to execute all the transactions that occurred after genesis.
---

Database snapshots provide a point-in-time view of a database's store. In Sui, the database snapshot captures a running database's view of the Sui network from a particular node at the end of an epoch. While validators can enable snapshots, they are typically most valuable for Full node operators.

Snapshots of the Sui network enable Full node operators a way to bootstrap a Full node without having to execute all the transactions that occurred after genesis. You can upload snapshots to remote object stores like S3, Google Cloud Storage, Azure Blob Storage, and similar services. These services typically run the export process in the background so there is no degradation in performance for your Full node. With snapshots stored in the cloud, you're more easily able to recover quickly from catastrophic failures in your system or hardware.

To maintain a healthy Sui network, Sui encourages the Sui community to bring up additional snapshots to ensure stronger data availability across the network.

## Supported snapshot types

Sui supports two types of snapshots:

- **RocksDB snapshots** are a point-in-time view of a database store. This means that the snapshot keeps the state of the system at the moment it generates the snapshot, including non-pruned data, additional indices, and other data.
- **Formal snapshots** are database agnostic with a minimalistic format, in other words they contain only the data necessary to restore a node to a valid state at the specified epoch, thus they have a much smaller storage footprint and are generally faster to restore from when compared to database snapshots. Formal snapshots are also supported natively by the Sui protocol. In this context, this means that we can cryptographically verify the contents of the formal snapshot against a commitment from the committee at the epoch we are restoring to. This verification happens automatically and by default during a Formal snapshot restore (unless explicitly bypassed). 

:::info

Formal snapshots are not suitable for use if you are running an RPC node that does any historical data lookups. For more information on node data management, see [Data Management](./data-management.mdx).

:::

You can configure a Full node snapshot to generate a state snapshot at the end of each epoch.
A single Full node can generate RocksDB snapshots, Formal snapshots, or both.

## Formal snapshots

Formal snapshots provide a mechanism for a node to restore to a canonical state (the state of a full pruned and compacted node at the end of an epoch) at some prior point in time without having to execute all the transactions that have occurred since genesis. Unlike existing database snapshots, these formal snapshots have the following properties:

1. **Minimalism:** Formal snapshots currently contain only the end of epoch live object set (the set of all object versions eligible for use as input objects for future transactions). Sui syncs all other critical chain information from the chain or derives it. Thus, formal snapshots contain only the necessary data required for a node to startup at epoch boundary and participate in the network.
1. **Agnosticism:** Formal snapshots are by nature agnostic to the underlying database choice or implementation of the protocol. As the live object set is protocol defined, so is the formal snapshot.
1. **Verifiability:** Formal snapshots have first-class support in the core Sui protocol. As such, they must be trustless/verifiable by the node operator upon download. To support this, the protocol signs a commitment to the live object state at end of epoch, which formal snapshots are checked against at restore time. If this verification fails, the node state is moved back to the state before the snapshot restore attempt.

Because these snapshots do not contain indexes, they are most immediately useful for validators and state sync Full nodes (SSFNs). You can upload snapshots to remote object stores like S3, Google Cloud Storage, Azure Blob Storage, and similar services. These services typically run the export process in the background so there is no degradation in performance for your Full node. With snapshots stored in the cloud, you can recover from catastrophic failures in your system or hardware more efficiently.

## Restoring a Full node using snapshots

### Restoring using RocksDB snapshots

To restore from a RocksDB snapshot, follow these steps:

1. Download the snapshot for the epoch you want to restore to your local disk. There is one snapshot per epoch in s3 bucket.
1. Place the snapshot into the directory that the `db-path` value points to in your fullnode.yaml file. For example, if the `db-path` value points to `/opt/sui/db/authorities_db/full_node_db` and you want to restore from epoch 10, then copy the snapshot to the directory with this command:

   You can use the aws cli (provided you have credentials to associate with the download):
   `aws s3 cp s3://<BUCKET_NAME>/epoch_10 /opt/sui/db/authorities_db/full_node_db/live --recursive --request-payer requester`.
   
   An alternative is to use `sui-tool` to copy the files. The following example command is for reading from a snapshot bucket that you host:
   ```
   sui-tool download-db-snapshot --latest \
       --network <NETWORK> --snapshot-bucket <BUCKET-NAME> \
       --snapshot-bucket-type <TYPE> --path <PATH-TO-NODE-DB> \
       --num-parallel-downloads 25 \
       --skip-indexes
   ```
   - `--epoch`: The epoch that you want to download. Mysten Labs hosted buckets will only keep the last 90 epochs, you can check the most recent epoch on sui explorers like [suivision](https://suivision.xyz/) or [suiscan](https://suiscan.xyz/).
   - `--latest`: Rather than explicitly passing a epoch via `--epoch`, you can pass the `--latest` flag, which will automatically select the latest snapshot`
   - `--network`: Network to download snapshot for. Defaults to "mainnet".
   - `--path`: Path to snapshot directory on local filesystem.
   - `--no-sign-request`: If set, `--snapshot-bucket` and `--snapshot-bucket-type` are ignored, and a static Cloudflare R2 bucket is used.
   - `--snapshot-bucket`: Source snapshot bucket name, eg `mysten-mainnet-snapshots`. This cannot be used with `--no-sign-request`.
   - `--snapshot-bucket-type`: Snapshot bucket type. GCS and S3 currently supported. This cannot be used with `--no-sign-request`.
   - `--skip-indexes`: Skips downloading the very large `indexes/` dir, used by jsonrpc on the fullnode

   The following environment variables are used if `--no-sign-request` is not set:
   * *AWS*: `AWS_SNAPSHOT_ACCESS_KEY_ID`, `AWS_SNAPSHOT_SECRET_ACCESS_KEY`, `AWS_SNAPSHOT_REGION`
   * *GCS*: `GCS_SNAPSHOT_SERVICE_ACCOUNT_FILE_PATH`
   * *AZURE*: `AZURE_SNAPSHOT_STORAGE_ACCOUNT`, `AZURE_SNAPSHOT_STORAGE_ACCESS_KEY`

1. When using `sui-tool download-db-snapshot` the database is copied to the location you pass to `--path`, in a directory named `epoch_[NUM]`. Rename the `epoch_[NUM]` directory to `live/` under your node's `db_path`, for example `cp -r /tmp/epoch_[NUM] /opt/sui/db/authorities_db/full_node_db/live`.
1. Make sure you update the ownership of the downloaded directory to the sui user (whichever linux user you run `sui-node` as)
   `sudo chown -R sui:sui  /opt/sui/db/authorities_db/full_node_db/live`.
1. Start the Sui node.

:::info

When you restore a Full node from a snapshot, write it to the path `/opt/sui/db/authorities_db/full_node_db/live`. When restoring a Validator node, you can shorten the database destination to `/opt/sui/db/authorities_db/live`. Check the `db_path` field of your Full node or Validator configs to confirm the path location.

:::

### Restoring using Formal snapshots

To restore using a Formal snapshot, use the `sui-tool` binary. `sui-tool` can be downloaded along with other sui binaries.
See [Install Sui](../developer/getting-started/sui-install.mdx) for more details.

The following steps can be used to restore a node from a Formal snapshot:

1. If it's running, stop the node.
2. Run the command:
   ```
   sui-tool download-formal-snapshot --latest --genesis "<PATH-TO-GENESIS-BLOB>" \
        --network <NETWORK> --snapshot-bucket <BUCKET-NAME> --snapshot-bucket-type <TYPE> \
        --path <PATH-TO-NODE-DB> --num-parallel-downloads 50 --no-sign-request
   ```
   - `--epoch`: The epoch that you want to download. Mysten Labs hosted buckets will only keep the last 90 epochs, you can check the most recent epoch on sui explorers like [suivision](https://suivision.xyz/) or [suiscan](https://suiscan.xyz/).
   - `--latest`: Rather than explicitly passing a epoch via `--epoch`, you can pass the `--latest` flag, which will automatically select the latest snapshot`
   - `--genesis`: The path to the location of the network's `genesis.blob`.
   - `--network`: Network to download snapshot for. Defaults to "mainnet".
   - `--path`: Path to snapshot directory on local filesystem.
   - `--no-sign-request`: If set, `--snapshot-bucket` and `--snapshot-bucket-type` are ignored, and Cloudflare R2 is used.
   - `--snapshot-bucket`: Source snapshot bucket name, eg `mysten-mainnet-snapshots`. This cannot be used with `--no-sign-request`.
   - `--snapshot-bucket-type`: Snapshot bucket type. GCS and S3 currently supported. This cannot be used with `--no-sign-request`.

   The following environment variables are used if `--no-sign-request` is not set:
   * *AWS*: `AWS_SNAPSHOT_ACCESS_KEY_ID`, `AWS_SNAPSHOT_SECRET_ACCESS_KEY`, `AWS_SNAPSHOT_REGION`
   * *GCS*: `GCS_SNAPSHOT_SERVICE_ACCOUNT_FILE_PATH`
   * *AZURE*: `AZURE_SNAPSHOT_STORAGE_ACCOUNT`, `AZURE_SNAPSHOT_STORAGE_ACCESS_KEY`


## Mysten Labs managed snapshots

Mysten Labs hosts two tiers of snapshot storage access. **High throughput, Requester Pays enabled buckets**, and **free, permissionless buckets**.

**High throughput, Requester Pays enabled buckets:**
* GCS and S3 are both setup with requester pays. This means that you'll need to provide a set of valid AWS/GCP credentials when downloading from these buckets.
[Requester Pays](https://cloud.google.com/storage/docs/requester-pays) means you are charged for the egress costs of pulling the snapshot data.
* If you are looking for the best download speeds, we recommend using the S3 buckets with [transfer acceleration](https://aws.amazon.com/s3/transfer-acceleration/) enabled.

**Free, permissionless buckets:**
* These are currently hosted on Cloudflare R2, currently only in North America, but we plan on adding more regions soon.
* Since the bucket is open to the internet, there's no need to provide any cloud credentials.

### Bucket Names
**S3**
Testnet: `s3://mysten-testnet-snapshots/`, `s3://mysten-testnet-formal/`
Mainnet: `s3://mysten-mainnet-snapshots/`,  `s3://mysten-mainnet-formal/`

**GCS**
Testnet: `gs://mysten-testnet-snapshots/`, `gs://mysten-testnet-formal/`
Mainnet: `gs://mysten-mainnet-snapshots/`,  `gs://mysten-mainnet-formal/`

![Mysten Managed Snapshots](./images/mysten-cloud-snapshots.png "A diagram that shows the current architecture of mysten snapshot availability")

## Enabling snapshots

Full nodes do not take snapshots by default. To enable this feature you must apply specific configs to your Full node.

Follow these steps to change the configs for a Full node:

1. Stop your node, if it's running.
2. Open your fullnode.yaml config file and apply config updates as the following sections show.
3. Save the fullnode.yaml file and restart the node.

### Enabling DB snapshots

Add an entry to the config file for `db-checkpoint-config`. Using Amazon's S3 service as an example:
   ```yaml
   db-checkpoint-config:
     perform-db-checkpoints-at-epoch-end: true
     perform-index-db-checkpoints-at-epoch-end: true
     object-store-config:
       object-store: "S3"
       bucket: "<BUCKET-NAME>"
       aws-access-key-id: “<ACCESS-KEY>”
       aws-secret-access-key: “<SHARED-KEY>”
       aws-region: "<BUCKET-REGION>"
       object-store-connection-limit: 20
   ```
   - `object-store`: The remote object store to upload snapshots. Set as Amazon's `S3` service in the example.
   - `bucket`: The S3 bucket name to store the snapshots.
   - `aws-access-key-id` and `aws-secret-access-key`: AWS authentication information with write access to the bucket.
   - `aws-region`: Region where bucket exists.
   - `object-store-connection-limit`: Number of simultaneous connections to the object store.

### Enabling Formal snapshots

 Add an entry to the config file for `state-snapshot-write-config`. Using Amazon's S3 service as an example:
   ```yaml
   state-snapshot-write-config:
     object-store-config:
       object-store: "S3"
       bucket: "<BUCKET-NAME>"
       aws-access-key-id: “<ACCESS-KEY>”
       aws-secret-access-key: “<SHARED-KEY>”
       aws-region: "<BUCKET-REGION>"
       object-store-connection-limit: 200
   ```
   The configuration settings shown in the example are specific to AWS S3, but GCS, Azure Storage, and Cloudflare R2 are all supported.


```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/node-tools.mdx
```
---
title: Node Tools
---

This guide focuses on using the Sui CLI `validator` commands. 

:::info

This tool only supports pending validators and active validators at the moment.

:::

## Preparation

1. Make sure you have completed all the [prerequisites](../developer/getting-started/sui-install.mdx#prerequisites).

2. Build the `sui` binary, which you need for the genesis ceremony. This step can be done on any machine you like. It does not have to be done on the machine on which you will run the validator.

    1. Clone the git repo:

           `git clone git@github.com:MystenLabs/sui.git && cd sui`

    2. Check out the commit to use for the testnet:

           `git checkout testnet`

    3. Build sui binary

           `cargo build --bin sui`

    4. Remember the path to your binary:

           `export SUI_BINARY="$(pwd)/target/debug/sui"`

3. Run the following command to set up your Sui account and CLI environment. 

    1. If this is the first time running this program, it will ask you to provide a Sui Fullnode Server URL and a meaningful environment alias. It will also generate a random key pair in `sui.keystore` and a config `client.yaml`. Swap in your validator account key if you already have one.

    2. If you already set it up, simply make sure 
      a. `rpc` is correct in `client.yaml`. 
      b. `active_address` is correct in `client.yaml`.
      b. `sui.keystore` contains your account key pair.

        If at this point you can't find where `client.yaml` or `sui.keystore` is or have other questions, read [Sui Client CLI tutorial](/references/cli/client.mdx).

        ``` bash
        $ sui client
        ```

4. To test you are connected to the network and configured your config correctly, run the following command to display your validator info.

``` bash
$ sui validator display-metadata
```

## Using Sui CLI 

#### Print help info

``` bash
$ sui validator --help
```

#### Display validator metadata
``` bash
$ sui validator display-metadata
```

or 

``` bash
$ sui validator display-metadata <validator-address>
```
to print another validator's information.

#### Update validator metadata

Run the following to see how to update validator metadata. Read description carefully about when the change will take effect.

``` bash
$ sui validator update-metadata --help
```

You can update the following on-chain metadata:
1. name
1. description
1. image URL
1. project URL
1. network address
1. p2p address
1. primary address
1. worker address
1. protocol public key
1. network public key
1. worker public key

Notably, only the first 4 metadata listed above take effect immediately.

If you change any metadata from points 5 to 11, they will be changed only after the next epoch - for these, you'll want to restart the validator program immediately after the next epoch, with the new key files and/or updated `validator.yaml` config. Particularly, make sure the new address is not behind a firewall.

Run the following to see how to update each metadata.

``` bash
$ sui validator update-metadata --help
```

#### Operation cap

Operation Cap allows a validator to authorizer another account to perform certain actions on behalf of this validator. Read about [Operation Cap here](./validator-tasks.mdx#operation-cap).

The Operation Cap holder (either the valdiator itself or the delegatee) updates its Gas Price and reports validator peers with the Operation Cap.

#### Update gas price

To update Gas Price, run

```sh
$ sui validator update-gas-price <gas-price>
```

if the account itself is a validator and holds the Operation Cap. Or 

```sh
$ sui validator update-gas-price --operation-cap-id <operation-cap-id> <gas-price>
```

if the account is a delegatee.

#### Report validators

To report validators peers, run

```sh
$ sui validator report-validator <reportee-address>
```

Add `--undo-report false` if it intents to undo an existing report.

Similarly, if the account is a delegatee, add `--operation-cap-id <operation-cap-id>` option to the command.

if the account itself is a validator and holds the Operation Cap. Or 

```sh
$ sui validator update-gas-price --operation-cap-id <operation-cap-id> <gas-price>
```

if the account is a delegatee.


#### Become a validator / join committee

To become a validator candidate, first run

```sh
$ sui validator make-validator-info <name> <description> <image-url> <project-url> <host-name> <gas_price>
```

This will generate a `validator.info` file and key pair files. The output of this command includes:
  1. Four key pair files (Read [more here](./validator-tasks.mdx#key-management)). ==Set their permissions with the minimal visibility (chmod 600, for example) and store them securely==. They are needed when running the validator node as covered below.
    a. If you follow this guide thoroughly, this key pair is actually copied from your `sui.keystore` file.
  2. `validator.info` file that contains your validator info. **Double check all information is correct**.

Then run 

``` sh
$ sui validator become-candidate {path-to}validator.info
```

to submit an on-chain transaction to become a validator candidate. The parameter is the file path to the validator.info generated in the previous step. **Make sure the transaction succeeded (printed in the output).**

At this point you are validator candidate and can start to accept self staking and delegated staking. 

**If you haven't, start a fullnode now to catch up with the network. When you officially join the committee but is not fully up-to-date, you cannot make meaningful contribution to the network and may be subject to peer reporting hence face the risk of reduced staking rewards for you and your delegators.**

Once you collect enough staking amount, run

```sh
$ sui validator join-committee
```

to become a pending validator. A pending validator will become active and join the committee starting from next epoch.


#### Leave committee

To leave committee, run

```sh
$ sui validator leave-committee
```

You are removed from the committee starting from the next epoch.

### Generate the payload to create PoP

Serialize the payload that is used to generate proof of possession. This allows the signer to take the payload offline for an authority protocol BLS keypair to sign.

```sh
$ sui validator serialize-payload-pop --account-address $ACCOUNT_ADDRESS --protocol-public-key $BLS_PUBKEY
```
```sh
Serialized payload: $PAYLOAD_TO_SIGN
```
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/operator/archives.mdx
```
---
title: Sui Archives
description: The archive is a historical record of all transactions on Sui. Enable archiving on your Full nodes as a best practice.
---

A Sui archive is a history of all transaction data on Sui. In some cases, peer nodes may not catch up with all transactions and effects through synchronization if they lag behind the current epoch by more than the latest few epochs. In such cases, instead of relying on synchronization, peer nodes can fallback to downloading the relevant information from an archive.

:::info
Starting with the 1.49 release, the existing special archive format is being deprecated in favor of a generic data ingestion format. Please migrate your configs using the configuration example that follows. The deprecated configuration is currently included for reference, but will be removed after a few releases.
:::

## Set up archival fallback (latest) {#set-up-archival-fallback}

To enable your node to fallback to an archive in case of lag, add this to your fullnode.yaml file:

<Tabs groupId="object-store">
<TabItem value="mainnet" label="Mainnet">

```yaml
state-archive-read-config:
  - ingestion-url: "https://checkpoints.mainnet.sui.io"
    # How many objects to read ahead when catching up
    concurrency: 5
```

</TabItem>
<TabItem value="testnet" label="Testnet">

```yaml
state-archive-read-config:
  - ingestion-url: "https://checkpoints.testnet.sui.io"
    # How many objects to read ahead when catching up
    concurrency: 5
```

</TabItem>
</Tabs>


## Set up archival fallback(deprecated) {#set-up-archival-fallback-deprecated}
<Tabs groupId="object-store">
<TabItem value="s3" label="Amazon S3">
```yaml
state-archive-read-config:
  - object-store-config:
      object-store: "S3"
      # Use mysten-testnet-archives for testnet
      # Use mysten-mainnet-archives for mainnet
      bucket: "mysten-<testnet|mainnet>-archives"
      # you can either provide your own aws credentials via "aws-secret-access-key" and
      # "aws-access-key-id" or set no-sign-request: true
      no-sign-request: true
      aws-region: "us-west-2"
      object-store-connection-limit: 20
    concurrency: 5
    # Whether to prune local state based on latest checkpoint in archive.
    # This should stay false for most use cases
    use-for-pruning-watermark: false
```
</TabItem>
<TabItem value="gcs" label="Google Cloud Storage">
```yaml
state-archive-read-config:
  - object-store-config:
      object-store: "GCS"
      # Use mysten-mainnet-archives for mainnet
      # Notice there is no archive bucket setup for testnet in GCS
      bucket: "mysten-<testnet|mainnet>-archives"
      # Use your gcloud service account credentials
      google-service-account: "</path/to/service/account/credentials>"
      object-store-connection-limit: 20
    # How many objects to read ahead when catching up
    concurrency: 5
    # Whether to prune local state based on latest checkpoint in archive.
    # This should stay false for most use cases
    use-for-pruning-watermark: false
```
</TabItem>
</Tabs>



```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/nft.mdx
```
---
title: Create a Non-Fungible Token
keywords: [ERC-721, NFT]
description: On Sui, everything is an object. Moreover, everything is a non-fungible token (NFT) as its objects are unique, non-fungible, and owned.
---

On Sui, everything is an object. Moreover, everything is a non-fungible token (NFT) as its objects are unique, non-fungible, and owned.

Creating NFTs on Sui differs from other blockchains that are not object based. Those blockchains require a dedicated standard to handle the properties that define NFTs because they are based on a mapping between smart contracts and the token's ID. For instance, the ERC-721 standard on Ethereum was necessary to pair a globally unique ID with the relevant smart contract address to create a unique token instance on the network. 

On Sui, every object already has a unique ID, so whether you're dealing with a million fungible tokens, like coins, or thousands of NFTs with individual characteristics, like SuiFrens, your smart contracts on Sui always interact with individual objects. 

Imagine you create an Excitable Chimp NFT collection on Sui and another blockchain that isn't object based. To get an attribute like the Chimp's name on the other blockchain, you would need to interact with the smart contract that created the NFT to get that information (typically from off-chain storage) using the NFT ID. On Sui, the name attribute can be a field on the object that defines the NFT itself. This construct provides a much more straightforward process for accessing metadata for the NFT as the smart contract that wants the information can just return the name from the object itself.

## Example

The following example creates a basic NFT on Sui. The `TestnetNFT` struct defines the NFT with an `id`, `name`, `description`, and `url` fields. 

{@inject: examples/move/nft/sources/testnet_nft.move#struct=TestnetNFT noComments}

In this example, anyone can mint the NFT by calling the `mint_to_sender` function. As the name suggests, the function creates a new `TestnetNFT` and transfers it to the address that makes the call. 

{@inject: examples/move/nft/sources/testnet_nft.move#fun=mint_to_sender noComments}

The module includes functions to return NFT metadata, too. Referencing the hypothetical used previously, you can call the `name` function to get that value. As you can see, the function simply returns the name field value of the NFT itself.

{@inject: examples/move/nft/sources/testnet_nft.move#fun=name noComments}

<details>
<summary>
`testnet_nft.move` 
</summary>

{@inject: examples/move/nft/sources/testnet_nft.move}

</details>

## Related links

- [Soulbound NFT](./nft/nft-soulbound.mdx): Example of a non-transferable NFT. 
- [NFT Rental](./nft/nft-rental.mdx): Example that rents NFTs using Kiosk Apps. 
- [Asset Tokenization](./nft/asset-tokenization.mdx): Example that uses NFTs to tokenize real-world assets.
- [Kiosk](../../standards/kiosk.mdx): Asset storage on the Sui network.
- [Kiosk Apps](../../standards/kiosk-apps.mdx): Extend the functionality of the Kiosk standard. 
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced.mdx
```
---
title: Advanced Topics
---

Information in the Advanced Topics section covers coding practices, useful features, and other developer-focused considerations that might arise as you continue your development journey on Sui. The topics in this section aren't necessarily more difficult than other topics, but they include subjects you might not encounter or need to consider until you're developing more advanced solutions on the Sui network.

## Custom Indexer

You can build custom indexers using the Sui micro-data ingestion framework. To create an indexer, you subscribe to a checkpoint stream with full checkpoint content. Establishing a custom indexer helps improve latency, allows pruning the data of your Sui Full node, and provides efficient assemblage of checkpoint data.

Go to [Custom Indexer](./advanced/custom-indexer.mdx).

## Migrating to GraphQL 

See the Migrating to GraphQL guide to upgrade your smart contracts to use the GraphQL API.

{@include: ../../snippets/migrate-to-graphql.mdx}

Go to [Migrating to GraphQL](./advanced/graphql-migration.mdx).
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/getting-started.mdx
```
---
title: Getting Started
---

Sui is the first internet-scale programmable blockchain platform. That might read like marketing speak, but as you peruse the documentation to understand the technology, you will discover that Sui addresses many of the problems that hold blockchains back from mass adoption. 

Before you can get started developing on Sui, you need to understand the code repository and install its binaries. 

## Install Sui 

{@include: ../../snippets/quick-install.mdx}

You can also install Sui from binaries or from source, as detailed in the Install Sui page.

Go to [Install Sui](./getting-started/sui-install.mdx).

## After installing Sui

After you have Sui installed on your system, you can begin to connect with a network and publish smart contracts. 

- [Connect to a Sui Network](./getting-started/connect.mdx)
- [Connect to a Local Network](./getting-started/local-network.mdx)
- [Get Sui Address](./getting-started/get-address.mdx)
- [Get SUI Coins](./getting-started/get-coins.mdx)
    :::tip
    {@include: ../../snippets/faucet-online.mdx}
    :::


## Access Sui data

Outline of the interfaces that are currently available to access the Sui network data, along with an overview of how that's gradually evolving.

Go to [Access Sui Data](./getting-started/data-serving.mdx).

## Move IDEs and plugins

The following table lists proven choices for IDEs with Move extensions. These IDEs and plugins are not required, but they provide a better experience for developing on Sui.

| IDE | Move plugin | Description |
| --- | ------ | ----------- |
| [Visual Studio Code](https://code.visualstudio.com/) | &bull; [Move extension](https://marketplace.visualstudio.com/items?itemName=mysten.move)<br/>&bull; [Move syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax) | The recommended free IDE for Move development from Microsoft. |
| [IntelliJ IDEA](https://www.jetbrains.com/idea/) | [Move Language Plugin](https://plugins.jetbrains.com/plugin/14721-move-language) | A commercial IDE from JetBrains. |
| [Emacs](https://www.gnu.org/software/emacs/) | [move-mode](https://github.com/amnn/move-mode) | A free and open source text editor. |
| [Github Codespaces](https://github.com/features/codespaces) | [Move Syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax) | A web-based IDE from GitHub. |

:::info 

Some plugins might not yet provide highlighting support for [Move 2024](./advanced/move-2024-migration.mdx).

:::

## Related links

After installing Sui and setting up your development environment, use the information in the following sections to continue your development journey.

- [App Examples](./app-examples.mdx): A mix of end-to-end examples that you can draw inspiration from in your own projects.
- [Sui 101](./sui-101.mdx): Topics that you should know when just starting out to develop on Sui.
- [Advanced Topics](./advanced.mdx): Topics that you might not find beneficial until you start solving more complex problems.
- [Cryptography](./cryptography.mdx): Leverage cryptography functions to provide security for your smart contract actions. 

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples.mdx
```
---
title: App Examples
description: Ever-growing list of example packages that demonstrate solutions built on the Sui blockchain, written by Sui and Move experts. Use these examples to learn Sui and Move, and to extract techniques you can apply to your own Sui projects.
---

The ever-growing number of examples in this section showcase packages for the Sui blockchain. Extract techniques used in these examples to apply to your own Sui projects as they are written by Sui and Move experts. 

{@include: ../../snippets/warn-ml-rpcs.mdx}

## Examples

Sui is dedicated to providing a wide range of examples to guide you in proper programming techniques for the Sui blockchain. This list will continue to grow, so check back often. 

:::tip

The projects are grouped by stack type and are sorted by complexity.

:::

### Full-stack apps
- [Distributed Counter](./app-examples/e2e-counter.mdx): An end-to-end example that creates a basic decentralized counter that anyone can increment, but only the object owner can reset it. The example includes Move code to create the package and leverages the Sui TypeScript SDK to provide a basic frontend.
- [Trustless Swap](./app-examples/trustless-swap.mdx): This example demonstrates trustless swaps on the Sui blockchain using a shared object as an escrow account.
- [Coin Flip](./app-examples/coin-flip.mdx): The Coin Flip app demonstrates on-chain randomness.
- [Reviews Rating](./app-examples/reviews-rating.mdx): This example demonstrates implementing a reviews-rating platform for the food service industry on Sui.
- [Blackjack](./app-examples/blackjack.mdx): This example demonstrates the logic behind an on-chain version of the popular casino card game, Blackjack.
- [Plinko](./app-examples/plinko.mdx): This example puts the classic Plinko game on chain, demonstrating use of cryptography-based strategies to create a fair and transparent game of chance. 

### Smart contracts
- [Tic-tac-toe](./app-examples/tic-tac-toe.mdx): Three implementations of the classic tic-tac-toe game on the Sui network to demonstrate different approaches to user interaction.

### Smart contracts & Backend
- [Weather Oracle](./app-examples/weather-oracle.mdx): The Sui Weather Oracle demonstrates how to create a basic weather oracle that provides real-time weather data.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/zklogin-onboarding.mdx
```
---
title: zkLogin Onboarding
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/dev-cheat-sheet.mdx
```
---
title: Sui Developer Cheat Sheet
sidebar_label: Dev Cheat Sheet
---

Quick reference on best practices for Sui Network developers.

## Move

### General

- Read about package upgrades and write upgrade-friendly code:
  - Packages are immutable, so buggy package code can be called forever. Add protections at the object level instead.
  - If you upgrade a package `P` to `P'`, other packages and clients that depend on `P` will continue using `P`, not auto-update to `P'`. Both dependent packages and client code must be explicitly updated to point at `P'`.
  - Packages that expect to be extended by dependent packages can avoid breaking their extensions with each upgrade by providing a standard (unchanging) interface that all versions conform to. See this example for [message sending](https://github.com/wormhole-foundation/wormhole/blob/74dea3bf22f0e27628b432c3e9eac05c85786a99/sui/wormhole/sources/publish_message.move) across a bridge from Wormhole. Extension packages that produce messages to send can use [`prepare_message`](https://github.com/wormhole-foundation/wormhole/blob/74dea3bf22f0e27628b432c3e9eac05c85786a99/sui/wormhole/sources/publish_message.move#L68-L90) from any version of the Wormhole package to produce a [`MessageTicket`](https://github.com/wormhole-foundation/wormhole/blob/74dea3bf22f0e27628b432c3e9eac05c85786a99/sui/wormhole/sources/publish_message.move#L52-L66) while client code to send the message must pass that `MessageTicket` into [`publish_message`](https://github.com/wormhole-foundation/wormhole/blob/74dea3bf22f0e27628b432c3e9eac05c85786a99/sui/wormhole/sources/publish_message.move#L92-L152) in the latest version of the package.
  - `public` function signatures cannot be deleted or changed, but `public(friend)` functions can. Use `public(friend)` or private visibility liberally unless you are exposing library functions that will live forever.
  - It is not possible to delete `struct` types, add new fields (though you can add dynamic fields), or add new [abilities](https://move-language.github.io/move/abilities.html) via an upgrade. Introduce new types carefully—they will live forever!
- Use `vector`-backed collections (`vector`, `VecSet`, `VecMap`, `PriorityQueue`) with a **known** maximum size of ≤ 1000 items.
  - Use dynamic field-backed collections (`Table`, `Bag`, `ObjectBag`, `ObjectTable`, `LinkedTable`) for any collection that allows third-party addition, larger collections, and collections of unknown size.
  - Move objects have a maximum size of 250KB—any attempt to create a larger object leads to an aborted transaction. Ensure that your objects do not have an ever-growing `vector`-backed collection.
- If your function `f` needs a payment in (e.g.) SUI from the caller, use `fun f(payment: Coin<SUI>)` not `fun f(payment: &mut Coin<SUI>, amount: u64)`. This is safer for callers—they know exactly how much they are paying, and do not need to trust `f` to extract the right amount.
- Don't micro-optimize gas usage. Sui computation costs are rounded up to the closest _bucket_, so only very drastic changes will make a difference. In particular, if your transaction is already in the lowest cost bucket, it can't get any cheaper.
- Follow the [Move coding conventions](https://move-language.github.io/move/coding-conventions.html) for consistent style.

### Composability

- Use the `display` standard to customize how your objects show up in wallets, apps, and explorers
- Avoid “self-transfers”—whenever possible, instead of writing `transfer::transfer(obj, tx_context::sender(ctx))`, return `obj` from the current function. This allows a caller or programmable transaction block to use `obj`.

### Testing

- Use [`sui::test_scenario`](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/test/test_scenario.move) to mimic multi-transaction, multi-sender test scenarios.
- Use the [`sui::test_utils`](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/test/test_utils.move#L5) module for better test error messages via `assert_eq`, debug printing via `print`, and test-only destruction via `destroy`.
- Use `sui move test --coverage` to compute code coverage information for your tests, and `sui move coverage source --module <name>` to see uncovered lines highlighted in red. Push coverage all the way to 100% if feasible.

## Apps

- For optimal performance and data consistency, apps should submit writes and reads for the same full node. In the TS SDK, this means that apps should use the wallet's [`signTransactionBlock`](https://sdk.mystenlabs.com/dapp-kit) API, then submit the transaction via a call to [`execute_transactionBlock`](/sui-api-ref#sui_executetransactionblock) on the app's full node, _not_ use the wallet's `signAndExecuteTransactionBlock` API. This ensures read-after-write-consistency--reads from the app's full node will reflect writes from the transaction right away instead of waiting for a checkpoint.
- For lower latency, use [`executeTransactionBlock`](/sui-api-ref#sui_executetransactionblock) with `"showEffects": false` and `"showEvents": false` if your app needs to know that a transaction was confirmed, but does not immediately need to see the transaction effects or read the objects/events written by the transaction.
- Apps should implement a local cache for frequently read data rather than over-fetching from the full node.
- Whenever possible, use programmable transaction blocks to compose existing on-chain functionality rather than publishing new smart contract code. Programmable transaction blocks allow large-scale batching and heterogeneous composition, driving already-low gas fees down even further.
- Apps should leave gas budget, gas price, and coin selection to the wallet. This gives wallets more flexibility, and it's the wallet's responsibility to dry run a transaction to ensure it doesn't fail.

## Signing

- **Never** sign two concurrent transactions that are touching the same owned object. Either use independent owned objects, or wait for one transaction to conclude before sending the next one. Violating this rule might lead to client [equivocation](/references/sui-glossary.mdx#equivocation), which locks up the owned objects involved in the two transactions until the end of the current epoch.
- Any `sui client` command that crafts a transaction (e.g., `sui client publish`, `sui client call`) can accept the `--serialize-output` flag to output a base64 transaction to be signed.
- Sui supports several signature schemes for transaction signing, including native multisig.

## zkLogin

- Call the proving service as sparingly as possible. Design your app flows such that you call the proving service only when the user is about to perform a real transaction.
- Beware of how you cache the ephemeral private key. Treat the private key akin to a piece of highly sensitive data, e.g., password. If an (unexpired) ephemeral private key and its corresponding ZK proof are leaked, then an attacker can steal user's assets.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/starter-templates.mdx
```
---
title: Starter Templates
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/stablecoins.mdx
```
---
title: Stablecoins on Sui
sidebar_label: Stablecoins
description: Stablecoins are a type of cryptocurrency that are designed to maintain a stable value relative to a fiat currency or a basket of assets. 
---

Stablecoins are a type of cryptocurrency that are designed to maintain a stable value relative to a fiat currency or a basket of assets. They are widely used for trading, lending, and as a store of value. 

## Available stablecoins

On Sui, you can interact with various stablecoins such as USDC, USDT, Agora, and Ondo USDY.

### USDC (USD Coin)

USDC is a fully collateralized US dollar stablecoin issued by regulated financial institutions. Each USDC token is backed by one US dollar held in reserve. USDC is widely used for trading, payments, and as a stable store of value.

For more detailed information on how to interact with USDC on Sui, refer to the [USDC guide](#usdc-guide).

**Site:** [Circle](https://www.circle.com/en/usdc)

### USDT (Tether)

USDT, also known as Tether, is one of the oldest and most widely used stablecoins. It is pegged to the US dollar and is backed by a mix of reserves, including cash, cash equivalents, and other assets.

USDT is currently not issued natively on Sui. For more information on bridging USDT to Sui, refer to [SUI Bridging](../../concepts/tokenomics/sui-bridging.mdx).

**Site:** [Tether](https://tether.to/)

### Agora

AUSD is a fully collateralized US dollar stablecoin issued by Agora Finance.

**Site:** [Agora Finance](https://www.agora.finance/)

### Ondo USDY
USDY is a fully collateralized US dollar stablecoin issued by Ondo Finance, allowing users to earn yield from US Treasury Bills.

**Site:** [Ondo Finance](https://ondo.finance/)

## How to use USDC on Sui {#usdc-guide}

:::info
While this example uses USDC, the same principles can be applied to any asset on Sui that uses the [Sui Coin standard](../../standards/coin.mdx).
:::

### Prerequisites

- Make sure you have some USDC tokens. Get Testnet tokens from Circle's [faucet](https://faucet.circle.com/).

### USDC stablecoin source code

The USDC stablecoin source code is available in the [circlefin/stablecoin-sui](https://github.com/circlefin/stablecoin-sui/blob/master/packages/usdc/sources/usdc.move) repository.

### Import the USDC module in your Move package

To import the USDC module, add the following line to the `[dependencies]` section of your Move package's `Move.toml` file:

```toml
usdc = { git = "https://github.com/circlefin/stablecoin-sui.git", subdir = "packages/usdc", rev = "master" }
```

After importing the module, your Move package should look like the following:

{@inject: examples/move/usdc_usage/Move.toml}

:::warning
The `usdc` package uses a specific version of the `sui` package, which causes a version conflict with the `Sui` package in the Sui framework. You can override the version of the `Sui` package in your `Move.toml` file to use a different version. Add the `override = true` flag to the `Sui` package in your `Move.toml` file.
:::

### Using USDC in Move

USDC uses the [Sui Coin standard](../../standards/coin.mdx) and can be used just like any other coin type in the Sui framework.

After importing the `usdc` package, you can use the `USDC` type.

```move
use usdc::usdc::USDC;
```

Then use the `USDC` type just as you would use the `SUI` type when accepting a `Coin<SUI>` parameter.

{@inject: examples/move/usdc_usage/sources/example.move#fun=buy_sword_with_usdc}

The following example demonstrates how to use the USDC stablecoin in a Move package and how it relates to using the `SUI` type as well as any generic coin types.

{@inject: examples/move/usdc_usage/sources/example.move}

### Using USDC in PTBs

Use USDC in your [PTBs](/guides/developer/sui-101/building-ptb) just like any other coin type.

Create a `Coin<USDC>` object with the `coinWithBalance` function.

```typescript
const usdcCoin = coinWithBalance({
  type: '0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29::usdc::USDC',
  balance: 1_000_000
})
```

:::info
`0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29` is the [Testnet address](https://suiscan.xyz/testnet/coin/0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29::usdc::USDC) for USDC, while `0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7` is the [Mainnet address](https://suiscan.xyz/coin/0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC).
:::

This coin object can be used as a parameter for any function that accepts a `Coin<USDC>` parameter or a generic `Coin` parameter.

```typescript
const [sword] = tx.moveCall({
  target: '0xcbbf37a851ed7b625731ca497e2d4aea18cf18145fac3b78bd64f274f6a09d30::usdc_usage::buy_sword_with_usdc', 
  arguments: [
    usdcCoin
  ]
});
```

```typescript
const [sword] = tx.moveCall({
  target: '0xcbbf37a851ed7b625731ca497e2d4aea18cf18145fac3b78bd64f274f6a09d30::usdc_usage::buy_sword_with_arbitrary_coin', 
  typeArguments: ['0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29::usdc::USDC'],
  arguments: [
    usdcCoin
  ]
});
```

This coin object can also be used as input for the `transferObjects` function.

```typescript
tx.transferObjects([usdcCoin], recipientAddress);
```

## Related links

- [Regulated Coin and Deny List](./coin/regulated.mdx): Create a regulated coin and add or remove names from the deny list.
- [Loyalty Token](./coin/loyalty.mdx): Create a token to reward user loyalty.
- [In-Game Token](./coin/in-game-token.mdx): Create tokens that can be used only within a mobile game.
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/coin.mdx
```
---
title: Create Coins and Tokens
description: Learn how to mint coins and tokens on the Sui network.
---

Coins and tokens on Sui are similar. In practice, the terms are used interchangeably, but there are some differences in their implementation. You can learn about these differences in the respective standard documentation, [Closed-Loop Token](../../standards/closed-loop-token.mdx) and [Coin](../../standards/coin.mdx).

Publishing a coin on Sui is similar to publishing a new type. The main difference is the requirement of a one time witness when creating a coin.

{@inject: examples/move/coin/sources/my_coin.move noComments}

The `Coin<T>` is a generic implementation of a coin on Sui. Access to the `TreasuryCap` provides control over the minting and burning of coins. Further transactions can be sent directly to the `sui::coin::Coin` with `TreasuryCap` object as authorization.

The example module includes a `mint` function. You pass the `TreasuryCap` created from the `init` function to the module's `mint` function. The function then uses the `mint` function from the `Coin` module to create (mint) a coin and then transfer it to an address. 

{@inject: examples/move/coin/sources/my_coin.move#fun=mint noComments}

### Sui CLI

If you published the previous example to a Sui network, you can use the `sui client call` command to mint coins and deliver them to the address you provide. See [Sui CLI](../../references/cli.mdx) for more information on the command line interface.

{@include: ../../snippets/info-gas-budget.mdx}

```sh
$ sui client call --function mint --module mycoin --package <PACKAGE-ID> --args <TREASURY-CAP-ID> <COIN-AMOUNT> <RECIPIENT-ADDRESS> --gas-budget <GAS-AMOUNT>
```

If the call is successful your console displays the result, which includes a **Balance Changes** section with the following information included:

```sh
...

Owner: Account Address ( <RECIPIENT-ADDRESS> ) 
CoinType: <PACKAGE-ID>::mycoin::MYCOIN 
Amount: <COIN-AMOUNT>

...
```

## DenyList

The Sui framework provides a `DenyList` singleton, shared object that the bearer of a `DenyCapV2` can access to specify a list of addresses that are unable to use a Sui core type. The initial use case for `DenyList`, however, focuses on limiting access to coins of a specified type. This is useful, for example, when creating a regulated coin on Sui that requires the ability to block certain addresses from using it as inputs to transactions. Regulated coins on Sui satisfy any regulations that require the ability to prevent known bad actors from having access to those coins. 

:::info

The `DenyList` object is a system object that has the address `0x403`. You cannot create it yourself.

:::

## Create regulated coin

If you need the ability to deny specific addresses from having access to your coin, you can use the `create_regulated_currency_v2` function (instead of `create_currency`) to create it.

Behind the scenes, `create_regulated_currency_v2` uses the `create_currency` function to create the coin, but also produces a `DenyCapV2` object that allows its bearer to control access to the coin's deny list in a `DenyList` object. Consequently, the way to create a coin using `create_regulated_currency_v2` is similar to the previous example, with the addition of a transfer of the `DenyCap` object to the module publisher.

## Create tokens

Tokens reuse the `TreasuryCap` defined in the `sui::coin` module and therefore have the same initialization process. The `coin::create_currency` function guarantees the uniqueness of the `TreasuryCap` and forces the creation of a `CoinMetadata` object.

Coin-like functions perform the minting and burning of tokens. Both require the `TreasuryCap`:

- `token::mint` - mint a token
- `token::burn` - burn a token

See [Closed-Loop Token](../../standards/closed-loop-token.mdx) standard for complete details of working with tokens.

## Related links

- [Regulated Coin and Deny List](./coin/regulated.mdx): Create a regulated coin and add or remove names from the deny list.
- [Loyalty Token](./coin/loyalty.mdx): Create a token to reward user loyalty.
- [In-Game Token](./coin/in-game-token.mdx): Create tokens that can be used only within a mobile game.
- [Stablecoins](./stablecoins): The Sui network has native stablecoins, including USDC.
- [One Time Witness](https://move-book.com/programmability/one-time-witness.html): The Move Book documentation of the one time witness pattern. 

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/first-app.mdx
```
---
title: Your First Sui dApp
description: Build your first dApp and publish it on chain. These guides demonstrate the basics you need to know to start your development journey on Sui.
---

Before you can create your first dApp on the Sui network, you must have [Sui installed](./getting-started/sui-install.mdx).

dApp stands for "decentralized application", which is an application that runs on a blockchain or decentralized network instead of a centralized server. Typical dApps do not run solely on the blockchain, but instead are composed of different pieces, like a TypeScript frontend that interacts with code that lives on a blockchain. Sui needs code written in Move for the pieces of a dApp that live on chain. These pieces are referred to as packages, modules, or smart contracts.

The instructions in this section walk you through writing a basic package, debugging and testing your code, and publishing. You need to follow these instructions in the order they appear to complete the exercise.

You use the `move` Sui CLI command for some instructions. The Sui CLI installs with the binaries, so you have it on your system if you follow the install instructions. To verify you have it installed, run the following command in a terminal or console.

```sh
$ sui --version
```

If the console does not respond with a version number similar to the following, see the instructions to install Sui.

```sh
$ sui 1.xx.x-abc123xyz
```

## Connecting to a network

After installing Sui, you can connect to a network. Sui has three public networks (Devnet, Testnet, Mainnet), and you can also run and connect to a local Sui network. For each network, you need an on-chain address specific to that network. The address is an object with a unique ID in the form `0x8bd4613c004aac53d06bb7ceb7f46832c9ae69bdc105dfc5fcac225d2061fcac`. In addition to that address, you need SUI to pay for the gas fees associated with your on-chain activity, like publishing packages and making Move calls to those packages. For all networks besides Mainnet, you can get free SUI coins for your account to facilitate package development. For the purposes of this example, connect to the Testnet network.

### Connect to Testnet

If you already have a network config set up, switch your active environment to Testnet. The following instruction is for the initial set up. 

1. In your terminal or console, use the following command to begin the configuration:
    ```sh
    $ sui client
    ```
1. At the prompt, type <kbd>y</kbd> and press <kbd>Enter</kbd> to connect to a Sui Full node server.
1. At the following prompt, type the address of the Testnet server (`https://fullnode.testnet.sui.io:443`) and press <kbd>Enter</kbd>.
1. At the following prompt, type `testnet` to give the network an alias and press <kbd>Enter</kbd>. You can use the alias in subsequent commands instead of typing the complete URL.
1. At the following prompt, type `0` and press <kbd>Enter</kbd>. The selection creates an address in the `ed25519` signing scheme.
1. The response provides an alias for your address, the actual address ID, and a secret recovery phrase. Be sure to save this information for later reference. Because this is on the Testnet network, the security of this information is not as important as if it were on Mainnet.
1. In your terminal or console, use the following command to get SUI for your account.
    ```sh
    $ sui client faucet
    ```
1. You can confirm that you received SUI by using the following command. There may be a delay in receiving coins depending on the activity of the network.
    ```sh
    $ sui client gas
    ```
You are now connected to the Sui Testnet network and should have an account with available SUI.  


## Related links

- [Write a Move Package](./first-app/write-package.mdx): Continue this example by creating the necessary Move code for your package.
- [Connect to a Sui Network](./getting-started/connect.mdx): Connect to an available Sui network.
- [Connect to a Local Network](./getting-started/local-network.mdx): Start and connect to a local Sui network.
- [Get Sui Address](./getting-started/get-address.mdx): Get an address for the current Sui network.
- [Get SUI Tokens](./getting-started/get-coins.mdx): Get SUI for the active address on Devnet, Testnet, or a local network.
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101.mdx
```
---
title: Sui 101
description: Collection of core Sui concepts that developers use to create objects and interact with them on the Sui blockchain. 
---

In many education systems, 101-level classes are those that teach core competencies to build a foundation for the more advanced topics that are to come. The topics in this section provide the same experience for the Sui blockchain. They examine the core Sui development concepts that you use to build apps on Sui. As you start developing more advanced solutions, knowledge of these topics provides a good base for understanding the more advanced concepts you will employ.

## Working with PTBs

You can create programmable transaction blocks (PTBs) on Sui to perform multiple commands in a single transaction. The Working with PTBs topics demonstrate how to build efficient PTBs using the Sui TypeScript SDK.

Go to [Working with PTBs](./sui-101/working-with-ptbs.mdx).

## Using Events

You can emit events from your published packages on the Sui network. Using Events demonstrates how to emit events from your on-chain packages and monitor the activity of other objects emitting events.

Go to [Using Events](./sui-101/using-events.mdx).

## Shared versus Owned Objects

Objects on Sui, unlike other blockchains, can be owned as well as shared. You can create transactions that leverage either type or both. Shared versus Owned Objects examines the differences and what considerations you should account for when deciding how to structure your on-chain app. 

Go to [Shared versus Owned Objects](./sui-101/shared-owned.mdx).

## Access On-Chain Time

Sui provides a `Clock` module you can use to get network-based time. Access On-Chain Time examines the `Clock` module and the behavior of the available methods that affect transaction processing speed and the temporal exactness of the data you receive.

Go to [Access On-Chain Time](./sui-101/access-time.mdx).
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/cryptography.mdx
```
---
title: Cryptography
---

Effective use of cryptography keeps your smart contract transactions secure on the Sui blockchain. 

## Signature verification

Move contracts in Sui support verifications for several on-chain signature schemes. Not all signatures supported in on-chain verification are supported as user signature verification. See [Signatures](../../concepts/cryptography/transaction-auth/signatures.mdx) for valid signature schemes for transaction authorization.

Go to [Sui On-Chain Signatures Verification in Move](./cryptography/signing.mdx).

## Groth16

A zero-knowledge proof is a method by which a party, known as the prover, can confirm the truthfulness of a claim without disclosing any information about the underlying data. For instance, it's possible for the prover to demonstrate they have solved a sudoku puzzle without showing the actual solution. Groth16 is one such proof you can use in your smart contracts.

Go to [Groth16](./cryptography/groth16.mdx).

## Hashing

A cryptographic hash function is a widely used cryptographic primitive that maps an arbitrary length input to a fixed length output, the hash value. The hash function is designed to be a one-way function, which means that it is infeasible to invert the function to find the input data from a given hash value, and to be collision resistant, which means that it is infeasible to find two different inputs that map to the same hash value. Use available hashing functions to provide security to your smart contracts.

Go to [Hashing](./cryptography/hashing.mdx).

## Elliptic Curve Verifiable Random Function (ECVRF)

Use ECVRFs to generate a random number and provide proof that the number used a secret key for generation. The public key corresponding to the secret key verifies the proof, so you can use it as a random number generator that generates outputs that anyone can verify. Applications that need verifiable randomness on chain can also benefit from its use.

Go to [ECVRF](./cryptography/ecvrf.mdx).

## Multisig

Sui allows you to mix and match key schemes in a single multisig account. For example, you can pick a single Ed25519 mnemonic-based key and two ECDSA secp256r1 keys to create a multisig account that always requires the Ed25519 key, but also one of the ECDSA secp256r1 keys to sign. You could use this structure for mobile secure enclave stored keys as two-factor authentication.

Go to [Multisig](./cryptography/multisig.mdx).

## Related links

- [Cryptography concepts](../../concepts/cryptography.mdx): Before you use the guides, you might want to learn about the concepts behind the use of cryptography on Sui.
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced/security-best-practices.mdx
```
---
title: Security Best Practices
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced/graphql-migration.mdx
```
---
title: Migrating to GraphQL (Alpha)
beta: testnet, devnet, mainnet
---

{@include: ../../../snippets/migrate-to-graphql.mdx}

For a comprehensive list of all available GraphQL features, consult the [reference](../../../references/sui-graphql).

:::info

{@include: ../../../snippets/data-serving-msg.mdx}

{@include: ../../../snippets/data-serving-gql-alpha.mdx}

:::

### Example 1: Get total transaction blocks

The goal is to get the total number of transaction blocks in the network.

<Tabs groupId="migrating-json-rpc">

<TabItem value="json-rpc1" label="JSON-RPC">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sui_getTotalTransactionBlocks",
  "params": []
}
```

</TabItem>
<TabItem value="graphql1" label="GraphQL">

```graphql
query {
  checkpoint {
    networkTotalTransactions
  }
}
```

</TabItem>
</Tabs>

### Example 2: Get a specific transaction block
The goal is to get the transaction block by its digest.

<Tabs groupId="migrating-json-rpc">

<TabItem value="json-rpc2" label="JSON-RPC">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sui_getTransactionBlock",
  "params": [
    "Hay2tj3GcDYcE3AMHrej5WDsHGPVAYsegcubixLUvXUF",
    {
      "showInput": true,
      "showRawInput": false,
      "showEffects": true,
      "showEvents": true,
      "showObjectChanges": false,
      "showBalanceChanges": false
    }
  ]
}
```

</TabItem>
<TabItem value="graphql2" label="GraphQL">

```graphql
query {
  transactionBlock(digest: "Hay2tj3GcDYcE3AMHrej5WDsHGPVAYsegcubixLUvXUF") {
    gasInput {
      gasSponsor {
        address
      }
      gasPrice
      gasBudget
    }
    effects {
      status
      timestamp
      checkpoint {
        sequenceNumber
      }
      epoch {
        epochId
        referenceGasPrice
      }
    }
  }
}
```
</TabItem>
</Tabs>

### Example 3: Get coin objects owned by an address

The goal is to return all `Coin<0x2::sui::SUI>` objects an address owns.

<Tabs groupId="migrating-json-rpc">

<TabItem value="json-rpc3" label="JSON-RPC">

```json
query {
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_getCoins",
  "params": [
    "0x5094652429957619e6efa79a404a6714d1126e63f551f4b6c7fb76440f8118c9", //owner
    "0x2::sui::SUI",                                                      //coin type
    "0xe5c651321915b06c81838c2e370109b554a448a78d3a56220f798398dde66eab", //cursor
    3 //limit
  ]
}
```

</TabItem>
<TabItem value="graphql3" label="GraphQL">

```graphql
query {
  address(address: "0x5094652429957619e6efa79a404a6714d1126e63f551f4b6c7fb76440f8118c9") {
    coins(
      first: 3,
      after: "IAB3ha2PEA4ESRF4UErsJufJEwYpmSbCq7UNpxIHnLhG",
      type: "0x2::sui::SUI"
    ) {
      nodes {
        address
      }
    }
  }
}
```

:::info
The cursor is now passed in the `after` (or `before`) fields on the connection, and the limit in the `first` or `last` fields.
:::

</TabItem>
</Tabs>

## New features

There are also things that GraphQL can do, which JSON-RPC cannot:

### Example 4: Getting objects by type

This query fetches the latest versions of objects of type `0x2::package::Publisher` that are currently live on-chain.

```graphql
query {
  objects(filter: { type: "0x2::package::Publisher" }) {
    nodes {
      address
      digest
      asMoveObject {
        contents { json }
      }
    }
  }
}
```

### Example 5: Paging through package versions

The goal is to find all versions of the Sui framework, and list their modules:

```graphql
query {
  packageVersions(address: "0x2") {
    nodes {
      version
      modules {
        nodes {
          name
        }
      }
    }
  } 
}
```

## Related links
  
- [GraphQL reference](../../../references/sui-graphql.mdx): Auto-generated GraphQL reference for Sui RPC.
- [GraphQL quick-start](../getting-started/graphql-rpc.mdx): Querying Sui RPC with GraphQL gets you started using GraphQL to query the Sui RPC for on-chain data.
- [GraphQL concepts](../../../concepts/graphql-rpc.mdx): GraphQL for Sui RPC examines the elements of GraphQL that you should know to get the most from the service.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced/custom-indexer.mdx
```
---
title: Custom Indexer
description: You can build custom indexers using the Sui micro-data ingestion framework. To create an indexer, you subscribe to a checkpoint stream with full checkpoint content. Establishing a custom indexer helps improve latency, allows pruning the data of your Sui Full node, and provides efficient assemblage of checkpoint data.
---

:::info

{@include: ../../../snippets/data-serving-msg.mdx}

:::

You can build custom indexers using the Sui micro-data ingestion framework. To create an indexer, you subscribe to a checkpoint stream with full checkpoint content. This stream can be one of the publicly available streams from Mysten Labs, one that you set up in your local environment, or a combination of the two.  

Establishing a custom indexer helps improve latency, allows pruning the data of your Sui Full node, and provides efficient assemblage of checkpoint data.

## Interface and data format

To use the framework, implement a basic interface:

```rust
#[async_trait]
trait Worker: Send + Sync {
    async fn process_checkpoint(&self, checkpoint: &CheckpointData) -> Result<()>;
}
```

In this example, the `CheckpointData` struct represents full checkpoint content. The struct contains checkpoint summary and contents, as well as detailed information about each individual transaction. The individual transaction data includes events and input/output objects. The full definition for this content is in the [full_checkpoint_content.rs](https://github.com/MystenLabs/sui/blob/releases/sui-graphql-rpc-v2024.1.0-release/crates/sui-types/src/full_checkpoint_content.rs) file of the `sui-types` crate.

:::tip

See the [Source code for an implementation](#source-code) section for a complete code example.

:::

## Checkpoint stream sources

Data ingestion for your indexer supports several checkpoint stream sources.

### Remote reader

The most straightforward stream source is to subscribe to a remote store of checkpoint contents. Mysten Labs provides the following buckets:

- Testnet: `https://checkpoints.testnet.sui.io`
- Mainnet: `https://checkpoints.mainnet.sui.io`

The checkpoint files are stored in the following format: `https://checkpoints.testnet.sui.io/<checkpoint_id>.chk`. You can download the checkpoint file by sending an HTTP GET request to the relevant URL. Try it yourself for checkpoint 1 at [https://checkpoints.testnet.sui.io/1.chk](https://checkpoints.testnet.sui.io/1.chk).

```mermaid
flowchart LR
  A("fa:fa-cloud Cloud storage(S3, GCP)");
  B[("fa:fa-gears
  Indexer
  daemon")];
  B-->A;
  B<-->C("fa:fa-floppy-disk Progress store");
  subgraph External
    D("fa:fa-database Postgres");
    E("fa:fa-database BigQuery");
    F("fa:fa-database S3");
  end
  B-->External
```

The Sui data ingestion framework provides a helper function to quickly bootstrap an indexer workflow.

{@inject: examples/custom-indexer/rust/remote_reader.rs}

This is suitable for setups with a single ingestion pipeline where progress tracking is managed outside of the framework.

### Local reader

Colocate the data ingestion daemon with a Full node and enable checkpoint dumping on the latter to set up a local stream source. After enabling, the Full node starts dumping executed checkpoints as files to a local directory, and the data ingestion daemon subscribes to changes in the directory through an inotify-like mechanism. This approach allows minimizing ingestion latency (checkpoint are processed immediately after a checkpoint executor on a Full node) and getting rid of dependency on an externally managed bucket.

To enable, add the following to your [Full node configuration](../../operator/sui-full-node.mdx) file:

```yaml
checkpoint-executor-config:
  checkpoint-execution-max-concurrency: 200
  local-execution-timeout-sec: 30
  data-ingestion-dir: <path to a local directory>
```

```mermaid
flowchart LR
  subgraph Sui
    A("fa:fa-server Full node");
    A-->B("fa:fa-folder Local directory");
    B-->C[("fa:fa-gears
    Indexer
    daemon")];
  end
  subgraph cloud[Cloud storage]
    pg(fa:fa-cloud Postgres);
    bq(fa:fa-cloud BigQuery);
    s1(fa:fa-cloud S3);
  end
  C-->cloud;
  C<-->D("fa:fa-floppy-disk Progress store");
```

{@inject: examples/custom-indexer/rust/local_reader.rs}

Let's highlight a couple lines of code:

```rust
let worker_pool = WorkerPool::new(CustomWorker, "local_reader".to_string(), concurrency);
executor.register(worker_pool).await?;
```

The data ingestion executor can run multiple workflows simultaneously. For each workflow, you need to create a separate worker pool and register it in the executor. The `WorkerPool` requires an instance of the `Worker` trait, the name of the workflow (which is used for tracking the progress of the flow in the progress store and metrics), and concurrency.

The concurrency parameter specifies how many threads the workflow uses. Having a concurrency value greater than 1 is helpful when tasks are idempotent and can be processed in parallel and out of order. The executor only updates the progress/watermark to a certain checkpoint when all preceding checkpoints are processed.

### Hybrid mode

Specify both a local and remote store as a fallback to ensure constant data flow. The framework always prioritizes locally available checkpoint data over remote data. It's useful when you want to start utilizing your own Full node for data ingestion but need to partially backfill historical data or just have a failover. 

```rust
executor.run(
    PathBuf::from("./chk".to_string()), // path to a local directory
    Some("https://checkpoints.testnet.sui.io".to_string()), // Remote Checkpoint Store
    vec![], // optional remote store access options
    ReaderOptions::default(),
    exit_receiver,
    ).await?;
```


### Manifest 

Code for the cargo.toml manifest file for the custom indexer.

{@inject: examples/custom-indexer/rust/Cargo.toml}

## Source code for an implementation {#source-code}

Find the following source code in the [Sui repo](https://github.com/mystenlabs/sui/tree/main/examples/custom-indexer/rust). 

{@inject: examples/custom-indexer/rust/Cargo.toml}

{@inject: examples/custom-indexer/rust/local_reader.rs}

{@inject: examples/custom-indexer/rust/remote_reader.rs}


## Related links

- [Sui internal example](https://github.com/MystenLabs/sui/tree/main/crates/sui-data-ingestion/src/): Sui data ingestion daemon that runs internal pipelines.
- [Production example](https://github.com/MystenLabs/sui/tree/main/crates/suins-indexer/src): Sui Name Service custom indexer.
- [Using Events](../sui-101/using-events.mdx): Events in Sui enable you to monitor on-chain activity in near-real time when coupled with a custom indexer.


```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced/wallet-integrations.mdx
```
---
title: Wallet Integrations
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced/min-gas-fees.mdx
```
---
title: Minimize Gas Fees
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced/randomness-onchain.mdx
```
---
title: On-Chain Randomness
description: Randomness is a valuable tool to simulate chance on chain, but can also expose flaws in your logic. Understanding the vulnerabilities and accounting for them can mitigate the threat exposure for your smart contracts.
---

Generating pseudo-random values in Move is similar to solutions in other languages. A Move function can create a new instance of `RandomGenerator` and use it for generating random values of different types, for example, `generate_u128(&mut generator), generate_u8_in_range(&mut generator, 1, 6)`, or,

```move
entry fun roll_dice(r: &Random, ctx: &mut TxContext): Dice {
  let mut generator = new_generator(r, ctx); // generator is a PRG
  Dice { value: random::generate_u8_in_range(&mut generator, 1, 6) }
}
```

`Random` has a reserved address `0x8`. See <a href="/references/framework/sui-framework/random" data-noBrokenLinkCheck='true'>random.move</a> for the Move APIs for accessing randomness on Sui.

:::note

Although `Random` is a shared object, it is inaccessible for mutable operations, and any transaction attempting to modify it fails.

:::

Having access to random numbers is only one part of designing secure applications, you should also pay careful attention to how you use that randomness.
To securely access randomness:

- Define your function as (private) `entry`.
- Prefer generating randomness using function-local `RandomGenerator`.
- Make sure that the "unhappy path" of your function does not consume more resources than the "happy path".

## Limited resources and `Random` dependent flows

Be aware that some resources that are available to transactions are limited.
If you are not careful, an attacker can break or exploit your application by deliberately controlling the point where your function runs out of resources.

Concretely, gas is such a resource.
Consider the following vulnerable code:

```move
// Insecure implementation, do not use!
entry fun insecure_play(r: &Random, payment: Coin<SUI>, ...) {
  ...
  let mut generator = new_generator(r, ctx);
  let win = generator.generate_bool();
  if (win) { // happy flow
    ... cheap computation ...
  } else {
    ... very expensive computation ...
  }
}
```

Observe that the gas costs of a transaction that calls `insecure_play` depends on the value of `win`.
An attacker could call this function with a gas budget that is sufficient for the "happy flow" but not the "unhappy one", resulting in it either winning or reverting the transaction (but never losing the payment).

:::warning

The `Random` API does not automatically prevent this kind of attack, and you must be aware of this subtlety when designing your contracts.

:::


Other limited resources per transaction that you should consider are:

- The number of new objects.
- The number of objects that can be used (including dynamic fields).
- Number of events emitted.
- Number of UIDs generated, or deleted, or transferred.
- For a complete list of the current limits defined in the Protocol Config, see [this](https://github.com/MystenLabs/sui/blob/main/crates/sui-protocol-config/src/lib.rs#L731).



For many use cases this attack is not an issue, like when selecting a raffle winner, or lottery numbers, as the code running is independent of the randomness.
However, in the cases where it can be problematic, you can consider one of the following:

- Use two steps:
Split the logic to two functions that must be called by different transactions.
The first function, called by transaction `tx1`, fetches a random value and stores it in an object that is unreadable by other commands in `tx1` (for example, by transferring the object to the caller, or, by storing the tx digest and checking it is different on read).
A second function, called by transaction `tx2`, reads the stored value and completes the operation.
`tx2` might indeed fail, but now the random value is fixed and cannot be modified using repeated calls.
It is important that the inputs to the second function are fixed and cannot be modified after `tx1` (otherwise an attacker can modify them after seeing the randomness committed by `tx1`).
Also, it is important to gracefully handle the case in which the second step is never completed (for example, charge a fee in the first step).
See [this](https://github.com/MystenLabs/sui/blob/main/examples/move/random/random_nft/sources/example.move#L117-L142) for example implementation.
- Write the function in a way that the happy flow consumes more resources than the unhappy one. Keep the following in mind:
  - External functions or native ones can change in the future, potentially resulting in different costs compared to the time you conducted your tests.
  - [profile-transaction](../../../references/cli/client.mdx#profile-a-transaction) can be used to profile the costs of a transaction.
  - UIDs generated and deleted on the same transaction do not count towards the limit. 



## Use (non-public) `entry` functions

While composition is very powerful for smart contracts, it opens the door to attacks on functions that use randomness.
Consider for example a betting game that uses randomness for rolling dice:

```move
module games::dice {
  ...
  public enum Ticket has drop {
    Lost,
    Won,
  }

  public fun is_winner(t: &Ticket): bool {
    match (t) {
      Ticket::Won => true,
      Ticket::Lost => false,
    }
  }

  /// If you guess correctly the output, then you get a GuessedCorrectly object.
  /// Otherwise you get nothing.
  public fun play_dice(guess: u8, fee: Coin<SUI>, r: &Random, ctx: &mut TxContext): Ticket {
    // Pay for the turn
    assert!(coin::value(&fee) == 1000000, EInvalidAmount);
    transfer::public_transfer(fee, CREATOR_ADDRESS);

    // Roll the dice
    let mut generator = new_generator(r, ctx);
    if (guess == generator.generate_u8_in_range(1, 6)) {
      Ticket::Won
    } else {
      Ticket::Lost
    }
  }
  ...
}
```

An attacker can deploy the next function:

```move
public fun attack(guess: u8, r: &Random, ctx: &mut TxContext): Ticket {
  let t = dice::play_dice(guess, r, ctx);
  // revert the transaction if play_dice lost
  assert!(!dice::is_winner(&t), 0);
  t
}
```

The attacker can now call `attack` with a guess, and **always** revert the fee transfer if the guess is incorrect.

To protect against composition attacks, define your function as a private `entry` function so functions from other modules cannot call it.

:::tip

The Move compiler enforces this behavior by rejecting `public` functions with `Random` as an argument.

:::

## Programmable transaction block (PTB) restrictions

A similar attack to the one previously described involves PTBs _even_ when `play_dice` is defined as a private `entry` function.
For example, consider the `entry play_dice(guess: u8, fee: Coin<SUI>, r: &Random, ctx: &mut TxContext): Ticket { … }` function defined earlier, the attacker can publish the function

```move
public fun attack(t: Ticket): Ticket {
  assert!(!dice::is_winner(&t), 0);
  t
}
```

and send a PTB with commands `play_dice(...), attack(Result(0))` where `Result(0)` is the output of the first command.
As before, the attack takes advantage of the atomic nature of PTBs and always reverts the _entire transaction_ if the
guess was incorrect, without paying the fee. Sending multiple transactions can repeat the attack, each one executed with
different randomness and reverted if the guess is incorrect.

:::tip

To protect against PTB-based composition attacks, Sui rejects PTBs that have commands that are not `TransferObjects` or `MergeCoins` following a `MoveCall` command that uses `Random` as an input.

:::

## Instantiating `RandomGenerator`

`RandomGenerator` is secure as long as it's created by the consuming module. If passed as an argument, the caller might be able to predict the outputs of that `RandomGenerator` instance (for example, by calling `bcs::to_bytes(&generator)` and parsing its internal state).

:::tip

The Move compiler enforces this behavior by rejecting `public` functions with `RandomGenerator` as an argument.

:::

## Accessing `Random` from TypeScript

If you want to call `roll_dice(r: &Random, ctx: &mut TxContext)` in module `example`, use the following code snippet:

```typescript
const tx = new Transaction();
tx.moveCall({
  target: "${PACKAGE_ID}::example::roll_dice",
  arguments: [tx.object.random()]
});
...
```

## Related Links

- [Sui Framework Reference](../../../references/framework)
  - <a href="/references/framework/sui-framework/random" data-noBrokenLinkCheck="true">
    	random.move
    </a>
- [Raffle example](https://github.com/MystenLabs/sui/blob/main/examples/move/random/raffles)
- [Sui Client CLI](../../../references/cli/client)

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced/move-2024-migration.mdx
```
---
title: Migrating to Move 2024
description: New features are becoming available to Move in 2024. These features are opt-in, so existing code will continue to function as expected. If you want to use these features in code you've already written, however, there are some steps you must take and breaking changes to be aware of to migrate to Move 2024.
---

New features for Move are becoming available in 2024, a part of the aptly titled "Move 2024" edition. Many of these changes are enhancements to the source language, affecting the compiler without requiring any changes to the binary representation published on chain.

The primary goal of these changes is to make Move easier to write, and hopefully easier to read. The relatively few breaking changes introduced to the source language are to better position Move to handle future advancements.

Existing code will continue to compile, even with the addition of these new features. And because these features are opt-in, you can write your packages with the new features, even if your dependencies do not. Opting to take advantage of the new features in your current modules, however, does introduce some breaking changes.

This document highlights some new features to try out and shows how to migrate your existing modules to use Move 2024.

:::info

Please, provide any feedback or report any issues you encounter via [GitHub](https://github.com/MystenLabs/sui/issues/new/choose), [Discord](https://discord.gg/Sui), or [Telegram](https://t.me/SuiTokenNetwork).

:::

## How to migrate

To migrate a project to Move 2024 Beta:

1. Delete your existing `Move.lock` file (if one exists) to make sure you're using the newest `sui-framework` version.
1. Perform one of the following:
   - Run `sui move migrate` in the root of your Move project. See [Automatic migration](#automatic-migration).
   - Alternatively, update your `Move.toml` file's `[package]` entry to include `edition = "2024.beta"`. If you do this, you might receive a number of new errors related to the [breaking changes](#breaking-changes).

### Automatic migration {#automatic-migration}

Move 2024 includes an automatic migration script that you can use by calling `sui move migrate` in the root of your Move project. Upon running, your console prompts you for which Move edition to use. If you select `2024.beta`, the script invokes the compiler and attempts to automatically update your code to avoid the [breaking changes](#breaking-changes) the update introduces (including marking structs as `public`, mutable variables with the `mut` keyword, avoiding restricted keywords, swapping `friend`s for `public(package)`, and even updating paths to global paths in many cases).

After this is done, your console displays a diff of the changes the script intends to make. If you accept the changes, the script updates your code and your `Move.toml` file automatically. You are now using Move 2024 Beta.

### Update IDE support

Use the new [VSCode Move extension](https://marketplace.visualstudio.com/items?itemName=mysten.move) to get support for Move 2024 features. The new extension has a number of improvements over the original [move-analyzer extension](https://marketplace.visualstudio.com/items?itemName=move.move-analyzer), but if you would like to keep using the original one, be sure to rebuild and reinstall the `move-analyzer` binary to get 2024 support:

```sh
$ cargo install --git https://github.com/MystenLabs/sui.git move-analyzer
```

See the getting started guide on [Move IDEs and plugins](../../../references/contribute/sui-environment.mdx#move-ides-and-plugins) for more information.

## New features

Here is a brief overview of some of the new features in Move 2024.

### Method syntax

You can call certain functions now as methods using the `.` syntax. For example, the following call

```move
vector::push_back(&mut v, coin::value(&c));
```

can now be written as

```move
v.push_back(c.value());
```

Where the receiver of the method (`v` and `c` in this example) is automatically borrowed if necessary (as `&mut v` and `&c` respectively).

You can call any function defined in the same module as the receiver's type as a method if it takes the receiver as its first argument.

For functions defined outside the module, you can declare methods using `public use fun` and `use fun`.

### Index syntax

With method syntax, you can annotate certain functions as being `#[syntax(index)]` methods. You then call these methods using `v[i]`-style calls.

For example,

```move
*&mut v[i] = v[j];
```

resolves to

```move
*vector::borrow_mut(&mut v, i) = *vector::borrow(&v, j);
```

### public(package) {#public-package}

`friend` declarations, and the associated `public(friend)` visibility modifiers, are deprecated. In their place is the `public(package)` visibility modifier, which allows calling functions only within the same package where they are defined.

### Positional fields

You can now define `struct`s with positional fields, which are accessed by zero-based index. For example,

```move
public struct Pair(u64, u64) has copy, drop, store;
```

then to access each field,

```move
public fun sum(p: &Pair): u64 {
  p.0 + p.1
}
```

And as this example shows, you can now declare abilities after the struct field list.

### Nested `use` and standard library defaults

You can now nest `use` aliases for more conciseness.

```move
use sui::{balance, coin::{Self, Coin}};
```

Additionally, the following `use` declarations are now automatically included in every module:

```move
use std::vector;
use std::option::{Self, Option};
use sui::object::{Self, ID, UID};
use sui::transfer;
use sui::tx_context::{Self, TxContext};
```

### Automatic referencing in equality

Equality operations, `==` and `!=`, now automatically borrow if one side is a reference and the other is not. For example,

```move
fun check(x: u64, r: &u64): bool {
  x == r
}
```

is equivalent to

```move
fun check(x: u64, r: &u64): bool {
  &x == r
}
```

This automatic borrowing can occur on either side of `==` and `!=`.

### Loop labels

When nesting loops, it can be convenient to break to the outer loop. For example,

```move
let mut i = 0;
let mut j = 0;
let mut terminate_loop = false;
while (i < 10) {
    while (j < 10) {
        if (haystack(i, j) == needle) {
            terminate_loop = true;
            break;
        };
        j = j + 1;
    };
    if (terminate_loop) break;
    i = i + 1;
}
```

Now, you can directly name the outer loop (`outer` in this case) and break it all at once:

```move
let mut i = 0;
let mut j = 0;
'outer: while (i < 10) {
    while (j < 10) {
        if (haystack(i, j) == needle) break'outer;
        j = j + 1;
    };
    i = i + 1;
}
```

### `break` with value

It's now possible to `break` with a value from a `loop`. For example,

```move
let mut i = 0;
let x: u64 = loop {
    if (v[i] > 10) break i;
    i = i + 1;
};
```

You can achieve this with labels, as well. For example,

```move
let mut i = 0;
let mut j = 0;
let item = 'outer: loop {
    while (j < 10) {
        let item = haystack(i, j);
        if (item == needle) break'outer option::some(item);
        j = j + 1;
    };
    i = i + 1;
    if (i == 10) break option::none();
};
```

## Breaking changes {#breaking-changes}

Breaking changes are, unfortunately, a growing pain in Move 2024. We anticipate these changes to be minimally invasive and have provided a migration script to automate them in most cases. In addition, these changes pave the way for new features still to come in Move 2024.

### Datatype visibility requirements

Currently, all structs in Move are, by convention, public: any other module or package can import them and refer to them by type. To make this clearer, Move 2024 requires that all structs be declared with the `public` keyword. For example,

```move
// legacy code
struct S { x: u64 }

// Move 2024 code
public struct S { x: u64 }
```

Any non-public struct produces an error at this time, though the Move team is working on new visibility options for future releases.

### Mutability requirements

Previously, all variables in Move were implicitly mutable. For example,

```move
fun f(s: S, y: u64): u64 {
    let a = 0;
    let S { x } = s;
    a = 1;
    x = 10;
    y = 5;
    x + y
}
```

Now, you must declare mutable variables explicitly:

```move
fun f(s: S, mut y: u64): u64 {
    let mut a = 0;
    let S { mut x } = 5;
    a = 1;
    x = 10;
    y = 5;
    x + y
}
```

The compiler now produces an error if you attempt to reassign or borrow a variable mutably without this explicit declaration.

### Removing friends and `public(friend)`

Friends and the `public(friend)` visibilities were introduced early in Move's development, predating even the package system. As indicated in the [public(package)](#public-package) section, `public(package)` deprecates `public(friend)` in Move 2024.

The following declaration now produces an error:

```move
module pkg::m {
    friend pkg::a;
    public(friend) fun f() { ... }
}

module pkg::a {
    fun calls_f() { ... pkg::m::f() ... }
}
```

Instead, if you want your function to be visible only in the package, write:

```move
module pkg::m {
    public(package) fun f() { ... }
}

module pkg::a {
    // this now works directly
    fun calls_f() { ... pkg::m::f() ... }
}
```

### New keywords

Looking toward the future, Move 2024 Beta adds the following keywords to the language: `enum`, `for`, `match`, `mut`, and `type`. The compiler, unfortunately, now produces parsing errors when it finds these in other positions. This is a necessary change as the language matures. If you perform automatic migration, the migration tool renames these as `enum` and so on, rewriting the code to use these escaped forms.

### Revised paths and namespaces

Move 2024 revises how paths and namespaces work compared to legacy Move, toward easing `enum` aliasing in the future. Consider the following snippet from a test annotation in the `sui_system` library:

```move
use sui_system::sui_system;
...
#[expected_failure(abort_code = sui_system::validator_set::EInvalidCap)]
```

Legacy Move would always treat a three-part name as an address(`sui_system`), module(`validator_set`), and module member (`EInvalidCap`). Move 2024 respects scope for `use`, so `sui_system` in the attribute resolves to the module, producing a name resolution error overall.

To avoid cases where this is the intended behavior, Move 2024 introduces a prefix operation for global qualification. To use, you can rewrite this annotation as:

```move
use sui_system::sui_system;
...
#[expected_failure(abort_code = ::sui_system::validator_set::EInvalidCap)]
                             // ^ note `::` here
```

The migration script attempts to remediate naming errors using global qualification when possible.

## Follow along

The beta release of Move 2024 comes with some powerful new features in addition to the breaking changes described here. There are also more on the horizon. Join the [Sui developer newsletter](https://sui.io/developers#newsletter) to learn about new, exciting features coming to Move this year, including syntactic macros, enums with pattern matching, and other user-defined syntax extensions.

### `alpha` and `beta` guidance

- `beta` (specified via `edition = "2024.beta"`) is the recommended edition. It includes all the new
  features mentioned above and all breaking changes. While there is the risk of breaking changes or
  bugs in `beta`, you should feel comfortable using it in your projects. As new features are added
  and tested, they will be included in the `beta` edition. The `beta` edition will end after _all_
  features for the year have been added and finalized.
- `alpha` (specified via `edition = "2024.alpha"`) will get new features and changes as they are
  developed. Breaking changes to features in `alpha` should be expected. As such, take caution when
  using`alpha` in your projects.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced/maximize-reach.mdx
```
---
title: Maximize your Reach
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced/local-fee-markets.mdx
```
---
title: Object-Based Local Fee Markets
description: Object-based local fee markets limit the rate of transactions writing to a single shared object, preventing the network from becoming overloaded with checkpoints that take too long to execute.
---

Object-based local fee markets limit the rate of transactions writing to a single shared object, preventing the network from becoming overloaded with checkpoints that take too long to execute.

The Sui network's object-based architecture allows processing many different user transactions massively in parallel, in a way that's not possible on most other networks. However, if multiple transactions are all writing to the same shared object, they must execute in sequential order. There is a limit to how many transactions the network can process that touch one specific object.

If you see transactions fail with the error `ExecutionCancelledDueToSharedObjectCongestion`, you are observing object-based local fee markets at work. Continue reading to learn:

- How transaction space is allocated on a congested shared object.
- How to bid for priority access to limited space.
- How to structure your applications and transactions for maximum throughput.

## How object-based local fee markets work

Sui's local fee market algorithm runs every time a new batch of sequenced transactions is received from consensus.

1. Sorts all transactions in order of gas price, from highest to lowest.

1. Estimates each transaction's execution cost using the [`ExecutionTimeEstimate`](https://github.com/MystenLabs/sui/blob/main/crates/sui-core/src/authority/execution_time_estimator.rs) heuristic.

1. The [`SharedObjectCongestionTracker`](https://github.com/MystenLabs/sui/blob/main/crates/sui-core/src/authority/shared_object_congestion_tracker.rs) keeps a running tally of how much per-object congestion budget is used. If all shared objects used by the transaction have enough budget left, the transaction is scheduled. In that case, it consumes budget for the mutable shared objects that it uses. Keep in mind that immutable shared objects don't consume any budget, because multiple immutable uses of a shared object can execute in parallel. If the transaction cannot be scheduled, it is deferred until the next commit.

### Priority ordering of transactions

Transaction priority is determined solely by gas price. If you want your transaction to be assigned access to shared objects ahead of others in the same consensus commit, you must pay a higher gas price than the others. This is the only way to get priority access.

Using a gas price that is at least five times the reference gas price also increases the likelihood that the transaction is included in the earliest consensus commit possible. See [SIP-45](https://github.com/sui-foundation/sips/blob/main/sips/sip-45.md) for details.

### Cost estimation of transactions

Sui limits the per-commit execution capacity of each shared object. If transactions touching a shared object have a low estimated execution time, more of them can fit. If they have a high estimated execution time, not as many can fit.  

Transaction execution time is estimated separately for each top-level Move function called from a PTB. Measurements of actual execution time are shared between the validators, and the cost estimate used for scheduling is the stake-weighted median of these measurements of past invocations. (For most functions, which are never called with congested inputs, a low default estimate is used.)

### Transaction deferral

If the network is unable to schedule a transaction because it's trying to use a congested shared object with no space left, the transaction is deferred. This means that validators hold onto the transaction and attempt to schedule it with the next commit, each time prioritizing all waiting transactions by gas price.

If a transaction is deferred for several commits without successfully being scheduled, it's cancelled and returns an `ExecutionCancelledDueToSharedObjectCongestion` error. You'll need to try it again with a higher gas price, or at a time when the shared objects it depends on are not as congested.

### Determining total per-object capacity

At the protocol level, Sui is configured with a per-commit target utilization and burst capacity for each shared object. On average, a shared object's activity cannot exceed the per-commit limit. However, short bursts of traffic might exceed the limit temporarily.

There is no way to increase the total execution capacity of a particular shared object. The network sets that limit to ensure that validators, Full nodes, and indexers can all execute checkpoints in a reasonable amount of time.

## Practical takeaways

- For priority access to a congested shared object, set a higher gas price.

- When designing Move packages, avoid using a single shared object if possible. For example, a DEX application with a single, main shared object and dynamic fields for each currency pair would suffer much more congestion than one with a separate object per currency pair.

- If your object `O` is congested, optimize the execution time of the functions that are commonly used to access the object. For example, if all the accesses to your object happen via Move function `f`, halving the execution time of `f` will effectively double the number of transactions that can touch `O` in a single commit.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/advanced/efficient-smart-contracts.mdx
```
---
title: Efficient Smart Contracts
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/getting-started/connect.mdx
```
---
title: Connect to a Sui Network
description: Besides Mainnet, Sui offers Testnet, Devnet, and local networks that you can connect to for development. You can also configure a custom RPC endpoint. 
---

Sui has Mainnet, Devnet, and Testnet networks available. You can use one of the test networks, Devnet or Testnet, to experiment with the version of Sui running on that network. You can also spin up a [local Sui network](./local-network.mdx) for local development. 

The Sui Testnet and Devnet networks consist of several validator nodes to validate each network's transactions. Clients send transactions and read requests via this endpoint: `https://fullnode.<SUI-NETWORK-VERSION>.sui.io:443` using [JSON-RPC](/references/sui-api.mdx).

You can [request test SUI tokens](#request-test-tokens) through the Sui [devnet-faucet](https://discordapp.com/channels/916379725201563759/971488439931392130) and [testnet-faucet](https://discord.com/channels/916379725201563759/1037811694564560966) Discord channels, depending on which version of the network you use. If connected to Localnet, use cURL to request tokens from your [local faucet](./local-network.mdx#use-the-local-faucet). The coins on these networks have no financial value. There is no faucet service for Mainnet.

See announcements about Sui in the [#announcements](https://discord.com/channels/916379725201563759/925109817834631189) Discord channel.

See the [terms of service](https://sui.io/terms/) for using Sui networks.

{@include: ../../../snippets/data-wipe.mdx}

## Sui CLI

Sui provides [Sui command line interface (CLI)](/references/cli/client.mdx) to interact with Sui networks:

- Create and manage your private keys
- Create example NFTs
- Call and publish Move modules


## Environment set up

First, [Install Sui](./sui-install.mdx#install-binaries). After you install Sui, [request SUI test tokens](#request-gas-tokens) through Discord for the network you are using: [Devnet](https://discordapp.com/channels/916379725201563759/971488439931392130) or [Testnet](https://discord.com/channels/916379725201563759/1037811694564560966). If connected to Localnet, use cURL to request tokens from your [local faucet](./local-network.mdx#use-the-local-faucet).

To check whether Sui is already installed, run the following command:

```sh
$ which sui
```

If Sui is installed, the command returns the path to the Sui binary. If Sui is not installed, it returns `sui not found`.

See the [Sui Releases](https://github.com/MystenLabs/sui/releases) page to view the changes in each Sui release.

## Configure Sui client

If you previously ran `sui genesis` to create a local network, it created a Sui client configuration file (client.yaml) that connects to `localhost` at `http://0.0.0.0:9000`. See [Connect to a custom RPC endpoint](#connect-to-a-custom-rpc-endpoint) to update the client.yaml file.

To connect the Sui client to a network, run the following command:

```sh
$ sui client
```

If you receive the `sui-client` help output in the console, you already have a client.yaml file. See [Connect to a custom RPC endpoint](#connect-to-a-custom-rpc-endpoint) to add a new environment alias or to switch the currently active network.

The first time you start Sui client without having a client.yaml file, the console displays the following message:

```
Config file ["<PATH-TO-FILE>/client.yaml"] doesn't exist, do you want to connect to a Sui Full node server [y/N]?
```

Press **y** and then press **Enter**. The process then requests the RPC server URL: 

```
Sui Full node server URL (Defaults to Sui Testnet if not specified) :
```

Press **Enter** to connect to Sui Testnet. To use a custom RPC server, Sui Devnet, or Sui Mainnet, enter the URL to the correct RPC endpoint and then press **Enter**.

If you enter a URL, the process prompts for an alias for the environment:

```
Environment alias for [<URL-ENTERED>] :
```
Type an alias name and press **Enter**.

```
Select key scheme to generate keypair (0 for ed25519, 1 for secp256k1, 2 for secp256r1):
```

Press **0**, **1**, or **2** to select a key scheme and the press **Enter**.

Sui returns a message similar to the following (depending on the key scheme you selected) that includes the address and 12-word recovery phrase for the address:

```
Generated new keypair for address with scheme "ed25519" [0xb9c83a8b40d3263c9ba40d551514fbac1f8c12e98a4005a0dac072d3549c2442]
Secret Recovery Phrase : [cap wheat many line human lazy few solid bored proud speed grocery]
```

### Connect to a custom RPC endpoint

If you previously used `sui genesis` with the force option (`-f` or `--force`), your client.yaml file already includes two RPC endpoints: `localnet` at `http://0.0.0.0:9000` and `devnet` at `https://fullnode.devnet.sui.io:443`. You can view the defined environments with the `sui client envs` command, and switch between them with the `sui client switch` command.

If you previously installed a Sui client that connected to a Sui network, or created a local network, you can modify your existing client.yaml file to change the configured RPC endpoint. The `sui client` commands that relate to environments read from and write to the client.yaml file.

To check currently available environment aliases, run the following command: 

```sh
$ sui client envs
```

The command outputs the available environment aliases, with `(active)` denoting the currently active network.
```sh
localnet => http://0.0.0.0:9000 (active)
devnet => https://fullnode.devnet.sui.io:443
```

To add a new alias for a custom RPC endpoint, run the following command. Replace values in `<` `>` with values for your installation:

```sh
$ sui client new-env --alias <ALIAS> --rpc <RPC-SERVER-URL>
```

To switch the active network, run the following command:

```sh
$ sui client switch --env <ALIAS>
```

If you encounter an issue, delete the Sui configuration directory (`~/.sui/sui_config`) and reinstall the latest [Sui binaries](./sui-install.mdx#install-sui-binaries).

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/getting-started/sui-install.mdx
```
---
title: Install Sui
description: Install the Sui framework and required prerequisites on your system, including the Sui command line interface to interact with the Sui network.
---

The quickest way to install Sui is using the binaries delivered with every release. If you require more control over the install process, you can install from source. To take advantage of containerization, you can utilize the Docker images in the `docker` folder of the sui repository.

## Supported operating systems {#supported-operating-systems}

Sui supports the following operating systems:

- Linux - Ubuntu version 22.04 (Jammy Jellyfish) or later
    - The [`sui-node` binary from AWS](#aws-sui-node) supports only version 22.04
- macOS - macOS Monterey or later
- Microsoft Windows - Windows 10 and 11

::::info[Fastest method]

## Quick install using Homebrew, Chocolatey, or suiup {#install-homebrew}

{@include: ../../../snippets/quick-install.mdx}

:::note

If you use this method to install Sui, you are all set. The quick install is suitable for most use cases. The remaining installation methods are for those wanting more control over the installation process.

:::
::::

## Download binaries from GitHub {#install-binaries}

Each Sui release provides a set of binaries for several operating systems. You can download these binaries from GitHub and use them to install Sui.

<Tabs groupId="operating-systems">

<TabItem value="linux" label="Linux">
1. Go to https://github.com/MystenLabs/sui.
1. In the right pane, find the **Releases** section.

    ![Sui releases in GitHub](./images/releases.png)
1. Click the release tagged **Latest** to open the release's page.
1. In the **Assets** section of the release, select the .tgz compressed file that corresponds to your operating system.
1. Extract all files from the .tgz file into the preferred location on your system. These instructions assume you extract the files into a `sui` folder at the user root of your system for demonstration purposes. Replace references to this location in subsequent steps if you choose a different directory.
1. Navigate to the expanded folder. You should have the following extracted files:

    {@include: ../../../snippets/lists/binaries-file-list.mdx}

1. Add the folder containing the extracted files to your `PATH` variable. To do so, you can update your `~/.bashrc` to include the location of the Sui binaries. If using the suggested location, you type `export PATH=$PATH:~/sui` and press Enter.
1. Start a new terminal session or type `source ~/.bashrc` to load the new `PATH` value.

</TabItem>

<TabItem value="mac" label="macOS">

1. Go to https://github.com/MystenLabs/sui.
1. In the right pane, find the **Releases** section.

    ![Sui releases in GitHub](./images/releases.png)
1. Click the release tagged **Latest** to open the release's page.
1. In the **Assets** section of the release, select the .tgz compressed file that corresponds to your operating system.
1. Extract all files from the .tgz file into the preferred location on your system. These instructions assume you extract the files into a `sui` folder at the user root of your system. Replace references to this location in subsequent steps if you choose a different directory.
1. Navigate to the expanded folder. You should have the following extracted files:

    {@include: ../../../snippets/lists/binaries-file-list.mdx}

1. Add the folder containing the extracted files to your `PATH` variable. To do so, you can update your `~/.zshrc` or `~/.bashrc` to include the location of the Sui binaries. If using the suggested location, you type `export PATH=$PATH:~/sui` and press Enter.
1. Start a new terminal session or type `source ~/.zshrc` (or `.bashrc`) to load the new `PATH` value.
1. If running the binaries for the first time, you might receive an error from MacOS that prevents the binaries from running. If you receive this error, close the dialog and type `xattr -d com.apple.quarantine ~/sui/*` in your terminal and press Enter (be sure to adjust the path if different).

</TabItem>

<TabItem value="win" label="Windows">

1. Go to https://github.com/MystenLabs/sui.
1. In the right pane, find the **Releases** section.

    ![Sui releases in GitHub](./images/releases.png)
1. Click the release tagged **Latest** to open the release's page.
1. In the **Assets** section of the release, select the .tgz compressed file that corresponds to your operating system.
1. Extract all files from the .tgz file into the preferred location on your system. These instructions assume you extract the files into a `sui` folder at the root of your C drive. Replace references to this location in subsequent steps if you choose a different directory.

    :::info

    Windows does not natively support .tgz files, but you can use a free compressed file app like [7Zip](https://7-zip.org/) to extract.

    :::

1. Navigate to the expanded folder. You should have the following extracted files:

    {@include: ../../../snippets/lists/binaries-file-list.mdx}

1. Add the folder containing the extracted files to your `PATH` variable. There are several ways to get to the setting depending on your version of Windows. One way that works on all versions of Windows is to type `sysdm.cpl` in a console to open the System Properties window. Under the **Advanced** tab, click the **Environment Variables...** button.
1. In the Environment Variables window, select the `Path` variable and click the **Edit...** button.
1. In the Edit environment variable window, click **New** and add the path to your expanded folder. Using the example path, this would be `C:\sui`.
1. Click **OK**.

</TabItem>

</Tabs>

:::info

Running binaries other than `sui` might require installing prerequisites itemized in the following section.

:::

#### Confirm the installation {#confirm-the-installation}

To confirm that Sui installed correctly, type `sui --version` in your console or terminal and press Enter. The response should provide the Sui version installed. If the console or terminal responds with a command not found error, make sure the full path to your Sui binaries is included in your `PATH` variable.

## Install from Cargo {#install-sui-binaries-from-source}

Run the following command to install Sui binaries from the `testnet` branch:

```sh
$ cargo install --locked --git https://github.com/MystenLabs/sui.git --branch testnet sui --features tracing
```

Enabling the `tracing` feature is important as it adds Move test coverage and debugger support in the Sui CLI. Without it these two features will not be able to be used.

The install process can take a while to complete. You can monitor installation progress in the terminal. If you encounter an error, make sure to install the latest version of all prerequisites and then try the command again.

To update to the latest stable version of Rust:

```sh
$ rustup update stable
```

The command installs Sui components in the `~/.cargo/bin` folder.

## Upgrade from Cargo

If you previously installed the Sui binaries, you can update them to the most recent release with the same command you used to install them (changing `testnet` to the desired branch):

```sh
$ cargo install --locked --git https://github.com/MystenLabs/sui.git --branch testnet sui --features tracing
```

The `tracing` feature is important as it adds Move test coverage and debugger support in the Sui CLI. Unless it is enabled you will not be able to use these two features.

## Install `sui-node` for Ubuntu from AWS {#aws-sui-node}

The `sui-node` binaries for Ubuntu 22.04 are available for download from AWS. You can use either the commit sha or version tag in the URL to retrieve the specific version of Sui you want. Use one of these values to construct the AWS download URL.

The URL is in the form `https://sui-releases.s3-accelerate.amazonaws.com/<SHA-OR-TAG>/sui-node`, where you replace `<SHA-OR-TAG>` with the proper value. For example, the URL is `https://sui-releases.s3-accelerate.amazonaws.com/00544a588bb71c395d49d91f756e8bfe96067eca/sui-node` to download the release with the relevant commit sha. If you visit the URL using a browser, the binary downloads automatically.

After downloading, open a console to the file's location and change its permission to `755`.
```sh
$ chmod 755 sui-node
```

Add the file's location to your PATH variable if it's directory is not already included. Follow the steps in [Sui Full Node Configuration](../../operator/sui-full-node) to complete the setup.

## Build from source

Follow the instructions in this topic to install the Rust crates (packages) required to interact with Sui networks, including the Sui CLI.

To install Sui from source, you first need to install its [prerequisites](#prerequisites) for your operating system. After installing the supporting technologies, you can install [Sui binaries from source](#install-sui-binaries-from-source).

You can also download the [source code](/references/contribute/sui-environment.mdx) to have local access to files.

#### Prerequisites {#prerequisites}

Your system needs the following prerequisites available to successfully install Sui.

#### Rust and Cargo {#rust-and-cargo}

Sui requires Rust and Cargo (Rust's package manager) on all supported operating systems. The suggested method to install Rust is with `rustup` using cURL.

Some other commands in the installation instructions also require cURL to run. If you can't run the cURL command to install Rust, see the instructions to install cURL for your operating system in the following section before you install Rust.

Use the following command to install Rust and Cargo on macOS or Linux:

```sh
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

If you use Windows 11, see information about using the [Rust installer](https://www.rust-lang.org/tools/install) on the Rust website. The installer checks for C++ build tools and prompts you to install them if necessary. Select the option that best defines your environment and follow the instructions in the install wizard.

For additional installation options, see [Install Rust](https://www.rust-lang.org/tools/install).

Sui uses the latest version of Cargo to build and manage dependencies. See the [Cargo installation](https://doc.rust-lang.org/cargo/getting-started/installation.html) page on the Rust website for more information.

Use the following command to update Rust with `rustup`:

```sh
$ rustup update stable
```
#### Additional prerequisites by operating system

Select the appropriate tab to view the requirements for your system.

<Tabs groupId="operating-systems">

<TabItem value="linux" label="Linux">

The prerequisites needed for the Linux operating system include:

- cURL
- Rust and Cargo
- Git CLI
- CMake
- GCC
- libssl-dev
- libclang-dev
- libpq-dev (optional)
- build-essential

:::info

The Linux instructions assume a distribution that uses the APT package manager. You might need to adjust the instructions to use other package managers.

:::

Install the prerequisites listed in this section. Use the following command to update `apt-get`:

```sh
$ sudo apt-get update
```

#### All Linux prerequisites

Reference the relevant sections that follow to install each prerequisite individually, or run the following to install them all at once:

{@include: ../../../snippets/linux-deps.mdx}

#### cURL {#curl}

Install cURL with the following command:

```sh
$ sudo apt-get install curl
```

Verify that cURL installed correctly with the following command:

```sh
$ curl --version
```

#### Git CLI {#git-cli}

Run the following command to install Git, including the [Git CLI](https://cli.github.com/):

```sh
$ sudo apt-get install git-all
```

For more information, see [Install Git on Linux](https://github.com/git-guides/install-git#install-git-on-linux) on the GitHub website.

#### CMake {#cmake}

Use the following command to install CMake.

```sh
$ sudo apt-get install cmake
```

To customize the installation, see [Installing CMake](https://cmake.org/install/) on the CMake website.

#### GCC {#gcc}

Use the following command to install the GNU Compiler Collection, `gcc`:

```sh
$ sudo apt-get install gcc
```

#### libssl-dev {#libssl-dev}

Use the following command to install `libssl-dev`:

```sh
$ sudo apt-get install libssl-dev
```

If the version of Linux you use doesn't support `libssl-dev`, find an equivalent package for it on the [ROS Index](https://index.ros.org/d/libssl-dev/).

(Optional) If you have OpenSSL you might also need to also install `pkg-config`:

```sh
$ sudo apt-get install pkg-config
```

#### libclang-dev {#libclang-dev}

Use the following command to install `libclang-dev`:

```sh
$ sudo apt-get install libclang-dev
```

If the version of Linux you use doesn't support `libclang-dev`, find an equivalent package for it on the [ROS Index](https://index.ros.org/d/libclang-dev/).

#### libpq-dev (optional) {#libpq-dev}

{@include: ../../../snippets/libpq-req.mdx}

Use the following command to install `libpq-dev`:

```sh
$ sudo apt-get install libpq-dev
```

If the version of Linux you use doesn't support `libpq-dev`, find an equivalent package for it on the [ROS Index](https://index.ros.org/d/libpq-dev/).

#### build-essential {#build-essential}

Use the following command to install `build-essential`:

```sh
$ sudo apt-get install build-essential
```

</TabItem>

<TabItem value="mac" label="macOS">

The prerequisites needed for the macOS operating system include:

- Rust and Cargo
- Homebrew
- cURL
- CMake
- libpq (optional)
- Git CLI
- PostgreSQL

macOS includes a version of cURL you can use to install Homebrew. Use Homebrew to install other tools, including a newer version of cURL.

#### Homebrew {#brew}

Use the following command to install [Homebrew](https://brew.sh/):

```sh
$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

:::info

If you used the commands in the [Install using Homebrew](#install-homebrew) section, you do not need to install anything else.

:::

#### All macOS prerequisites

With Homebrew installed, you can install individual prerequisites from the following sections or install them all at once with this command:

{@include: ../../../snippets/macos-deps.mdx}


#### cURL {#curl-1}

Use the following command to update the default [cURL](https://curl.se) on macOS:

```sh
$ brew install curl
```

#### CMake {#cmake-1}

Use the following command to install CMake:

```sh
$ brew install cmake
```

To customize the installation, see [Installing CMake](https://cmake.org/install/) on the CMake website.

#### libpq (optional) {#libpq-1}

{@include: ../../../snippets/libpq-req.mdx}

Use the following command to install libpq:
```sh
$ brew install libpq
```

#### Git CLI {#git-cli-1}

Use the following command to install Git:

```sh
$ brew install git
```

After installing Git, download and install the [Git command line interface](https://git-scm.com/download/).

#### PostgreSQL

Visit the official [PostgreSQL website](https://wiki.postgresql.org/wiki/Main_Page) for instructions on downloading PostgreSQL.

</TabItem>

<TabItem value="win" label="Windows">

The prerequisites needed for the Windows 11 operating system include:

- cURL
- Rust and Cargo
- Git CLI
- CMake
- C++ build tools
- LLVM compiler

#### cURL {#curl-2}

Windows 11 ships with a Microsoft version of [cURL](https://curl.se/windows/microsoft.html) already installed. If you want to use the curl project version instead, download and install it from [https://curl.se/windows/](https://curl.se/windows/).

#### Git CLI {#git-cli-2}

Download and install the [Git command line interface](https://git-scm.com/download/).

#### CMake {#cmake-2}

Download and install [CMake](https://cmake.org/download/) from the CMake website.

#### Protocol Buffers {#protocol-buffers}

Download [Protocol Buffers](https://github.com/protocolbuffers/protobuf/releases) (protoc-xx.x-win32.zip or protoc-xx.x-win64.zip) and add the \bin directory to your Windows PATH environment variable.

#### Additional tools for Windows {#additional-tools-windows}

Sui requires the following additional tools on computers running Windows.

- For Windows on ARM64 only - [Visual Studio 2022 Preview](https://visualstudio.microsoft.com/vs/preview/).
- [C++ build tools](https://visualstudio.microsoft.com/downloads/) is required to [install Rust](#rust-and-cargo).
- The [LLVM Compiler Infrastructure](https://releases.llvm.org/). Look for a file with a name similar to LLVM-15.0.7-win64.exe for 64-bit Windows, or LLVM-15.0.7-win32.exe for 32-bit Windows.

</TabItem>

</Tabs>

## Using Sui from command line

With Sui installed, you can interact with Sui networks using the Sui CLI. For more details, see the [Sui CLI](/references/cli.mdx) reference.

## Installing Sui developer tools

If you use VSCode, you can install the [Move extension](https://marketplace.visualstudio.com/items?itemName=mysten.move) to get language server support for Move, as well as support for building, testing, and debugging Move code within the IDE.
You can install the extension either by searching the fully-qualified extension name, `Mysten.move`, in the extension view, or by pressing `Ctrl-P` or `Cmd-P` and typing `ext install mysten.move`.
Installing the Move extension also installs the appropriate `move-analyzer` binary for your operating system, as well as the [Move Trace Debugger](https://marketplace.visualstudio.com/items?itemName=mysten.move-trace-debug) extension, and [Move Syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax) extension.

There are also community Move packages for [Emacs](https://github.com/amnn/move-mode), [Vim](https://github.com/yanganto/move.vim), and [Zed](https://github.com/Tzal3x/move-zed-extension).

## Next steps {#next-steps}

Now that you have Sui installed, it's time to start developing. Check out the following topics to start working with Sui:

- Read about the [Sui CLI](/references/cli.mdx), the most straightforward way to start exploring Sui networks.
- [Learn about the available networks](./connect.mdx) and connect to one.
- [Get some coins](./get-coins.mdx) on a development network.
- [Build your first dApp](../first-app.mdx) to start your on-chain journey.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/getting-started/local-network.mdx
```
---
title: Connect to a Local Network
---

Use a Sui local network to test your dApps against the latest changes to Sui, and to prepare for the next Sui release to the Devnet or Testnet network. Sui CLI provides the `sui start` command to start a local network. There are several services that can be started when using `sui start`, such as an indexer, a faucet, or a local instance of the GraphQL service (including the web-based GraphiQL IDE). You can use the included faucet to get test SUI to use on the local network.

If you haven't already, you need to [install Sui CLI](./sui-install.mdx) on your system.

## Start the local network

To start the local network, run the following command after you install Sui CLI.

```sh
$ RUST_LOG="off,sui_node=info" sui start --with-faucet --force-regenesis
```

This command:

- Calls the Sui CLI binary with two flags:
- `--with-faucet` to start a faucet service.
- `--force-regenesis` to generate a new genesis and not persist the local network state.
- Instructs Rust to set specific logging through the `RUST_LOG`=`off,sui_node=info` flags, which turns off logging for all components except `sui-node`. If you want to see more detailed logs, you can remove `RUST_LOG` from the command.

:::info
Each time you start the network by passing `--force-regenesis`, the local network starts from a random genesis with no previous data, and the local network is not persisted. If you'd like to persist data, skip passing the `--force-regenesis` flag. For more details, see the [Persist local network state](#persist-local-network-state) section. Please note that a temporary directory is created in `/tmp`, which might not work if the `/tmp` folder is mounted to `/tmpfs`. If this is the case, set `TMPDIR=./some_folder`.
:::

To customize your local Sui network, such as starting other services or changing default ports and hosts, include additional flags or options in the `sui start` command.

:::info
Options and flags like `with-indexer`, `with-graphql`, and related require you to have Postgresq/libpq installed. Check out the list of possible options below to find which is the default expected DB, or how to pass a different DB.
:::

The following is a list of possible options and flags to pass to `sui start`:

```
    --network.config <CONFIG_DIR>            Config directory that will be used to store network config, node db, keystore sui genesis -f --with-faucet generates a genesis config that can be used to start this process. Use with caution as the `-f` flag
                                             will overwrite the existing config directory. We can use any config dir that is generated by the `sui genesis`
    --force-regenesis                        A new genesis is created each time this flag is set, and state is not persisted between runs. Only use this flag when you want to start the network from scratch every time you run this command
    --with-graphql[=<WITH_GRAPHQL>]          Start a GraphQL server on localhost and port: 127.0.0.1:9125, or on the port provided. When providing a specific value, please use the = sign between the flag and value: `--with-graphql=6125`. Note that
                                             GraphQL requires a running indexer
    --with-faucet[=<WITH_FAUCET>]            Start a faucet with default host and port: 127.0.0.1:9123, or on the port provided. When providing a specific value, please use the = sign between the flag and value: `--with-faucet=6123`
    --with-indexer[=<WITH_INDEXER>]          Start an indexer with default host and port: 0.0.0.0:9124, or on the port provided. When providing a specific value, please use the = sign between the flag and value: `--with-indexer=6124`.                                          The indexer be started in writer mode and reader mode
    --fullnode-rpc-port <FULLNODE_RPC_PORT>  Port to start the Fullnode RPC server on. Default port is 9000 [default: 9000]
    --pg-port <PG_PORT>                      Port for the Indexer Postgres DB. Default port is 5432 [default: 5432]
    --pg-host <PG_HOST>                      Hostname for the Indexer Postgres DB. Default host is localhost [default: localhost]
    --pg-db-name <PG_DB_NAME>                DB name for the Indexer Postgres DB. Default DB name is sui_indexer [default: sui_indexer]
    --pg-user <PG_USER>                      DB username for the Indexer Postgres DB. Default username is postgres [default: postgres]
    --pg-password <PG_PASSWORD>              DB password for the Indexer Postgres DB. Default password is postgrespw [default: postgrespw]
    --epoch-duration-ms <EPOCH_DURATION_MS>  Set the epoch duration. Can only be used when `--force-regenesis` flag is passed or if there's no genesis config and one will be auto-generated. When this flag is not set but `--force-regenesis` is set, the
                                             epoch duration will be set to 60 seconds
    --no-full-node                           Start the network without a fullnode
-h, --help                                   Print help (see more with '--help')
```

Use `sui start --help` to see these options in your console.

### Persist local network state

By default, when using `sui start` the command uses an existing genesis and network configuration if the `~/.sui/sui_config` folder exists and includes a `genesis.blob` file. If the folder doesn't exist, it creates the folder and generates a new genesis configuration. If you pass `--network.config`, the command checks for the network config file and tries to load the genesis blob as per the network config file.

Whenever you stop and start the network without passing the `--force-regenesis` flag, all history is preserved and accessible.

:::info
To generate a custom genesis, use the `sui genesis` command and pass the desired custom values. For more information about possible flags and options, run `sui genesis --help`.
:::

### Access your local Full node

Use the following command to retrieve the total transaction count from your local network:

```sh
$ curl --location --request POST 'http://127.0.0.1:9000' \
--header 'Content-Type: application/json' \
--data-raw '{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sui_getTotalTransactionBlocks",
  "params": []
}'
```

If successful, the response resembles the following:

```json
{
	"jsonrpc": "2.0",
	"result": 168,
	"id": 1
}
```

## Connect the Sui CLI to your local network

You can use the Sui CLI with any Sui network. By default it connects to Sui Devnet. To connect to your local network, create a new environment alias named `local` that sets the RPC URL the client uses to your local network.

```sh
$ sui client new-env --alias local --rpc http://127.0.0.1:9000
```

Next, use the following command to set the active environment to the new `local` environment you created.

```
sui client switch --env local
```

The command returns:

`Active environment switched to [local]`

You can check the current active environment with the following command:

```sh
$ sui client active-env
```

The command returns:

`local`

## Show the current active address

The Sui Client CLI uses the active address for command if you don't specify one. Use the following command to show the active address on your local network.

```
sui client active-address
```

The command returns an address, for example:

`0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de`

Use the active address to get test SUI to use on your local network. Use the `sui client addresses` command to see all of the addresses on your local network.

:::info

The address returned when you run the command is unique and does not match the one used in this example.

:::

## Use the local faucet {#use-the-local-faucet}

Transactions on your local network require SUI coins to pay for gas fees just like other networks. You can use the active address with the faucet.

Sui CLI provides the `sui client faucet` command to get coins from the faucet. In the most basic case, run `sui client faucet` and wait up to 60 seconds for the coins to reach your address. Use `sui client gas` to check for the new coins.

:::info

The `faucet` command uses the active address and the active network environment by default. If you need to pass in a different address or faucet server URL, check the `help` menu. If you're using a different network than a local network or the public ones (`fullnode.network.sui.io`), pass the URL to the faucet server.

:::

### Check the gas coin objects for the active address

After you get coins from the faucet, use the following command to view the coin objects for the address:

```sh
$ sui client gas
```

The response resembles the following, but with different IDs:

```sh
╭────────────────────────────────────────────────────────────────────┬────────────╮
│ gasCoinId                                                          │ gasBalance │
├────────────────────────────────────────────────────────────────────┼────────────┤
│ 0x1d790713c1c3441a307782597c088f11230c47e609af2cec97f393123ea4de45 │ 200000000  │
│ 0x20c1d5ad2e8693953fca09fd2fec0fbc52a787e0a0f77725220d36a09a5b312d │ 200000000  │
│ 0x236714566110f5624516faa0da215ad29f8daa611e8b651d1e972168207567b2 │ 200000000  │
│ 0xc81f30256bb04ad84bc4a92017cffd7c1f98286e028fa504d8515ad72ddd1088 │ 200000000  │
│ 0xf61c8b21b305cc8e062b3a37de8c3a37583e17f437a449a2ab42321d019aeeb4 │ 200000000  │
╰────────────────────────────────────────────────────────────────────┴────────────╯
```

## Generate example data

Use the TypeScript SDK to add example data to your network. This requires to start a local network with an indexer and GraphQL: `sui start --force-regenesis --with-faucet --with-indexer --with-graphql`.
Then run the following command from the `sui` root folder:

```sh
$ pnpm --filter @mysten/sui test:e2e
```

For additional information about example data for testing, see [https://github.com/MystenLabs/ts-sdks/tree/main/packages/typescript#testing](https://github.com/MystenLabs/ts-sdks/tree/main/packages/typescript#testing).

## Monitor activity

Use a Sui network explorer to monitor your local network activity. You can build and run one locally or use the **Custom RPC URL** setting available on many online explorers to provide your local network's RPC URL (`http://127.0.0.1:9000` by default).

{@include: ../../../snippets/lists/sui-explorers.mdx}

## Troubleshooting

If you do not use [Node.js 18](https://nodejs.org/de/blog/announcements/v18-release-announce), you might see the following message:

`Retrying requesting from faucet: Retry failed: fetch is not defined`

To resolve this, switch or update to Node.js 18 and then try again.

## Test with the Sui TypeScript SDK

The published version of the Sui TypeScript SDK might be an earlier version than the version of Sui you installed for your local network. To make sure you're using the latest version of the SDK, use the `experimental`-tagged version (for example, `0.0.0-experimental-20230317184920`) in the [Current Tags](https://www.npmjs.com/package/@mysten/sui?activeTab=versions) section of the Sui NPM registry.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/getting-started/get-address.mdx
```
---
title: Get Sui Address
description: You need an address on the Sui network before you can start trading NFTs, purchase SUI tokens, or perform other transactions.
---

An address is a way to uniquely and anonymously identify an account that exists on the Sui blockchain network. In other words, an address is a way for a user to store and use tokens on the Sui network, without providing any personally identifying information (such as email address, phone number, and so on). For example, if you want to purchase a number of SUI tokens to play a game, you must specify an address where these tokens are to be deposited.

The Sui address is unique, similarly to the way a social security number or a personal identification number is unique to one person. However, in Sui you can create and own multiple addresses, all of which are unique. 

In Sui, an address is 32 bytes and is often encoded in hexadecimal with a `0x` prefix. For example, this is a valid Sui address: `0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331`. You can use a Sui network explorer to find more information about this address and the objects it owns.

If you'd like to understand how a Sui address is derived from private keys and other cryptography related topics, see the [Keys and Addresses](/concepts/cryptography/transaction-auth/keys-addresses.mdx) topic.


## How to obtain a Sui address

Sui provides multiple ways to obtain a Sui address. The following are the two most common. 

### Command line interface

If you are using the Sui command line interface (CLI) to interact with the Sui network, you can use the `sui client` command to generate a new address. By default, when the Sui CLI runs for the first time it will prompt you to set up your local wallet, and then it generates one Sui address and the associated secret recovery phrase. Make sure you write down the secret recovery phrase and store it in a safe place. 

To generate a new Sui address use `sui client new-address ed25519`, which specifies the keypair scheme flag to be of type `ed25519`.

For more information, see the [Sui Client CLI](../../../references/cli/client.mdx) documentation.

To see all the generated addresses in the local wallet on your machine, run `sui keytool list`. For more information about the keytool options, see the [Sui Keytool CLI](../../../references/cli/keytool.mdx) documentation.

:::danger

The private keys associated with the Sui addresses are stored locally on the machine where the CLI is installed, in the `~/.sui/sui_config/sui.keystore` file. Make sure you do not expose this to anyone, as they can use it to get access to your account.

:::

### Sui wallets

One of the most straightforward ways to obtain a Sui address for first-time users is through wallets that access the Sui network. Unlike the cli option, wallets connected to the Sui network provide visual workflows that might be preferable to some users. The Sui Foundation does not offer this type of wallet, but there are several options available from builders on the Sui network. 

The following Chrome extension wallets integrate with your browser and have a UI workflow that walks you through the process of creating an address. Consult documentation for your chosen extension for the exact process of obtaining an address.

:::info

Links to these extensions are provided for your convenience. Their inclusion is not an endorsement, recommendation, or approval of any kind. Perform your own due diligence before making a decision on what extension to use.

:::

- [Slush — A Sui wallet](https://chromewebstore.google.com/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil): Formerly known as Sui Wallet, Slush is a wallet from the same team that built Sui - Mysten Labs.
- [Suiet | Sui Wallet](https://chromewebstore.google.com/detail/suiet-sui-wallet/khpkpbbcccdmmclmpigdgddabeilkdpd): The Suiet wallet for everyone, built on the Sui blockchain. 
- [Glass wallet](https://chromewebstore.google.com/detail/glass-wallet-sui-wallet/loinekcabhlmhjjbocijdoimmejangoa): Glass Wallet is a non-custodial wallet that allows you to control your coins, keys, and NFT securely.
- [Martian Aptos & Sui Wallet Extension](https://chromewebstore.google.com/detail/martian-aptos-sui-wallet/efbglgofoippbgcjepnhiblaibcnclgk): Martian is a self-custodial crypto wallet for Aptos and Sui.
- [Surf Wallet](https://chromewebstore.google.com/detail/surf-wallet/emeeapjkbcbpbpgaagfchmcgglmebnen): Surf Wallet is a platform that allows for convenient and secure transfer of tokens and collection of NFTs on the blockchain.
- Visit the [chrome web store](https://chromewebstore.google.com/search/sui%20wallet) for a complete list of available Sui wallet extensions.
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/getting-started/graphql-rpc.mdx
```
---
title: Querying Sui RPC with GraphQL (Alpha)
description: Introductory guide to making queries of the Sui RPC using the GraphQL service.
---

:::info

{@include: ../../../snippets/data-serving-msg.mdx}

{@include: ../../../snippets/data-serving-gql-alpha.mdx}

:::

The quickest way to access the GraphQL service for Sui RPC is through the online IDE that provides a complete toolbox for fetching data and executing transactions on the network. The online IDE provides features such as auto-completion (use Ctrl+Space or just start typing), built-in documentation (Book icon, top-left), multi-tabs, and more.

The online IDE is available for [Mainnet](https://sui-mainnet.mystenlabs.com/graphql) and [Testnet](https://sui-testnet.mystenlabs.com/graphql). This guide contains various queries that you can try directly in the IDE.

:::info
- Any existing addresses/object IDs in these examples refer to `mainnet` data only.
- Both [mainnet](https://sui-mainnet.mystenlabs.com/graphql) and [testnet](https://sui-testnet.mystenlabs.com/graphql) services are rate-limited to keep network throughput optimized.
:::

For more details about some concepts used in the examples below, please see the [GraphQL concepts](../../../concepts/graphql-rpc.mdx) page, and consult the [reference](../../../references/sui-graphql.mdx) for full documentation on the supported schema.


## Discovering the schema

GraphQL introspection exposes the schema supported by the RPC service. The IDE's "Docs" pane (Book icon, top-left) and Search dialog (<kbd>Cmd</kbd>+<kbd>K</kbd> on macOS or <kbd>Ctrl</kbd>+<kbd>K</kbd> on Windows and Linux) offer a way to browse introspection output interactively.

The [official documentation](https://graphql.org/learn/introspection/) provides an overview on introspection, and how to interact with it programmatically.

## Finding the reference gas price for latest epoch

```graphql
query {
  epoch {
    referenceGasPrice
  }
}
```

## Finding information about a specific historical epoch

This example finds the total stake rewards, the reference gas price, the number of checkpoints and the total gas fees for epoch 100. Note that in the query, the `id` argument is optional, and defaults to the latest epoch.

```graphql
query {
  epoch(id: 100) # note that id is optional, and without it, latest epoch is returned
  {
    epochId
    totalStakeRewards
    referenceGasPrice
    totalCheckpoints
    totalGasFees
    totalStakeSubsidies
    storageFund {
      totalObjectStorageRebates
      nonRefundableBalance
    }
  }
}
```

## Finding a transaction block by its digest

This example gets a transaction block by its digest and shows information such as the gas sponsor's address, the gas price, the gas budget, and effects from executing that transaction block.

```graphql
query {
  transactionBlock(digest: "FdKFgsQ9iRrxW6b1dh9WPGuNuaJWMXHJn1wqBQSqVqK2") {
    gasInput {
      gasSponsor {
        address
      }
      gasPrice
      gasBudget
    }
    effects {
      status
      timestamp
      checkpoint {
        sequenceNumber
      }
      epoch {
        epochId
        referenceGasPrice
      }
    }
  }
}
```

## Finding the last ten transactions that are not a system transaction

```graphql
query {
  transactionBlocks(last: 10, filter: {kind: PROGRAMMABLE_TX}) {
    nodes {
      digest
      kind {
        __typename
      }
    }
  }
}
```

## Finding all transactions that touched a given object

This example finds all the transactions that touched (modified/transferred/deleted) a given object. This is useful for when we want to trace the flow of a Coin/StakeSui/NFT.

:::info
This example uses GraphQL [variables](../../../concepts/graphql-rpc.mdx#variables) and [pagination](../../../concepts/graphql-rpc.mdx#pagination). When using the online IDE, copy the variables JSON to the "Variables" window, below the main editor.
:::

```graphql
query ($objectID: SuiAddress!) {
  transactionBlocks(filter: {changedObject: $objectID}) {
    nodes {
      sender {
        address
      }
      digest
      effects {
        objectChanges {
          nodes {
            address
          }
        }
      }
    }
  }
}
```

**Variables**:
```json
{
  "objectID": "0x11c6ae8432156527fc2e12e05ac7db79f2e972510a823a4ef2e670f27ad7b52f"
}
```

## Filtering transaction blocks by a function

This example finds the last ten transaction blocks that called the `public_transfer` function, (as a move call transaction command).

:::info
This example makes usage of the filter `last`, which indicates that the user only wants the last ten transaction blocks known to the service.
:::

```graphql
{
  transactionBlocks(
    last: 10,
      filter: {
        function: "0x2::transfer::public_transfer"
      }
  ) {
    nodes { digest }
  }
}
```

## Finding transaction balance changes

This example finds the balance changes of all the transactions where a given address called a staking-related function. This is useful when you want to get your staking or unstaking history.

```graphql
query ($address: SuiAddress!) {
  transactionBlocks(filter: {
    function: "0x3::sui_system::request_add_stake"
    sentAddress: $address
  }) {
    nodes {
      digest
      effects {
        balanceChanges {
          nodes {
            owner {
              address
            }
            amount
          }
        }
      }
    }
  }
}
```

**Variables**:
```json
{
  "address": "0xa9ad44383140a07cc9ea62d185c12c4d9ef9c6a8fd2f47e16316229815862d23"
}
```

## Fetching a dynamic field on an object

:::info
This example uses aliases and [fragments](../../../concepts/graphql-rpc.mdx#fragments).
:::

```graphql
query DynamicField {
  object(
    address: "0xb57fba584a700a5bcb40991e1b2e6bf68b0f3896d767a0da92e69de73de226ac"
  ) {
    dynamicField(
      name: {
        type: "0x2::kiosk::Lock",
        bcs: "NLArx1UJguOUYmXgNG8Pv8KbKXLjWtCi6i0Yeq1Vhfw=",
      }
    ) {
      ...DynamicFieldSelect
    }
  }
}

fragment DynamicFieldSelect on DynamicField {
  name {
    ...MoveValueFields
  }
  value {
    ...DynamicFieldValueSelection
  }
}

fragment DynamicFieldValueSelection on DynamicFieldValue {
  __typename
  ... on MoveValue {
    ...MoveValueFields
  }
  ... on MoveObject {
    hasPublicTransfer
    contents {
      ...MoveValueFields
    }
  }
}

fragment MoveValueFields on MoveValue {
  type {
    repr
  }
  data
  bcs
}
```

## Fetching all dynamic fields on an object

This query can be used to paginate over the dynamic fields of an object. This works even when the object in question is [wrapped](../../../concepts/object-ownership/wrapped.mdx), by using the <a href="/references/sui-api/sui-graphql/reference/queries/owner" data-noBrokenLinkCheck='true'>owner</a> query, so can be used for iterating over the elements of on-chain data structures, like tables and bags. See [The Move Book](https://move-book.com/programmability/dynamic-collections.html) to learn more about dynamic collections available in Move.

:::info
This example uses [fragments](../../../concepts/graphql-rpc.mdx#fragments) and [variables](../../../concepts/graphql-rpc.mdx#variables).
:::

```graphql
query ($id: SuiAddress!) {
  owner(address: $id) {
    dynamicFields {
      nodes {
        name { ...Value }
        value {
          __typename
          ... on MoveValue {
            ...Value
          }
          ... on MoveObject {
            contents {
              ...Value
            }
          }
        }
      }
    }
  }
}

fragment Value on MoveValue {
  type {
    repr
  }
  json
}
```

## Paginating checkpoints forward, five at a time {#page-forward}

```graphql
query ($after: String) {
  checkpoints(first: 5, after: $after) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      digest
      timestamp
    }
  }
}
```

Sets up a paginated query, starting at the genesis checkpoint, reading five checkpoints at a time, in increasing order of sequence number. The value of `pageInfo.hasNextPage` determines whether there is another page to be read, and the value of `pageInfo.endCursor` is fed back in as the cursor to read `$after`.

:::info

This example uses GraphQL [variables](../../../concepts/graphql-rpc.mdx#variables) and [pagination](../../../concepts/graphql-rpc.mdx#pagination).

:::

## Paginating checkpoints backwards, five at a time {#page-back}

```graphql
query ($before: String) {
  checkpoints(last: 5, before: $before) {
    pageInfo {
      hasPreviousPage
      startCursor
    }
    nodes {
      digest
      timestamp
    }
  }
}
```

Sets up a paginated query, starting at the latest indexed checkpoint, reading five checkpoints at a time, in decreasing order of sequence number. The value of `pageInfo.hasPreviousPage` determines whether there is another page to be read, and the value of `pageInfo.startCursor` is fed back in as the cursor to read `$before`.

:::info
This example uses GraphQL [variables](../../../concepts/graphql-rpc.mdx#variables) and [pagination](../../../concepts/graphql-rpc.mdx#pagination).
:::

## Executing a transaction

Transaction execution takes in two arguments, `txBytes` and `signatures`. `txBytes` is the serialized unsigned transaction data, which can be generated when using the Sui CLI's `client call` [command](../../../references/cli/client.mdx), to call a Move function by passing the `--serialize-unsigned-transaction` flag. The `signatures` can be generated using Sui CLI's [keytool](../../../references/cli/keytool.mdx) command `sui keytool sign`. More information on Sui CLI can be found [here](/references/cli).

```graphql
mutation ($tx: String!, $sigs: [String!]!) {
  executeTransactionBlock(txBytes: $tx, signatures: $sigs) {
    errors
    effects {
      status
      epoch {
        startTimestamp
      }
      gasEffects {
        gasSummary {
          computationCost
        }
      }
    }
  }
}
```

**Variables**:
```json
{
  "tx": "AAACACAZXApmrHgzTs3FGDyXWka+wmMCy2IwOdKLmTWHb5PnFQEASlCnLAw4qfzLF3unH9or5/L7YpOlReaSEWfoEwhTqpavSxAAAAAAACCUFUCOn8ljIxcG9O+CA1bzqjunqr4DLDSzSoNCkUvu2AEBAQEBAAEAALNQHmLi4jgC5MuwwmiMvZEeV5kuyh+waCS60voE7fpzAa3v/tOFuqDvQ+bjBpKTfjyL+6yIg+5eC3dKReVwghH/rksQAAAAAAAgxtZtKhXTr1zeFAo1JzEqVKn9J1H74ddbCJNVZGo2I1izUB5i4uI4AuTLsMJojL2RHleZLsofsGgkutL6BO36c+gDAAAAAAAAQEIPAAAAAAAA",
  "sigs": [
    "AB4ZihXxUMSs9Ju5Cstuuf/hvbTvvycuRk2TMuagLYNJgQuAeXmKyJF9DAXUtL8spIsHrDQgemn4NmojcNl8HQ3JFqhnaTC8gMX4fy/rGgqgL6CDcbikawUUjC4zlkflwg=="
  ]
}
```

## Other examples

You can find other examples in the [repository](https://github.com/MystenLabs/sui/tree/releases/sui-graphql-rpc-v2024.1.0-release/crates/sui-graphql-rpc/examples), grouped into sub-directories. For example, there are directories for [transaction block effects](https://github.com/MystenLabs/sui/tree/releases/sui-graphql-rpc-v2024.1.0-release/crates/sui-graphql-rpc/examples/transaction_block_effects), [protocol configs](https://github.com/MystenLabs/sui/tree/releases/sui-graphql-rpc-v2024.1.0-release/crates/sui-graphql-rpc/examples/protocol_configs), [stake connection](https://github.com/MystenLabs/sui/tree/releases/sui-graphql-rpc-v2024.1.0-release/crates/sui-graphql-rpc/examples/stake_connection), and more.

:::info
Examples in the repository are designed to work with the version of GraphQL built at the same revision. The links above point to examples intended for [GraphQL v2024.1](https://github.com/MystenLabs/sui/tree/releases/sui-graphql-rpc-v2024.1.0-release), the latest production version at the time of writing.
:::

## Related links

- [GraphQL migration](../advanced/graphql-migration.mdx): Migrating to GraphQL guides you through migrating Sui RPC projects from JSON-RPC to GraphQL.
- [GraphQL concepts](../../../concepts/graphql-rpc.mdx): GraphQL for Sui RPC examines the elements of GraphQL that you should know to get the most from the service.
- [GraphQL reference](../../../references/sui-graphql.mdx): Auto-generated GraphQL reference for Sui RPC.
- [Sui Testnet GraphiQL](https://sui-testnet.mystenlabs.com/graphql): Sui GraphiQL IDE for the Testnet network.
- [Sui Mainnet GraphiQL](https://sui-mainnet.mystenlabs.com/graphql): Sui GraphiQL IDE for the Mainnet network.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/getting-started/get-coins.mdx
```
---
title: Get SUI Tokens
---

Sui faucet is a helpful tool where Sui developers can get free test SUI tokens to deploy and interact with their programs on Sui's Devnet and Testnet networks. There is no faucet for Sui Mainnet...

## Prerequisites

To request tokens from the faucet, you must own a wallet address that can receive the SUI tokens. See the [Get Sui Address](./get-address.mdx) topic if you don't already have an address or need to create a new one.

## Request test tokens through the online faucet {#online-faucet}

https://faucet.sui.io/: Visit the online faucet to request SUI tokens.

How to use:

1. Connect your wallet or paste your wallet address in the address field.
1. Use the network dropdown to select the correct network.
1. Click the **Request SUI** button. 

To request more SUI, refresh your browser and click the Request SUI button again. The requests are rate limited, however, so too many requests results in a waiting period before you are able to request more tokens. 

### Return unused Testnet SUI

The Testnet faucet drains from a finite pool of SUI. If the pool empties, it disrupts faucet service for the rest of the community. To help ensure this doesn't happen, you can use the online faucet to return your unused SUI to the pool.

There are two ways to return unused Testnet SUI:

- Connect your wallet to the online faucet, and click the **Return tokens to faucet** button. Approve the transaction using your wallet and your Testnet SUI are returned to the pool.
- If you prefer not to connect your wallet, click the **Copy** button to the right of the return address and send the tokens via a separate transaction.

## Request test tokens through the CLI

If you are using the Devnet or Testnet networks, or you spun up a local network, you can use the [Sui CLI](../../../references/cli/client.mdx) to request tokens for your address. The `sui client faucet` uses the active network and active address that is currently set in the Sui CLI by default, but you can specify custom data through the following two arguments:

- `--address` argument to provide a specific address (or its alias),
- `--url` argument to provide a custom faucet endpoint.

## Request test tokens through Discord

1. Join [Discord](https://discord.gg/sui).
   If you try to join the Sui Discord channel using a newly created Discord account, you may need to wait a few days for validation.
1. Request test SUI tokens in the Sui [#devnet-faucet](https://discord.com/channels/916379725201563759/971488439931392130) or [#testnet-faucet](https://discord.com/channels/916379725201563759/1037811694564560966) Discord channels. Send the following message to the channel with your client address:
   `!faucet <Your client address>`

## Request test tokens through wallet

You can request test tokens within [Sui Wallet](https://github.com/MystenLabs/mysten-app-docs/blob/main/mysten-sui-wallet.md#add-sui-tokens-to-your-sui-wallet).

## Request test tokens through cURL

Use the following cURL command to request tokens directly from the faucet server:

```
curl --location --request POST 'https://faucet.devnet.sui.io/v2/gas' \
--header 'Content-Type: application/json' \
--data-raw '{
    "FixedAmountRequest": {
        "recipient": "<YOUR SUI ADDRESS>"
    }
}'
```

If you're working with a local network, replace `'https://faucet.devnet.sui.io/v2/gas'` with the appropriate value based on which package runs your network:

- `sui-faucet`: `http://127.0.0.1:5003/gas`
- `sui`: `http://127.0.0.1:9123/gas`

## Request test tokens through TypeScript SDK

You can also access the faucet using the Sui TypeScript SDK.

```typescript
import { getFaucetHost, requestSuiFromFaucetV2 } from '@mysten/sui/faucet';

// get tokens from the Devnet faucet server
await requestSuiFromFaucetV2({
	// connect to Devnet
	host: getFaucetHost('devnet'),
	recipient: '<YOUR SUI ADDRESS>',
});
```

## Test tokens on a local network

If you are running a local Sui network, you can get tokens from your local faucet. See the [Connect to a Local Network](./local-network.mdx#use-the-local-faucet) topic for details.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/getting-started/data-serving.mdx
```
---
title: Access Sui Data
description: Overview of the types of data access mechanisms available in Sui.
---

You can access Sui network data like [Transactions](/concepts/transactions.mdx), [Checkpoints](/concepts/cryptography/system/checkpoint-verification.mdx), [Objects](/concepts/object-model.mdx), [Events](/guides/developer/sui-101/using-events.mdx), and more through the available interfaces. You can use this data in your application workflows, to analyze network behavior across applications or protocols of interest, or to perform audits on parts or the whole of the network.

This document outlines the interfaces that are currently available to access the Sui network data, along with an overview of how that's gradually evolving. Refer to the following definitions for release stages mentioned in this document:

- **Alpha** - Experimental release that is subject to change and is not recommended for production use. You can use it for exploration in non-production environments.
- **Beta** - Somewhat stable release that is subject to change based on user feedback. You can use it for testing and production readiness in non-production environments. If you use it in production, do so at your own risk. Only entertain using after verifying the desired functional, performance, and other relevant characteristics in a non-production environment, and if you are comfortable keeping your application regularly updated for any changes.
- **Generally available (GA)** - Fully stable release that you can use in production. Notifications for any breaking changes are made in advance. 

## Current data access interfaces

Currently, you can use any of the following mechanisms to access Sui network data:

- Directly connect to [JSON-RPC](/references/sui-api.mdx) hosted on Sui [Full nodes](guides/operator/sui-full-node.mdx) that are operated by [RPC providers](https://sui.io/developers#dev-tools) (filter by `RPC`) or [Data indexer operators](https://github.com/sui-foundation/awesome-sui?tab=readme-ov-file#indexers--data-services).
  - The [Mainnet](https://fullnode.mainnet.sui.io:443), [Testnet](https://fullnode.testnet.sui.io:443), or [Devnet](https://fullnode.devnet.sui.io:443) load balancer URLs abstract the Sui Foundation-managed Full nodes. Those are not recommended for production use.
- Set up your own [custom indexer](/guides/developer/advanced/custom-indexer.mdx) to continuously load the data of interest into a Postgres database.

:::info

You can also use one of the [future-oriented interfaces](#future-data-access-interfaces) that are available in alpha or beta, but those are not recommended for production use.

:::

### JSON-RPC

You can currently get real-time or historical data from a Sui Full node. Retention period for historical data depends on the [pruning strategy](/guides/operator/data-management.mdx#sui-full-node-pruning-policies) that node operators implement, though currently the default configuration for all Full nodes is to implicitly fall back on a [Sui Foundation-managed key-value store for historical transaction data](/guides/operator/data-management.mdx#sui-full-node-key-value-store-backup).

:::caution

WebSocket-based JSON RPCs `suix_subscribeEvent` and `suix_subscribeTransaction` were deprecated in July 2024. Do not rely on those RPCs in your applications. Refer to [Future data access interfaces](#future-state-data-interfaces) to learn about a future alternative.

:::

### Custom indexer

If you need more control over the types, granularity, and retention period of the data that you need in your application, or if you have specific query patterns that could be best served from a relational database, then you can set up your own [custom indexer](/guides/developer/advanced/custom-indexer.mdx) or reach out to a [Data indexer operator](https://github.com/sui-foundation/awesome-sui?tab=readme-ov-file#indexers--data-services) that might already have set one up. 

If you set up your own indexer, you are responsible for its ongoing maintenance and the related infrastructure and operational costs. You can reduce your costs by implementing a pruning strategy for the relational database by taking into account the retention needs of your application.

## Future data access interfaces

<div class="bg-sui-ghost-white">
![Future state data serving stack](../images/dataservingstack.png)
</div>

Primary interfaces to access Sui access data in the future include:

- [gRPC API](../../../concepts/grpc-overview.mdx) will replace JSON-RPC on Full nodes, and is currently available in beta. If you already use the JSON-RPC or are starting to utilize it as a dependency for your use case, you would need to migrate to gRPC or GraphQL (see below) within a reasonable duration. Refer to the [high-level timeline for gRPC availability](#grpc-api).
- Indexer 2.0 will include a performant and scalable implementation of the Sui indexer framework and is currently available in alpha. You can use it to load data at scale from Full nodes into a Postgres relational database.
- [GraphQL RPC](/references/sui-graphql.mdx) will include a lightweight GraphQL RPC Server that you can use to read data from the Indexer 2.0's relational database. It is currently available in alpha. You can use it as an alternative to gRPC, including for migration from JSON-RPC for an existing application. Refer to the [high-level timeline for GraphQL availability](#graphql-rpc).

You could still utilize an [RPC provider](https://sui.io/developers#dev-tools) (filter by `RPC`) or a [Data indexer operator](https://github.com/sui-foundation/awesome-sui?tab=readme-ov-file#indexers--data-services) with these options, assuming some or all of those providers choose to operate the Indexer 2.0 and the GraphQL RPC Server.

### gRPC API

As mentioned previously, [gRPC API](../../../concepts/grpc-overview.mdx) will replace the JSON-RPC on Full nodes, such that JSON-RPC will be deprecated when gRPC API is generally available. Apart from the message and request format changes between the two, the gRPC API comes with a couple of key functional differences:

- It will have streaming or subscription API endpoints to consume real-time streaming data in your application without having to poll for those records. This support will be a proper replacement of the deprecated WebSocket support in JSON-RPC.
- It will not have implicit fallback on the previously mentioned [Sui Foundation-managed key-value store for historical transaction data](/guides/operator/data-management.mdx#sui-full-node-key-value-store-backup). Full node operators, RPC providers, and data indexer operators are encouraged to run their own instance of a similar archival store, which you can explicitly define a dependency on to get the relevant historical data.

See [When to use gRPC vs GraphQL with Indexer 2.0](#when-to-use-grpc-vs-graphql-with-indexer-20) for a comparison with GraphQL RPC.

:::info

The [gRPC API](../../../concepts/grpc-overview.mdx) is in beta, which is a somewhat stable release that is subject to change based on user feedback. You can use it for testing and production readiness in non-production environments.

:::

**High-level timeline**

The target times indicated below are tentative and subject to updates based on project progress and your feedback.

| Tentative time | Milestone | Description |
| -------- | ------- | ------- |
| :heavy_check_mark: April 2025 | Beta release of initial set of polling-based APIs. | You can start validating the initial gRPC integration from your application and share feedback on the improvements you want to see. |
| June 2025 | Beta release of streaming APIs and the remaining set of polling-based APIs. | If your use case requires streaming low-latency data, this is an apt time to start validating that integration. Also, the functionality of the API coverage will be complete at this point, so you can start migrating your application in non-production environments. |
| August 2025 | GA release of polling-based APIs with appropriate SDK support. | You can start migration and cutover of your application in the production environment, with the support for streaming APIs still in beta. |
| October 2025 | GA release of scalable streaming APIs. | If your use case requires streaming low-latency data, you can now use those APIs at scale. **JSON-RPC will be deprecated at this point and migration notice period will start.** |
| June 2026 | End of migration timeline. | **JSON-RPC will be fully deactivated at this point.** This timeline assumes about 9 months of migration notice period. |

### Indexer 2.0

As mentioned, Indexer 2.0 will include a performant and scalable implementation of the indexer framework. The underlying framework uses the Full node RPCs to ingest the data, initially using the current generally available JSON-RPC, and later using the gRPC API.

Indexer 2.0 will be declarative such that you can seamlessly configure it to load different kinds of Sui network data into Postgres relational tables in parallel. This change is being implemented to improve the performance of the data ingestion into the Postgres database. In addition, you can configure pruning for different tables in the Postgres database, allowing you to tune it for the desired combination of performance and cost characteristics.

:::info

Indexer 2.0 is currently in alpha and not recommended for production use. A sneak preview of how you could set up Indexer 2.0 today is available [on GitHub](https://github.com/amnn/sui-sender-indexer).

:::

### GraphQL RPC

The [GraphQL RPC Server](/references/sui-graphql.mdx) will provide a performant GraphQL RPC layer while reading data from the Indexer 2.0's Postgres database. GraphQL RPC will be an alternative to gRPC API. If you are already using JSON-RPC in your application today, you would have an option to migrate to GraphQL RPC by either operating the combined stack of Indexer 2.0, Postgres database, and GraphQL RPC server on your own, or by utilizing it as a service from an RPC provider or data indexer operator.

GraphQL RPC Server will be a lightweight server component that will allow you to combine data from multiple Postgres database tables using GraphQL's expressive querying system, which is appealing to frontend developers.

See [When to use gRPC vs GraphQL with Indexer 2.0](#when-to-use-grpc-vs-graphql-with-indexer-20) for a comparison with the gRPC API.

:::info

GraphQL RPC Server is currently in alpha and not recommended for production use. Check out [this getting started document for GraphQL RPCs](guides/developer/getting-started/graphql-rpc.mdx) that refers to the Mysten Labs-managed stack of GraphQL RPC Server along with the underlying Postgres database and Indexer 2.0.

Based on valuable feedback from the community, the GraphQL RPC release stage has been updated to alpha. Refer to the high-level timeline for beta and GA releases in this document.

:::

**High-level timeline**

The target times indicated in this table are tentative and subject to updates based on project progress and your feedback.

| Tentative time | Milestone | Description |
| -------- | ------- | ------- |
| July 2025 | Beta release of GraphQL RPC Server and Indexer 2.0. | You can start validating the setup of Indexer 2.0, along with testing the GraphQL RPC Server to access the indexed Sui data. You can also start migrating your application in the non-production environments, and share feedback on the improvements you want to see. |
| October 2025 | Deprecation of JSON-RPC. | **JSON-RPC will be deprecated at this point and migration notice period will start.** |
| December 2025 | GA release of GraphQL RPC Server and Indexer 2.0. | You can start migration and cutover of your application in the production environment. |
| June 2026 | End of migration timeline. | **JSON-RPC will be fully deactivated at this point.** This timeline assumes about 9 months of migration notice period. |

### When to use gRPC vs GraphQL with Indexer 2.0

You can use the high-level criteria mentioned in the following table to determine whether gRPC API or GraphQL RPC with Indexer 2.0 would better serve your use case. It's not an exhaustive list and it's expected that either of the options could work suitably for some of the use cases.

| Dimension | gRPC API | GraphQL RPC with Indexer 2.0 |
| -------- | ------- | ------- |
| Type of application or data consumer. | Ideal for Web3 exchanges, defi market maker apps, other defi protocols or apps with ultra low-latency needs. | Ideal for webapp builders or builders with slightly relaxed latency needs. |
| Query patterns. | Okay to read data from different endpoints separately and combine on the client-side; faster serialization, parsing, and validation due to binary format. | Allows easier decoupling of the client with the ability to combine data from different tables in a single request; returns consistent data from different tables across similar checkpoints, including for paginated results. |
| Retention period requirements. | Default retention period will be two weeks with actual configuration dependent on the Full node operator and their needs and goals; see history-related note after the table. | Default retention period in Postgres database will be four weeks with actual configuration depending on your or a RPC provider or Data indexer operator's needs; see history-related note after the table. |
| Streaming needs. | Will include a streaming or subscription API before beta release. | Subscription API is planned but will be available after GA. |
| Incremental costs. | Little to no incremental costs if already using Full node JSON-RPC. | Somewhat significant incremental costs if already using Full node JSON-RPC and if retention period and query patterns differences are insignificant. |

:::info

This table only mentions the default retention period for both options. The expectation is that it's reasonable for a Full node operator, RPC provider, or data indexer operator to configure that to a few times higher without significantly impacting the performance. Also by default, GraphQL RPC Server can directly connect to a archival key-value store for historical data beyond the retention period configured for the underlying Postgres database. Whereas in comparison, gRPC API will not have such direct connectivity to an archival key-value store.

Relevant guidelines will be provided before each option's respective GA release. Those will include recommendations for how to access historical data beyond the configured retention period for your interface of choice.

:::

Refer to the following articles outlining general differences between gRPC and GraphQL. Please validate the accuracy and authenticity of the differences using your own experiments.

- https://stackoverflow.blog/2022/11/28/when-to-use-grpc-vs-graphql/
- https://blog.postman.com/grpc-vs-graphql/

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/cryptography/groth16.mdx
```
---
title: Groth16
---

A zero-knowledge proof allows a prover to validate that a statement is true without revealing any information about the inputs. For example, a prover can validate that they know the solution to a sudoku puzzle without revealing the solution.

Zero-knowledge succinct non-interactive argument of knowledge (zk-SNARKs) are a family of zero-knowledge proofs that are non-interactive, have succinct proof size and efficient verification time. An important and widely used variant of them is pairing-based zk-SNARKs like the [Groth16](https://eprint.iacr.org/2016/260.pdf) proof system, which is one of the most efficient and widely used.

The Move API in Sui enables you to verify any statement that can be expressed in a NP-complete language efficiently using Groth16 zk-SNARKs over either the BN254 or BLS12-381 elliptic curve constructions.

There are high-level languages for expressing these statements, such as [Circom](https://docs.circom.io), used in the following example.

Groth16 requires a trusted setup for each circuit to generate the verification key. The API is not pinning any particular verification key and each user can generate their own parameters or use an existing verification to their apps.

## Usage

The following example demonstrates how to create a Groth16 proof from a statement written in Circom and then verify it using the Sui Move API. The API currently supports up to eight public inputs.

### Create circuit

In this example, we create a proof which demonstrates that we know a factorisation `a * b = c` of a publicly known number `c` without revealing `a` and `b`.

```circom
pragma circom 2.1.5;

template Main() {
    signal input a;
    signal input b;
    signal output c;

    c <== a * b;
}
component main = Main();
```
Assuming that the [circom compiler has been installed](https://docs.circom.io/getting-started/installation/), the above circuit is compiled using the following command:

```sh
$ circom main.circom --r1cs --wasm
```

This outputs the constraints in R1CS format and the circuit in Wasm format.

### Generate proof

To generate a proof verifiable in Sui, you need to generate a witness. This example uses Arkworks' [ark-circom](https://github.com/gakonst/ark-circom) Rust library. The code constructs a witness for the circuit and generates a proof for it for a given input. Finally, it verifies that the proof is correct.

```rust
use ark_bn254::Bn254;
use ark_circom::CircomBuilder;
use ark_circom::CircomConfig;
use ark_groth16::{Groth16, prepare_verifying_key};
use ark_serialize::CanonicalSerialize;
use ark_snark::SNARK;
use rand::rngs::StdRng;
use rand::SeedableRng;

fn main() {
    // Load the WASM and R1CS for witness and proof generation
    let cfg = CircomConfig::<Bn254>::new("../circuit/main_js/main.wasm", "../circuit/main.r1cs").unwrap();
    let mut builder = CircomBuilder::new(cfg);

    // Private inputs: A factorisation of a number
    builder.push_input("a", 641);
    builder.push_input("b", 6_700_417);

    let circuit = builder.setup();

    // Generate a random proving key. WARNING: This is not secure. A proving key generated from a ceremony should be used in production.
    let mut rng: StdRng = SeedableRng::from_seed([0; 32]);
    let pk =
        Groth16::<Bn254>::generate_random_parameters_with_reduction(circuit, &mut rng).unwrap();

    let circuit = builder.build().unwrap();
    let public_inputs = circuit.get_public_inputs().unwrap();

    // Create proof
    let proof = Groth16::<Bn254>::prove(&pk, circuit, &mut rng).unwrap();

    // Verify proof
    let pvk = prepare_verifying_key(&pk.vk);
    let verified = Groth16::<Bn254>::verify_with_processed_vk(&pvk, &public_inputs, &proof).unwrap();
    assert!(verified);

    // Print verifying key
    let mut pk_bytes = Vec::new();
    pk.vk.serialize_compressed(&mut pk_bytes).unwrap();
    println!("Verifying key: {}", hex::encode(pk_bytes));

    // Print proof
    let mut proof_serialized = Vec::new();
    proof.serialize_compressed(&mut proof_serialized).unwrap();
    println!("Proof: {}", hex::encode(proof_serialized));

    // Print public inputs. Note that they are concatenated.
    let mut public_inputs_serialized = Vec::new();
    public_inputs.iter().for_each(|input| {
        input.serialize_compressed(&mut public_inputs_serialized).unwrap();
    });
    println!("Public inputs: {}", hex::encode(public_inputs_serialized));
}
```
Recall that this creates a proof that the prover knows a factorisation, in this case of the [5th Fermat number](https://en.wikipedia.org/wiki/Fermat_number#Factorization) (<i>2<sup>32</sup> + 1 = 4294967297 = 641 * 6700417</i>).

The output of the above function will be
```
Verifying key: 94d781ec65145ed90beca1859d5f38ec4d1e30d4123424bb7b0c6fc618257b1551af0374b50e5da874ed3abbc80822e4378fdef9e72c423a66095361dacad8243d1a043fc217ea306d7c3dcab877be5f03502c824833fc4301ef8b712711c49ebd491d7424efffd121baf85244404bded1fe26bdf6ef5962a3361cef3ed1661d897d6654c60dca3d648ce82fa91dc737f35aa798fb52118bb20fd9ee1f84a7aabef505258940dc3bc9de41472e20634f311e5b6f7a17d82f2f2fcec06553f71e5cd295f9155e0f93cb7ed6f212d0ccddb01ebe7dd924c97a3f1fc9d03a9eb915020000000000000072548cb052d61ed254de62618c797853ad3b8a96c60141c2bfc12236638f1b0faf9ecf024817d8964c4b2fed6537bcd70600a85cdec0ca4b0435788dbffd81ab
Proof: 212d4457550f258654a24a6871522797ab262dee4d7d1f89af7da90dc0904eac57ce183e6f7caca9a98755904c1398ff6288cec9877f98f2d3c776c448b9ad166839e09d77967b66129c4942eee6d3eaf4a0ce2a841acc873a46ae35e40f0088288d038857c70a1415300544d7cf376949a372049679afa35ee5206b58266184
Public inputs: 0100000001000000000000000000000000000000000000000000000000000000
```
All these outputs are needed to verify the proof.

### Verification in Sui

The API in Sui for verifying a proof expects a special processed verification key, where only a subset of the values are used. Ideally, computation for this prepared verification key happens only once per circuit. You can perform this processing using the `sui::groth16::prepare_verifying_key` method of the Sui Move API with a serialization of the `params.vk` value used previously.

The output of the `prepare_verifying_key` function is a vector with four byte arrays, which corresponds to the `vk_gamma_abc_g1_bytes`, `alpha_g1_beta_g2_bytes`, `gamma_g2_neg_pc_bytes`, `delta_g2_neg_pc_bytes`.

To verify a proof, you also need two more inputs, `public_inputs_bytes` and `proof_points_bytes`, which are printed by the program above.

The following example smart contract uses the output from the program above. It first prepares a verification key and verifies the corresponding proof. This example uses the BN254 elliptic curve construction, which is given as the first parameter to the `prepare_verifying_key` and `verify_groth16_proof` functions. You can use the `bls12381` function instead for BLS12-381 construction.

```rust
use sui::groth16;

public fun groth16_bn254_test() {
    let pvk = groth16::prepare_verifying_key(&groth16::bn254(), &x"94d781ec65145ed90beca1859d5f38ec4d1e30d4123424bb7b0c6fc618257b1551af0374b50e5da874ed3abbc80822e4378fdef9e72c423a66095361dacad8243d1a043fc217ea306d7c3dcab877be5f03502c824833fc4301ef8b712711c49ebd491d7424efffd121baf85244404bded1fe26bdf6ef5962a3361cef3ed1661d897d6654c60dca3d648ce82fa91dc737f35aa798fb52118bb20fd9ee1f84a7aabef505258940dc3bc9de41472e20634f311e5b6f7a17d82f2f2fcec06553f71e5cd295f9155e0f93cb7ed6f212d0ccddb01ebe7dd924c97a3f1fc9d03a9eb915020000000000000072548cb052d61ed254de62618c797853ad3b8a96c60141c2bfc12236638f1b0faf9ecf024817d8964c4b2fed6537bcd70600a85cdec0ca4b0435788dbffd81ab");
    let proof_points = groth16::proof_points_from_bytes(x"212d4457550f258654a24a6871522797ab262dee4d7d1f89af7da90dc0904eac57ce183e6f7caca9a98755904c1398ff6288cec9877f98f2d3c776c448b9ad166839e09d77967b66129c4942eee6d3eaf4a0ce2a841acc873a46ae35e40f0088288d038857c70a1415300544d7cf376949a372049679afa35ee5206b58266184");
    let public_inputs = groth16::public_proof_inputs_from_bytes(x"0100000001000000000000000000000000000000000000000000000000000000");
    assert!(groth16::verify_groth16_proof(&groth16::bn254(), &pvk, &public_inputs, &proof_points));
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/cryptography/multisig.mdx
```
---
title: Multisig Authentication
description: Guide on how to create a multisig transaction and then submit it against a local network using the Sui CLI.
---

The following steps demonstrate how to create a multisig transaction and then submit it against a network using the [Sui CLI](/references/cli.mdx). A transaction can be the transfer of an object, the publish or upgrade of a package, the payment of SUI, and so on.

To learn more about how to create multisig addresses and create multisig transactions using the TypeScript SDK, see the [SDK documentation](https://sdk.mystenlabs.com/typescript/cryptography/multisig) for details.

## Prerequisites

This topic assumes you are somewhat familiar with the Sui CLI, specifically the `sui client` and `sui keytool` commands. Consequently, a command might be introduced without any context. If you are unsure about the details of a referenced command, see the Sui CLI documentation for more information.

You need an existing address on the network you are working on to receive an object. The topic assumes that this address is the current active address (`sui client active-address`), but any address you have access to is fine.

The topic also assumes that your active environment is Testnet (`sui client active-env`). You can perform these steps on Devnet or a local network as well, but you must adjust the instructions appropriately.

## Executing multisig transactions

To demonstrate multisig, this topic guides you through setting up and executing a multisig transaction using the Sui CLI.

### Create addresses with different schemes

To begin, create three addresses that will act as the signers for the transaction you perform later in the instruction. Use the `sui client new-address` command to generate a Sui address and public key for three supported key schemes.

```sh
$ sui client new-address ed25519
```
```sh
$ sui client new-address secp256k1
```
```sh
$ sui client new-address secp256r1
```

The console displays a response to each successful call that is similar to the following:

```sh
╭──────────────────────────────────────────────────╮
│ Created new keypair and saved it to keystore.    │
├────────────────┬─────────────────────────────────┤
│ alias          │ <ALIAS>                         │
│ address        │ <SUI-ADDRESS>                   │
│ keyScheme      │ <KEY-SCHEME>                    │
│ recoveryPhrase │ <RECOVERY-PHRASE>               │
╰────────────────┴─────────────────────────────────╯
```

When working with blockchain data, addresses and hashed values create large strings that can be cumbersome to work with in a CLI environment. To make referencing values easier in subsequent commands (and facilitate copy and paste), this topic uses shell variables. Use the values you receive from the console responses to set shell variables for these addresses, replacing the `<SUI-ADDRESS-*>` variables with the appropriate address. 

```sh
$ ADDRESS1=<SUI-ADDRESS-ED25519>
```
```sh
$ ADDRESS2=<SUI-ADDRESS-SECP256K1>
```
```sh
$ ADDRESS3=<SUI-ADDRESS-SECP256R1>
```

Create one more shell variable assigned to your active address.

```sh
$ ACTIVE=<ACTIVE-ADDRESS>
```

:::tip

You can set the shell variables to the alias values instead of addresses if you want.

:::

### Verify addresses

Use `sui keytool` to list the addresses you created in the previous section.

```sh
$ sui keytool list
```

The response resembles the following, but displays actual alias names, addresses, keys, and peer IDs:

```sh
╭────────────────────────────────────────────────────────────────────╮
│ ╭─────────────────┬──────────────────────────────────────────────╮ │
| | alias           |  <ALIAS-NAME>                                | |
│ │ suiAddress      │  <SUI-ADDRESS>                               │ │
│ │ publicBase64Key │  <PUBLIC-KEY>                                │ │
│ │ keyScheme       │  ed25519                                     │ │
│ │ flag            │  0                                           │ │
│ │ peerId          │  <PEER-ID>                                   │ │
│ ╰─────────────────┴──────────────────────────────────────────────╯ │
│ ╭─────────────────┬──────────────────────────────────────────────╮ │
| | alias           |  <ALIAS-NAME>                                | |
│ │ suiAddress      │  <SUI-ADDRESS>                               │ │
│ │ publicBase64Key │  <PUBLIC-KEY>                                │ │
│ │ keyScheme       │  secp256k1                                   │ │
│ │ flag            │  0                                           │ │
│ │ peerId          │  <PEER-ID>                                   │ │
│ ╰─────────────────┴──────────────────────────────────────────────╯ │
│ ╭─────────────────┬──────────────────────────────────────────────╮ │
| | alias           |  <ALIAS-NAME>                                | |
│ │ suiAddress      │  <SUI-ADDRESS>                               │ │
│ │ publicBase64Key │  <PUBLIC-KEY>                                │ │
│ │ keyScheme       │  secp256r1                                   │ │
│ │ flag            │  0                                           │ │
│ │ peerId          │  <PEER-ID>                                   │ │
│ ╰─────────────────┴──────────────────────────────────────────────╯ │
╰────────────────────────────────────────────────────────────────────╯
```

The output includes public key data that you use later, so create shell variables to store the information. Don't forget to replace `<PUBLIC-KEY-*>` with the actual values you receive from the previous console response.

```sh
$ PKEY_1=<PUBLIC-KEY-ED25519>
```
```sh
$ PKEY_2=<PUBLIC-KEY-SECP256K1>
```
```sh
$ PKEY_3=<PUBLIC-KEY-SECP256R1>
```

### Create a multisig address

To sign a transaction using multisig, you need to create a multisig address using `sui keytool multi-sig-address`. The multisig address is created using the public keys from each individual participating address. Each address is also assigned a `weight` value that determines how many are needed to create a valid signature. When summed, the `weight` of the included signatures must be greater than or equal to the `threshold` value you also set with the command. For this example, use the following command, which states that the first two addresses require at least one more signature to create a valid multisig. The last address has a weight of `3`, which is equal to the `threshold` value, so its owner can create a valid signature without the others.

```sh
$ sui keytool multi-sig-address --pks $PKEY_1 $PKEY_2 $PKEY_3 --weights 1 2 3 --threshold 3
```

The response resembles the following:

```
╭─────────────────┬─────────────────────────────────────────────────────────╮
│ multisigAddress │  <MULTISIG-ADDRESS>                                     │
│ multisig        │ ╭─────────────────────────────────────────────────────╮ │
│                 │ │ ╭─────────────────┬───────────────────────────────╮ │ │
│                 │ │ │ address         │  <SUI-ADDRESS>                │ │ │
│                 │ │ │ publicBase64Key │  <PUBLIC-KEY>                 │ │ │
│                 │ │ │ weight          │  1                            │ │ │
│                 │ │ ╰─────────────────┴───────────────────────────────╯ │ │
│                 │ │ ╭─────────────────┬───────────────────────────────╮ │ │
│                 │ │ │ address         │  <SUI-ADDRESS>                │ │ │
│                 │ │ │ publicBase64Key │  <PUBLIC-KEY>                 │ │ │
│                 │ │ │ weight          │  2                            │ │ │
│                 │ │ ╰─────────────────┴───────────────────────────────╯ │ │
│                 │ │ ╭─────────────────┬───────────────────────────────╮ │ │
│                 │ │ │ address         │  <SUI-ADDRESS>                │ │ │
│                 │ │ │ publicBase64Key │  <PUBLIC-KEY>                 │ │ │
│                 │ │ │ weight          │  3                            │ │ │
│                 │ │ ╰─────────────────┴───────────────────────────────╯ │ │
│                 │ ╰─────────────────────────────────────────────────────╯ │
╰─────────────────┴─────────────────────────────────────────────────────────╯
```

### Add SUI to the multisig address

Before getting SUI, set a `MULTISIG` shell variable to the multisig address provided at the top of the previous response (substituting the actual address for `<MULTISIG-ADDRESS>`).

```sh
$ MULTISIG=<MULTISIG-ADDRESS>
```

If you use the `sui client objects $MULTISIG` command, you can see that the newly created multisig address has no objects. This means you need to get SUI before you can perform any transactions. To get SUI for your multisig account, use the `sui client faucet` command and provide the multisig address using the `--address` flag. Run this command twice so that the multisig address owns at least two SUI. This example uses two SUI so that one can be transferred and the other can pay for gas.

```sh
$ sui client faucet --address $MULTISIG
```

Use the `sui client gas` command to verify the address now has at least two SUI.

```sh
$ sui client gas $MULTISIG
```

### Transfer SUI to your active address

It's now time to transfer an object from the multisig address. For simplicity, this example uses one of the coins your multisig address owns as the transfer object. Copy the object ID for one of the address' coins and use it to set a shell variable value.

```sh
$ COIN=<COIN-OBJECT-ID>
```

Use the `sui client transfer` command to set up the transfer. The `--serialize-unsigned-transaction` flag outputs the Base64-encoded transaction bytes.

{@include: ../../../snippets/info-gas-budget.mdx}

```sh
$ sui client transfer --to $ACTIVE --object-id $COIN --gas-budget <GAS-AMOUNT> --serialize-unsigned-transaction
```

The console displays the result (`<TX-BYTES-RESULT>`), which you can assign to another shell variable.

```sh
$ TXBYTES=<TX-BYTES-RESULT>
```

### Sign the transaction with two public keys

Use the `sui keytool sign` command to sign the transaction using two of the addresses you created previously. 

:::info

You can create the signature with other tools, as well, as long as you serialize it to `flag || sig || pk`.

:::

```sh
$ sui keytool sign --address $ADDRESS1 --data $TXBYTES
```
```sh
$ sui keytool sign --address $ADDRESS2 --data $TXBYTES
```

Each successful call to the command receives a response similar to the following.

```sh
╭──────────────┬─────────────────────────────╮
│ suiAddress   │ <ADDRESS>                   │
│ rawTxData    │ <TRANSACTION-HASH>          │
│ intent       │ ╭─────────┬─────╮           │
│              │ │ scope   │  0  │           |
│              │ │ version │  0  │           |
│              │ │ app_id  │  0  │           |
|              | ╰─────────┴─────╯           │
│ rawIntentMsg │ <INTENT-MSG-HASH>           │
│ digest       │ <DIGEST-HASH>               │
│ suiSignature │ <SIGNATURE-HASH>            │
╰──────────────┴─────────────────────────────╯
```

Create two more shell variables to store the signatures, replacing `<SIGNATURE-HASH-*>` with the values from the previous command responses.

```sh
$ SIG_1=<SIGNATURE-HASH-ED25519>
```
```sh
$ SIG_2=<SIGNATURE-HASH-SECP256K1>
```

### Combine individual signatures into a multisig

As mentioned, the multisig must be composed of enough individual signatures such that the sum of the participating signer weights is greater than the `threshold` value. Use the `sui keytool multi-sig-combine-partial-sig` command to combine the ed25519 signature (`weight: 1`) and the secp256k1 (`weight: 2`). To complete the command, you must provide all public keys, their weights, and the threshold that defined the multisig address.

```sh
$ sui keytool multi-sig-combine-partial-sig --pks $PKEY_1 $PKEY_2 $PKEY_3 --weights 1 2 3 --threshold 3 --sigs $SIG_1 $SIG_2
```

If successful, the console responds with a message similar to the following.

```sh
╭────────────────────┬──────────────────────────────╮
│ multisigAddress    │  <MULTISIG-ADDRESS>          │
│ multisigParsed     │  <MULTISIG-PARSED-HASH>      │
│ multisigSerialized │  <MULTISIG-SERIALIZED-HASH>  │
╰────────────────────┴──────────────────────────────╯
```

### Execute the transaction

Use `sui client execute-signed-tx` to execute the multisig transaction. Set a shell variable equal to the `multisigSerialized` value you receive from the previous response, then use it to build the `execute-signed-tx` command.

```sh
$ MULTISIG_SERIALIZED=<MULTISIG-SERIALIZED-HASH>
```

```sh
$ sui client execute-signed-tx --tx-bytes $TXBYTES --signatures $MULTISIG_SERIALIZED
```

If successful, the console responds with transaction details. 

<details>
<summary>
Transaction response
</summary>
This response contains the actual values from a test signing. Your response should be formatted the same but the values you receive are going to be different.

```sh
Transaction Digest: 7mBWUxT6HUVDa8bii3PZJc7nhWqefTLNTsGbHYnx7ZA4
╭─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                                                                                                                                                                                                                                                        │
├─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35                                                                                                                                                                                                                                                              │
│ Gas Owner: 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35                                                                                                                                                                                                                                                           │
│ Gas Budget: 2997880 MIST                                                                                                                                                                                                                                                                                                                │
│ Gas Price: 1000 MIST                                                                                                                                                                                                                                                                                                                    │
│ Gas Payment:                                                                                                                                                                                                                                                                                                                            │
│  ┌──                                                                                                                                                                                                                                                                                                                                    │
│  │ ID: 0xc62a5e163e599729509d6cebde097cac04e5d1b3bbc9a169144e8dfa602a0768                                                                                                                                                                                                                                                               │
│  │ Version: 289574879                                                                                                                                                                                                                                                                                                                   │
│  │ Digest: 2PMc8L67YbZmna4hoaryX9cZZFSgFNPEYPEeCqcDPCcX                                                                                                                                                                                                                                                                                 │
│  └──                                                                                                                                                                                                                                                                                                                                    │
│                                                                                                                                                                                                                                                                                                                                         │
│ Transaction Kind: Programmable                                                                                                                                                                                                                                                                                                          │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮                                                                                                                                                                                                                            │
│ │ Input Objects                                                                                            │                                                                                                                                                                                                                            │
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤                                                                                                                                                                                                                            │
│ │ 0   Pure Arg: Type: address, Value: "0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241" │                                                                                                                                                                                                                            │
│ │ 1   Imm/Owned Object ID: 0xe7acb59c190d7fcfcb622916e929c92007f6da15128fd84c8a2afd94a39edf11              │                                                                                                                                                                                                                            │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯                                                                                                                                                                                                                            │
│ ╭──────────────────────╮                                                                                                                                                                                                                                                                                                                │
│ │ Commands             │                                                                                                                                                                                                                                                                                                                │
│ ├──────────────────────┤                                                                                                                                                                                                                                                                                                                │
│ │ 0  TransferObjects:  │                                                                                                                                                                                                                                                                                                                │
│ │  ┌                   │                                                                                                                                                                                                                                                                                                                │
│ │  │ Arguments:        │                                                                                                                                                                                                                                                                                                                │
│ │  │   Input  1        │                                                                                                                                                                                                                                                                                                                │
│ │  │ Address: Input  0 │                                                                                                                                                                                                                                                                                                                │
│ │  └                   │                                                                                                                                                                                                                                                                                                                │
│ ╰──────────────────────╯                                                                                                                                                                                                                                                                                                                │
│                                                                                                                                                                                                                                                                                                                                         │
│ Signatures:                                                                                                                                                                                                                                                                                                                             │
│    AwICIrr3sYG1hx2DaVkS3levGuTv68GA1RL+6ZFbtnFV5PBPkEHuysjme9nG0hZ3hQ0eDds2CedbKkLqDyCUXMNQDwEUtr9SYWRGiJJih21cAXgpSxf5Y53HFcmzJPWfxac54l21YVx6hc7vhI1xunMzhVeQlCa53vVJiAtWKLKz+H7FBgADAPZrm85y/Gn83R6kUhXme9J8W2ilJyda6cAObtuyJ3CqAQICAwSWHr3Q2vGVFH4SQckaQs76X89S6hX3NUarydSY3jgCAQNqj1MFWmTysOPFDXdNfD2kJlQhWTiT3AbxdlJDDWozIgMDAA== │
│                                                                                                                                                                                                                                                                                                                                         │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: 7mBWUxT6HUVDa8bii3PZJc7nhWqefTLNTsGbHYnx7ZA4                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 600                                                                               │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0xc62a5e163e599729509d6cebde097cac04e5d1b3bbc9a169144e8dfa602a0768                         │
│  │ Owner: Account Address ( 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35 )  │
│  │ Version: 289574880                                                                             │
│  │ Digest: DWmLziJZEHwhkAfdBWVhn8HnJU7DMepDmjVLps2peSx8                                           │
│  └──                                                                                              │
│  ┌──                                                                                              │
│  │ ID: 0xe7acb59c190d7fcfcb622916e929c92007f6da15128fd84c8a2afd94a39edf11                         │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  │
│  │ Version: 289574880                                                                             │
│  │ Digest: JBA6PrhWuTUJ3P8NXBpgBetFBaSJacEvQKS4USK9EfAr                                           │
│  └──                                                                                              │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: 0xc62a5e163e599729509d6cebde097cac04e5d1b3bbc9a169144e8dfa602a0768                         │
│  │ Owner: Account Address ( 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35 )  │
│  │ Version: 289574880                                                                             │
│  │ Digest: DWmLziJZEHwhkAfdBWVhn8HnJU7DMepDmjVLps2peSx8                                           │
│  └──                                                                                              │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 1976000 MIST                                                                     │
│    Computation Cost: 1000000 MIST                                                                 │
│    Storage Rebate: 1956240 MIST                                                                   │
│    Non-refundable Storage Fee: 19760 MIST                                                         │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    F6TBXbvdK9fi4BnxZMBkL7QeNyv1612778i12ZPhafJD                                                   │
│    HFi4TniDvgL1jDzgPHjzJhxR8nbavLmPH3LLDnNL5Tqd                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────╮
│ No transaction block events │
╰─────────────────────────────╯

╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                   │
├──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Mutated Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0xc62a5e163e599729509d6cebde097cac04e5d1b3bbc9a169144e8dfa602a0768                  │
│  │ Sender: 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35                    │
│  │ Owner: Account Address ( 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35 ) │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 289574880                                                                            │
│  │ Digest: DWmLziJZEHwhkAfdBWVhn8HnJU7DMepDmjVLps2peSx8                                          │
│  └──                                                                                             │
│  ┌──                                                                                             │
│  │ ObjectID: 0xe7acb59c190d7fcfcb622916e929c92007f6da15128fd84c8a2afd94a39edf11                  │
│  │ Sender: 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35                    │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 ) │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 289574880                                                                            │
│  │ Digest: JBA6PrhWuTUJ3P8NXBpgBetFBaSJacEvQKS4USK9EfAr                                          │
│  └──                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Balance Changes                                                                                   │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                              │
│  │ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: 1000000000                                                                             │
│  └──                                                                                              │
│  ┌──                                                                                              │
│  │ Owner: Account Address ( 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35 )  │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: -1001019760                                                                            │
│  └──                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```
</details>

## Related links

- [Multisig](../../../concepts/cryptography/transaction-auth/multisig.mdx): Definition of multisig transactions on the Sui network and how to use it with CLI.
- [Multisig Typescript SDK](https://sdk.mystenlabs.com/typescript/cryptography/multisig): How to create multisig addresses and sign transactions using the Sui SDK.
- [SDK documentation](https://sdk.mystenlabs.com/typescript/cryptography/multisig): See the Sui TypeScript SDK documentation to learn how to use the library with multisig transactions.
- [Sui CLI](../../../references/cli.mdx): Interact with the Sui network, its features, and the Move programming language from a command line.
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/cryptography/zklogin-integration.mdx
```
---
title: zkLogin Integration Guide
---

Here is the high-level flow the wallet or frontend application must implement to support zkLogin-enabled transactions:

1. The wallet creates an ephemeral key pair.
1. The wallet prompts the user to complete an OAuth login flow with the nonce corresponding to the ephemeral public key.
1. After receiving the JSON Web Token (JWT), the wallet obtains a zero-knowledge proof.
1. The wallet obtains a unique user salt based on a JWT. Use the OAuth subject identifier and salt to compute the zkLogin Sui address.
1. The wallet signs transactions with the ephemeral private key.
1. The wallet submits the transaction with the ephemeral signature and the zero-knowledge proof.

Let's dive into the specific implementation details.

## Install the zkLogin TypeScript SDK

To use the zkLogin TypeScript SDK in your project, run the following command in your project root:

```sh npm2yarn
npm install @mysten/sui
```

If you want to use the latest experimental version:

```sh npm2yarn
npm install @mysten/sui@experimental
```

## Get JWT

1. Generate an ephemeral key pair. Follow the same process as you would generating a key pair in a traditional wallet. See [Sui SDK](https://sdk.mystenlabs.com/typescript/cryptography/keypairs) for details.

1. Set the expiration time for the ephemeral key pair. The wallet decides whether the maximum epoch is the current epoch or later. The wallet also determines whether this is adjustable by the user.

1. Assemble the OAuth URL with configured client ID, redirect URL, ephemeral public key and nonce: This is what the application sends the user to complete the login flow with a computed [nonce](#notations).

```typescript
import { generateNonce, generateRandomness } from '@mysten/sui/zklogin';

const FULLNODE_URL = 'https://fullnode.devnet.sui.io'; // replace with the RPC URL you want to use
const suiClient = new SuiClient({ url: FULLNODE_URL });
const { epoch, epochDurationMs, epochStartTimestampMs } = await suiClient.getLatestSuiSystemState();

const maxEpoch = Number(epoch) + 2; // this means the ephemeral key will be active for 2 epochs from now.
const ephemeralKeyPair = new Ed25519Keypair();
const randomness = generateRandomness();
const nonce = generateNonce(ephemeralKeyPair.getPublicKey(), maxEpoch, randomness);
```

The auth flow URL can be constructed with `$CLIENT_ID`, `$REDIRECT_URL` and `$NONCE`.

For some providers ("Yes" for "Auth Flow Only"), the JWT can be found immediately in the redirect URL after the auth flow.

For other providers ("No" for "Auth Flow Only"), the auth flow only returns a code (`$AUTH_CODE`) in redirect URL. To retrieve the JWT, an additional POST call is required with "Token Exchange URL".

| Provider  | Auth Flow URL                                                                                                                                                                       | Token Exchange URL                                                                                                                  | Auth Flow Only |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- | -------------- |
| Google    | `https://accounts.google.com/o/oauth2/v2/auth?client_id=$CLIENT_ID&response_type=id_token&redirect_uri=$REDIRECT_URL&scope=openid&nonce=$NONCE`                                     | N/A                                                                                                                                 | Yes            |
| Facebook  | `https://www.facebook.com/v17.0/dialog/oauth?client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&scope=openid&nonce=$NONCE&response_type=id_token`                                      | N/A                                                                                                                                 | Yes            |
| Twitch    | `https://id.twitch.tv/oauth2/authorize?client_id=$CLIENT_ID&force_verify=true&lang=en&login_type=login&redirect_uri=$REDIRECT_URL&response_type=id_token&scope=openid&nonce=$NONCE` | N/A                                                                                                                                 | Yes            |
| Kakao     | `https://kauth.kakao.com/oauth/authorize?response_type=code&client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&nonce=$NONCE`                                                           | `https://kauth.kakao.com/oauth/token?grant_type=authorization_code&client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&code=$AUTH_CODE` | No             |
| Apple     | `https://appleid.apple.com/auth/authorize?client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&scope=email&response_mode=form_post&response_type=code%20id_token&nonce=$NONCE`           | N/A                                                                                                                                 | Yes            |
| Slack     | `https://slack.com/openid/connect/authorize?response_type=code&client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&nonce=$NONCE&scope=openid`                                           | `https://slack.com/api/openid.connect.token?code=$AUTH_CODE&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET`                      | Yes            |
| Microsoft | `https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=$CLIENT_ID&scope=openid&response_type=id_token&nonce=$NONCE&redirect_uri=$REDIRECT_URL`                   | Yes                                                                                                                                 |

## Decoding JWT

Upon successful redirection, the OpenID provider attaches the JWT as a URL parameter. The following is an example using the Google flow.

```
http://host/auth?id_token=tokenPartA.tokenPartB.tokenPartC&authuser=0&prompt=none
```

The `id_token` param is the JWT in encoded format. You can validate the correctness of the encoded token and investigate its structure by pasting it in the [jwt.io](https://jwt.io) website.

To decode the JWT you can use a library like: `jwt_decode:` and map the response to the provided type `JwtPayload`:

```typescript
const decodedJwt = jwt_decode(encodedJWT) as JwtPayload;

export interface JwtPayload {
	iss?: string;
	sub?: string; //Subject ID
	aud?: string[] | string;
	exp?: number;
	nbf?: number;
	iat?: number;
	jti?: string;
}
```

## User salt management

zkLogin uses the user salt to compute the zkLogin Sui address (see [definition](../../../concepts/cryptography/zklogin.mdx#address-definition)). The salt must be a 16-byte value or a integer smaller than `2n**128n`. There are several options for the application to maintain the user salt:

1. Client side:
   - Option 1: Request user input for the salt during wallet access, transferring the responsibility to the user, who must then remember it.
   - Option 2: Browser or Mobile Storage: Ensure proper workflows to prevent users from losing wallet access during device or browser changes. One approach is to email the salt during new wallet setup.
2. Backend service that exposes an endpoint that returns a unique salt for each user consistently.
   - Option 3: Store a mapping from user identifier (e.g. `sub`) to user salt in a conventional database (e.g. `user` or `password` table). The salt is unique per user.
   - Option 4: Implement a service that keeps a master seed value, and derive a user salt with key derivation by validating and parsing the JWT. For example, use `HKDF(ikm = seed, salt = iss || aud, info = sub)` defined [here](https://github.com/MystenLabs/fastcrypto/blob/e6161f9279510e89bd9e9089a09edc018b30fbfe/fastcrypto/src/hmac.rs#L121). Note that this option does not allow any rotation on master seed or change in client ID (i.e. aud), otherwise a different user address will be derived and will result in loss of funds.

Here's an example request and response for the Mysten Labs-maintained salt server (using option 4). If you want to use the Mysten Labs salt server, please refer to [Enoki docs](https://docs.enoki.mystenlabs.com/) and contact us. Only valid JWT authenticated with whitelisted client IDs are accepted.

```sh
$ curl -X POST https://salt.api.mystenlabs.com/get_salt -H 'Content-Type: application/json' -d '{"token": "$JWT_TOKEN"}'
```

```sh
Response: {"salt":"129390038577185583942388216820280642146"}
```

User salt is used to disconnect the OAuth identifier (sub) from the on-chain Sui address to avoid linking Web2 credentials with Web3 credentials. While losing or misusing the salt could enable this link, it wouldn't compromise fund control or zkLogin asset authority. See more discussion [here](#security-and-privacy).

## Get the user's Sui address

Once the OAuth flow completes, the JWT can be found in the redirect URL. Along with the user salt, the zkLogin address can be derived as follows:

```typescript
import { jwtToAddress } from '@mysten/sui/zklogin';

const zkLoginUserAddress = jwtToAddress(jwt, userSalt);
```

## Get the zero-knowledge proof

The next step is to fetch the ZK proof. This is an attestation (proof) over the ephemeral key pair that proves the ephemeral key pair is valid.

First, generate the extended ephemeral public key to use as an input to the ZKP.

```typescript
import { getExtendedEphemeralPublicKey } from '@mysten/sui/zklogin';

const extendedEphemeralPublicKey = getExtendedEphemeralPublicKey(ephemeralKeyPair.getPublicKey());
```

You need to fetch a new ZK proof if the previous ephemeral key pair is expired or is otherwise inaccessible.

Because generating a ZK proof can be resource-intensive and potentially slow on the client side, it's advised that wallets utilize a backend service endpoint dedicated to ZK proof generation.

There are two options:

1. Call the Mysten Labs-maintained proving service.
1. Run the proving service in your backend using the provided Docker images.

### Call the Mysten Labs-maintained proving service

If you want to use the Mysten hosted ZK Proving Service for Mainnet, please refer to [Enoki docs](https://docs.enoki.mystenlabs.com/) and contact us for accessing it.

Use the `prover-dev` endpoint (https://prover-dev.mystenlabs.com/v1) freely for testing on Devnet. Note that you can submit proofs generated with this endpoint for Devnet zkLogin transactions only; submitting them to Testnet or Mainnet fails.

You can use BigInt or Base64 encoding for `extendedEphemeralPublicKey`, `jwtRandomness`, and `salt`. The following examples show two sample requests with the first using BigInt encoding and the second using Base64.

```sh
$ curl -X POST $PROVER_URL -H 'Content-Type: application/json' \
-d '{"jwt":"$JWT_TOKEN", \
"extendedEphemeralPublicKey":"84029355920633174015103288781128426107680789454168570548782290541079926444544", \
"maxEpoch":"10", \
"jwtRandomness":"100681567828351849884072155819400689117", \
"salt":"248191903847969014646285995941615069143", \
"keyClaimName":"sub" \
}'
```

```sh
$ curl -X POST $PROVER_URL -H 'Content-Type: application/json' \
-d '{"jwt":"$JWT_TOKEN", \
"extendedEphemeralPublicKey":"ucbuFjDvPnERRKZI2wa7sihPcnTPvuU//O5QPMGkkgA=", \
"maxEpoch":"10", \
"jwtRandomness":"S76Qi8c/SZlmmotnFMr13Q==", \
"salt":"urgFnwIxJ++Ooswtf0Nn1w==", \
"keyClaimName":"sub" \
}'
```

Response:

```json
{
	"proofPoints": {
		"a": [
			"17267520948013237176538401967633949796808964318007586959472021003187557716854",
			"14650660244262428784196747165683760208919070184766586754097510948934669736103",
			"1"
		],
		"b": [
			[
				"21139310988334827550539224708307701217878230950292201561482099688321320348443",
				"10547097602625638823059992458926868829066244356588080322181801706465994418281"
			],
			[
				"12744153306027049365027606189549081708414309055722206371798414155740784907883",
				"17883388059920040098415197241200663975335711492591606641576557652282627716838"
			],
			["1", "0"]
		],

		"c": [
			"14769767061575837119226231519343805418804298487906870764117230269550212315249",
			"19108054814174425469923382354535700312637807408963428646825944966509611405530",
			"1"
		]
	},
	"issBase64Details": {
		"value": "wiaXNzIjoiaHR0cHM6Ly9pZC50d2l0Y2gudHYvb2F1dGgyIiw",
		"indexMod4": 2
	},
	"headerBase64": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifQ"
}
```

### How to handle CORS error

To avoid possible CORS errors in Frontend apps, it is suggested to delegate this call to a backend service.

The response can be mapped to the inputs parameter type of `getZkLoginSignature` of zkLogin SDK.

```typescript
const proofResponse = await post('/your-internal-api/zkp/get', zkpRequestPayload);

export type PartialZkLoginSignature = Omit<
	Parameters<typeof getZkLoginSignature>['0']['inputs'],
	'addressSeed'
>;
const partialZkLoginSignature = proofResponse as PartialZkLoginSignature;
```

### Run the proving service in your backend

1. Install [Git Large File Storage](https://git-lfs.com/) (an open-source Git extension for large file versioning) before downloading the zkey.

1. Download the [Groth16 proving key zkey file](https://docs.circom.io/getting-started/proving-circuits/). There are zkeys available for all Sui networks. See [the Ceremony section](#ceremony) for more details on how the main proving key is generated.

   - Main zkey (for Mainnet and Testnet)
     ```sh
     $ wget -O - https://raw.githubusercontent.com/sui-foundation/zklogin-ceremony-contributions/main/download-main-zkey.sh | bash
     ```
   - Test zkey (for Devnet)

     ```sh
     $ wget -O - https://raw.githubusercontent.com/sui-foundation/zklogin-ceremony-contributions/main/download-test-zkey.sh | bash
     ```

   - To verify the download contains the correct zkey file, you can run the following command to check the Blake2b hash: `b2sum ${file_name}.zkey`.

     | Network          | zkey file name      | Hash                                                                                                                               |
     | ---------------- | ------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
     | Mainnet, Testnet | `zkLogin-main.zkey` | `060beb961802568ac9ac7f14de0fbcd55e373e8f5ec7cc32189e26fb65700aa4e36f5604f868022c765e634d14ea1cd58bd4d79cef8f3cf9693510696bcbcbce` |
     | Devnet           | `zkLogin-test.zkey` | `686e2f5fd969897b1c034d7654799ee2c3952489814e4eaaf3d7e1bb539841047ae8ee5fdcdaca5f4ddd76abb5a8e8eb77b44b693a2ba9d4be57e94292b26ce2` |

1. For the next step, you need two Docker images from the [mysten/zklogin repository](https://hub.docker.com/repository/docker/mysten/zklogin/general) (tagged as `prover` and `prover-fe`). To simplify, a docker compose file is available that automates this process. Run `docker compose` with the downloaded zkey from the same directory as the YAML file.

```yaml
services:
  backend:
    image: mysten/zklogin:prover-stable
    volumes:
      # The ZKEY environment variable must be set to the path of the zkey file.
      - ${ZKEY}:/app/binaries/zkLogin.zkey
    environment:
      - ZKEY=/app/binaries/zkLogin.zkey
      - WITNESS_BINARIES=/app/binaries

  frontend:
    image: mysten/zklogin:prover-fe-stable
    command: '8080'
    ports:
      # The PROVER_PORT environment variable must be set to the desired port.
      - '${PROVER_PORT}:8080'
    environment:
      - PROVER_URI=http://backend:8080/input
      - NODE_ENV=production
      - DEBUG=zkLogin:info,jwks
      # The default timeout is 15 seconds. Uncomment the following line to change it.
      # - PROVER_TIMEOUT=30
```

```
ZKEY=<path_to_zkLogin.zkey> PROVER_PORT=<PROVER_PORT> docker compose up
```

1. To call the service, the following two endpoints are supported:
   - `/ping`: To test if the service is up. Running `curl http://localhost:PROVER_PORT/ping` should return `pong`.
   - `/v1`: The request and response are the same as the Mysten Labs maintained service.

A few important things to note:

- The backend service (mysten/zklogin:prover-stable) is compute-heavy. Use at least the minimum recommended 16 cores and 16GB RAM. Using weaker instances can lead to timeout errors with the message "Call to rapidsnark service took longer than 15s". You can adjust the environment variable `PROVER_TIMEOUT` to set a different timeout value, for example, `PROVER_TIMEOUT=30` for a timeout of 30 seconds.

- If you want to compile the prover from scratch (for performance reasons), please see our fork of [rapidsnark](https://github.com/MystenLabs/rapidsnark#compile-prover-in-server-mode). You'd need to compile and launch the prover in server mode.

- Setting `DEBUG=*` turns on all logs in the prover-fe service some of which may contain PII. Consider using DEBUG=zkLogin:info,jwks in production environments.

## Assemble the zkLogin signature and submit the transaction

First, sign the transaction bytes with the ephemeral private key using the key pair generated previously. This is the same as [traditional KeyPair signing](https://sdk.mystenlabs.com/typescript/cryptography/keypairs). Make sure that the transaction `sender ` is also defined.

```typescript
const ephemeralKeyPair = new Ed25519Keypair();

const client = new SuiClient({ url: '<YOUR_RPC_URL>' });

const txb = new Transaction();

txb.setSender(zkLoginUserAddress);

const { bytes, signature: userSignature } = await txb.sign({
	client,
	signer: ephemeralKeyPair, // This must be the same ephemeral key pair used in the ZKP request
});
```

Next, generate an address seed by combining `userSalt`, `sub` (subject ID), and `aud` (audience).

Set the address seed and the partial zkLogin signature to be the `inputs` parameter.

You can now serialize the zkLogin signature by combining the ZK proof (`inputs`),
the `maxEpoch`, and the ephemeral signature (`userSignature`).

```typescript
import { genAddressSeed, getZkLoginSignature } from '@mysten/sui/zklogin';

const addressSeed = genAddressSeed(
	BigInt(userSalt!),
	'sub',
	decodedJwt.sub,
	decodedJwt.aud,
).toString();

const zkLoginSignature = getZkLoginSignature({
	inputs: {
		...partialZkLoginSignature,
		addressSeed,
	},
	maxEpoch,
	userSignature,
});
```

Finally, execute the transaction.

```typescript
client.executeTransactionBlock({
	transactionBlock: bytes,
	signature: zkLoginSignature,
});
```

## Caching the ephemeral private key and ZK proof

As previously documented, each ZK proof is tied to an ephemeral key pair. So you can reuse the proof to sign any number of transactions until the ephemeral key pair expires (until the current epoch crosses `maxEpoch`).

You might want to cache the ephemeral key pair along with the ZKP for future uses.

However, the ephemeral key pair needs to be treated as a secret akin to a key pair in a traditional wallet. This is because if both the ephemeral private key and ZK proof are revealed to an attacker, then they can typically sign any transaction on behalf of the user (using the same process described previously).

Consequently, you should not store them persistently in a storage location that is not secure, on any platform. For example, on browsers, use session storage instead of local storage to store the ephemeral key pair and the ZK proof. This is because session storage automatically clears its data when the browser session ends, while data in local storage persists indefinitely.

## Efficiency considerations

Compared to traditional signatures, zkLogin signatures take a longer time to generate. For example, the prover that Mysten Labs maintains typically takes about three seconds to return a proof, which runs on a machine with 16 vCPUs and 64 GB RAM. Using more powerful machines, such as those with physical CPUs or graphics processing units (GPUs), can reduce the proving time further.

Carefully consider how many requests your application needs to make to the prover. Broadly speaking, the right metric to consider is the number of active user sessions and not the number of signatures. This is because you can cache the same ZK proof and reuse it across the session, as previously explained. For example, if you expect a million active user sessions per day, then you need a prover that can handle one or two requests per second (RPS), assuming evenly distributed traffic.

The prover that Mysten Labs maintains is set to auto-scale to handle traffic surges. If you are not sure whether Mysten Labs can handle a specific number of requests or expect a sudden spike in the number of prover requests your application needs to make, please reach out to us on [Discord](https://discord.gg/sui). Our plan is to horizontally scale the prover to handle any RPS you require.

## Related links

- [zkLogin Concepts](../../../concepts/cryptography/zklogin.mdx)
- [zkLogin Example](./zklogin-integration/zklogin-example.mdx)
- [Configure OpenID Providers](./zklogin-integration/developer-account.mdx)

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/cryptography/signing.mdx
```
---
title: Sui On-Chain Signatures Verification in Move
---

Move contracts in Sui support verifications for several signature schemes on-chain. Not all signatures supported in on-chain verification are supported as user signature verification. See [Sui Signatures](/concepts/cryptography/transaction-auth/signatures.mdx#user-signature) for valid signature schemes for transaction authorization.

This topic covers:
1. How to use [fastcrypto](https://github.com/MystenLabs/fastcrypto)'s CLI tool to create a signature of a given scheme. For testing and debugging only, DO NOT use in production.
1. Call the Move method on-chain to verification by submitting the signature, the message and the public key. 

Signature schemes covered: 
- Ed25519 signature (64 bytes)
- Secp256k1 non-recoverable signature (64 bytes)
- Secp256k1 recoverable signature (65 bytes)
- Secp256r1 non-recoverable signature (64 bytes)
- Secp256r1 recoverable signature (65 bytes)
- BLS G1 signature (minSig setting)
- BLS G2 signature (minPk setting)

## Usage

### Set up fastcrypto CLI binary

```sh
git@github.com:MystenLabs/fastcrypto.git
cd fastcrypto/
cargo build --bin sigs-cli
```

### Sign with CLI and submit to on-chain Move method

#### Ed25519 signature (64 bytes)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme ed25519 --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme ed25519 --msg $MSG --secret-key  $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the verify method in Move. All inputs are represented in bytes in hex format:

```move
    use sui::ed25519;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    let verify = ed25519::ed25519_verify(&sig, &pk, &msg);
    assert!(verify == true, 0);
```

#### Secp256k1 non-recoverable signature (64 bytes)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme secp256k1 --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme secp256k1 --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the verify method in Move.

```move
    use sui::ecdsa_k1;
    
    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    // The last param 1 represents the hash function used is SHA256, the default hash function used when signing in CLI.
    let verify = ecdsa_k1::secp256k1_verify(&sig, &pk, &msg, 1);
    assert!(verify == true, 0);
```

#### Secp256k1 recoverable signature (65 bytes)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme secp256k1-rec --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme secp256k1-rec --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the ecrecover method in Move and check equality.
```move
    use sui::ecdsa_k1;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    // The last param 1 represents the hash function used is SHA256, the default hash function used when signing in CLI.
    let recovered = ecdsa_k1::secp256k1_ecrecover(&sig, &msg, 1);
    assert!(pk == recovered, 0);
```

#### Secp256r1 non-recoverable signature (64 bytes)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme secp256r1 --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme secp256r1 --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the verify method in Move.

```move
    use sui::ecdsa_r1;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    // The last param 1 represents the hash function used is SHA256, the default hash function used when signing in CLI.
    let verify = ecdsa_r1::secp256r1_verify(&sig, &pk, &msg, 1);
    assert!(verify == true, 0);
```

#### Secp256r1 recoverable signature (65 bytes)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme secp256r1-rec --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme secp256r1-rec --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the ecrecover method in Move and check equality.

```move
    use sui::ecdsa_r1;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    // The last param 1 represents the hash function used is SHA256, the default hash function used when signing in CLI.
    let recovered = ecdsa_r1::secp256r1_ecrecover(&sig, &msg, 1);
    assert!(pk == recovered, 0);
```

#### BLS G1 signature (48 bytes, minSig setting)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme bls12381-minsig --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme bls12381-minsig --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the verify method in Move.

```move
    use sui::bls12381;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    let verified = bls12381::bls12381_min_sig_verify(&sig, &pk, &msg);
    assert!(verified == true, 0);
```

#### BLS G1 signature (96 bytes, minPk setting)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme bls12381-minpk --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme bls12381-minpk --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the verify method in Move.

```move
    use sui::bls12381;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    let verified = bls12381::bls12381_min_pk_verify(&sig, &pk, &msg);
    assert!(verified == true, 0);
```

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/cryptography/hashing.mdx
```
---
title: Hashing
description: Sui supports SHA2-256, SHA3-256, Keccak256, Blake2b-256 cryptographic hash functions.
---

A cryptographic hash function is a widely used cryptographic primitive that maps an arbitrary length input to a fixed length output, the hash value. The hash function is designed to be a one-way function, which means that it is infeasible to invert the function to find the input data from a given hash value, and to be collision resistant, which means that it is infeasible to find two different inputs that map to the same hash value.

The Sui Move API supports the following cryptographic hash functions:

* SHA2-256 as `std::hash::sha2_256`
* SHA3-256 as `std::hash::sha3_256`
* Keccak256 as `sui::hash::keccak256`
* Blake2b-256 as `sui::hash::blake2b256`

## Usage

The SHA2-256 and SHA3-256 hash functions are available in the Move Standard Library in the `std::hash` module. The following example shows how to use the SHA2-256 hash function in a smart contract:

```move
module test::hashing_std {
    use std::hash;
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;
    use sui::transfer;
    use std::vector;

    /// Object that holds the output hash value.
    struct Output has key, store {
        id: UID,
        value: vector<u8>
    }

    public fun hash_data(data: vector<u8>, recipient: address, ctx: &mut TxContext) {
        let hashed = Output {
            id: object::new(ctx),
            value: hash::sha2_256(data),
        };
        // Transfer an output data object holding the hashed data to the recipient.
        transfer::public_transfer(hashed, recipient)
    }
}
```

The Keccak256 and Blake2b-256 hash functions are available through the `sui::hash` module in the Sui Move Library. An example of how to use the Keccak256 hash function in a smart contract is shown below. Notice that here, the input to the hash function is given as a reference. This is the case for both Keccak256 and Blake2b-256.

```move
module test::hashing_sui {
    use sui::hash;
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;
    use sui::transfer;
    use std::vector;

    /// Object that holds the output hash value.
    struct Output has key, store {
        id: UID,
        value: vector<u8>
    }

    public fun hash_data(data: vector<u8>, recipient: address, ctx: &mut TxContext) {
        let hashed = Output {
            id: object::new(ctx),
            value: hash::keccak256(&data),
        };
        // Transfer an output data object holding the hashed data to the recipient.
        transfer::public_transfer(hashed, recipient)
    }
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/cryptography/ecvrf.mdx
```
---
title: Elliptic Curve Verifiable Random Function
sidebar_label: ECVRF
description: Elliptic curve verifiable random function is a cryptographic algorithm that enables you to generate a random number and provide proof that the number used a secret key for generation.
---

A verifiable random function (VRF) is a cryptographic primitive that enables you to generate a random number and provide proof that the number used a secret key for generation. Anyone can verify the proof using the public key corresponding to the secret key, so you can use it as a random number generator (RNG) that generates outputs that anyone can verify. Applications that need verifiable randomness on chain can also benefit from its use.

## VRF construction

The VRF used in the Move API in Sui is an elliptic curve VRF (ECVRF) following the [CFRG VRF draft specifications version 15](https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/15/). It uses [Ristretto255](https://ristretto.group) elliptic curve group construction with the SHA-512 hash function. The nonce is generated according to [RFC6979](https://www.rfc-editor.org/info/rfc6979).

Any implementation following the same specifications with suite string `sui_vrf` (see section 5 in the [VRF specs](https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/15/)) can be used to compute VRF output and generate proofs.

The [fastcrypto](https://github.com/MystenLabs/fastcrypto) library provides a CLI tool for such an implementation and is used in the following example.

### Generate keys

From the root of the `fastcrypto` repository, run the following command to generate a key pair:

```sh
$ cargo run --bin ecvrf-cli keygen
```
This outputs a secret key and a public key in hex format. Both the secret and public keys are 32-byte strings:

```sh
Secret key: c0cbc5bf0b2f992fe14fee0327463c7b03d14cbbcb38ce2584d95ee0c112b40b
Public key: 928744da5ffa614d65dd1d5659a8e9dd558e68f8565946ef3d54215d90cba015
```

### Compute VRF output and proof

To compute the VRF output and proof for the input string `Hello, world!`, which is `48656c6c6f2c20776f726c6421` in hexadecimal, with the key pair generated previously, run the following command:

```sh
$ cargo run --bin ecvrf-cli prove --input 48656c6c6f2c20776f726c6421 --secret-key c0cbc5bf0b2f992fe14fee0327463c7b03d14cbbcb38ce2584d95ee0c112b40b
```

This should the 80-byte proof and VRF 64-byte output, both in hex format:
```sh
Proof:  18ccf8bf316f00b387fc6e7b26f2d3ddadbf5e9c66d3a30986f12b208108551f9c6da87793a857d79261338a50430074b1dbc7f8f05e492149c51313381248b4229ebdda367146dbbbf95809c7fb330d
Output: 2b7e45821d80567761e8bb3fc519efe5ad80cdb4423227289f960319bbcf6eea1aef30c023617d73f589f98272b87563c6669f82b51dafbeb5b9cf3b17c73437
```

### Verify proof

You can verify the proof and output in a smart contract using `sui::ecvrf::ecvrf_verify` from the Sui Move framework:

```move
module math::ecvrf_test {
    use sui::ecvrf;
    use sui::event;

    /// Event on whether the output is verified
    struct VerifiedEvent has copy, drop {
        is_verified: bool,
    }

    public fun verify_ecvrf_output(output: vector<u8>, alpha_string: vector<u8>, public_key: vector<u8>, proof: vector<u8>) {
        event::emit(VerifiedEvent {is_verified: ecvrf::ecvrf_verify(&output, &alpha_string, &public_key, &proof)});
    }
}
```

You can also use the CLI tool for verification:

```sh
$ cargo run --bin ecvrf-cli verify --output 2b7e45821d80567761e8bb3fc519efe5ad80cdb4423227289f960319bbcf6eea1aef30c023617d73f589f98272b87563c6669f82b51dafbeb5b9cf3b17c73437 --proof 18ccf8bf316f00b387fc6e7b26f2d3ddadbf5e9c66d3a30986f12b208108551f9c6da87793a857d79261338a50430074b1dbc7f8f05e492149c51313381248b4229ebdda367146dbbbf95809c7fb330d --input 48656c6c6f2c20776f726c6421 --public-key 928744da5ffa614d65dd1d5659a8e9dd558e68f8565946ef3d54215d90cba015
```

The preceding command returns the verification:

```sh
Proof verified correctly!
```

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/cryptography/zklogin-integration/developer-account.mdx
```
---
title: Configure OpenID Providers
---

To integrate zkLogin with your app, you need an OAuth client from at least one of the [available providers](#openid-providers). You use the Client ID and redirect URI from those providers in your zkLogin project. For example, the following TypeScript code constructs a Google login URL for testing.

```typescript
const REDIRECT_URI = '<YOUR_SITE_URL>';

const params = new URLSearchParams({
	// Configure client ID and redirect URI with an OpenID provider
	client_id: $CLIENT_ID,
	redirect_uri: $REDIRECT_URI,
	response_type: 'id_token',
	scope: 'openid',
	// See below for details about generation of the nonce
	nonce: nonce,
});

const loginURL = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
```

## OpenID providers

{@include: ../../../../snippets/openid-providers.mdx}

## Configuring an OpenID provider

Select a tab for instruction on configuring the client ID (`$CLIENT_ID` in the previous example) and redirect URI (`$REDIRECT_URI` in the previous example) with the relevant provider.

<Tabs groupId="oauth-providers">

<TabItem label="Google" value="google">

1. Navigate a browser to the [Google Cloud dashboard](https://console.cloud.google.com/home/dashboard). Either sign in or register for a Google Cloud account.
1. Open **APIs & Services** > **Credentials** using the Google Cloud dashboard navigation. 

    ![1](images/google-nav.png 'Open APIs & Services > Credentials')

1. On the Credentials page, select **CREATE CREDENTIALS** > **OAuth client ID**.

    ![2](images/google-oauth.png 'Select CREATE CREDENTIALS > OAuth client ID')

1. Set the **Application type** and **Name** of your application.

    ![3](images/google-appmeta.png 'Set type and name')

1. In the **Authorized redirect URIs** section, click the **ADD URI** button. Set the value for your redirect URI in the field. This should be the wallet or application frontend.

    ![4](images/google-addauth.png 'Add redirect URL')

1. Click **Create**. If successful, Google Cloud displays the **OAuth client created** dialog with metadata, including your **Client ID**. Click **OK** to dismiss the dialog. 

Your new OAuth client should now appear in the **OAuth 2.0 Client IDs** section of the Credentials page. Click the **Client ID** that appears next to the client to copy the value to your clipboard. Click the client name to access the redirect URI and other client data.

</TabItem>

<TabItem label="Facebook" value="facebook">

1. Register for a Facebook developer account and access the [dashboard](https://developers.facebook.com/apps/).

1. Select "Build your app" then "Products" then "Facebook Login" where you can find the client ID. Set the redirect URL. This should be the wallet or application frontend.

![1](../../../../concepts/cryptography/images/zklogin-facebook1.png 'Sign up for Facebook developer account')

_Sign up for Facebook developer account_

![2](../../../../concepts/cryptography/images/zklogin-facebook2.png 'Go to Settings')

_Go to Settings_

</TabItem>

<TabItem label="Twitch" value="twitch">

1. Register for a Twitch developer account. Access the [dashboard](https://dev.twitch.tv/console).

1. Go to "Register Your Application" then "Application" where you can find the client ID. Set the redirect URL. This should be the wallet or application frontend.

![1](../../../../concepts/cryptography/images/zklogin-twitch1.png "Sign up for Twitch developer account")

*Sign up for Twitch developer account*

![2](../../../../concepts/cryptography/images/zklogin-twitch2.png "Go to Console")

*Go to Console*

</TabItem>

<TabItem label="Kakao" value="kakao">

1. Register for a Kakao developer account. Access the [dashboard](https://developers.kakao.com/console/app) and add an application.

![1](../../../../concepts/cryptography/images/zklogin-kakao1.png "Add applications to Kakao")

*Add applications to Kakao*

1. Go to "App Keys" where you can find the corresponding client ID for different platforms.

- Native app key: Used to call APIs through the Android or iOS SDK.
- JavaScript key: Used to call APIs through the JavaScript SDK.
- REST API key: Used to call APIs through the REST API.

![2](../../../../concepts/cryptography/images/zklogin-kakao2.png "Find Client ID")

*Find client ID*

1. Toggle on "Kakao Login Activation" and "OpenID Connect Activation". Set the redirect URL in "Kakao Login" under "Product Settings". This should be the wallet or application frontend.

![1](../../../../concepts/cryptography/images/zklogin-kakao3.png "Set Redirect URL")

*Set redirect URL*

</TabItem>

<TabItem label="Slack" value="slack">

1. Register for a Slack developer account. Access the [dashboard](https://api.slack.com/apps) and go to "Create New App" then choose "From scratch".

	![1](../../../../concepts/cryptography/images/zklogin-slack1.png "Create app in Slack")

	*Create app in Slack*

1. Find the Client ID and Client Secret under "App Credentials".

	![1](../../../../concepts/cryptography/images/zklogin-slack2.png "Find Client ID and Client Secret")

	*Find Client ID and Client Secret*

1. Set Redirect URL in "OAuth & Permissions" under "Features". This should be the wallet or application frontend.

	![1](../../../../concepts/cryptography/images/zklogin-slack3.png "Set Redirect URL")

	*Set Redirect URL*

</TabItem>

<TabItem label="Apple" value="apple">

1. Register for an [Apple developer account](https://developer.apple.com/). Go to the **Certificates, Identifiers and Profiles** section.

	![1](../../../../concepts/cryptography/images/zklogin-apple1.png "Click on Certificates, Identifiers and Profiles")
	
	*This is where you can create Certificates, Identifiers and Profiles*

1. Create an App ID
    - From the sidebar, select **Identifiers** and click the blue plus icon to create a new one.
    - Choose **App IDs** as the identifier type and click **Continue**.
    - In the next screen, enter a descriptive name for your App ID and a unique Bundle ID in reverse-dns format (for example, `com.example.app`).
    - Scroll down to the list of capabilities and enable **Sign In with Apple** by checking the box next to it.

	![1](../../../../concepts/cryptography/images/zklogin-apple2.png "Create an App ID")
	
	*This is how you can enable Sign In with Apple for your App ID*

1. Create a Services ID

	A Services ID identifies a specific instance of your app and is used as the OAuth `client_id`. You need a Services ID if you want to use **Sign In with Apple** for your web app.

	![1](../../../../concepts/cryptography/images/zklogin-apple3.png "Create a Services ID")

	*This is where you Create a Services ID*

1. Create a new identifier and select **Services IDs** as the identifier type.

    - In the next step, enter a name for your app that will be displayed to the users during the sign-in process and a unique identifier that will be used as the OAuth `client_id`. Make sure to enable **Sign In with Apple** by checking the box next to it.
	- Click the **Configure** button next to **Sign In with Apple** to set up the domain and redirect URLs for your app. You need to specify the domain name where your app is hosted and the redirect URL that will handle the OAuth response from Apple.

	Select the App ID that you created in the previous step as the Primary App ID. This will associate your Services ID with your App ID.

	Enter the domain name of your app (for example, example-app.com) and the redirect URL that will receive the authorization code from Apple (for example, https://example-app.com/redirect). Note that Apple does not allow localhost or IP addresses as valid domains or redirect URLs.

	Click **Save** and then **Continue** and **Register** until you complete this step.

	You have now created an App ID and a Services ID for your app. The identifier of your Services ID is your OAuth `client_id`. In my example, that is com.example.client.

	![1](../../../../concepts/cryptography/images/zklogin-apple4.png "Set Redirect URL")
	
	*This is where you Set Redirect URL*

</TabItem>

<TabItem label="Microsoft" value="microsoft">

1. Register and sign in to the [Microsoft Entra admin center](https://entra.microsoft.com/). 
1. Select **Applications** > **App registrations** from the left nav.

	![Nav menu](./images/microsoft1.png)
1. Click the **New Registration** button in the top left to open the **Register an application** page.

	![New Registration](./images/microsoft2.png)
1. Type the application name in the **Name** field, select the appropriate **Supported account types** option, and set the **Redirect URI** value. When satisfied, click **Register**.

	![Create application page](./images/microsoft3.png "Create application")
1. After clicking the **Register** button, the admin center opens the application view. Select **Authentication** from the left nav of the application view.

	![Select Authentication](./images/microsoft4.png "Select Authentication")
1. In the **Implicit grant and hybrid flows** section, check the **ID tokens (used for implicit and hybrid flows)** box.

	![Enable ID tokens](./images/microsoft5.png "Enable ID tokens")
1. Click **Save**.
1. Client ID is available in the **Essentials** section of the application's **Overview** tab.

	![Find Client ID](./images/microsoft6.png "Find Client ID")
</TabItem>

</Tabs>

## Related links

- [zkLogin Integration Guide](../zklogin-integration.mdx)
- [zkLogin Example](./zklogin-example.mdx)
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/cryptography/zklogin-integration/zklogin-example.mdx
```
---
title: zkLogin Example
description: An example that breaks down the logic behind each step of zkLogin.
---

The Sui community created an example to facilitate a comprehensive understanding of each step involved in Sui zkLogin for developers.

- [Sui zkLogin Example](https://sui-zklogin.vercel.app/)

![ZKLogin Overview](images/overview.png "ZKLogin Overview")
This example breaks down the complete process of Sui zkLogin into seven steps, as follows:

1. Generate ephemeral key pair
1. Fetch JWT
1. Decode JWT
1. Generate salt
1. Generate user Sui address
1. Fetch ZK proof
1. Assemble zkLogin signature

Each step includes corresponding code snippets, providing instructions on how to obtain the required data for each step.

## Operating environment

The example runs in Sui Devnet. All data the user generates is stored locally on the client-side (browser). The acquisition of the zero-knowledge proof (ZK proof) is done through a call to the [Mysten Labs-maintained proving service](../zklogin-integration.mdx#call-the-mysten-labs-maintained-proving-service). Therefore, running the example does not require an additional deployed backend server (or a Docker container).

## Storage locations for key data

The following table lists the storage location for key data the example uses:

| Data | Storage location |
| --- | --- |
| Ephemeral key pair | `window.sessionStorage` |
| Randomness | `window.sessionStorage` | 
| User salt | `window.localStorage` | 
| Max epoch | `window.localStorage` | 

The user salt is stored long-term in the browser's `localStorage`. Consequently, provided the `localStorage` is not cleared manually, you can use the same JWT (in this example, logging in with the same Google account) to access the corresponding zkLogin address generated from the current salt value at any time.

:::caution

Changing browsers or devices results in the inability to access previously generated Sui zkLogin addresses, even when using the same JWT.

:::

## Troubleshooting

- **ZK Proof request failure:**
  - This might occur because of inconsistencies in the creation of multiple randomness or user salts, causing request failures. Click the **Reset Button** in the top right corner of the UI to restart the entire process.

- **Request test tokens failure:**
  - This is because you have surpassed the faucet server request frequency limitations. 
  - You can go to Sui [#devnet-faucet](https://discord.com/channels/916379725201563759/971488439931392130) or [#testnet-faucet](https://discord.com/channels/916379725201563759/1037811694564560966) Discord channels to claim test coins.

- Any suggestions are welcome on the project's GitHub repo through raised issues, and of course, pull requests are highly appreciated.

## Related links

- [zkLogin Integration Guide](../zklogin-integration.mdx)
- [zkLogin FAQ](../../../../concepts/cryptography/zklogin.mdx#faq)
- [Configure OpenID Providers](./developer-account.mdx)

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/nft/nft-soulbound.mdx
```
---
title: Soulbound NFT Example
description: An example using Sui Move struct abilities and the Sui Framework's `transfer` module to make a NFT soulbound (non-transferable).
keywords: [ERC-721, NFT, Soulbound]
---

A soulbound NFT is an NFT that is non-transferable. After an NFT is minted to a Sui account, the NFT is "bounded" to that account and cannot be transferred. This implementation leverages the custom logic of the Sui framework's transfer functions. The <a href="/references/framework/sui-framework/transfer" data-noBrokenLinkCheck='true'>`sui::transfer` module</a> contains two functions that transfers objects: <a href="/references/framework/sui-framework/transfer#function-transfer" data-noBrokenLinkCheck='true'>`transfer::transfer`</a> and <a href="/references/framework/sui-framework/transfer#function-public_transfer" data-noBrokenLinkCheck='true'>`transfer::public_transfer`</a>. 

Typically, when defining new NFTs or object types on Sui, you don't need to create a transfer function because the Sui Framework offers `transfer::public_transfer` which anyone can use to transfer objects. However, `transfer::public_transfer` requires transferred objects have the `key` and `store` ability. Therefore, if you define a new NFT type that has the `key` ability, meaning it is a Sui object, but not the `store` ability, the holders won't be able to use `transfer::public_transfer`. This results in a soulbound NFT.

It is also possible to create custom transfer logic for NFTs on Sui. The `transfer::transfer` function has custom rules performed by the Sui Move bytecode verifier that ensures that the transferred objects are defined in the module where transfer is invoked. While removing the `store` ability from a struct definition makes `transfer::public_transfer` unusable, `transfer::transfer` can still be used as long as it's used in the module that defined that object's type. This allows for the module owner to provide custom transfer logic for their soulbound NFTs. 

## Example

The following example creates a basic soulbound NFT on Sui. The `TestnetSoulboundNFT` struct defines the NFT with an `id`, `name`, `description`, and `url` fields. 

{@inject: examples/move/nft-soulbound/sources/testnet_soulbound_nft.move#struct=TestnetSoulboundNFT noComments}

This `TestnetSoulboundNFT` struct is defined with the `key` ability but without the `store` ability. This means you cannot transfer it with `transfer::public_transfer`. Instead, use `transfer::transfer` with custom transfer logic implemented in the same module. 

This example also shows how to provide custom transfer logic using the `transfer::transfer` function. This is where you can add additional logic, such as resetting the NFT's stats or requiring a payment. Don't provide this functionality if the NFT is fully soulbound. 

{@inject: examples/move/nft-soulbound/sources/testnet_soulbound_nft.move#fun=transfer}

<details>
<summary>
`testnet_soulbound_nft.move` 
</summary>

{@inject: examples/move/nft-soulbound/sources/testnet_soulbound_nft.move}

</details>

## Related links

- [Soulbound NFT example source code](https://github.com/MystenLabs/sui/tree/main/examples/move/nft-soulbound): The source code that this document references.
- [NFT Rental](/guides/developer/nft/nft-rental.mdx): Example that rents NFTs using Kiosk Apps. 
- [Asset Tokenization](/guides/developer/nft/asset-tokenization.mdx): Example that uses NFTs to tokenize real-world assets.
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/nft/asset-tokenization.mdx
```
---
title: Asset Tokenization
description: Learn how to tokenize assets on the Sui blockchain. Asset tokenization refers to the process of representing real-world assets, such as real estate, art, commodities, stocks, or other valuable assets, as digital tokens on the blockchain network.
---

Asset tokenization refers to the process of representing real-world assets, such as real estate, art, commodities, stocks, or other valuable assets, as digital tokens on the blockchain network. This involves converting the ownership or rights of an asset into digital tokens, which are then recorded and managed on the blockchain.

## High-level overview

The concept is to divide high-value assets into smaller, more affordable units, representing ownership or a fraction of the asset.

This strategy enables wider participation from investors who might want to mitigate risk by investing in a portion of a digital asset rather than being the sole owner, thereby expanding accessibility to a broader range of investors.

This pattern is similar to the [ERC1155](https://eips.ethereum.org/EIPS/eip-1155) multi-token standard with additional functionality. This makes it a suitable choice for Solidity based use cases that one might want to implement on Sui.

- **Asset creation**

  Each asset is fractionalized into a total supply, with each fraction represented as either a non-fungible token (NFT) or fungible token (FT) type collectible. This ensures that each individual fraction maintains a balance equal to or greater than one, and when combined, all fractions collectively reach the total supply of the asset.

  Besides the total supply, each asset is defined by various other fields such as name, description, and more. These fields collectively form the metadata for the asset, and they remain consistent across all fractions of the asset.

- **NFTs vs FTs distinction**

  Each time a tokenized asset is minted, there's a possibility for it to be created with new metadata. If new metadata is incorporated, the tokenized asset is deemed unique, transforming it into an NFT. In this case, its balance is limited to one, signifying that only a single instance of this asset exists.

  If there's no additional metadata, the tokenized asset is categorized as an FT, allowing its balance to exceed one, enabling multiple identical instances of the asset to exist.

  FTs possess the capability to merge (join) among themselves or be split when the balance is greater than one. This functionality allows for the aggregation or division of units of the token, offering flexibility in handling varying quantities as needed.

  As previously mentioned, all the collectibles of tokenized assets, whether NFTs or FTs, when combined, can amount to the maximum total supply of the asset.

- **Burnability**

  When you create the asset, you can define whether the fractions of the asset are eligible for removal or destruction from circulation. The process of removing or destroying assets is called burning.

  If a tokenized asset is burnable, then burning a fraction causes the circulating supply to decrease by the balance of the burnt item. The total supply, however, remains constant, allowing you to mint the burned fractions again if needed, thus maintaining the predetermined total supply of the asset.

## Move packages

As with all smart contracts on Sui, Move provides the logic that powers asset tokenization.

### asset_tokenization package

:::info

This reference implementation uses the [Kiosk standard](../../../standards/kiosk.mdx) to ensure that tokenized assets operate within their defined policy. Use the implementation as presented to have marketable tokenized assets that support rules like royalties, commissions, and so on.

If using Kiosk is not a requirement, then you can exclude the unlock module and some of the proxy's methods related to transfer policies.

:::

Select a module to view its details:

<Tabs groupId="modules">

<TabItem label="tokenized_asset" value="tokenized_asset">

The `tokenized_asset` module operates in a manner similar to the `coin` library.

When it receives a new one-time witness type, it creates a unique representation of a fractional asset. This module employs similar implementations to some methods found in the `Coin` module. It encompasses functionalities pertinent to asset tokenization, including new asset creation, minting, splitting, joining, and burning. See [One Time Witness](https://move-book.com/programmability/one-time-witness.html) in The Move Book for more information.

**Structs**

- `AssetCap`

  Generate an `AssetCap` for each new asset represented as a fractional NFT. In most scenarios, you should create it as an owned object, which you can then transfer to the platform's administrator for access-restricted method invocation.

  ```rust
  struct AssetCap<phantom T> {
      id: UID,
      // the current supply in circulation
      supply: Supply<T>,
      // the total max supply allowed to exist at any time
      total_supply: u64,
      // Determines if the asset can be burned or not
      burnable: bool
  }
  ```

- `AssetMetadata`

  The `AssetMetadata` struct defines the metadata representing the entire asset to fractionalize. This should be a shared object.

  ```rust
  struct AssetMetadata<phantom T> has key, store {
          id: UID,
          /// Name of the asset
          name: String,
          // the total max supply allowed to exist at any time
          total_supply: u64,
          /// Symbol for the asset
          symbol: ascii::String,
          /// Description of the asset
          description: String,
          /// URL for the asset logo
          icon_url: Option<Url>
      }
  ```

- `TokenizedAsset`

  The `TokenizedAsset` is minted with a specified balance that is less than or equal to the remaining supply. If the `VecMap` of an asset is populated with values, indicating multiple unique entries, it is considered an NFT. Conversely, if the `VecMap` of an asset is not populated, indicating an absence of individual entries, it is considered an FT.

  ```rust
  struct TokenizedAsset<phantom T> has key, store {
          id: UID,
          /// The balance of the tokenized asset
          balance: Balance<T>,
          /// If the VecMap is populated, it is considered an NFT, else the asset is considered an FT.
          metadata: VecMap<String, String>,
          /// URL for the asset image (optional)
          image_url: Option<Url>,
      }
  ```

- `PlatformCap`

  The `PlatformCap` refers to the capability issued to the individual who deploys the contract. This capability grants specific permissions or authority related to the platform's functionalities, allowing the deployer certain controlled actions or access rights within the deployed contract.

  ```rust
  /// Capability that is issued to the one deploying the contract
  struct PlatformCap has key, store { id: UID }
  ```

**Functions**

- `init`

  This function creates a `PlatformCap` and sends it to the sender.

  ```rust
  fun init(ctx: &mut TxContext) {}
  ```

- `new_asset`

  This function holds the responsibility of creating a fresh representation of an asset, defining its crucial attributes. Upon execution, it returns two distinct objects: the `AssetCap` and `AssetMetadata`. These objects encapsulate the necessary information and characteristics defining the asset within the system.

  ```rust
  public fun new_asset<T: drop>(
          witness: T,
          total_supply: u64,
          symbol: ascii::String,
          name: String,
          description: String,
          icon_url: Option<Url>,
          burnable: bool,
          ctx: &mut TxContext
      ): (AssetCap<T>, AssetMetadata<T>) {}
  ```

- `mint`

  The function performs the minting of a tokenized asset. If new metadata is introduced during this process, the resulting tokenized asset is considered unique, resulting in the creation of an NFT with a balance set to 1. Alternatively, if no new metadata is added, the tokenized asset is classified as an FT, permitting its balance to surpass 1, as specified by a provided argument. Upon execution, the function returns the tokenized asset object.

  ```rust
  public fun mint<T>(
          cap: &mut AssetCap<T>,
          keys: vector<String>,
          values: vector<String>,
          value: u64,
          ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

- `split`

  This function is provided with a tokenized asset of the FT type and a balance greater than 1, along with a value less than the object's balance, and performs a split operation on the tokenized asset. The operation divides the existing tokenized asset into two separate tokenized assets. The newly created tokenized asset has a balance equal to the given value, while the balance of the provided object is reduced by the specified value. Upon completion, the function returns the newly created tokenized asset. This function does not accept or operate on tokenized assets of the NFT type.

  ```rust
  public fun split<T>(
          self: &mut TokenizedAsset<T>,
          split_amount: u64,
          ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

- `join`

  This function is given two tokenized assets of the FT type and executes a merge operation on the tokenized assets. The operation involves increasing the balance of the first tokenized asset by the balance of the second one. Subsequently, the second tokenized asset is burned or removed from circulation. After the process concludes, the function returns the ID of the burned tokenized asset.

  This function does not accept or operate on tokenized assets of the NFT type.

  ```rust
  public fun join<T>(
          self: &mut TokenizedAsset<T>,
          other: TokenizedAsset<T>
      ): ID {}
  ```

- `burn`

  This function requires the `assetCap` as a parameter, thereby restricting its invocation solely to the platform admin. Additionally, it accepts a tokenized asset that is burned as part of its operation. Upon burning the provided tokenized asset, the circulating supply decreases by the balance of the burnt item. It necessitates a tokenized asset that is burnable.

  ```rust
  public fun burn<T>(
          cap: &mut AssetCap<T>,
          tokenized_asset: TokenizedAsset<T>
      )
  ```

- `total_supply`

  This function retrieves and returns the value representing the total supply of the asset.

  ```rust
  public fun total_supply<T>(cap: &AssetCap<T>): u64 {}
  ```

- `supply`

  This function retrieves and returns the value representing the current circulating supply of the asset.

  ```rust
  public fun supply<T>(cap: &AssetCap<T>): u64 {}
  ```

- `value`

  This function takes a tokenized asset as input and retrieves its associated balance value.

  ```rust
  public fun value<T>(tokenized_asset: &TokenizedAsset<T>): u64 {}
  ```

- `create_vec_map_from_arrays`

  This internal helper function populates a `VecMap<String, String>`. It assists in the process of filling or setting key-value pairs within the `VecMap` data structure.

  ```rust
  fun create_vec_map_from_arrays(
          keys: vector<String>,
          values: vector<String>
      ): VecMap<String, String> {}
  ```

</TabItem>

<TabItem label="proxy" value="proxy">

The `proxy` module comprises methods that the type owner utilizes to execute publisher-related operations.

**Structs**

- `Proxy`

  The `PROXY` struct represents the one-time witness (OTW) to claim the publisher.

  ```rust
  struct PROXY has drop {}
  ```

- `Registry`

  This shared object serves as a repository for the `Publisher` object, specifically intended to control and restrict access to the creation and management of transfer policies for tokenized assets. Mutable access to this object is exclusively granted to the actual publisher.

  ```rust
  struct Registry has key {
          id: UID,
          publisher: Publisher
      }
  ```

- `ProtectedTP`

  This is a shared object that stores an empty transfer policy. It is required to create one per type `<T>` generated by a user. Its involvement is apparent in the unlock module.

  ```rust
  struct ProtectedTP<phantom T> has key, store {
          id: UID,
          policy_cap: TransferPolicyCap<T>,
          transfer_policy: TransferPolicy<T>
      }
  ```

**Functions**

- `init`

  This function is responsible for creating the `Publisher` object, encapsulating it within the registry, and subsequently sharing the `Registry` object.

  ```rust
  fun init(otw: PROXY, ctx: &mut TxContext) {}
  ```

- `setup_tp`

  This function leverages the publisher nested within the registry and the sender's publisher. It generates and returns a transfer policy and the associated transfer policy cap specific to the `TokenizedAsset<T>`. This type 'T' is derived from the `Publisher` object.

  It also generates an empty transfer policy wrapped in a `ProtectedTP<T>` object, which is shared. You can use this functionality under specific conditions to override the kiosk lock rule.

  ```rust
  public fun setup_tp<T: drop>(
          registry: &Registry,
          publisher: &Publisher,
          ctx: &mut TxContext
      ): (TransferPolicy<TokenizedAsset<T>>,
          TransferPolicyCap<TokenizedAsset<T>>) {}
  ```

- `new_display`

  This function utilizes the publisher nested within the registry and the sender's publisher to generate and return an empty `Display` for the type `TokenizedAsset<T>`, where `T` is encapsulated within the `Publisher` object.

  ```rust
  public fun new_display<T: drop>(
          registry: &Registry,
          publisher: &Publisher,
          ctx: &mut TxContext
      ): Display<TokenizedAsset<T>> {}
  ```

- `transfer_policy`

  This function, provided with the `protectedTP`, returns the transfer policy specifically designed for the type `TokenizedAsset<T>`

  ```rust
  public(friend) fun transfer_policy<T>(
          protected_tp: &ProtectedTP<T>
      ): &TransferPolicy<T> {}

  ```

- `publisher_mut`

  This function can only be accessed by the owner of the platform cap. It requires the registry as an argument to obtain a mutable reference to the publisher.

  ```rust
  public fun publisher_mut(
      _: &PlatformCap,
      registry: &mut Registry
  ): &mut Publisher {}
  ```

</TabItem>

<TabItem label="unlock" value="unlock">

The `unlock` module facilitates the unlocking of a tokenized asset specifically for authorized burning and joining.

It allows tokenized asset type creators to enable these operations for kiosk assets without necessitating adherence to the default set of requirements, such as rules or policies.

**Structs**

- `JoinPromise`

  A promise object is established to prevent attempts of permanently unlocking an object beyond the intended scope of joining.

  ```rust
  struct JoinPromise {
      /// the item where the balance of the burnt tokenized asset will be added.
      item: ID,
      /// burned is the id of the tokenized asset that will be burned
      burned: ID,
      /// the expected final balance of the item after merging
      expected_balance: u64
  }
  ```

- `BurnPromise`

  A promise object created to ensure the permanent burning of a specified object.

  ```rust
  struct BurnPromise {
    expected_supply: u64
  }
  ```

**Functions**

- `asset_from_kiosk_to_join`

  This helper function is intended to facilitate the joining of tokenized assets locked in kiosk. It aids in unlocking the tokenized asset that is set for burning and ensures that another tokenized asset of the same type will eventually contain its balance by returning a `JoinPromise.`

  ```rust
  public fun asset_from_kiosk_to_join<T>(
    self: &TokenizedAsset<T>, // A
    to_burn: &TokenizedAsset<T>, // B
    protected_tp: &ProtectedTP<TokenizedAsset<T>>, // unlocker
    transfer_request: TransferRequest<TokenizedAsset<T>> // transfer request for b
  ): JoinPromise {}
  ```

- `prove_join`

  A function utilized to demonstrate that the unlocked tokenized asset is successfully burned and its balance is incorporated into an existing tokenized asset.

  ```rust
  public fun prove_join<T>(
    self: &TokenizedAsset<T>,
    promise: JoinPromise,
    proof: ID) {
  }
  ```

- `asset_from_kiosk_to_burn`

  Helper function that facilitates the burning of tokenized assets locked in a kiosk. It assists in their unlocking while ensuring a promise that the circulating supply will be reduced, achieved by returning a `BurnPromise`.

  ```rust
  public fun asset_from_kiosk_to_burn<T>(
      to_burn: &TokenizedAsset<T>,
      asset_cap: &AssetCap<T>,
      protected_tp: &ProtectedTP<TokenizedAsset<T>>,
      transfer_request: TransferRequest<TokenizedAsset<T>>,
    ): BurnPromise {
  }
  ```

- `prove_burn`

  Ensures that the circulating supply of the asset cap is reduced by the balance of the burned tokenized asset.

  ```rust
  public fun prove_burn<T>(
    asset_cap: &AssetCap<T>,
    promise: BurnPromise) {
  }
  ```

</TabItem>

</Tabs>

### template package

An example use case package that enables utilization of Rust WASM functionality to support seamless asset creation on the browser.

This is similar to the launchpad approach and serves as the template package whenever a new asset requires representation as a tokenized asset.

Effectively allowing users to edit fields of this template contract on the fly and publish it with the edits included.
This package implements two essential modules, each catering to distinct functionalities required for asset tokenization.
More details regarding how Rust WASM was implemented can be found in the [Web Assembly](#webassembly-wasm-and-template-package) section.

- **Modules**

  - `template`

    This is the module that supports defining a new asset.

    When you need to represent a new asset as a fractional asset, modify this module to `<template>::<TEMPLATE>`, with the `<template>` (in capitals) being the OTW of this new asset.

    This module calls the `asset_tokenization::tokenized_asset::new_asset(...)` method, which facilitates the declaration of new fields for the asset:

    - `witness`: The OTW `NEW_ASSET`
    - `total_supply`: The total supply allowed to exist at any time
    - `symbol`: The symbol for the asset
    - `name`: The name of the asset
    - `description`: The description of the asset
    - `icon_url`: The URL for the asset logo (optional)
    - `burnable`: Boolean that defines if the asset can be burned by an admin

  - `genesis`

    A genesis type of module that includes a OTW so that the sender can claim the publisher.

### Publish and mint tokenized sequence diagram

```mermaid
sequenceDiagram
    participant Platform Admin
    participant Asset Creator
    participant Kiosk
    participant tokenized_asset
    participant proxy
    participant template
    participant genesis
    participant genesis
    participant Blockchain
    Platform Admin->>Blockchain: Publish asset_tokenization package (tokenized_asset, proxy, unlock modules)
    Blockchain-->>tokenized_asset: tokenized_asset module is published
    Blockchain-->>proxy: proxy module is published
    tokenized_asset->>Platform Admin: Send Platform Cap (owned object)
    proxy->>Blockchain: Share Registry (shared object)
    Asset Creator->>template: Pass Asset Info, AssetOTW as input
    Asset Creator->>genesis: Pass PublisherOTW as input
    Asset Creator->>Blockchain: Publish template package (template, genesis modules)
    Blockchain-->>genesis: genesis module is published
    Blockchain-->>template: template module is published
    genesis->>Asset Creator: Send Publisher (owned object)
    template->>tokenized_asset: Create new asset using Asset Info as input
    tokenized_asset-->>Asset Creator: Send Asset Cap (owned object)
    tokenized_asset-->>Blockchain: Share Asset Metadata (shared object)
    Asset Creator->>proxy: Use Publisher as input to setup_tp
    Blockchain->>proxy: Use Registry as input to setup_tp
    proxy-->>Blockchain: Share created Transfer Policy, ProtectedTP (shared objects)
    proxy-->>Asset Creator: Send created Transfer Policy Cap (owned object)
    Asset Creator->>tokenized_asset: Define type of tokenized asset (FT, NFT) to mint
    tokenized_asset-->>Asset Creator: Return minted Tokenized Asset
    Asset Creator->>Kiosk: Place Tokenized Asset
```

### Join sequence diagram

The following sequence diagram presenting how the join flow would take place. The following flow assumes that:

- Tokenized assets X and Y have already been minted by the creator of their type.
- Tokenized assets X and Y are already placed and locked inside the user's kiosk.
- Everything is executed in the same programmable transaction block (PTB).

```mermaid
sequenceDiagram
    participant User
    participant User's Kiosk
    participant kiosk module
    participant unlock module
    participant tokenized asset module
    participant blockchain

User's Kiosk->>kiosk module: Borrow Tokenized Asset X
kiosk module-->>User: Returns Promise, Tokenized Asset X
User's Kiosk->>kiosk module: List Tokenized Asset Y for zero price
User's Kiosk->>kiosk module: Purchase Tokenized Asset Y
kiosk module-->>User: Returns Transfer Request, Tokenized Asset Y
User->>unlock module: Use Transfer Request, Tokenized Asset X, Y as input to asset_from_kiosk_to_join
blockchain->>unlock module: Use Protected TP as input to asset_from_kiosk_to_join
unlock module-->>User: Returns Join Promise, Tokenized Asset X,Y Objects
User->>tokenized asset module: Use Tokenized Asset X,Y as input to join
tokenized asset module-->>User: Return Burn Proof, Tokenized Asset X
User->>unlock module: Use Burn Proof, Join Promise, Tokenized Asset X as input to prove_join
unlock module-->>User: Return Tokenized Asset X
User->>User's Kiosk: Resolve Promise by returning Tokenized Asset X in user's Kiosk
```

### Burn sequence diagram

The following sequence diagram shows the burn flow and assumes that:

- Tokenized asset has already been minted by the creator of its type.
- Tokenized asset is already placed and locked inside the user's Kiosk.
- Everything is executed in the same PTB.

```mermaid
sequenceDiagram
    participant User
    participant User's Kiosk
    participant kiosk module
    participant unlock module
    participant tokenized asset module
    participant blockchain

User's Kiosk->>kiosk module: List Tokenized Asset for zero price
User's Kiosk->>kiosk module: Purchase Tokenized Asset
kiosk module-->>User: Returns Transfer Request, Tokenized Asset Object
User->>unlock module: Use Transfer Request, Tokenized Asset Object, Asset Cap as input to asset_from_kiosk_to_burn
blockchain->>unlock module: Use Protected TP as Input to asset_from_kiosk_to_burn
unlock module-->>User: Returns Burn Promise, Tokenized Asset Object, Asset Cap
User->>tokenized asset module: Use Tokenized Asset Object, Asset Cap as input to burn
tokenized asset module-->>User: Returns Asset Cap
User->>unlock module: Use Burn Proof, Asset Cap as input to prove_burn
unlock module-->>User: Returns Asset Cap
```

## Variations

The packages and modules provided demonstrate how you could implement asset tokenization for your project. Your particular use case probably necessitates altering the contract for convenience or to introduce new features.

### Example convenience alteration

Instead of implementing the unlock functionality in multiple steps inside of a PTB, it would also be possible to create a method that performs the purchase, borrowing, unlocking and joining of an asset all on one function. This is how that would look like for the joining operation:

```rust
public fun kiosk_join<T>(
	kiosk: &mut Kiosk,
  kiosk_cap: &KioskOwnerCap,
	protected_tp: &ProtectedTP<TokenizedAsset<T>>,
  ta1_id: ID,
  ta2_id: ID,
  ctx: &mut TxContext
) {

	kiosk::list<TokenizedAsset<T>>(kiosk, kiosk_cap, ta2_id, 0);
	let (ta1, promise_ta1) = kiosk::borrow_val(kiosk, kiosk_cap, ta1_id);
	let coin = coin::zero<SUI>(ctx);
	let (ta2, request) = kiosk::purchase(kiosk, ta2_id, coin);

	let tp_ref = proxy::transfer_policy(protected_tp);
	let (_item, _paid, _from) = transfer_policy::confirm_request(
	    tp_ref,
	    request
	);

	tokenized_asset::join(&mut ta1, ta2);

	kiosk::return_val(kiosk, ta1, promise_ta1);
}
```

### Example alteration for use case

:::caution

The following example splits (effectively replacing) the `AssetCap<T>` into two new objects: the `Treasury<T>` and the `AdminCap<T>`. The access to methods defined in the original package, should now be carefully re-designed as this change can introduce unwanted effects. This required re-design is not entirely contained in this example and only some methods are changed for demonstration purposes (or as a thorough exercise).

:::

Assume you want to allow the users to also burn assets, not only admins. This still needs to be an authorized operation but it would allow the flexibility of consuming tokenized assets for a use case specific purpose (for example, burning all of the collectibles you've gathered to combine them). To achieve this, the admin can mint tickets that contain the ID of the asset they are allowed to burn. To support this functionality you must redesign the smart contract and separate the admin from the asset's treasury of each asset, which now holds only supply related information. Sample changes that need to happen follow:

**Structs**

Create a ticket that has only the `key` ability so that the receiver cannot trade it.

```rust
struct BurnTicket<phantom T> has key {
	id: UID,
	tokenized_asset_id: ID // the tokenized asset that this ticket gives access to burn
}
```

The struct that now only holds treasury related information (results from splitting the `AssetCap`, meaning it's no longer part of this design) is created as a shared object. Change functions like `mint` to also take as input both the `Treasury` object and the `AdminCap` object.

```rust
struct Treasury<phantom T> has key, store {
	id: UID,
	supply: Supply<T>,
  total_supply: u64,
}
```

The other half of the `AssetCap` functionality which retains the admin capability and the configuration of burnability is an owned object sent to the creator of type `<T>`.

```rust
struct AdminCap<phantom T> has key, store {
	id: UID,
	burnable: bool
}
```

**Method Signatures**

The `AdminCap` here acts both as an admin capability and a type insurance. Encoding the information of both the asset type that is allowed to be deleted with this ticket.
This function should assert that the asset T is burnable and return a `BurnTicket<T>`.

```rust
public fun mint_burn_ticket<T>(
	cap: &AdminCap<T>,
	tokenized_asset_id: ID,
	ctx: &mut TxContext
): BurnTicket
```

Burning on the user side requires for them to access the shared `Treasury` object. This function burns the tokenized asset and decreases the supply.

```rust
public fun burn_with_ticket<T>(
	treasury: &mut Treasury<T>,
	self: TokenizedAsset<T>,
	ticket: BurnTicket<T>)
```

# Deployment

{@include: ../../../snippets/initialize-sui-client-cli.mdx}

## Publishing

At this stage, you can choose to manually deploy the contracts or utilize the publish bash script that automatically deploys the contracts and sets up most of the `.env` Asset Tokenization related fields for you.
The `.env.template` file denotes variables that the script automatically fills in.
You can see a reference here:

```
SUI_NETWORK = rpc endpoint of the network of your choice | auto filled by publish script
ASSET_TOKENIZATION_PACKAGE_ID = Created by publishing `asset_tokenization` package | auto filled by publish script
REGISTRY = Created by publishing `asset_tokenization` package | auto filled by publish script

TEMPLATE_PACKAGE_ID = Created by publishing `template` package
ASSET_CAP_ID = Created by publishing `template` package
ASSET_METADATA_ID = Created by publishing `template` package
ASSET_PUBLISHER = Created by publishing `template` package

PROTECTED_TP = Created by calling `setup_tp` function
TRANSFER_POLICY = Created by calling `setup_tp` function

OWNER_MNEMONIC_PHRASE = your mnemonic | can be exported locally in the terminal before publishing
BUYER_MNEMONIC_PHRASE = buyer's mnemonic | can be exported locally in the terminal before publishing
TARGET_KIOSK = kiosk id
BUYER_KIOSK = kiosk id


TOKENIZED_ASSET = tokenized asset id (created by minting)
FT1 = tokenized asset id (to be joined)
FT2 = tokenized asset id (to be joined)
```

For more details on publishing, please check the setup folder's [README](https://github.com/MystenLabs/asset-tokenization/tree/main/setup).

### Publishing packages

Select a package for specific instructions.

{@include: ../../../snippets/info-gas-budget.mdx}

<Tabs>

<TabItem label="asset_tokenization" value="asset_tokenization">

### Manually

In a terminal or console at the `move/asset_tokenization` directory of the project enter:

```sh
$ sui client publish --gas-budget <GAS-BUDGET>
```

For the gas budget, use a standard value such as `20000000`.

The package should successfully deploy, and you then see:

```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING asset_tokenization
Successfully verified dependencies on-chain against source.
```

You can also view a multitude of information and transactional effects.

You should choose and store the `package ID` and the `registry ID` from the created objects in the respective fields within your .env file.

Afterward, it's necessary to modify the `Move.toml` file. Under the `[addresses]` section, replace `0x0` with the same `package ID`. Optionally, under the `[package]` section, add `published-at = <package ID>` (this step is not needed if you see a `Move.lock` file after running `sui client publish`).

### Automatically

The fields that are automatically filled are: `SUI_NETWORK`, `ASSET_TOKENIZATION_PACKAGE_ID` and `REGISTRY`.

To publish with the bash script run:

```sh
$ npm run publish-asset-tokenization
```

After publishing, you can now edit the `Move.toml` file like described in the Manual flow.

For more details regarding this process, please consult the setup folder's [README](https://github.com/MystenLabs/asset-tokenization/tree/main/setup).

</TabItem>

<TabItem label="template" value="template">

### Manually

In a terminal or console at the `move/template` directory of the project enter:

```sh
$ sui client publish --gas-budget <GAS-BUDGET>
```

For the gas budget, use a standard value such as `20000000`.

The package should successfully deploy, and you then see:

```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY asset_tokenization
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING template
Successfully verified dependencies on-chain against source.
```

You can also view a multitude of information and transactional effects.

You should choose and store the `package ID`, asset `metadata ID`, `asset cap ID` and the `Publisher ID` from the created objects in the respective fields within your .env file.

### Automatically

The process of automatic deployment for the template package refers to publishing a new asset via the WASM library. Quick start steps:

- Ensure that the `asset_tokenization` package address is set in the `[addresses]` section of `asset_tokenization/Move.toml`. This address should be the same as the original package deployment.
- If a `Move.lock` file exists after running`sui client publish`, go on to the next step. If not, ensure that the `asset_tokenization/Move.toml` file has its `published-at` field uncommented and populated with the address of the latest package deployment.
- Make any changes to the template fields by changing the input parameters of the `publishNewAsset` function.
- Run `npm run publish-template`.
- You should choose and store the _Template Package ID_, _asset metadata ID_, _asset cap ID_ and the _publisher ID_ from the created objects in the respective fields within your **.env** file.

For more details regarding this process, please consult the setup folder's [README](https://github.com/MystenLabs/asset-tokenization/tree/main/setup).

</TabItem>

</Tabs>

## WebAssembly (WASM) and template package {#webassembly-wasm-and-template-package}

:::tip

You can find a public facing reference to the WASM library in the [move-binary-format-wasm](https://github.com/MystenLabs/sui/tree/main/sdk/move-binary-format-wasm) Sui repo subfolder.

:::

This feature was developed with the intent to enable Move bytecode serialization and deserialization on the web. In essence, this feature allows you to edit existing contracts in a web environment.

In the case of asset tokenization, these edits allow you to create and publish new types that represent physical or digital assets that we want to tokenize.

### Bytecode manipulation {#bytecode-manipulation}

:::caution

On modifications that are made to the template package this process needs to be repeated. Note that some alterations, like changing a constant name, do not affect the produced bytecode.

:::

Before proceeding to how to make these edits, it's important to understand how the library exposes the template module bytecode. The process is currently manual. This requires that you build and retrieve the compiled bytecode. To do this, navigate inside the template folder and run the following command:

```sh
$ xxd -c 0 -p build/template/bytecode_modules/template.mv | head -n 1
```

<details>
  <summary>
  Console response
  </summary>

The response you should receive looks similar to the following:

```sh
a11ceb0b060000000a010010021026033637046d0a05776807df01ec0108cb03800106cb043
e0a8905050c8e0549001303140107010d01120215021602170004020001000c01000101010c
010001020307000302070100000403070006050200070607000009000100010a0a0b0102021
2050700030c010401000311060401000418050800050e0601010c050f1001010c06100d0e00
070b050300030304030109060c070f02080007080600040b040108070b010108000b0201080
00b04010807010807010b04010900010a020109000108030108050108000809000308030805
08050b0401080701070806020b010109000b02010900010b02010800010608060105010b010
10800020900050841737365744361700d41737365744d65746164617461064f7074696f6e06
537472696e670854454d504c415445095478436f6e746578740355726c0561736369690b647
56d6d795f6669656c6404696e6974096e65775f6173736574156e65775f756e736166655f66
726f6d5f6279746573046e6f6e65066f7074696f6e137075626c69635f73686172655f6f626
a6563740f7075626c69635f7472616e736665720673656e64657204736f6d6506737472696e
670874656d706c6174650f746f6b656e697a65645f6173736574087472616e736665720a747
85f636f6e746578740375726c04757466380000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000100000000000000000000000000000000000000000000000000000000000000
02d9ebdef1e3cb5eb135362572b18faeb61259afe651a463f1384745ebd7fd51da030864000
000000000000a02070653796d626f6c0a0205044e616d650a020c0b4465736372697074696f
6e0a02090869636f6e5f75726c0101010a02010000020108010000000002230704070621040
738000c02050b0704110938010c020b020c050b0007000701110207021105070311050b0507
050a0138020c040c030b0438030b030b012e110838040200
```

</details>

Copy the output you receive and paste it in the return instruction of the `getBytecode` method, which is located inside the [bytecode-template.ts](https://github.com/MystenLabs/asset-tokenization/blob/main/setup/src/utils/bytecode-template.ts) file.

Additionally, because the template package contains two modules, and therefore has another dependency, you also need to retrieve the bytecode of the genesis module in a similar fashion. This module bytecode, however, is not edited and isn't used as is. This operation is not directly relevant to the WASM library, but is necessary to successfully deploy the edited template module. To acquire the bytecode for genesis, navigate to the `template` folder and run:

```sh
$ xxd -c 0 -p build/template/bytecode_modules/genesis.mv | head -n 1
```

The output format is similar to the template module but smaller in length. Similarly to what you did with the template module, you need to copy this output but this time paste it in the bytecode constant variable located in the [genesis_bytecode.ts](https://github.com/MystenLabs/asset-tokenization/blob/main/setup/src/utils/genesis_bytecode.ts) file.

With the above setup, the library can now manipulate the bytecode by deserializing it, editing it, and serializing it again so that you can publish it.

### Closer view of the template module

Taking a look at the template module, you should see that a few constants have been defined:

```rust
...
const TOTAL_SUPPLY: u64 = 100;
const SYMBOL: vector<u8> = b"Symbol";
const NAME: vector<u8> = b"Name";
const DESCRIPTION: vector<u8> = b"Description";
const ICON_URL: vector<u8> = b"icon_url";
const BURNABLE: bool = true;
...
```

These constants act as a reference point that the WASM library is able to modify. If you take a look at the TypeScript code that performs the edit and deploys, you can see in action how these fields are identified and updated:

```tsx
...
const template = getBytecode();

const compiledModule = new CompiledModule(
  JSON.parse(wasm.deserialize(template))
)
  .updateConstant(0, totalSupply, "100", "u64")
  .updateConstant(1, symbol, "Symbol", "string")
  .updateConstant(2, asset_name, "Name", "string")
  .updateConstant(3, description, "Description", "string")
  .updateConstant(4, iconUrl, "icon_url", "string")
  .updateConstant(5, burnable, "true", "bool")
  .changeIdentifiers({
    template: moduleName,
    TEMPLATE: moduleName.toUpperCase(),
  });

const bytesToPublish = wasm.serialize(JSON.stringify(compiledModule));
...
```

Examine the `updateConstant` method, which is used to update constants. This method takes four arguments:

- An `idx` (index) that the declared constant would have in the constant pool. The order is sequential, starting from 0 for the first constant defined in the Move file and stepping plus one for each consecutive constant.
- A `value` that contains an updated value of the constant you want to change.
- An `expectedValue` that contains the current value of the constant.
- An `expectedType` that contains the current type of the constant.

The last two arguments are required to minimize the risk of accidentally updating the wrong constant since this library is directly manipulating complied bytecode, which is quite dangerous.

Additionally, the `changeIdentifiers` method updates identifiers, which in our case are the module name and the struct name. This method takes a JSON object as an argument with keys of the current identifier names in the module and values being the desired names you want to change them into.

Lastly, to deploy the changed template module, build and publish:

```tsx
...
const tx = new Transaction();
  tx.setGasBudget(100000000);
  const [upgradeCap] = tx.publish({
    modules: [[...fromHex(bytesToPublish)], [...fromHex(genesis_bytecode)]],
    dependencies: [
      normalizeSuiObjectId("0x1"),
      normalizeSuiObjectId("0x2"),
      normalizeSuiObjectId(packageId),
    ],
  });

  tx.transferObjects(
    [upgradeCap],
    tx.pure(signer.getPublicKey().toSuiAddress(), "address")
  );
...
```

As mentioned in the [Bytecode manipulation](#bytecode-manipulation) section, the modules that you need to publish are the template and the genesis, hence the reason you have two elements in the `modules` array. It's also important to include any dependencies defined in the `Move.toml` file of the involved packages. The `packageId` used previously is the address the `asset_tokenization` package has been deployed to.

## TypeScript

Now, you can begin interacting with the deployed smart contract and your tokenized asset.

In a terminal or console within the project's setup directory, utilize the following commands:

- **Create Transfer Policy**

  First, create a `TransferPolicy` and a `ProtectedTP` with the following command:

  ```sh
  $ npm run call create-tp
  ```

  After executing the command, the console displays the effects of the transaction.

  By searching the transaction digest on a Sui network explorer, you can locate the created objects. Subsequently, select and save the `TransferPolicy ID` and the `ProtectedTP ID` from these objects into the respective fields within your .env file.

- **Add Rules**

  In the project's file `transferPolicyRules.ts` located in the directory `setup/src/functions`, you can modify the code to include the desired rules for your transfer policy.

  Code snippet to be modified:

  ```rust
  // A demonstration of using all the available rule add/remove functions.
      // You can chain these commands.
      tpTx
          .addFloorPriceRule('1000')
          .addLockRule()
          .addRoyaltyRule(percentageToBasisPoints(10), 0)
          // .addPersonalKioskRule()
          // .removeFloorPriceRule()
          // .removeLockRule()
          // .removeRoyaltyRule()
          // .removePersonalKioskRule()
  ```

  By running the command `npm run call tp-rules`, the rules will be added to your transfer policy.

  Now, investors can trade the fractions of your asset according to the rules you've set.

- **Select Kiosk**

  You must place the tokenized assets within a kiosk if marketable assets are desired. Subsequently, you can list and sell them to other users. It's imperative to lock the objects in the kiosk to prevent any future unauthorized usage outside the defined policy that you set.

  Best practices recommend a single, comprehensive kiosk for all operations. However, this might not always be the case. Therefore, this project requires the use of only one personal kiosk to ensure consistency and better management, even if you own multiple kiosks.

  To enforce this rule, execute the command `npm run call select-kiosk`. This provides you with the specific kiosk ID to use for this project.

  Then, store the provided Kiosk ID in the appropriate field within your .env file.

- **Mint**

  In the project's file `mint.ts`, found in the directory `setup/src/functions`, you can edit the code to mint the desired type (NFT/FT) and balance for your asset.

  As previously mentioned, if additional metadata is provided, the tokenized asset is treated as an NFT with a value of one. However, if there is no extra metadata, the tokenized asset is regarded as an FT, and you have the flexibility to select its balance, which can exceed one.

  Here is an example from the code that needs modification:

  ```rust
  // example without metadata -> FT
  function getVecMapValues() {

    const keys : string[] = [];
    const values : string[] = [];

    return { keys, values };
  }
  ```

  or

  ```rust
  // example with metadata -> NFT
  function getVecMapValues() {
  	const keys = [
  	  "Piece",
  	  "Is it Amazing?",
  	  "In a scale from 1 to 10, how good?",
    ];
    const values = ["8/100", "Yes", "11"];

    return { keys, values };
  }
  ```

  Upon executing the command `npm run call mint`, a new tokenized asset is minted. You can save the object's `ID` in the .env file for future reference.

- **Lock**

  Locking the objects within the kiosk is crucial to prevent any unauthorized usage beyond the established policy.

  Upon executing the command `npm run call lock`, your newly minted tokenized asset is secured within your kiosk.

  Before running the command, make sure that the field `TOKENIZED_ASSET` within your `.env` file is populated with the object you intend to lock.

- **Mint and Lock**

  Executing the command `npm run call mint-lock` performs both the mint and lock functions sequentially, ensuring the minted asset is created and immediately locked within the kiosk.

- **List**

  Now that your tokenized asset is placed and locked within your kiosk, you can proceed to list it for sale.

  In the project's file `listItem.ts`, found in the directory `setup/src/functions`, you can adjust the code to specify the desired asset for listing.

  Code snippet to be modified:

  ```rust
  const SALE_PRICE = '100000';
    kioskTx
      .list({
          itemId,
          itemType,
          price: SALE_PRICE,
      })
      .finalize();
  ```

  By running the command `npm run call list`, your tokenized asset is listed and made available for sale.

- **Purchase**

  When a user intends to purchase an item, it needs to be listed for sale. After the user selects the item to buy, they are required to modify the following snippet of code found in the file `purchaseItem.ts`, located in the `setup/src/functions` directory.

  ```rust
  const item = {
      itemType: tokenizedAssetType,
      itemId: tokenized_asset ?? tokenizedAssetID,
      price: "100000",
      sellerKiosk: targetKioskId,
  };
  ```

  Apart from specifying the item and its type, the buyer must set the specific price and the seller's kiosk ID to execute the purchase transaction successfully, accomplished by running `npm run call purchase`.

- **Join**

  When you execute the command `npm run call join`, two specified tokenized assets of the FT type are merged together. Before running the command, make sure that the fields `FT1` and `FT2` within your `.env` file are populated with the objects you intend to merge.

- **Burn**

  When you intend to burn a tokenized asset, execute the command `npm run call burn`. Following this action, the specified asset is destroyed. Before running the command, make sure that the field `TOKENIZED_ASSET` within your `.env` file is populated with the object you intend to burn.

- **Get Balance**

  By executing the command `npm run call get-balance`, you can retrieve the balance value associated with the specified tokenized asset.

- **Get Supply**

  By executing the command `npm run call get-supply`, you can retrieve the value representing the current circulating supply of the asset.

- **Get Total Supply**

  By executing the command `npm run call get-total-supply`, you can retrieve the value representing the current circulating supply of the asset.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/nft/nft-rental.mdx
```
---
title: NFT Rental Example
description: An example using the Kiosk Apps standard that provides the ability for users to rent NFTs according to the rules of a provided policy instead of outright owning them. This approach closely aligns with the ERC-4907 renting standard, making it a suitable choice for Solidity-based use cases intended for implementation on Sui.
keywords: [ERC-721, NFT]
---

NFT renting is a mechanism that allows individuals without ownership or possession of a specific NFT to temporarily utilize or experience it. The implementation of this process leverages the [Kiosk Apps standard](../../../standards/kiosk-apps.mdx) to establish an infrastructure for rental transactions. This approach closely aligns with the [Ethereum ERC-4907](https://eips.ethereum.org/EIPS/eip-4907) renting standard, making it a suitable choice for Solidity-based use cases intended for implementation on Sui.

The NFT Rental example satisfies the following project requirements:

- Enable a lender to offer their assets for renting for a specified period of time (list for renting).
- Enable a lender to define the rental duration.
    - Borrower has to comply with the renting period.
- Borrower can gain mutable or immutable access to the NFT.
    - Immutable access is read-only.
    - Mutable, the lender should consider downgrade and upgrade operations and include them in the renting fee.
- After the renting period has finished, the item can be sold normally.
- Creator-defined royalties are respected by encompassing [transfer policy rules](../../../concepts/transfers/custom-rules.mdx).

## Use cases

Some use cases for real-world NFT rental example include:

- [Gaming](#gaming)
- [Ticketing](#ticketing) 
- [Virtual land](#virtual-land)
- [Temporary assets and subscriptions](#temp-assets-subs)

### Gaming

There are multiple cases in gaming where renting NFTs can be beneficial to user experience:

- **In-game assets:** NFTs can represent unique in-game items, characters, skins, or accessories. Players can rent these assets securely.
- **Ownership and authenticity:** NFTs provide a transparent and immutable record of ownership, ensuring that players who truly own their in-game items can rent them and receive back the item under rent after the renting period expires. This can combat issues like fraud and counterfeiting.
- **Cross-game integration:** Renting NFTs can work across multiple games, allowing players to carry and rent their unique items or characters from one game to another, fostering interoperability.
- **Gaming collectibles:** NFTs can represent digital collectibles within games, creating a digital asset ecosystem where players can rent unique items.

### Ticketing

In the realm of ticketing, NFTs play a pivotal role in enhancing transferability. These digital assets facilitate a secure and traceable transfer, resale, or rental of tickets, mitigating the risk of counterfeit tickets within the secondary market. The blockchain-based nature of NFTs ensures transparency and authenticity in each transaction, providing users with a reliable and fraud-resistant means to engage in ticket-related activities. This innovation not only simplifies the process for ticket holders but also contributes to a more trustworthy and efficient secondary ticket market.

### Virtual land {#virtual-land}

Renting virtual lands and offices in the metaverse provides businesses with flexible solutions, enabling event companies to host gatherings without the commitment of permanent acquisitions and facilitating remote work through virtual offices. This approach not only offers cost-effective alternatives but also aligns with the evolving dynamics of digital business operations.

### Temporary assets and subscriptions {#temp-assets-subs}

Temporary assets and subscriptions are notable applications of rental NFTs, offering accessibility to virtual experiences like high-end virtual casinos or curated digital fashion. These NFTs cater to diverse budgets, broadening audience reach. Subscription rentals extend to pools of digital assets, allowing users to pay monthly for a set number of items, fostering accessibility, user retention, and acquisition. Holders can rent out unused subscriptions, ensuring no loss for them, potential customer gains for the protocol, and a commitment-free trial for temporary holders. This showcases the adaptability and user-centric appeal of rental NFTs in diverse scenarios.

## Smart contract design

:::warning

Transferring kiosks might result in unexpected behaviors while an asset is being rented. If you want to disallow kiosk transferring all together, consider using personal kiosks.

:::

The rental smart contract uses the [Kiosk Apps](../../../standards/kiosk-apps.mdx) standard. Both the lender and borrower must install a Kiosk extension to take part, and the creator of the borrowed asset type must create a rental policy and `ProtectedTP` object to allow the extension to manage rentals while enforcing royalties.

:::info

This implementation is charging a rental fee based on days. You can re-purpose and update the logic to support charging per hour, or even seconds.

:::

## Move modules

The NFT Rental example uses a single module, `nft_rental.move`. You can find the source for this file hosted in the [sui repository](https://github.com/MystenLabs/sui/tree/main/examples/move/nft-rental/sources/nft_rental.move) in the `examples` directory. The source code includes extensive comments to help you follow the example's logic and structure. 

### nft_rental

The `nft_rental` module provides an API that facilitates lending or borrowing through the following operations:

- List for renting
- Delist from renting
- Rent
- Borrow by reference and borrow by value
- Reclaim for the lender

### Structs

The object model of the `nft_rental` module provides the structure of the app, beginning with the `Rentables` object. The struct has only the `drop` ability and acts as the extension key for the kiosk `Rentables` extension.

```move
public struct Rentables has drop {}
```

The `Rented` struct represents a rented item. The only field the struct includes is the ID of the object. It is used as the dynamic field key in the borrower's `Bag` entry when someone is actively borrowing an item. The struct has `store`, `copy`, and `drop` abilities because they are necessary for all dynamic field keys.

```move
public struct Rented has store, copy, drop { id: ID }
```

The `Listed` struct represents a listed item. The only field the struct includes is the ID of the object. It is used as the dynamic field key in the renter's `Bag` entry after an item is listed for renting. Like `Rented`, this struct has `store`, `copy`, and `drop` abilities because they are necessary for all dynamic field keys.

```move
public struct Listed has store, copy, drop { id: ID }
```

The `Promise` struct is created for borrowing by value. The `Promise` operates as the hot potato (a struct that has no capabilities that you can only pack and unpack in its module) that can only be resolved by returning the item back to the extension's `Bag`.

The `Promise` field lacks the `store` ability as it shouldn't be wrapped inside other objects.
It also lacks the `drop` ability because only the `return_val` function can consume it.

```move
public struct Promise {
  item: Rented,
  duration: u64,
  start_date: u64,
  price_per_day: u64,
  renter_kiosk: address,
  borrower_kiosk: ID
}
```

The `Rentable` struct is as a wrapper object that holds an asset that is being rented. Contains information relevant to the rental period, cost, and renter.
This struct requires the `store` ability because it stores a value `T` that definitely also has `store`.

```move
public struct Rentable<T: key + store> has store {
  object: T,
  /// Total amount of time offered for renting in days.
  duration: u64,
  /// Initially undefined, is updated once someone rents it.
  start_date: Option<u64>,
  price_per_day: u64,
  /// The kiosk id that the object was taken from.
  kiosk_id: ID,
}
```

The `RentalPolicy` struct is a shared object that every creator mints. The struct defines the royalties the creator receives from each rent invocation.

```move
public struct RentalPolicy<phantom T> has key, store {
  id: UID,
  balance: Balance<SUI>,
  /// Note: Move does not support float numbers.
  ///
  /// If you need to represent a float, you need to determine the desired
  /// precision and use a larger integer representation.
  ///
  /// For example, percentages can be represented using basis points:
  /// 10000 basis points represent 100% and 100 basis points represent 1%.
  amount_bp: u64
}
```

The `ProtectedTP` object is a shared object that creators mint to enable renting. The object provides authorized access to an empty `TransferPolicy`.
This is in part required because of the restrictions that Kiosk imposes around royalty enforced items and their tradability. 
Additionally it allows the rental module to operate within the Extension framework while maintaining the guarantee that the assets 
handled will always be tradable.

A protected empty transfer policy is required to facilitate the rental process so that the extension can transfer the asset without any additional rules to resolve (like lock rule, loyalty rule, and so on). If creators want to enforce royalties on rentals, they can use the `RentalPolicy` detailed previously.

```move
public struct ProtectedTP<phantom T> has key, store {
  id: UID,
  transfer_policy: TransferPolicy<T>,
  policy_cap: TransferPolicyCap<T>
}
```

### Function signatures

The NFT Rental example includes the following functions that define the project's logic. 

The `install` function enables installation of the `Rentables` extension in a kiosk. The party facilitating the rental process is responsible for making sure that the user installs the extension in their kiosk.

```move
public fun install(
  kiosk: &mut Kiosk,
  cap: &KioskOwnerCap,
  ctx: &mut TxContext
){
  kiosk_extension::add(Rentables {}, kiosk, cap, PERMISSIONS, ctx);
}
```

The `remove` function enables the owner (and only the owner) of the kiosk to remove the extension. The extension storage must be empty for the transaction to succeed. The extension storage empties after the user is no longer borrowing or renting any items. The `kiosk_extension::remove` function performs the ownership check before executing. 

```move
public fun remove(kiosk: &mut Kiosk, cap: &KioskOwnerCap, _ctx: &mut TxContext){
  kiosk_extension::remove<Rentables>(kiosk, cap);
}
```

The `setup_renting` function mints and shares a `ProtectedTP` and a `RentalPolicy` object for type `T`. The publisher of type `T` is the only entity that can perform the action.

```move
public fun setup_renting<T>(publisher: &Publisher, amount_bp: u64, ctx: &mut TxContext) {
  // Creates an empty TP and shares a ProtectedTP<T> object.
  // This can be used to bypass the lock rule under specific conditions.
  // Storing inside the cap the ProtectedTP with no way to access it
  // as we do not want to modify this policy
  let (transfer_policy, policy_cap) = transfer_policy::new<T>(publisher, ctx);

  let protected_tp = ProtectedTP {
    id: object::new(ctx),
    transfer_policy,
    policy_cap,
  };

  let rental_policy = RentalPolicy<T> {
    id: object::new(ctx),
    balance: balance::zero<SUI>(),
    amount_bp,
  };

  transfer::share_object(protected_tp);
  transfer::share_object(rental_policy);
}
```

The `list` function enables listing of an asset within the `Rentables` extension's bag, creating a bag entry with the asset's ID as the key and a `Rentable` wrapper object as the value. Requires the existence of a `ProtectedTP` transfer policy that only the creator of type `T` can create. The function assumes an item is already placed (and optionally locked) in a kiosk.

```move
public fun list<T: key + store>(
  kiosk: &mut Kiosk,
  cap: &KioskOwnerCap,
  protected_tp: &ProtectedTP<T>,
  item_id: ID,
  duration: u64,
  price_per_day: u64,
  ctx: &mut TxContext,
) {
    
  // Aborts if Rentables extension is not installed.
  assert!(kiosk_extension::is_installed<Rentables>(kiosk), EExtensionNotInstalled);

  // Sets the kiosk owner to the transaction sender to keep metadata fields up to date.
  // This is also crucial to ensure the correct person receives the payment.
  // Prevents unexpected results in cases where the kiosk could have been transferred 
  // between users without the owner being updated.
  kiosk.set_owner(cap, ctx);

  // Lists the item for zero SUI.
  kiosk.list<T>(cap, item_id, 0);

  // Constructs a zero coin.
  let coin = coin::zero<SUI>(ctx);
  // Purchases the item with 0 SUI.
  let (object, request) = kiosk.purchase<T>(item_id, coin);

  // Resolves the TransferRequest with the empty TransferPolicy which is protected and accessible only via this module.
  let (_item, _paid, _from) = protected_tp.transfer_policy.confirm_request(request);

  // Wraps the item in the Rentable struct along with relevant metadata.
  let rentable = Rentable {
    object,
    duration,
    start_date: option::none<u64>(),
    price_per_day,
    kiosk_id: object::id(kiosk),
  };

  // Places the rentable as listed in the extension's bag (place_in_bag is a helper method defined in nft_rental.move file).
  place_in_bag<T, Listed>(kiosk, Listed { id: item_id }, rentable);
}
```

The `delist` function allows the renter to delist an item, as long as it's not currently being rented. The function also places (or locks, if a lock rule is present) the object back to owner's kiosk. You should mint an empty `TransferPolicy` even if you don't want to apply any royalties. If at some point you do want to enforce royalties, you can always update the existing `TransferPolicy`.

```move
public fun delist<T: key + store>(
  kiosk: &mut Kiosk,
  cap: &KioskOwnerCap,
  transfer_policy: &TransferPolicy<T>,
  item_id: ID,
  _ctx: &mut TxContext,
) {

  // Aborts if the cap doesn't match the Kiosk.
  assert!(kiosk.has_access(cap), ENotOwner);

  // Removes the rentable item from the extension's Bag (take_from_bag is a helper method defined in nft_rental.move file). 
  let rentable = take_from_bag<T, Listed>(kiosk, Listed { id: item_id });

  // Deconstructs the Rentable object.
  let Rentable {
    object,
    duration: _,
    start_date: _,
    price_per_day: _,
    kiosk_id: _,
  } = rentable;

  // Respects the lock rule, if present, by re-locking the asset in the owner's Kiosk.
  if (has_rule<T, LockRule>(transfer_policy)) {
    kiosk.lock(cap, transfer_policy, object);
  } else {
    kiosk.place(cap, object);
  };
}
```

The `rent` function enables renting a listed `Rentable`. It permits anyone to borrow an item on behalf of another user, provided they have the `Rentables` extension installed. The `rental_policy` defines the portion of the coin that is retained as fees and added to the rental policy's balance.

```move
public fun rent<T: key + store>(
  renter_kiosk: &mut Kiosk,
  borrower_kiosk: &mut Kiosk,
  rental_policy: &mut RentalPolicy<T>,
  item_id: ID,
  mut coin: Coin<SUI>,
  clock: &Clock,
  ctx: &mut TxContext,
) {

  // Aborts if Rentables extension is not installed.
  assert!(kiosk_extension::is_installed<Rentables>(borrower_kiosk), EExtensionNotInstalled);

  let mut rentable = take_from_bag<T, Listed>(renter_kiosk, Listed { id: item_id });

  // Calculates the price of the rental based on the days it was rented for by ensuring the outcome can be stored as a u64.
  let max_price_per_day = MAX_VALUE_U64 / rentable.duration;
  assert!(rentable.price_per_day <= max_price_per_day, ETotalPriceOverflow);
  let total_price = rentable.price_per_day * rentable.duration;

  // Accepts only exact balance for the payment and does not give change.
  let coin_value = coin.value();
  assert!(coin_value == total_price, ENotEnoughCoins);

  // Calculate fees_amount using the given basis points amount (percentage), ensuring the
  // result fits into a 64-bit unsigned integer.
  let mut fees_amount = coin_value as u128;
  fees_amount = fees_amount * (rental_policy.amount_bp as u128);
  fees_amount = fees_amount / (MAX_BASIS_POINTS as u128);

  // Calculate fees_amount using the given basis points amount (percentage), ensuring the result fits into a 64-bit unsigned integer.
  let fees = coin.split(fees_amount as u64, ctx);

  // Merges the fee balance of the given coin with the RentalPolicy balance.
  coin::put(&mut rental_policy.balance, fees);
  // Transfers the payment to the renter.
  transfer::public_transfer(coin, renter_kiosk.owner());
  rentable.start_date.fill(clock.timestamp_ms());

  place_in_bag<T, Rented>(borrower_kiosk, Rented { id: item_id }, rentable);
}
```

The `borrow` function enables the borrower to acquire the `Rentable` by reference from their bag.

```move
public fun borrow<T: key + store>(
  kiosk: &mut Kiosk,
  cap: &KioskOwnerCap,
  item_id: ID,
  _ctx: &mut TxContext,
): &T {
  // Aborts if the cap doesn't match the Kiosk.
  assert!(kiosk.has_access(cap), ENotOwner);
  let ext_storage_mut = kiosk_extension::storage_mut(Rentables {}, kiosk);
  let rentable: &Rentable<T> = &ext_storage_mut[Rented { id: item_id }];
  &rentable.object
}
```

The `borrow_val` function enables the borrower to temporarily acquire the `Rentable` with an agreement or promise to return it. The `Promise` stores all the information about the `Rentable`, facilitating the reconstruction of the `Rentable` upon object return.

```move
public fun borrow_val<T: key + store>(
  kiosk: &mut Kiosk,
  cap: &KioskOwnerCap,
  item_id: ID,
  _ctx: &mut TxContext,
): (T, Promise) {
  // Aborts if the cap doesn't match the Kiosk.
  assert!(kiosk.has_access(cap), ENotOwner);
  let borrower_kiosk = object::id(kiosk);

  let rentable = take_from_bag<T, Rented>(kiosk, Rented { id: item_id });

  // Construct a Promise struct containing the Rentable's metadata.
  let promise = Promise {
    item: Rented { id: item_id },
    duration: rentable.duration,
    start_date: *option::borrow(&rentable.start_date),
    price_per_day: rentable.price_per_day,
    renter_kiosk: rentable.kiosk_id,
    borrower_kiosk
  };

  // Deconstructs the rentable and returns the promise along with the wrapped item T.
  let Rentable {
    object,
    duration: _,
    start_date: _,
    price_per_day: _,
    kiosk_id: _,
  } = rentable;

  (object, promise)
}
```

The `return_val` function enables the borrower to return the borrowed item.

```move
public fun return_val<T: key + store>(
  kiosk: &mut Kiosk,
  object: T,
  promise: Promise,
  _ctx: &mut TxContext,
) {
  assert!(kiosk_extension::is_installed<Rentables>(kiosk), EExtensionNotInstalled);

  let Promise {
    item,
    duration,
    start_date,
    price_per_day,
    renter_kiosk,
    borrower_kiosk,
  } = promise;

  let kiosk_id = object::id(kiosk);
  assert!(kiosk_id == borrower_kiosk, EInvalidKiosk);

  let rentable = Rentable {
    object,
    duration,
    start_date: option::some(start_date),
    price_per_day,
    kiosk_id: renter_kiosk,
  };

  place_in_bag(kiosk, item, rentable);
}
```
:::note

The `reclaim` functionality is manually invoked and the rental service provider is responsible for ensuring that the renter is reminded to `reclaim`. As such, this can cause the borrower to hold the asset for longer than the rental period. This can be mitigated through modification of the current contract by adding an assertion in the `borrow` and `borrow_val` functions to check if the rental period has expired.

:::

The `reclaim` function enables an owner to claim back their asset after the rental period is over and place it inside their kiosk. If a lock rule is present, the example also locks the item inside the owner kiosk. 

```move
public fun reclaim<T: key + store>(
  renter_kiosk: &mut Kiosk,
  borrower_kiosk: &mut Kiosk,
  transfer_policy: &TransferPolicy<T>,
  clock: &Clock,
  item_id: ID,
  _ctx: &mut TxContext,
) {

  // Aborts if Rentables extension is not installed.
  assert!(kiosk_extension::is_installed<Rentables>(renter_kiosk), EExtensionNotInstalled);

  let rentable = take_from_bag<T, Rented>(borrower_kiosk, Rented { id: item_id });

  // Destructures the Rentable struct to place it back to the renter's Kiosk.
  let Rentable {
    object,
    duration,
    start_date,
    price_per_day: _,
    kiosk_id,
  } = rentable;

  // Aborts if provided kiosk is different that the initial kiosk the item was borrowed from.
  assert!(object::id(renter_kiosk) == kiosk_id, EInvalidKiosk);

  let start_date_ms = *option::borrow(&start_date);
  let current_timestamp = clock.timestamp_ms();
  let final_timestamp = start_date_ms + duration * SECONDS_IN_A_DAY;

  // Aborts if rental duration has not elapsed.
  assert!(current_timestamp > final_timestamp, ERentingPeriodNotOver);

  // Respects the lock rule, if present, by re-locking the asset in the owner's kiosk.
  if (transfer_policy.has_rule<T, LockRule>()) {
    kiosk_extension::lock<Rentables, T>(
      Rentables {},
      renter_kiosk,
      object,
      transfer_policy,
    );
  } else {
    kiosk_extension::place<Rentables, T>(
      Rentables {},
      renter_kiosk,
      object,
      transfer_policy,
    );
  };
}
```

## Sequence diagrams

:::note

This implementation assumes that each creator, as an enabling action, creates a `TransferPolicy` even if empty, so that the `Rentables` extension can operate. This is a requirement in addition to invoking the `setup_renting` method.

:::

### Initialize

The initialization process is part of the flow but only happens once for each entity:

- For a new type that a creator would like to allow to be rented
    - Involves invoking `setup_renting` and `TransferPolicy` creation with optional lock rule
- For a Borrower that has never borrowed before using this framework
    - If no kiosk exists for the user, one should be created
    - Involves installing the extension in their kiosk
- For a Renter that has never rented before using this framework
    - If no kiosk exists for the user, one should be created
    - Involves installing the extension in their kiosk

```mermaid
sequenceDiagram
    participant Creator
    participant Renter
    participant Borrower
    participant nft_rental module
    participant Renter's Extension
    participant Borrower's Extension
	participant transfer_policy module
    participant kiosk_lock_rule module
    participant blockchain
rect rgba(191, 223, 255, 0.2) 
		note right of Creator: Setup Renting
    Creator->>nft_rental module: Use Publisher and amountBP as inputs
    nft_rental module-->>blockchain: Shares ProtectedTP and RentalPolicy
    end
rect rgba(191, 223, 255, 0.2) 
		note right of Creator: Create TransferPolicy
    Creator ->> transfer_policy module: Use Publisher as input to create TransferPolicy
    transfer_policy module -->> blockchain: Shares TransferPolicy
    transfer_policy module-->> Creator: Returns TransferPolicyCap
    end
opt Add lock rule
    Creator ->> kiosk_lock_rule module: Use TransferPolicyCap as input in kiosk_lock_rule::add
    blockchain ->> kiosk_lock_rule module: Use TransferPolicy as input in kiosk_lock_rule::add
    kiosk_lock_rule module -->> blockchain: Shares TransferPolicy with lock rule
    kiosk_lock_rule module -->> Creator: Returns TransferPolicyCap
    end
rect rgba(191, 223, 255, 0.2)
		note right of Renter: Install Extension
    Renter->>nft_rental module: Use kiosk, kioskOwnerCap as input to install extension
    nft_rental module-->>Renter's Extension: Extension is installed to kiosk
    end
rect rgba(191, 223, 255, 0.2)
		note right of Borrower: Install Extension
    Borrower->>nft_rental module: Use kiosk, kioskOwnerCap as input to install extension
    nft_rental module-->>Borrower's Extension: Extension is installed to kiosk
    end
```

### List-Rent-Borrow-Reclaim

```mermaid
sequenceDiagram
    participant Creator's Rental Policy
    participant Renter
    participant Borrower
    participant nft_rental module
    participant Renter's Extension Bag
    participant Borrower's Extension Bag
    participant kiosk module
    participant Renter's Kiosk
    participant coin module
    participant blockchain
rect rgba(191, 223, 255, 0.2) 
    note right of Renter: List for rent
    Renter->>nft_rental module: Use kiosk, kioskOwnerCap, ProtectedTP, ObjectID and Renting info as inputs in list
    blockchain->>nft_rental module: Use protectedTP as input in list
    nft_rental module->>kiosk module: List object for zero price
    nft_rental module->>kiosk module: Purchase Object
    Renter's Kiosk->>kiosk module: Take object from kiosk
    kiosk module-->>nft_rental module: Returns Object
    nft_rental module-->>Renter's Extension Bag: Place Object in renter's bag
    end
rect rgba(191, 223, 255, 0.2)
		note right of Borrower: Rent
    Borrower->>nft_rental module: Use renter_kiosk, borrower_kiosk, RentalPolicy, objectID, coin and clock as inputs in rent
    blockchain->>nft_rental module: Use RentalPolicy as input in rent
    nft_rental module->>coin module: Calculate payment and fees
    coin module -->> Renter: Payment
    coin module -->> Creator's Rental Policy: Fees
    Renter's Extension Bag->>nft_rental module: Take object from renter's bag
    nft_rental module-->>Borrower's Extension Bag: Place rented Object in borrower's bag
    end
rect rgba(191, 223, 255, 0.2)
		note right of Borrower: Borrow
    Borrower->>nft_rental module: Use kiosk, kioskOwnerCap, ObjectID as input in borrow
    Borrower's Extension Bag->>nft_rental module: Take object from borrower's bag
    nft_rental module-->>Borrower: Object, Promise
        note right of Borrower: Perform operation & return Borrowed Item
    Borrower->>Borrower: Operation on Object
    Borrower->>nft_rental module: Resolve return promise by returning Object, Promise
    nft_rental module-->>Borrower's Extension Bag: Place rented Object in borrower's bag
    end
rect rgba(191, 223, 255, 0.2)
		note right of Renter: Reclaim
    Renter->>nft_rental module: Use renter_kiosk, borrower_kiosk, clock as inputs in reclaim
    blockchain ->>nft_rental module: Use TransferPolicy as input in reclaim
    Borrower's Extension Bag->>nft_rental module: Take Object from borrower's bag if renting period is over
    alt Empty Transfer Policy
        nft_rental module-->>Renter's Kiosk: Place Object
    else TransferPolicy with lock rule
        nft_rental module-->>Renter's Kiosk: Lock Object
    end 
    end
```

### List-Delist

```mermaid
sequenceDiagram
    participant Renter
    participant nft_rental module
    participant Renter's Extension Bag
    participant kiosk module
    participant Renter's Kiosk
    participant blockchain
rect rgba(191, 223, 255, 0.2) 
	note right of Renter: List for rent
    Renter->>nft_rental module: Use kiosk, kioskOwnerCap, ProtectedTP, ObjectID and Renting info as inputs in list
    blockchain->>nft_rental module: Use protectedTP as input in list
    nft_rental module->>kiosk module: List object for zero price
    nft_rental module->>kiosk module: Purchase Object
    Renter's Kiosk->>kiosk module: Take object from kiosk
    kiosk module-->>nft_rental module: Returns Object
    nft_rental module-->>Renter's Extension Bag: Place Object in renter's bag
    end
rect rgba(191, 223, 255, 0.2)
		note right of Renter: Delist
    Renter->>nft_rental module: Use renter_kiosk, borrower_kiosk, ObjectID as inputs in delist
    blockchain->>nft_rental module: Use transferPolicy as input in delist
    Renter's Extension Bag->>nft_rental module: Take Object from renter's bag
    alt Empty Transfer Policy
        nft_rental module-->>Renter's Kiosk: Place Object
    else TransferPolicy with lock rule
        nft_rental module-->>Renter's Kiosk: Lock Object
    end 
    end
```

## Deployment

{@include: ../../../snippets/initialize-sui-client-cli.mdx}

{@include: ../../../snippets/publish-to-devnet-with-coins.mdx}

## Related links

- [NFT Rental example](https://github.com/MystenLabs/sui/tree/main/examples/move/nft-rental): The source code that this document references.
- [Sui Kiosk](../../../standards/kiosk.mdx): Kiosk is a decentralized system for commerce applications on Sui.
- [Kiosk Apps](../../../standards/kiosk-apps.mdx): The Kiosk Apps standard extends the functionality of Sui Kiosk.  
- [Custom Transfer Rules](../../../concepts/transfers/custom-rules.mdx): Custom transfer rules are used in this example to define rental policies.
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101/sign-and-send-txn.mdx
```
---
title: Signing and Sending Transactions
---

Transactions in Sui represent calls to specific functionality (like calling a smart contract function) that execute on inputs to define the result of the transaction.

Inputs can either be an object reference (either to an owned object, an immutable object, or a shared object), or an encoded value (for example, a vector of bytes used as an argument to a Move call). After a transaction is constructed, usually through using [programmable transaction blocks](./building-ptb) (PTBs), the user signs the transaction and submits it to be executed on chain.

The signature is provided with the private key owned by the wallet, and its public key must be consistent with the transaction sender's Sui address.

Sui uses a `SuiKeyPair` to produce the signature, which commits to the Blake2b hash digest of the intent message (`intent || bcs bytes of tx_data`). The signature schemes currently supported are `Ed25519 Pure`, `ECDSA Secp256k1`, `ECDSA Secp256r1`, `Multisig`, and `zkLogin`.

You can instantiate `Ed25519 Pure`, `ECDSA Secp256k1`, and `ECDSA Secp256r1` using `SuiKeyPair` and use it to sign transactions. Note that this guide does not apply to `Multisig` and `zkLogin`, please refer to their own pages ([Multisig](/concepts/cryptography/transaction-auth/multisig) and [zkLogin](https://docs.sui.io/concepts/cryptography/zklogin) respectively) for instructions.

With a signature and the transaction bytes, a transaction can be submitted to be executed.

## Workflow

The following high-level process describes the overall workflow for constructing, signing and executing an on-chain transaction:

- Construct the transaction data by creating a `Transaction` where multiple transactions are chained. See [Building Programmable Transaction Blocks](./building-ptb.mdx) for more information.
- The SDK's built-in gas estimation and coin selection picks the gas coin.
- Sign the transaction to generate a [signature](/concepts/cryptography/transaction-auth/signatures#user-signature).
- Submit the `Transaction` and its signature for on-chain execution.

:::info

If you want to use a specific gas coin, first find the gas coin object ID to be used to pay for gas, and explicitly use that in the PTB. If there is no gas coin object, use the [splitCoin](./building-ptb#available-transactions) transaction to create a gas coin object. The split coin transaction should be the first transaction call in the PTB.

:::

## Examples

The following examples demonstrate how to sign and execute transactions using Rust, TypeScript, or the Sui CLI.

<Tabs groupId="code-language">

<TabItem value="ts-sdk" label="TypeScript">

There are various ways to instantiate a key pair and to derive its public key and Sui address using the Sui TypeScript SDK.

```tsx
import { fromHex } from '@mysten/bcs';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { type Keypair } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Secp256k1Keypair } from '@mysten/sui/keypairs/secp256k1';
import { Secp256r1Keypair } from '@mysten/sui/keypairs/secp256r1';
import { Transaction } from '@mysten/sui/transactions';

const kp_rand_0 = new Ed25519Keypair();
const kp_rand_1 = new Secp256k1Keypair();
const kp_rand_2 = new Secp256r1Keypair();

const kp_import_0 = Ed25519Keypair.fromSecretKey(
	fromHex('0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82'),
);
const kp_import_1 = Secp256k1Keypair.fromSecretKey(
	fromHex('0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82'),
);
const kp_import_2 = Secp256r1Keypair.fromSecretKey(
	fromHex('0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82'),
);

// $MNEMONICS refers to 12/15/18/21/24 words from the wordlist, e.g. "retire skin goose will hurry this field stadium drastic label husband venture cruel toe wire". Refer to [Keys and Addresses](/concepts/cryptography/transaction-auth/keys-addresses.mdx) for more.
const kp_derive_0 = Ed25519Keypair.deriveKeypair('$MNEMONICS');
const kp_derive_1 = Secp256k1Keypair.deriveKeypair('$MNEMONICS');
const kp_derive_2 = Secp256r1Keypair.deriveKeypair('$MNEMONICS');

const kp_derive_with_path_0 = Ed25519Keypair.deriveKeypair('$MNEMONICS', "m/44'/784'/1'/0'/0'");
const kp_derive_with_path_1 = Secp256k1Keypair.deriveKeypair('$MNEMONICS', "m/54'/784'/1'/0/0");
const kp_derive_with_path_2 = Secp256r1Keypair.deriveKeypair('$MNEMONICS', "m/74'/784'/1'/0/0");

// replace `kp_rand_0` with the variable names above.
const pk = kp_rand_0.getPublicKey();
const sender = pk.toSuiAddress();

// create an example transaction block.
const txb = new Transaction();
txb.setSender(sender);
txb.setGasPrice(5);
txb.setGasBudget(100);
const bytes = await txb.build();
const serializedSignature = (await keypair.signTransaction(bytes)).signature;

// verify the signature locally
expect(await keypair.getPublicKey().verifyTransaction(bytes, serializedSignature)).toEqual(true);

// define sui client for the desired network.
const client = new SuiClient({ url: getFullnodeUrl('testnet') });

// execute transaction.
let res = client.executeTransactionBlock({
	transactionBlock: bytes,
	signature: serializedSignature,
});
console.log(res);
```

</TabItem>

<TabItem value="rust" label="Rust">

The full code example below can be found under [crates/sui-sdk](https://github.com/MystenLabs/sui/blob/main/crates/sui-sdk/examples/sign_tx_guide.rs).

There are various ways to instantiate a `SuiKeyPair` and to derive its public key and Sui address using the Sui Rust SDK.

```rust
    // deterministically generate a keypair, testing only, do not use for mainnet, use the next section to randomly generate a keypair instead.
    let skp_determ_0 =
        SuiKeyPair::Ed25519(Ed25519KeyPair::generate(&mut StdRng::from_seed([0; 32])));
    let _skp_determ_1 =
        SuiKeyPair::Secp256k1(Secp256k1KeyPair::generate(&mut StdRng::from_seed([0; 32])));
    let _skp_determ_2 =
        SuiKeyPair::Secp256r1(Secp256r1KeyPair::generate(&mut StdRng::from_seed([0; 32])));

    // randomly generate a keypair.
    let _skp_rand_0 = SuiKeyPair::Ed25519(get_key_pair_from_rng(&mut rand::rngs::OsRng).1);
    let _skp_rand_1 = SuiKeyPair::Secp256k1(get_key_pair_from_rng(&mut rand::rngs::OsRng).1);
    let _skp_rand_2 = SuiKeyPair::Secp256r1(get_key_pair_from_rng(&mut rand::rngs::OsRng).1);

    // import a keypair from a base64 encoded 32-byte `private key`.
    let _skp_import_no_flag_0 = SuiKeyPair::Ed25519(Ed25519KeyPair::from_bytes(
        &Base64::decode("1GPhHHkVlF6GrCty2IuBkM+tj/e0jn64ksJ1pc8KPoI=")
            .map_err(|_| anyhow!("Invalid base64"))?,
    )?);
    let _skp_import_no_flag_1 = SuiKeyPair::Ed25519(Ed25519KeyPair::from_bytes(
        &Base64::decode("1GPhHHkVlF6GrCty2IuBkM+tj/e0jn64ksJ1pc8KPoI=")
            .map_err(|_| anyhow!("Invalid base64"))?,
    )?);
    let _skp_import_no_flag_2 = SuiKeyPair::Ed25519(Ed25519KeyPair::from_bytes(
        &Base64::decode("1GPhHHkVlF6GrCty2IuBkM+tj/e0jn64ksJ1pc8KPoI=")
            .map_err(|_| anyhow!("Invalid base64"))?,
    )?);

    // import a keypair from a base64 encoded 33-byte `flag || private key`. The signature scheme is determined by the flag.
    let _skp_import_with_flag_0 =
        SuiKeyPair::decode_base64("ANRj4Rx5FZRehqwrctiLgZDPrY/3tI5+uJLCdaXPCj6C")
            .map_err(|_| anyhow!("Invalid base64"))?;
    let _skp_import_with_flag_1 =
        SuiKeyPair::decode_base64("AdRj4Rx5FZRehqwrctiLgZDPrY/3tI5+uJLCdaXPCj6C")
            .map_err(|_| anyhow!("Invalid base64"))?;
    let _skp_import_with_flag_2 =
        SuiKeyPair::decode_base64("AtRj4Rx5FZRehqwrctiLgZDPrY/3tI5+uJLCdaXPCj6C")
            .map_err(|_| anyhow!("Invalid base64"))?;

    // replace `skp_determ_0` with the variable names above
    let pk = skp_determ_0.public();
    let sender = SuiAddress::from(&pk);
```

Next, sign transaction data constructed using an example programmable transaction block with default gas coin, gas budget, and gas price. See [Building Programmable Transaction Blocks](./building-ptb.mdx) for more information.

```rust
    // construct an example programmable transaction.
    let pt = {
        let mut builder = ProgrammableTransactionBuilder::new();
        builder.pay_sui(vec![sender], vec![1])?;
        builder.finish()
    };

    let gas_budget = 5_000_000;
    let gas_price = sui_client.read_api().get_reference_gas_price().await?;

    // create the transaction data that will be sent to the network.
    let tx_data = TransactionData::new_programmable(
        sender,
        vec![gas_coin.object_ref()],
        pt,
        gas_budget,
        gas_price,
    );
```

Commit a signature to the Blake2b hash digest of the intent message (`intent || bcs bytes of tx_data`).

```rust
    // derive the digest that the keypair should sign on, i.e. the blake2b hash of `intent || tx_data`.
    let intent_msg = IntentMessage::new(Intent::sui_transaction(), tx_data);
    let raw_tx = bcs::to_bytes(&intent_msg).expect("bcs should not fail");
    let mut hasher = sui_types::crypto::DefaultHash::default();
    hasher.update(raw_tx.clone());
    let digest = hasher.finalize().digest;

    // use SuiKeyPair to sign the digest.
    let sui_sig = skp_determ_0.sign(&digest);

    // if you would like to verify the signature locally before submission, use this function. if it fails to verify locally, the transaction will fail to execute in Sui.
    let res = sui_sig.verify_secure(
        &intent_msg,
        sender,
        sui_types::crypto::SignatureScheme::ED25519,
    );
    assert!(res.is_ok());
```

Finally, submit the transaction with the signature.

```rust
    let transaction_response = sui_client
        .quorum_driver_api()
        .execute_transaction_block(
            sui_types::transaction::Transaction::from_generic_sig_data(
                intent_msg.value,
                Intent::sui_transaction(),
                vec![GenericSignature::Signature(sui_sig)],
            ),
            SuiTransactionBlockResponseOptions::default(),
            None,
        )
        .await?;
```

</TabItem>

<TabItem value="cli" label="Sui CLI">

When using the [Sui CLI](/references/cli.mdx) for the first time, it creates a local file in `~/.sui/keystore` on your machine with a list of private keys (encoded as Base64 encoded `flag || 32-byte-private-key`). You can use any key to sign transactions by specifying its address. Use `sui keytool list` to see a list of addresses.

There are three ways to initialize a key:

```sh
# generate randomly.
sui client new-address ed25519
sui client new-address secp256k1
sui client new-address secp256r1

# import the 32-byte private key to keystore.
sui keytool import "0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82" ed25519
sui keytool import "0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82" secp256k1
sui keytool import "0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82" secp256r1

# import the mnemonics (recovery phrase) with derivation path to keystore.
# $MNEMONICS refers to 12/15/18/21/24 words from the wordlist, e.g. "retire skin goose will hurry this field stadium drastic label husband venture cruel toe wire". Refer to [Keys and Addresses](/concepts/cryptography/transaction-auth/keys-addresses.mdx) for more.

sui keytool import "$MNEMONICS" ed25519
sui keytool import "$MNEMONICS" secp256k1
sui keytool import "$MNEMONICS" secp256r1
```

Create a transfer transaction in the CLI. Set the `$SUI_ADDRESS` to the one corresponding to the keypair used to sign. `$GAS_COIN_ID` refers to the object ID that is owned by the sender to be used as gas. `$GAS_BUDGET` refers to the budget used to execute transaction. Then sign with the private key corresponding to the sender address. `$MNEMONICS` refers to 12/15/18/21/24 words from the wordlist, e.g. "retire skin goose will hurry this field stadium drastic label husband venture cruel toe wire". Refer to [Keys and Addresses](/concepts/cryptography/transaction-auth/keys-addresses.mdx) for more.

{@include: ../../../snippets/info-gas-budget.mdx}

```sh
$ sui client gas
```
```sh
$ sui client transfer-sui --to $SUI_ADDRESS --sui-coin-object-id $GAS_COIN_ID --gas-budget $GAS_BUDGET --serialize-unsigned-transaction
```
```sh
$ sui keytool sign --address $SUI_ADDRESS --data $TX_BYTES
```
```sh
$ sui client execute-signed-tx --tx-bytes $TX_BYTES --signatures $SERIALIZED_SIGNATURE
```

</TabItem>
</Tabs>

### Notes

1. This guide demonstrates how to sign with a single private key. Refer to [Multisig](/concepts/cryptography/transaction-auth/multisig.mdx) when it is preferred to set up more complex signing policies.
2. Similarly, native zkLogin does not follow the above steps, see [the docs](/concepts/cryptography/zklogin.mdx) to understand how to derive a zkLogin address, and produce a zkLogin signature with an ephemeral key pair.
3. If you decide to implement your own signing mechanisms instead of using the previous tools, see the [Signatures](/concepts/cryptography/transaction-auth/signatures.mdx) doc on the accepted signature specifications for each scheme.
4. Flag is one byte that differentiates signature schemes. See supported schemes and its flag in [Signatures](/concepts/cryptography/transaction-auth/signatures.mdx).
5. The `execute_transaction_block` endpoint takes a list of signatures, so it should contain exactly one user signature, unless you are using sponsored transaction that a second signature for the gas object can be provided. See [Sponsored Transactions](/concepts/transactions/sponsored-transactions.mdx) for more information.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101/working-with-ptbs.mdx
```
---
title: Working with Programmable Transaction Blocks
---

Programmable transaction blocks (PTBs) are key elements of the Sui ecosystem. Understanding PTBs and using them correctly are key fundamentals to creating efficient and cost-effective smart contracts. See [Programmable Transaction Blocks](../../../concepts/transactions/prog-txn-blocks.mdx) to learn about the structure of PTBs on Sui.

The topics in this section focus on effectively utilizing PTBs in your smart contracts.

## Building Programmable Transaction Blocks

To fully appreciate the possibilities PTBs offer, you must build them. Using tools like the [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript), you can begin to understand the power and flexibility they provide.

Go to [Building Programmable Transaction Blocks](./building-ptb.mdx).

## Coin Management

`Coin` objects on Sui are different than other blockchains in that they are [owned objects](../../../concepts/object-ownership/address-owned.mdx). Whether you need your smart contract to utilize SUI for gas payments or deal with generic coins, understanding coin management is crucial. Smart contracts use common patterns to accept coins and the PTBs you create must provide the correct interface to those smart contracts to facilitate successful transactions.

Go to [Coin Management](./coin-mgt.mdx).

## Simulating References

The [`borrow` module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui-framework/sui/borrow.md) of the Sui framework offers some features you can use when your PTBs use objects by reference.

Go to [Simulating References](./simulating-refs.mdx).

## Related links

Review this content for a complete picture of PTBs on Sui.

- [Programmable Transaction Blocks](../../../concepts/transactions/prog-txn-blocks.mdx): Conceptual overview of the PTB architecture.
- [Life of a Transaction](../../../concepts/sui-architecture/transaction-lifecycle.mdx): Discover the life of a transaction from inception to finality.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101/coin-mgt.mdx
```
---
title: Coin Management
description: Because Sui uses Coins as owned objects for transactions, you need to explicitly manage them in your programmable transaction block development.
---

A key concept when programming on Sui is that of owned objects. Address-owned objects are important in that they allow for highly parallelizable transactions. And they also logically map to assets or resources that someone exclusively owns. Coins are a typical case of owned object usage, with cash being a real-life reference. The owned objects paradigm, however, and particularly as related to coins, is somewhat of a divergence from other blockchains which have a concept of balance. In other words, in other systems, especially account based systems, coins are held in a single location (field) which can be thought of as a balance in a bank account.

Because Sui uses owned objects instead of a balance, it is common to own a number of coins, at times even a significant number of them. Some scenarios necessitate merging some or all of those coins into a single object. At times, merging coins together might even be required because the amount necessary to execute a transaction is more than any single coin the sender owns, thus making merging an inevitable step.

## SDK usage

The Sui SDKs ([TypeScript](https://sdk.mystenlabs.com/typescript) and [Rust](/references/rust-sdk.mdx)) manage coins on your behalf, removing the overhead of having to deal with coin management manually. The SDKs attempt to merge coins whenever possible and assume that transactions are executed in sequence. That's a reasonable assumption with wallet-based transactions and for common scenarios in general. Sui recommends relying on this feature if you do not have a need for heavy parallel or concurrent execution.

## Gas Smashing

When executing a transaction Sui allows you to provide a number of coins as payment. In other words, the payment can be a vector of coins rather than a single coin. That feature, known as gas smashing, performs merging of coins automatically, and presents the PTBs you write with a single gas coin that can be used for other purposes besides just gas.

Basically, you can provide as many coins as you want (with a max limit defined in the protocol configuration) and have all of them merged (smashed) into the first coin provided as payment. That coin, minus the gas budget, is then available inside the transaction and can be used in any command. If the coin is unused it is returned to the user.

Gas smashing is an important feature - and a key concept to understand - to have for the optimal management of coins. See [Gas Smashing](/concepts/transactions/gas-smashing.mdx) for more details.

## Generic coins

Gas smashing works well for `Coin<Sui>` objects, which is the only coin type that can be used for gas payment.

Any other coin type requires explicit management from users. PTBs offer a `mergeCoins` command that you can use to combine multiple coins into a single one. And a `splitCoins` as the complementary operation to break them up.

From a cost perspective, those are very cheap transactions, however they require a user to be aware of their coin distribution and their own needs.

## Concurrency

Merging coins, and particularly `Coin<Sui>`, into a single coin or a very small number of coins might prove problematic in scenarios where heavy or high concurrency is required.

If you merge all `Coin<Sui>` into a single one, you would need to sequentially submit every transaction. The coin - being an owned object - would have to be provided with a version and it would be locked by the system when signing a transaction, effectively making it impossible to use it in any other transaction until the one that locked it was executed. Moreover, an attempt to sign multiple transactions with the same coin might result in equivocation and the coin being unusable and locked until the end of the epoch.

So when you require heavy concurrency, you should first split a coin into as many coins as the number of transactions to execute concurrently. Alternatively, you could provide multiple and different coins (gas smashing) to the different transactions. It is critically important that the set of coins you use in the different transactions has no intersection at all.

The possible pitfalls in dealing with heavy concurrency are many. Concurrency in transaction execution is not the only performance bottleneck. In creating and submitting a transaction, several round trips with a Full node might be required to discover and fetch the right objects, and to dry run a transaction. Those round trips might affect performance significantly.

Concurrency is a difficult subject and is beyond the scope of this documentation. You must take maximum care when dealing with coin management in the face of concurrency, and the right strategy is often tied to the specific scenario, rather than universally available.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101/shared-owned.mdx
```
---
title: Shared versus Owned Objects
description: On Sui, you can use shared objects, owned objects, or both in your transactions. Weigh the benefits of each to decide the best approach for your project.
---

Objects on Sui can be shared (accessible for reads and writes by any transaction) or owned (accessible for reads and writes by transactions signed by their owner).  Many applications can be built using a solution that either uses shared objects or only owned objects, with trade-offs for each that need to be weighed.

Transactions that use only owned objects benefit from very low latency to finality, because they do not need to go through consensus.  On the other hand, the fact that only the owner of the object can access it complicates processes that need to work with objects owned by multiple parties, and access to very hot objects needs to be coordinated off-chain.

Transactions that access one or more shared objects require consensus to sequence reads and writes to those objects, resulting in a slightly higher gas cost and increased latency.

Transactions that access multiple shared objects, or particularly popular objects, might have increases in latency due to contention. However, the advantage of using shared objects lies in the flexibility of allowing multiple addresses to access the same object in a coordinated manner.

To summarize, applications that are extremely sensitive to latency or gas costs, that do not need to handle complex multi-party transactions, or that already require an off-chain service could benefit from a design that only uses owned objects. Applications that require coordination between multiple parties typically benefit from using shared objects.

For more information on the types of objects that Sui supports, see [Object Ownership](/concepts/object-ownership.mdx).

## Example: Escrow

The Escrow example demonstrates the trade-offs between shared objects and owned objects by implementing the same application in both styles. Both styles of the example implement a service that enables a trustless swap of objects between two addresses (a "trade"), with the service holding those objects in escrow.

### `Locked<T>` and `Key`

[Code Sample](https://github.com/MystenLabs/sui/blob/93e6b4845a481300ed4a56ab4ac61c5ccb6aa008/examples/move/escrow/sources/lock.move)

Both implementations use a primitive for locking values, which offers the following interface:

```move
module escrow::lock {
    public fun lock<T: store>(obj: T, ctx: &mut TxContext): (Locked<T>, Key);
    public fun unlock<T: store>(locked: Locked<T>, key: Key): T
}
```

Any `T: store` can be locked, to get a `Locked<T>` and a corresponding `Key`, and conversely, the locked value and its corresponding key can be consumed to get back the wrapped object.

The important property that this interface provides is that locked values cannot be modified except by unlocking them first (and later relocking them).  Because unlocking consumes the key, tampering with a locked value can be detected by remembering the ID of the key that it was locked with.  This prevents situations where one party in a swap changes the object they are offering to reduce its value.

### Owned objects

<details>
<summary>
`owned.move`
</summary>
{@inject: examples/trading/contracts/escrow/sources/owned.move}
</details>

The protocol for swapping via escrow implemented using owned objects starts with both parties locking their respective objects. 

```mermaid
flowchart TD
    SR[Locked&ltfa:fa-wrench S&gt, fa:fa-key key_s]
    BR[Locked&ltfa:fa-coins B&gt, fa:fa-key key_b]

    subgraph Seller
    a2(fa:fa-wrench S)--escrow::lock-->SR
    end

    subgraph Buyer
    a1(fa:fa-coins B)--escrow::lock-->BR
    end
```

This is used to prove that the object has not been tampered with after the swap has been agreed to. If either party doesn't want to proceed at this stage, they just unlock their object.

Assuming both parties are happy to continue, the next step requires both parties to swap the keys.

```mermaid
flowchart LR
    Buyer--fa:fa-key key_b-->Seller
    Seller--fa:fa-key key_s-->Buyer
```

A third party acts as custodian. The custodian holds objects that are waiting for their counterparts to arrive and when they arrive, it matches them up to complete the swap.

{@inject: examples/trading/contracts/escrow/sources/owned.move#fun=create noComments}

```mermaid
flowchart TB
    S["fa:fa-key key_s,
        Locked&ltfa:fa-wrench S&gt,
        exchange_key: fa:fa-key key_b,
        recipient: Buyer
    "]
    B["fa:fa-key key_b,
        Locked&ltfa:fa-coins B&gt,
        exchange_key: fa:fa-key key_s,
        recipient: Seller
    "]

    id1(Escrow&ltfa:fa-coins B&gt)-->Third_Party
    id2(Escrow&ltfa:fa-wrench S&gt)-->Third_Party
    subgraph Buyer
    direction TB
    B--create-->id1
    end

    subgraph Seller
    direction TB
    S--create-->id2
    end
```

The `create` function prepares the `Escrow` request and sends it to the `custodian`.  The object being offered by this party is passed in, locked, with its key, and the object being requested is identified by the ID of the key it was locked with.  While preparing the request, the offered object is unlocked, while remembering the ID of its key.

Although the custodian is trusted to preserve liveness (to complete swaps if it owns both sides of a swap and to return objects if requested), all other correctness properties are maintained in Move: Even though the custodian owns both objects being swapped, the only valid action they are permitted to take is to match them up with their correct counterpart to finish the swap, or to return them:

```mermaid
flowchart TB

    subgraph Third_Party
    direction TB
    id1(fa:fa-wrench S, fa:fa-coins B)
    id2(Escrow&ltfa:fa-coins B&gt, Escrow&ltfa:fa-wrench S&gt)
    id2--swap-->id1
    end

    Third_Party--fa:fa-wrench S-->Buyer
    Third_Party--fa:fa-coins B-->Seller
```

{@inject: examples/trading/contracts/escrow/sources/owned.move#fun=swap}

The `swap` function checks that senders and recipients match and that each party wants the object that the other party is offering, by comparing their respective key IDs.  If the custodian tried to match together two unrelated escrow requests to swap, the transaction would not succeed.

### Shared objects

<details>
<summary>
`shared.move`
</summary>
{@inject: examples/trading/contracts/escrow/sources/shared.move}
</details>

The protocol in the shared object case is less symmetric, but still starts with the first party locking the object they want to swap. 
```mermaid
flowchart TB
    B["Locked&ltfa:fa-coins B&gt, fa:fa-key key_b"]
        
    subgraph Buyer
    direction TB
    a1(fa:fa-coins B)--escrow::lock-->B
    end
```

The second party can then view the object that was locked, and if they decide they want to swap with it, they indicate their interest by creating a swap request:

```mermaid
flowchart TB
    S["fa:fa-wrench S,
        exchange_key: fa:fa-key key_b,
        recipient: Buyer
    "]

    id1(Shared Object)-->id2(Escrow&ltfa:fa-wrench S&gt)

    subgraph Seller
    direction TB
    S--create-->id2
    end
```

{@inject: examples/trading/contracts/escrow/sources/shared.move#fun=create noComments}

This time the `create` request accepts the object being escrowed directly (not locked), and creates a shared `Escrow` object.  The request remembers the address that sent it (who is allowed to reclaim the object if the swap hasn't already happened), and the intended recipient, who is then expected to continue the swap by providing the object they initially locked:

```mermaid
flowchart TB

    subgraph Buyer
    direction TB
    id1(Escrow&ltfa:fa-wrench S&gt,\n fa:fa-key key_b,\n Locked&ltfa:fa-coins B&gt)
    id2(fa:fa-wrench S)
    id1-->swap-->id2
    end

    swap--fa:fa-coins B-->Seller
```

{@inject: examples/trading/contracts/escrow/sources/shared.move#fun=swap}


Even though the `Escrow` object is a shared object that is accessible by anyone, the Move interface ensures that only the original sender and the intended recipient can successfully interact with it. `swap` checks that the locked object matches the object that was requested when the `Escrow` was created (again, by comparing key IDs) and assumes that the intended recipient wants the escrowed object (if they did not, they would not have called `swap`).

Assuming all checks pass, the object held in `Escrow` is extracted, its wrapper is deleted and it is returned to the first party.  The locked object offered by the first party is also unlocked and sent to the second party, completing the swap.

### Comparison

This topic explores two ways to implement a swap between two objects.  In both cases there is a point at which one party has made a request and the other has not responded.  At this point, both parties may want to access the `Escrow` object: One to cancel the swap, and the other to complete it.

In one case, the protocol uses only owned objects but requires a custodian to act as an intermediary. This has the advantage of avoiding the costs and latencies of consensus altogether, but involves more steps and requires trusting a third party for liveness.

In the other case, the object is custodied on chain in a shared object.  This requires consensus but involves fewer steps, and no third party.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101/access-time.mdx
```
---
title: Access On-Chain Time
description: Access network-based time for your transactions. Sui provides a Clock module to capture near-real time or epoch time in your Sui packages.
---

You have options when needing to access network-based time for your transactions. If you need a near real-time measurement (within a few seconds), use the immutable reference of time provided by the `Clock` module in Move. The reference value from this module updates with every network checkpoint. If you don't need as current a time slice, use the `epoch_timestamp_ms` function to capture the precise moment the current epoch started.

## The sui::clock::Clock module

To access a prompt timestamp, you must pass a read-only reference of `sui::clock::Clock` as an entry function parameter in your transactions. An instance of `Clock` is provided at address `0x6`, no new instances can be created.

Use the `timestamp_ms` function from the `sui::clock` module to extract a unix timestamp in milliseconds.

{@inject: crates/sui-framework/packages/sui-framework/sources/clock.move#fun=timestamp_ms noComments}

The example below demonstrates an entry function that emits an event containing a timestamp from the `Clock`:

{@inject: examples/move/basics/sources/clock.move#module=basics::clock noComments}

A call to the previous entry function takes the following form, passing `0x6` as the address for the `Clock` parameter:

{@include: ../../../snippets/info-gas-budget.mdx}

```sh
$ sui client call --package <EXAMPLE> --module 'clock' --function 'access' --args '0x6' --gas-budget <GAS-AMOUNT>
```

Expect the `Clock` timestamp to change at the rate the network generates checkpoints, which is about **every 1/4 second** with Mysticeti consensus. Find the current network checkpoint rate on this [public dashboard](https://metrics.sui.io/public-dashboards/4ceb11cc210d4025b122294586961169).

Successive calls to `sui::clock::timestamp_ms` in the same transaction always produce the same result (transactions are considered to take effect instantly), but timestamps from `Clock` are otherwise monotonic across transactions that touch the same shared objects: Successive transactions seeing a greater or equal timestamp to their predecessors.

Any transaction that requires access to a `Clock` must go through consensus because the only available instance is a shared object. As a result, this technique is not suitable for transactions that must use the single-owner fastpath (see Epoch timestamps for a single-owner-compatible source of timestamps).

Transactions that use the clock must accept it as an **immutable reference** (not a mutable reference or value). This prevents contention, as transactions that access the `Clock` can only read it, so do not need to be sequenced relative to each other. Validators refuse to sign transactions that do not meet this requirement and packages that include entry functions that accept a `Clock` or `&mut Clock` fail to publish.

The following functions test `Clock`-dependent code by manually creating a `Clock` object and manipulating its timestamp. This is possible only in test code:

{@inject: crates/sui-framework/packages/sui-framework/sources/clock.move#fun=create_for_testing,share_for_testing,increment_for_testing,set_for_testing,destroy_for_testing noComments}

The next example presents a basic test that creates a Clock, increments it, and then checks its value:

{@inject: crates/sui-framework/packages/sui-framework/tests/clock_tests.move#module=sui::clock_tests noComments}

## Epoch timestamps

Use the following function from the `sui::tx_context` module to access the timestamp for the start of the current epoch for all transactions (including ones that do not go through consensus):

{@inject: crates/sui-framework/packages/sui-framework/sources/tx_context.move#fun=epoch_timestamp_ms noComments}

The preceding function returns the point in time when the current epoch started, as a millisecond granularity unix timestamp in a `u64`. This value changes roughly **once every 24 hours**, when the epoch changes.

Tests based on `sui::test_scenario` can use `later_epoch` (following code), to exercise time-sensitive code that uses `epoch_timestamp_ms` (previous code):
{@inject: crates/sui-framework/packages/sui-framework/sources/test/test_scenario.move#fun=later_epoch noComments}

`later_epoch` behaves like `sui::test_scenario::next_epoch` (finishes the current transaction and epoch in the test scenario), but also increments the timestamp by `delta_ms` milliseconds to simulate the progress of time.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101/avoid-equivocation.mdx
```
---
title: Avoiding Equivocation
description: Avoid unintentionally locking objects with your smart contract logic. 
---

Equivocation is when validators send conflicting information about objects on the network. Sometimes this is because of bad actors trying to subvert the integrity of the Sui network. The network has measures in place to punish validators that might engage in such behavior.

The other source of equivocation does not originate from bad intentions. There are logic traps that smart contract code can inadvertently trigger, like when dealing with [sponsored transactions](https://docs.sui.io/guides/developer/sui-101/sponsor-txn#client-equivocation-risk). The effects of this type of equivocation can lock the objects your code interacts with until the end of the current epoch. This can lead to frustration for you, and more importantly, your users.

To avoid double spending, validators lock objects as they validate transactions. An equivocation occurs when an owned object pair (`ObjectId`, `SequenceNumber`) is concurrently used in multiple non-finalized transactions.

Perhaps the most common source of equivocation stems from the attempt to pay for gas using the same coin object. This can be a problem when performing multiple transactions that originate from the same sender.

It's not just objects that can cause equivocation. Any object used in multiple transactions can be a source of equivocation if not handled properly. Sui uses object versioning to track the status of objects across transactions and epochs. If a transaction modifies an object, then one of the results of that transaction is to update the version of that same object.

The versiong architecture is what supports paying the gas for a series of transactions using the same gas coin. Among other processing, the first transaction advances the version number of the coin and returns it to the sender. The next transaction can then use that same coin to pay for its gas. Equivocation is avoided because each transaction references a different version of the same coin.

## Common pitfalls to avoid

For most smart contracts, equivocation is not something that's an intended behavior. Perhaps the most common source of unintentional equivocation comes from multiple transactions performed by the same address. If you don't take care to handle the gas fees properly, you could lock up your smart contract by trying to use the same coin (and version) for more than one transaction.

If using a single thread, serialize transactions that use the same owned object. PTBs allow your transactions to use multiple operations against the same owned object. A PTB is essentially a single, serialized transaction, which can prevent `SequenceNumber` errors.

You should always take advantage of the inherent batching that PTBs provide. For example, consider an airdrop scenario where you want to mint and transfer an object to many users. Because PTBs allow up to 1,024 operations in a single PTB, you can airdrop your object to 512 users in a single transaction. This approach is much more cost efficient than looping over 512 individual transactions that mint and transfer to a single user each time. Batching transactions might remove the need for parallel execution, but you must consider the atomic nature of PTBs; if one instruction fails, the whole PTB fails. Consequently, parallel transactions might be preferred for some use cases.

Parallel transactions from multiple threads can cause unintentional equivocation errors if not managed properly. One way to avoid owned object equivocation is to create a separate owned object for each transaction thread. This ensures that each thread uses the correct version of its object input.

In cases where creating multiple owned objects is not practical or desired, you can create a wrapper around an object used across threads. The wrapper is a shared object that authorizes access to its object through an allowlist. Any time a transaction needs to access the wrapped object, it gets permission from the wrapper in the same PTB. When authorization needs transferring, the allowlist for the wrapper gets updated accordingly. This approach can create a latency bottleneck as the object wrapper creates sequentialized transactions that rely on its object for input. The Sui TypeScript SDK provides an executor class, `ParallelTransactionExecutor`, to process parallel transactions efficiently.

## Sui SDK

The Sui SDK offers transaction executors to help process multiple transactions from the same address.

### SerialTransactionExecutor

Use the `SerialTransactionExecutor` when processing transactions one after another. The executor grabs all the coins from the sender and combines them into a single coin that is used for all transactions.

Using the `SerialTransactionExecutor` prevents `SequenceNumber` errors by handling the versioning of object inputs across a PTB.

### ParallelTransactionExecutor

Use the `ParallelTransactionExecutor` when you want to process transactions with the same sender at the same time. This class creates a pool of gas coins that it manages to ensure parallel transactions don't equivocate those coins. The class tracks objects used across transactions and orders their processing so that the object inputs are also not equivocated.

## Debug tools

If you find your smart contracts unintentionally locking objects, there are some tools you can use to help fix the issue.

### sui-tool

You can install the `sui-tool` (https://github.com/MystenLabs/sui/tree/main/crates/sui-tool) utility and use the `locked-object` command to check the locked status of the passed asset on a specific RPC network (`--fullnode-rpc-url` value). If you provide an address, locked-object checks if all the gas objects owned by that address are locked. Pass an object ID to check if that specific object is locked.

```sh
$ cargo run --bin sui-tool
```
```sh
$ sui-tool locked-object --address 0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331 --fullnode-rpc-url <https://rpc.mainnet.sui.io:443>
```
```sh
$ sui-tool locked-object --id 0xd4c3ecf5eaa211da58c36495613899e70349f6048baaeca99596f1682e89c837 --fullnode-rpc-url <https://rpc.mainnet.sui.io:443>
```

:::tip

Include the `--rescue` flag to try and unlock the object the command targets. Rescue is possible if the object isn't already locked by a majority of validators.

:::

## Related links

- [Building Programmable Transaction Blocks](./building-ptb.mdx): Using the Sui TypeScript SDK to create programmable transaction blocks, which perform multiple commands in a single transaction.
- [Object and Package Versioning](../../../concepts/versioning.mdx): Versioning provides the ability to upgrade packages and objects on the Sui network.
- [Sponsored Transactions](./sponsor-txn.mdx): Sponsored transactions are a primitive on the Sui blockchain that enable the execution of a transaction where you pay the gas fee for your users transactions.
- [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript): The Sui TypeScript SDK is a modular library of tools for interacting with the Sui blockchain.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101/building-ptb.mdx
```
---
title: Building Programmable Transaction Blocks
description: Using the Sui TypeScript SDK, you can create programmable transaction blocks to perform multiple commands in a single transaction.
---

This guide explores creating a programmable transaction block (PTB) on Sui using the TypeScript SDK. For an overview of what a PTB is, see [Programmable Transaction Blocks](/concepts/transactions/prog-txn-blocks.mdx) in the Concepts section. If you don't already have the Sui TypeScript SDK, follow the [install instructions](https://sdk.mystenlabs.com/typescript/install) on the Sui TypeScript SDK site.

This example starts by constructing a PTB to send Sui. If you are familiar with the legacy Sui transaction types, this is similar to a `paySui` transaction. To construct transactions, import the `Transaction` class, and construct it:

```ts
import { Transaction } from '@mysten/sui/transactions';

const tx = new Transaction();
```

Using this, you can then add transactions to this PTB.

```ts
// Create a new coin with balance 100, based on the coins used as gas payment.
// You can define any balance here.
const [coin] = tx.splitCoins(tx.gas, [tx.pure('u64', 100)]);

// Transfer the split coin to a specific address.
tx.transferObjects([coin], tx.pure('address', '0xSomeSuiAddress'));
```

You can attach multiple transaction commands of the same type to a PTB as well. For example, to get a list of transfers, and iterate over them to transfer coins to each of them:

```ts
interface Transfer {
	to: string;
	amount: number;
}

// Procure a list of some Sui transfers to make:
const transfers: Transfer[] = getTransfers();

const tx = new Transaction();

// First, split the gas coin into multiple coins:
const coins = tx.splitCoins(
	tx.gas,
	transfers.map((transfer) => tx.pure('u64', transfer.amount)),
);

// Next, create a transfer transaction for each coin:
transfers.forEach((transfer, index) => {
	tx.transferObjects([coins[index]], tx.pure('address', transfer.to));
});
```

After you have the Transaction defined, you can directly execute it with a `SuiClient` and `KeyPair` using `client.signAndExecuteTransaction`.

```ts
client.signAndExecuteTransaction({ signer: keypair, transaction: tx });
```

## Constructing inputs

Inputs are how you provide external values to PTBs. For example, defining an amount of Sui to transfer, or which object to pass into a Move call, or a shared object.

There are currently two ways to define inputs:

- For objects: the `tx.object(objectId)` function is used to construct an input that contains an object reference.
- For pure values: the `tx.pure(type, value)` function is used to construct an input for a non-object input.
  - If value is a `Uint8Array`, then the value is assumed to be raw bytes and is used directly: `tx.pure(SomeUint8Array)`.
  - Otherwise, it's used to generate the BCS serialization layout for the value.
  - In the new version, a more intuitive way of writing is provided, for example: `tx.pure.u64(100)`, `tx.pure.string('SomeString')`, `tx.pure.address('0xSomeSuiAddress')`, `tx.pure.vector('bool', [true, false])`...

## Available transactions

Sui supports following transaction commands:

- `tx.splitCoins(coin, amounts)`: Creates new coins with the defined amounts, split from the provided coin. Returns the coins so that it can be used in subsequent transactions.
  - Example: `tx.splitCoins(tx.gas, [tx.pure.u64(100), tx.pure.u64(200)])`
- `tx.mergeCoins(destinationCoin, sourceCoins)`: Merges the sourceCoins into the destinationCoin.
  - Example: `tx.mergeCoins(tx.object(coin1), [tx.object(coin2), tx.object(coin3)])`
- `tx.transferObjects(objects, address)`: Transfers a list of objects to the specified address.
  - Example: `tx.transferObjects([tx.object(thing1), tx.object(thing2)], tx.pure.address(myAddress))`
- `tx.moveCall({ target, arguments, typeArguments })`: Executes a Move call. Returns whatever the Sui Move call returns.
  - Example: `tx.moveCall({ target: '0x2::devnet_nft::mint', arguments: [tx.pure.string(name), tx.pure.string(description), tx.pure.string(image)] })`
- `tx.makeMoveVec({ type, elements })`: Constructs a vector of objects that can be passed into a moveCall. This is required as there's no other way to define a vector as an input.
  - Example: `tx.makeMoveVec({ elements: [tx.object(id1), tx.object(id2)] })`
- `tx.publish(modules, dependencies)`: Publishes a Move package. Returns the upgrade capability object.

## Passing transaction results as arguments

You can use the result of a transaction command as an argument in subsequent transaction commands. Each transaction command method on the transaction builder returns a reference to the transaction result.

```ts
// Split a coin object off of the gas object:
const [coin] = tx.splitCoins(tx.gas, [tx.pure.u64(100)]);
// Transfer the resulting coin object:
tx.transferObjects([coin], tx.pure.address(address));
```

When a transaction command returns multiple results, you can access the result at a specific index either using destructuring, or array indexes.

```ts
// Destructuring (preferred, as it gives you logical local names):
const [nft1, nft2] = tx.moveCall({ target: '0x2::nft::mint_many' });
tx.transferObjects([nft1, nft2], tx.pure.address(address));

// Array indexes:
const mintMany = tx.moveCall({ target: '0x2::nft::mint_many' });
tx.transferObjects([mintMany[0], mintMany[1]], tx.pure.address(address));
```

## Use the gas coin

With PTBs, you can use the gas payment coin to construct coins with a set balance using `splitCoin`. This is useful for Sui payments, and avoids the need for up-front coin selection. You can use `tx.gas` to access the gas coin in a PTB, and it is valid as input for any arguments; with the exception of `transferObjects`, `tx.gas` must be used by-reference. Practically speaking, this means you can also add to the gas coin with `mergeCoins` or borrow it for Move functions with `moveCall`.

You can also transfer the gas coin using `transferObjects`, in the event that you want to transfer all of your coin balance to another address.

Of course, you can also transfer other coins in your wallet using their `Object ID`. For example,

```ts
const otherCoin = tx.object('0xCoinObjectId');
const coin = tx.splitCoins(otherCoin, [tx.pure.u64(100)]);
tx.transferObjects([coin], tx.pure.address(address));
```

## Get PTB bytes

If you need the PTB bytes, instead of signing or executing the PTB, you can use the `build` method on the transaction builder itself.

:::tip

You might need to explicitly call `setSender()` on the PTB to ensure that the `sender` field is populated. This is normally done by the signer before signing the transaction, but will not be done automatically if you're building the PTB bytes yourself.

:::

```ts
const tx = new Transaction();

// ... add some transactions...

await tx.build({ provider });
```

In most cases, building requires your JSON RPC provider to fully resolve input values.

If you have PTB bytes, you can also convert them back into a `Transaction` class:

```ts
const bytes = getTransactionBytesFromSomewhere();
const tx = Transaction.from(bytes);
```

## Building offline

In the event that you want to build a PTB offline (as in with no `provider` required), you need to fully define all of your input values, and gas configuration (see the following example). For pure values, you can provide a `Uint8Array` which is used directly in the transaction. For objects, you can use the `Inputs` helper to construct an object reference.

```ts
import { Inputs } from '@mysten/sui/transactions';

// For pure values:
tx.pure(pureValueAsBytes);

// For owned or immutable objects:
tx.object(Inputs.ObjectRef({ digest, objectId, version }));

// For shared objects:
tx.object(Inputs.SharedObjectRef({ objectId, initialSharedVersion, mutable }));
```

You can then omit the `provider` object when calling `build` on the transaction. If there is any required data that is missing, this will throw an error.

## Gas configuration

The new transaction builder comes with default behavior for all gas logic, including automatically setting the gas price, budget, and selecting coins to be used as gas. This behavior can be customized.

### Gas price

By default, the gas price is set to the reference gas price of the network. You can also explicitly set the gas price of the PTB by calling `setGasPrice` on the transaction builder.

```ts
tx.setGasPrice(gasPrice);
```

### Budget

By default, the gas budget is automatically derived by executing a dry-run of the PTB beforehand. The dry run gas consumption is then used to determine a balance for the transaction. You can override this behavior by explicitly setting a gas budget for the transaction, by calling `setGasBudget` on the transaction builder.

:::info

The gas budget is represented in Sui, and should take the gas price of the PTB into account.

:::

```ts
tx.setGasBudget(gasBudgetAmount);
```

### Gas payment

By default, the gas payment is automatically determined by the SDK. The SDK selects all coins at the provided address that are not used as inputs in the PTB.

The list of coins used as gas payment will be merged down into a single gas coin before executing the PTB, and all but one of the gas objects will be deleted. The gas coin at the 0-index will be the coin that all others are merged into.

```ts
// NOTE: You need to ensure that the coins do not overlap with any
// of the input objects for the PTB.
tx.setGasPayment([coin1, coin2]);
```

Gas coins should be objects containing the coins objectId, version, and digest (ie `{ objectId: string, version: string | number, digest: string }`).

### dApp / Wallet integration

The Wallet Standard interface has been updated to support the `Transaction` kind directly. All `signTransaction` and `signAndExecuteTransaction` calls from dApps into wallets is expected to provide a `Transaction` class. This PTB class can then be serialized and sent to your wallet for execution.

To serialize a PTB for sending to a wallet, Sui recommends using the `tx.serialize()` function, which returns an opaque string representation of the PTB that can be passed from the wallet standard dApp context to your wallet. This can then be converted back into a `Transaction` using `Transaction.from()`.

:::tip

You should not build the PTB from bytes in the dApp code. Using `serialize` instead of `build` allows you to build the PTB bytes within the wallet itself. This allows the wallet to perform gas logic and coin selection as needed.

:::

```ts
// Within a dApp
const tx = new Transaction();
wallet.signTransaction({ transaction: tx });

// Your wallet standard code:
function handleSignTransaction(input) {
	sendToWalletContext({ transaction: input.transaction.serialize() });
}

// Within your wallet context:
function handleSignRequest(input) {
	const userTx = Transaction.from(input.transaction);
}
```

## Sponsored PTBs

The PTB builder can support sponsored PTBs by using the `onlyTransactionKind` flag when building the PTB.

```ts
const tx = new Transaction();
// ... add some transactions...

const kindBytes = await tx.build({ provider, onlyTransactionKind: true });

// Construct a sponsored transaction from the kind bytes:
const sponsoredTx = Transaction.fromKind(kindBytes);

// You can now set the sponsored transaction data that is required:
sponsoredTx.setSender(sender);
sponsoredTx.setGasOwner(sponsor);
sponsoredTx.setGasPayment(sponsorCoins);
```

## Related links

- [Using Stablecoins in PTBs](/guides/developer/stablecoins#using-usdc-in-ptbs)
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101/sponsor-txn.mdx
```
---
title: Sponsored Transactions
description: Sponsored transactions are a primitive on the Sui blockchain that enable the execution of a transaction where you pay the gas fee for your users transactions.
---

A transaction on Sui takes a payment to execute. The payment, also known as gas, is a list of `0x2::coin::Coin<0x2::sui::Sui>` objects. Although gas is a critical piece in Sui tokenomics, it sometimes adds challenges when new Web3 users start to navigate on Sui.

Sponsored transactions are a primitive on the Sui blockchain that enable the execution of a transaction without a user paying the gas. Sponsored transactions can reduce the onboarding friction for users because the feature streamlines the process for end users. Using sponsored transactions, you can execute a transaction without requiring the user to pay it themselves. Instead, you can act as a sponsor of the transaction, offering your own payment gas objects for the transaction.

## Roles in sponsored transactions

In a sponsored transaction there are three roles: the user, the gas station, and the sponsor.

* The user is the entity who wants to execute a transaction. 
* The gas station is the entity that fulfills the sponsorship request for the user's transaction by providing the gas payment they own.
* The sponsor is entity that funds the gas station for its operations.

It's not uncommon for the gas station and the sponsor to be the same entity. For example, a web3 gaming studio could run its own gas station to sponsor users with real free-to-play gaming experiences at its user acquisition stage. Because it's not always trivial to maintain a gas station for teams of any size, that gaming studio could also leverage third-party gas stations to sponsor transactions they want to promote. 

The remainder of this guide assumes the sponsor uses their own gas station. 

## Use cases

The following sections describe some common scenarios where sponsored transactions offer an improved user experience.

### App-specific sponsorship

In this scenario, the sponsor has a specific set of applications they want to sponsor.

- If the transaction is initialized by the user, the sponsor examines the transaction to make sure it's within the set of approved applications before agreeing to provide the gas payment. 
- If the transaction is proposed by the sponsor, the user must examine the transaction and decide if they want to execute it. Examples of this type of transaction might include a rewards claim transaction of a campaign or a "try it out" advertisement transaction.

### Wildcard sponsorship

In this scenario, the sponsor has few restrictions on the type of transactions the gas payment can be used for.

- If the sponsor is a gasless wallet, it may agree to sponsor any valid transactions proposed by its users.
- In the form of a reward or discount, the sponsor could offer the user a wildcard gas payment, expressly promising to execute any transactions with that gas payment.

A sponsored transaction is not restricted to these use cases. Essentially, a sponsored transaction is any transaction jointly made by the user and the sponsor. As long as the stakeholders can agree on the transaction details, then the number of possible ways to provide sponsored transactions is limited only by the imagination. Because at least two stakeholders are involved in a sponsored transaction, however, there are some [additional risks](#risk) that you should take steps to mitigate.


## Sponsored transaction flow

This section is mostly for developers who are interested in building a gas station or integrating with one.

The data structure of a transaction resembles the following:

```rust

pub struct SenderSignedTransaction {
    pub intent_message: IntentMessage<TransactionData>,
    /// A list of signatures signed by all transaction participants.
    /// 1. non participant signature must not be present.
    /// 2. signature order does not matter.
    pub tx_signatures: Vec<GenericSignature>,
}

pub struct TransactionDataV1 {  // <-- A variant of `TransactionData`
    pub kind: TransactionKind,  // <-- This is the actual transaction details
    pub sender: SuiAddress,
    pub gas_data: GasData,
    pub expiration: TransactionExpiration,
}

pub struct GasData {
    pub payment: Vec<ObjectRef>,
    pub owner: SuiAddress,
    pub price: u64,
    pub budget: u64,
}

```

A few details of note for the preceding code:

- `sender` in `TransactionDataV1` (a variant of `TransactionData`) is the user address.
- `gas_data` in `TransactionDataV1` is the gas payment.
- `GasData` allows a list of gas objects, but the same address must own them, namely the `owner` in `GasData` (the sponsor). When `owner` is equal to `sender`, then it is a regular/non-sponsored transaction.
- `tx_signatures` in `SenderSignedTransaction` is a list of signatures. For a sponsored transaction, the list needs to contain both signatures of the user and the sponsor in some order. The signatures are signed over the entire `TransactionData`, including `GasData`.

So, to construct a correct sponsored transaction, you must first build a `TransactionData` object. If you are neither the user or the sponsor, you would then pass the transaction to both parties to sign. If you're the sponsor, you would sign the transaction and then pass it and the signature to the other party (in the form of `SenderSignedTransaction`) for them to sign. In practice, the latter is the more common scenario. 

There are three flows of sponsored transaction.

**User proposed transaction**

([swimlane link](https://swimlanes.io/d/wAcnOpA_h))

![](https://static.swimlanes.io/b090340af36c8a4af6c36d4479a4d04f.png)

**Sponsor proposed transaction**

([swimlane link](https://swimlanes.io/#ZZE9T8QwDIb3/ApvLIWBsQMSEh8DEkI6mInb+O6itk4VOxInxH8nqe76AVki+X392G+iXnuq4fYGdmNgCRHeYhiDkIP3iCzYqg9syuGg2WmstWZMDYjG1Ora9YCK8G0gn2LoPLt6rb/kQjXLQuwo1rBL/t65SCKLdkD5dJlWwzNKwS4SfY0+YsFt2I9zuTI/047mEuj67pKthjmlHj13ki+CD6EIA56gIfCslFfRHN8zIOgyoQJkB2G/pyhZsefNLKDAiKeBWDczC7YG++d97EQ5264ExB8YNUUyZtpjbmyP1Hbb+cX7H7g0PqW+fw0uf5KkZvAKLmE/deU4K9Iv))

![](https://static.swimlanes.io/d917884a263c494bb6127102d0f64840.png)


**Wildcard gas payment**


([swimlane link](https://static.swimlanes.io/ee3962b3ac3cc5d34f317cecdde125b0.png))

![](https://static.swimlanes.io/ee3962b3ac3cc5d34f317cecdde125b0.png)


## Risk considerations {#risk}

Because at least two stakeholders are involved in a sponsored transaction, you should take steps to mitigate risk.

### Client equivocation risk

Client equivocation happens when more than one legit transaction that shares at least one owned object (such as a gas coin object) at a certain version are submitted to the network simultaneously. On Sui, before a transaction is executed, owned objects in this transaction are locked on validators at specific versions. An honest validator only accepts one transaction and rejects others. Depending on the order validators receive these transactions, validators might accept different transactions. In the event of no single transaction getting accepted by at least 2/3rds of validators, the owned object is locked until end of the epoch.

Practically speaking, client equivocation is rare, mostly caused by buggy client software. After all, no one has incentives to lock their own objects. However, sponsored transactions come with counterparty risks. For example, a malicious user could equivocate the gas station's gas coin object by submitting another transaction that uses one owned object in the gas station signed transaction at the same version. Similarly, a Byzantine gas station could do the same to the user owned objects.

Although this risk might seem trivial, it is helpful to be aware of it. Your gas station should actively monitor user behavior and alert on anything abnormal. Whether you're a user taking advantage of sponsored transactions or a developer integrating with a gas station, consider your reputation to minimize the risk of client equivocation.

Both the user and the sponsor need to sign over the entire `TransactionData`, including `GasData` because otherwise a third party (such as a malicious Full node) could snip the partially signed data and cause client equivocation and locking of owned objects. 

### Censorship risk

If you chooses to submit the dual-signed transaction to the sponsor or gas station rather than a Full node, the transaction might be subject to sponsor or gas station censorship. Namely, the sponsor might choose not to submit the transaction to the network, or delay the submission. 

You can mitigate this risk by submitting the transaction directly to a Full node.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101/using-events.mdx
```
---
title: Using Events
description: Use events to notify on-chain assets of activity your smart contracts initiate and query events from other packages to trigger logic based on emitted events.
---

The Sui network stores countless objects on chain where Move code can perform actions using those objects. Tracking this activity is often desired, for example, to discover how many times a module mints an NFT or to tally the amount of SUI in transactions that a smart contract generates.

To support activity monitoring, Move provides a structure to emit events on the Sui network. You can then leverage a custom indexer to process checkpoint data that includes events that have been emitted. See the [custom indexer](../advanced/custom-indexer.mdx) topic in the Advanced section to learn how to stream checkpoints and filter events continuously. 

If you don't want to run a custom indexer, you can poll the Sui network to query for emitted events instead. This approach typically includes a database to store the data retrieved from these calls. The [Poll events](#poll-events) section provides an example of using this method.

## Move event structure

An event object in Sui consists of the following attributes:

- `id`: JSON object containing the transaction digest ID and event sequence.
- `packageId`: The object ID of the package that emits the event.
- `transactionModule`: The module that performs the transaction.
- `sender`: The Sui network address that triggered the event.
- `type`: The type of event being emitted.
- `parsedJson`: JSON object describing the event.
- `bcs`: Binary canonical serialization value.
- `timestampMs`: Unix epoch timestamp in milliseconds.

## Emit events in Move

To create an event in your Move modules, add the `sui::event` dependency.

```move
use sui::event;
```

With the dependency added, you can use the `emit` function to trigger an event whenever the action you want to monitor fires. For example, the following code is part of an example application that enables the locking of objects. The `lock` function handles the locking of objects and emits an event whenever the function is called.

{@inject: examples/trading/contracts/escrow/sources/lock.move#fun=lock noComments}

### Query events with RPC

The Sui RPC provides a [queryEvents](/sui-api-ref#suix_queryEvents) method to query on-chain packages and return available events. As an example, the following `curl` command queries the Deepbook package on Mainnet for a specific type of event:

```sh
$ curl -X POST https://fullnode.mainnet.sui.io:443 \
-H "Content-Type: application/json" \
-d '{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_queryEvents",
  "params": [
    {
      "MoveModule": {
        "package": "0x158f2027f60c89bb91526d9bf08831d27f5a0fcb0f74e6698b9f0e1fb2be5d05",
        "module": "deepbook_utils",
        "type": "0xdee9::clob_v2::DepositAsset<0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>"
      }
    },
    null,
    3,
    false
  ]
}'
```

<details>
<summary>
A successful `curl` return
</summary>
```json
{
	"jsonrpc": "2.0",
	"result": {
		"data": [
			{
				"id": {
					"txDigest": "8NB8sXb4m9PJhCyLB7eVH4onqQWoFFzVUrqPoYUhcQe2",
					"eventSeq": "0"
				},
				"packageId": "0x158f2027f60c89bb91526d9bf08831d27f5a0fcb0f74e6698b9f0e1fb2be5d05",
				"transactionModule": "deepbook_utils",
				"sender": "0x8b35e67a519fffa11a9c74f169228ff1aa085f3a3d57710af08baab8c02211b9",
				"type": "0xdee9::clob_v2::WithdrawAsset<0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>",
				"parsedJson": {
					"owner": "0x704c8c0d8052be7b5ca7174222a8980fb2ad3cd640f4482f931deb6436902627",
					"pool_id": "0x7f526b1263c4b91b43c9e646419b5696f424de28dda3c1e6658cc0a54558baa7",
					"quantity": "6956"
				},
				"bcs": "2szz6igTRuGmD7YATo8BEg81VLaei4od62wehadwMXYJv63UzJE16USL9pHFYBAGbwNkDYLCk53d45eFj3tEZK1vDGqtXcqH5US",
				"timestampMs": "1691757698019"
			},
			{
				"id": {
					"txDigest": "8NB8sXb4m9PJhCyLB7eVH4onqQWoFFzVUrqPoYUhcQe2",
					"eventSeq": "1"
				},
				"packageId": "0x158f2027f60c89bb91526d9bf08831d27f5a0fcb0f74e6698b9f0e1fb2be5d05",
				"transactionModule": "deepbook_utils",
				"sender": "0x8b35e67a519fffa11a9c74f169228ff1aa085f3a3d57710af08baab8c02211b9",
				"type": "0xdee9::clob_v2::OrderFilled<0x2::sui::SUI, 0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>",
				"parsedJson": {
					"base_asset_quantity_filled": "0",
					"base_asset_quantity_remaining": "1532800000000",
					"is_bid": false,
					"maker_address": "0x78a1ff467e9c15b56caa0dedfcfbdfe47c0c385f28b05fdc120b2de188cc8736",
					"maker_client_order_id": "1691757243084",
					"maker_rebates": "0",
					"order_id": "9223372036854839628",
					"original_quantity": "1614700000000",
					"pool_id": "0x7f526b1263c4b91b43c9e646419b5696f424de28dda3c1e6658cc0a54558baa7",
					"price": "605100",
					"taker_address": "0x704c8c0d8052be7b5ca7174222a8980fb2ad3cd640f4482f931deb6436902627",
					"taker_client_order_id": "20082022",
					"taker_commission": "0"
				},
				"bcs": "DcVGz85dWTLU4S33N7VYrhgbkm79ENhHVnp5kBfENEWEeMxHQuvsczg94teh6WHdYtwPqdEsPWdvSJ7ne5qiMxxn3kBm36KLyuuzHV1QdzF45GN8ZU1MDGU4XppiaqcMeRpPPiW8JpUDyeQoobKEV8fMqcyYpDq6KWtZ1WMoGvEDxFKDgFvW9Q7bt1JAzQehRkEKEDZ6dTwfiHw92QuFqczmZ5MKJLYzeysUsSw",
				"timestampMs": "1691757698019"
			},
			{
				"id": {
					"txDigest": "8b3byDuRojHXqmSz16PsyzfdXJEY5nZBGTM23gMsMAY8",
					"eventSeq": "0"
				},
				"packageId": "0x158f2027f60c89bb91526d9bf08831d27f5a0fcb0f74e6698b9f0e1fb2be5d05",
				"transactionModule": "deepbook_utils",
				"sender": "0x8b35e67a519fffa11a9c74f169228ff1aa085f3a3d57710af08baab8c02211b9",
				"type": "0xdee9::clob_v2::OrderFilled<0x2::sui::SUI, 0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>",
				"parsedJson": {
					"base_asset_quantity_filled": "700000000",
					"base_asset_quantity_remaining": "0",
					"is_bid": false,
					"maker_address": "0x03b86e93d80b27763ee1fc2c37e285465dff835769de9462d9ad4ebcf46ac6df",
					"maker_client_order_id": "20082022",
					"maker_rebates": "634",
					"order_id": "9223372036854839643",
					"original_quantity": "1000000000",
					"pool_id": "0x7f526b1263c4b91b43c9e646419b5696f424de28dda3c1e6658cc0a54558baa7",
					"price": "604100",
					"taker_address": "0x704c8c0d8052be7b5ca7174222a8980fb2ad3cd640f4482f931deb6436902627",
					"taker_client_order_id": "20082022",
					"taker_commission": "1058"
				},
				"bcs": "DcVGz85dWTLU4S33N7VYrhgbkm79ENhHVnp5kBfENEWEjN45pa9U3AkNhxfTRZbaHTQLugLBXttE32hpJKRsbrZGdryXMPmNA8EpHJnVcnYMXZmWXkNXvY1XjEYnAKU4BnhyJ9BQuxRJDXLA4DEu5uWEpWjLPD2ZHuxqHCn7GpUxvxJjHkKjr9jVVfeR6sN2uRhUXkThEDjCekrqaqwidkyXNmTzmZG4fre3eoZ",
				"timestampMs": "1691758372427"
			}
		],
		"nextCursor": {
			"txDigest": "8b3byDuRojHXqmSz16PsyzfdXJEY5nZBGTM23gMsMAY8",
			"eventSeq": "0"
		},
		"hasNextPage": true
	},
	"id": 1
}
```
</details>

The TypeScript SDK provides a wrapper for the `suix_queryEvents` method: [`client.queryEvents`](https://sdk.mystenlabs.com/typedoc/classes/_mysten_sui.client.SuiClient.html#queryEvents).

<details>
<summary>
    TypeScript SDK queryEvents example
</summary>

```
import { useCurrentAccount, useSignAndExecuteTransaction, useSuiClient } from "@mysten/dapp-kit";
import { Transaction } from "@mysten/sui/transactions";
import { Button, Flex, Heading } from "@radix-ui/themes";

export function Creategame({ onCreated }: { onCreated: (id: string) => void }) {
  const { mutateAsync: signAndExecute } = useSignAndExecuteTransaction();
  const currentAccount = useCurrentAccount();
  const client = useSuiClient();

  const executeMoveCall = async (method: "small" | "large") => {
    if (!currentAccount?.address) {
      console.error("No connected account found.");
      return;
    }

    try {
      const tx = new Transaction();

      tx.moveCall({
        arguments: [tx.pure.u64(method === "small" ? 0 : 1)],
        target: `<PACKAGE-ID>::<MODULE>::create_game`,
      });

      const txResult = await signAndExecute({
        transaction: tx,
      });

      await client.waitForTransaction({
        digest: txResult.digest
      });

      const eventsResult = await client.queryEvents({
        query: { Transaction: txResult.digest },
      });

      if (eventsResult.data.length > 0) {
        const firstEvent = eventsResult.data[0]?.parsedJson as { msg?: string };
        const result = firstEvent?.msg || "No events found for the given criteria.";
        onCreated(result);
      } else {
        onCreated("No events found for the given criteria.");
      }
    } catch (error) {
      console.error("Error creating game or querying events:", error);
    }
  };

  return (
    <>
      <Heading size="3">Game Start</Heading>
      <Flex direction="column" gap="2">
        <Flex direction="row" gap="2">
          <Button onClick={() => executeMoveCall("small")}>small</Button>
          <Button onClick={() => executeMoveCall("large")}>large</Button>
        </Flex>
      </Flex>
    </>
  );
}
```
The example displays the following JSON representation of the event. 
```
{
  "id": {
    "txDigest": "46vSzYS9PaTWZDju2N8ECebAGLrXBdrP9NmvvydtDW2c",
    "eventSeq": "0"
  },
  "packageId": "<PACKAGE-ID>",
  "transactionModule": "<MODULE>",
  "sender": "<SENDER-ADDRESS>",
  "type": "<PACKAGE-ID>::<MODULE>::Result",
  "parsedJson": {
    "msg": "You Lose :("
  },
  "bcs": "DRUZAsJK2DLrBj27"
}
```
</details>


#### Filtering event queries

To filter the events returned from your queries, use the following data structures.

| Query             | Description                                              | JSON-RPC Parameter Example                                                                            |
| ----------------- | -------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| `All`             | All events                                               | `{"All": []}`                                                                                         |
| `Any`             | Events emitted from any of the given filter              | `{"Any": SuiEventFilter[]}`                                                                           |
| `Transaction`     | Events emitted from the specified transaction            | `{"Transaction":"DGUe2TXiJdN3FI6MH1FwghYbiHw+NKu8Nh579zdFtUk="}`                                      |
| `MoveModule`      | Events emitted from the specified Move module            | `{"MoveModule":{"package":"<PACKAGE-ID>", "module":"nft"}}`                                           |
| `MoveEventModule` | Events emitted, defined on the specified Move module.    | `{"MoveEventModule": {"package": "<DEFINING-PACKAGE-ID>", "module": "nft"}}`                          |
| `MoveEventType`   | Move struct name of the event                            | `{"MoveEventType":"::nft::MintNFTEvent"}`                                                             |                                                                   
| `Sender`          | Query by sender address                                  | `{"Sender":"0x008e9c621f4fdb210b873aab59a1e5bf32ddb1d33ee85eb069b348c234465106"}`                     |
| `TimeRange`       | Return events emitted in [start_time, end_time] interval | `{"TimeRange":{"startTime":1669039504014, "endTime":1669039604014}}`                                  | 

### Query events in Rust

The [Sui by Example](https://github.com/gdanezis/sui-by-example/blob/main/src/05_reading_events/bin/main.rs) repo on GitHub contains a code sample that demonstrates how to query events using the `query_events` function. The package that `PACKAGE_ID_CONST` points to exists on Mainnet, so you can test this code using Cargo. To do so, clone the `sui-by-example` repo locally and follow the [Example 05 directions](https://github.com/gdanezis/sui-by-example/tree/main/src/05_reading_events). 

```rust
use sui_sdk::{rpc_types::EventFilter, types::Identifier, SuiClientBuilder};

const PACKAGE_ID_CONST: &str = "0x279525274aa623ef31a25ad90e3b99f27c8dbbad636a6454918855c81d625abc";

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let sui_mainnet = SuiClientBuilder::default()
        .build("https://fullnode.mainnet.sui.io:443")
        .await?;

    let events = sui_mainnet
        .event_api()
        .query_events(
            EventFilter::MoveModule {
                package: PACKAGE_ID_CONST.parse()?,
                module: Identifier::new("dev_trophy")?,
            },
            None,
            None,
            false,
        )
        .await?;

    for event in events.data {
        println!("Event: {:?}", event.parsed_json);
    }

    Ok(())
}
```

### Query events with GraphQL

<BetaTag beta="true" slim="true"/>

You can use GraphQL to query events instead of JSON RPC. The following example queries are in the [`sui-graphql-rpc` crate](https://github.com/MystenLabs/sui/tree/main/crates/sui-graphql-rpc/examples/event_connection) in the Sui repo. 

<details>
<summary>
Event connection
</summary>
{@inject: crates/sui-graphql-rpc/examples/event_connection/event_connection.graphql}
</details>

<details>
<summary>
Filter events by sender
</summary>
{@inject: crates/sui-graphql-rpc/examples/event_connection/filter_by_sender.graphql}
</details>

The [TypeScript SDK](https://sdk.mystenlabs.com/typedoc/modules/_mysten_sui.graphql.html) provides functionality to interact with the Sui GraphQL service.

## Monitoring events

Firing events is not very useful in a vacuum. You also need the ability to respond to those events. There are two methods from which to choose when you need to monitor on-chain events:
- Incorporate a [custom indexer](../advanced/custom-indexer.mdx) to take advantage of Sui's micro-data ingestion framework.
- Poll the Sui network on a schedule to query events.

Using a custom indexer provides a near-real time monitoring of events, so is most useful when your project requires immediate reaction to the firing of events. Polling the network is most useful when the events you're monitoring don't fire often or the need to act on those events are not immediate. The following section provides a polling example.

### Poll events {#poll-events}

To monitor events, you need a database to store checkpoint data. The [Trustless Swap](../app-examples/trustless-swap.mdx) example uses a Prisma database to store checkpoint data from the Sui network. The database is populated from polling the network to retrieve emitted events. 

<details>
<summary>
`event-indexer.ts` from Trustless Swap
</summary>
{@inject: examples/trading/api/indexer/event-indexer.ts noComments}
</details>

Trustless Swap incorporates handlers to process each event type that triggers. For the `locked` event, the handler in `locked-handler.ts` fires and updates the Prisma database accordingly.

<details>
<summary>
`locked-handler.ts` from Trustless Swap
</summary>
{@inject: examples/trading/api/indexer/locked-handler.ts}
</details>

## Related links

- [Custom Indexer](../advanced/custom-indexer.mdx): For near-real time monitoring of events, you can use a custom indexer.
- [Events](https://move-book.com/programmability/events.html): The Move Book shows how to emit events in Move.
- [Trustless Swap](../app-examples/trustless-swap.mdx): The Trustless Swap guide uses events to update the state of its frontend.
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/sui-101/simulating-refs.mdx
```
---
title: Simulating References
description: Use the borrow module in the Sui framework to include objects by reference in your programmable transaction blocks.
---

Everything on the Sui blockchain is an object. When you develop Move packages for the Sui network, you're typically manipulating or using on-chain objects in some way through functionality available in the Sui API. For most API functions, you provide an object by reference.

References are a key construct when programming in Move and on Sui. Most of the functionality available in the Sui API takes objects by reference.

There are two ways to use an object:

- **by value:** When you use an object by value, you have full control over that object. You can destroy it (if the functionality is available), wrap it (if it has the `store` ability), or transfer it to an address.
- **by reference:** When you use an object by reference, operations over that object are determined by the logic the module that defines the object provides because you are using a reference to its data rather than having ownership of the object itself. The restrictions of references allow you to develop smart contracts with a high level of security and safety around assets. There are two types of references:
  - Mutable reference (`&mut`): You can alter the object (according to the API) but you can't destroy or transfer it.
  - Immutable reference (`&`): Further restricts the set of operations and the guarantees/invariants over the referenced object. You have read-only access to the object's data.

Programmable transaction blocks (PTBs) do not currently allow the use of object references returned from one of its transaction commands. You can use input objects to the PTB, objects created by the PTB (like `MakeMoveVec`), or returned from a transaction command by value as references in subsequent transaction commands. If a transaction command returns a reference, however, you can't use that reference in any call, significantly limiting certain common patterns in Move.

## The borrow module

The Sui framework includes a [borrow](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/borrow.md) module that offers a solution to the reference problem. The module provides access to an object by value but builds a model that makes it impossible to destroy, transfer, or wrap the object retrieved. The borrow module exposes a `Referent` object that wraps another object (the object you want to reference). The module uses the hot potato pattern (via a `Borrow` instance) to allow retrieval of the wrapped object by value. Within the same PTB, the module then forces the object to be returned to the `Referent`. The `Borrow` instance guarantees that the object returned is the same that was retrieved.

As an example, consider the following module stub that exposes an object (`Asset`) and a function (`use_asset`) to use that object.

```rust
module a_module {
    struct Asset has key, store {
        … // some data
    }

    public fun use_asset(asset: &Asset) {
        …. // some code
    }
}
```

The function `use_asset` takes an immutable reference to the asset (`&Asset`), which is a common pattern in an API definition.

Now consider another module that uses this asset.

```rust
module another_module {
    struct AssetManager has key {
        asset: Asset,
    }

    public fun get_asset(manager: &AssetManager): &Asset {
        &manager.asset
    }
}
```

This module creates an object (`AssetManager`) that references the object (`Asset`) created in the previous module (`a_module`).

You could then write a Move function that retrieves an object by reference and passes it to the `use_asset` function.

```rust
fun do_something(manager: &AssetManager) {
    let asset = another_module::get_asset(manager);
    a_module::use_asset(asset);
}
```

The two functions in `do_something` are not valid within a PTB, however, because PTBs do not support a reference returned by a function and passed to another function.

To make this operation valid within a PTB, you would need to include functionality from the borrow module. Consequently, you could change the `another_module` code to the following:

```rust
module another_module {
    struct AssetManager has key {
        asset: Referent<Asset>,
    }

    public fun get_asset(manager: &mut AssetManager): (Asset, Borrow) {
        borrow::borrow(&mut manager.asset)
    }


    public fun return_asset(
        manager: &mut AssetManager,
        asset: Asset,
        b: Borrow) {
            borrow::put_back(&mut manager.asset, asset, b)
    }
}
```

Now the PTB can retrieve the asset, use it in a call to `use_asset`, and return the asset.

## Considerations

The `Borrow` object is the key to the guarantees the borrow module offers. The definition of `Borrow` is
`struct Borrow { ref: address, obj: ID }`
which makes it such that you cannot drop or save its instance anywhere, so it must be consumed in the same transaction that retrieves it (hot potato). Moreover, fields in the `Borrow` struct make sure that the object returned is for the same `Referent` and the object that was originally held by the `Referent` instance. In other words, there is no way to either keep the object retrieved or to swap it with another object in a different `Referent`.

:::caution

Using a `Referent` is a very explicit and intrusive change. That has to be taken into consideration when designing a solution.

:::

Support for references in a PTB is planned, which is a much more natural and proper pattern for APIs.

You must consider the implications of using the borrow module and whether you have a mechanism to later move to a more natural, reference pattern.

Finally, the `Referent` model forces the usage of a mutable reference and returns an object by value. Both have significant implications when designing an API. You must be careful in what logic your modules provide and how objects are exposed.

## Example

Extending the previous example, a PTB that calls `use_asset` is written as follows:

```rust
// initialize the PTB
const txb = new TransactionBlock();
// load the assetManager
const assetManager = txb.object(assetManagerId);
// retrieve the asset
const [asset, borrow] = txb.moveCall({
    target: "0xaddr1::another_module::get_asset",
    arguments: [ assetManager ],
});
// use the asset
txb.moveCall({
    target: "0xaddr2::a_module::use_asset",
    arguments: [ asset ],
});
// return the asset
txb.moveCall({
    target: "0xaddr1::another_module::return_asset",
    arguments: [ assetManager, asset, borrow ],
});
...
```

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/first-app/debug.mdx
```
---
title: Debugging
description: Move does not have a native debugger. You can, however, use the std::debug module to monitor variable values while your code executes.
---

Move does not currently have a native debugger. You can use the `std::debug` module, however, to print arbitrary values to the console. Monitoring variable values in this manner can provide insight into the logic of your modules. To do so, first declare an alias to the debug module in your source file for more concise access:

```move
use std::debug;
```

Then in places where you want to print out a value `v`, regardless of its type, add the following code:

```move
debug::print(&v);
```

or the following if `v` is already a reference:

```move
debug::print(v);
```

The debug module also provides a function to print out the current stacktrace:

```move
debug::print_stack_trace();
```

Alternatively, any call to abort or assertion failure also prints the stacktrace at the point of failure.

## Using debug in my_module

To see the module in action, update your `my_module` code to include debug calls. Specifically, update the `new_sword` function so that you print the value of `forge` before and after updating `swords_created`. Also, include a `print_stack_trace` so that the function looks like the following:

```move
public fun new_sword(
    forge: &mut Forge,
    magic: u64,
    strength: u64,
    ctx: &mut TxContext,
): Sword {
    debug::print(forge);
    forge.swords_created = forge.swords_created + 1;
    debug::print(forge);
    debug::print_stack_trace();
    Sword {
        id: object::new(ctx),
        magic: magic,
        strength: strength,
    }
}
```

To see the results, run the module's tests.

```sh
$ sui move test
```

The response prints out the expected results as the test calls the `new_sword` function.

```sh
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING my_first_package
Running Move unit tests
[ PASS    ] 0x0::my_module::test_module_init
[debug] 0x0::my_module::Forge {
  id: 0x2::object::UID {
    id: 0x2::object::ID {
      bytes: @0x34401905bebdf8c04f3cd5f04f442a39372c8dc321c29edfb4f9cb30b23ab96
    }
  },
  swords_created: 0
}
[debug] 0x0::my_module::Forge {
  id: 0x2::object::UID {
    id: 0x2::object::ID {
      bytes: @0x34401905bebdf8c04f3cd5f04f442a39372c8dc321c29edfb4f9cb30b23ab96
    }
  },
  swords_created: 1
}
Call Stack:
    [0] 0000000000000000000000000000000000000000000000000000000000000000::my_module::test_module_init

        Code:
            [35] LdU64(7)
            [36] MutBorrowLoc(3)
            [37] Call(15)
          > [38] Call(5)
            [39] LdConst(0)
            [40] CallGeneric(2)
            [41] ImmBorrowLoc(3)

        Locals:
            [0] -
            [1] { { { <OBJECT-ID-WITHOUT-0x> } }, 1 }
            [2] -
            [3] { 2, { 00000000000000000000000000000000000000000000000000000000000000ad, [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 0, 0, 0 } }


Operand Stack:

[ PASS    ] 0x0::my_module::test_sword_transactions
Test result: OK. Total tests: 2; passed: 2; failed: 0
```

The output shows the value of the `swords_created` field of the `Forge` change after the increment. The stack trace shows the bytecode instructions that have been executed so far, and the next few instructions to execute. 

:::info

The specific bytecode offsets and the indices of the local variables might vary depending on the version of the Sui toolchain.

:::

## Related links

- [Publish a Package](./publish.mdx): Publish the example to the Sui network.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/first-app/publish.mdx
```
---
title: Publish a Package
---

Before you can call functions in a Move package (beyond an emulated Sui execution scenario), that package must be available on the Sui network. When you publish a package, you are actually creating an immutable Sui object on the network that anyone can access.

To publish your package to the Sui network, use the `publish` CLI command in the root of your package. Use the `--gas-budget` flag to set a value for the maximum amount of gas the transaction can cost. If the cost of the transaction is more than the budget you set, the transaction fails and your package doesn't publish. 

{@include: ../../../snippets/info-gas-budget.mdx}

```sh
$ sui client publish --gas-budget 5000000
```

If the publish transaction is successful, your terminal or console responds with the details of the publish transaction separated into sections, including transaction data, transaction effects, transaction block events, object changes, and balance changes. 

In the **Object Changes** table, you can find the information about the package you just published in the **Published Objects** section. Your response has the actual `PackageID` that identifies the package (instead of `<PACKAGE-ID>`) in the form `0x123...ABC`.  

```sh
╭─────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                      │
├─────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                    │
│  ...                                                                │
|                                                                     |
│ Mutated Objects:                                                    │
│  ...                                                                │
|                                                                     |
│ Published Objects:                                                  │
│  ┌──                                                                │
│  │ PackageID: <PACKAGE-ID>                                          │
│  │ Version: 1                                                       │
│  │ Digest: <DIGEST-HASH>                                            │
│  │ Modules: my_module                                               │
│  └──                                                                │
╰─────────────────────────────────────────────────────────────────────╯
```

Your currently active address now has three objects (or more, if you had objects prior to this example). Assuming you are using a new address, running the `sui objects` command reveals what those objects are.

```
$ sui client objects

╭───────────────────────────────────────────────────────────────────────────────────────╮
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  <OBJECT-ID>                                                         │ │
│ │ version    │  10                                                                  │ │
│ │ digest     │  <DIGEST-HASH>                                                       │ │
│ │ objectType │  <PACKAGE-ID>::my_module::Forge                                      │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  <OBJECT-ID>                                                         │ │
│ │ version    │  10                                                                  │ │
│ │ digest     │  <DIGEST-HASH>                                                       │ │
│ │ objectType │  0x0000..0002::coin::Coin                                            │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  <OBJECT-ID>                                                         │ │
│ │ version    │  10                                                                  │ │
│ │ digest     │  <DIGEST-HASH>                                                       │ │
│ │ objectType │  0x0000..0002::package::UpgradeCap                                   │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
╰───────────────────────────────────────────────────────────────────────────────────────╯
```

The `objectId` field is the unique identifier of each object. 

- `Coin` object: You received the Coin object from the Testnet faucet. It's value is slightly less than when you received it because of the cost of gas for the publish transaction. 
- `Forge` object: Recall that the `init` function runs when the package gets published. The `init` function for this example package creates a `Forge` object and transfers it to the publisher (you).
- `UpgradeCap` object: Each package you publish results in the receipt of an `UpgradeCap` object. You use this object to upgrade the package later or to burn it so the package cannot be upgraded.

```mermaid
flowchart TB

    subgraph Sui Blockchain
        direction TB
        address --> Forge
	address --> UpgradeCap
	address --> Coin
    end
```

### Interact with the package

Now that the package is on chain, you can call its functions to interact with the package. You can use the `sui client call` command to make individual calls to package functions, or you can construct more advanced blocks of transactions using the `sui client ptb` command. The `ptb` part of the command stands for [programmable transaction blocks](../../../concepts/transactions/prog-txn-blocks.mdx). In basic terms, PTBs allow you to group commands together in a single transaction for more efficient and cost-effective network activity.

```mermaid
flowchart TB
    my_module["my_module::new_sword(&Forge, strength, magic)"]
    
    Sui_client["Sui client"]

    subgraph Sui Blockchain
	my_module
	my_module --Sword--> address
    end
    
    Sui_client --"PTB"--> my_module
```

For example, you can create a new `Sword` object defined in the package by calling the `new_sword` function in the `my_module` package, and then transfer the `Sword` object to any address:

```sh
$ sui client ptb \
	--assign forge @<FORGE-ID> \
	--assign to_address @<TO-ADDRESS> \
	--move-call <PACKAGE-ID>::my_module::new_sword forge 3 3 \
	--assign sword \
	--transfer-objects "[sword]" to_address \
	--gas-budget 20000000
```

:::info 

{@include: ../../../snippets/address-prefix.mdx}

Depending on your shell and operating system, you might need to pass some values with quotes (`"`), for example: `--assign "forge @<FORGE-ID>"`.

:::

Make sure to replace `<FORGE-ID>`, `<TO-ADDRESS>`, and `<PACKAGE-ID>` with the actual `objectId` of the `Forge` object, the address of the recipient (your address in this case), and the `packageID` of the package, respectively. 

After the transaction executes, you can check the status of the `Sword` object by using the `sui client objects` command again. Provided you used your address as the `<TO-ADDRESS>`, you should now see a total of four objects:

```
╭───────────────────────────────────────────────────────────────────────────────────────╮
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  <OBJECT-ID>                                                         │ │
│ │ version    │  11                                                                  │ │
│ │ digest     │  <DIGEST-HASH>                                                       │ │
│ │ objectType │  <PACKAGE-ID>::my_module::Forge                                      │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  <OBJECT-ID>                                                         │ │
│ │ version    │  11                                                                  │ │
│ │ digest     │  <DIGEST-HASH>                                                       │ │
│ │ objectType │  0x0000..0002::coin::Coin                                            │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  <OBJECT-ID>                                                         │ │
│ │ version    │  11                                                                  │ │
│ │ digest     │  <DIGEST-HASH>                                                       │ │
│ │ objectType │  <PACKAGE-ID>::my_module::Sword                                      │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  <OBJECT-ID>                                                         │ │
│ │ version    │  10                                                                  │ │
│ │ digest     │  <DIGEST-HASH>                                                       │ │
│ │ objectType │  0x0000..0002::package::UpgradeCap                                   │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
╰───────────────────────────────────────────────────────────────────────────────────────╯
```

Congratulations! You have successfully published a package to the Sui network and modified the blockchain state by using a programmable transaction block. 

## Related links

- [Debugging](./debug.mdx): Print values to aid in logic debugging.
- [Package Upgrades](../../../concepts/sui-move-concepts/packages.mdx): Upgrading packages published on the Sui network.
- [Publish a Move Package](../../../references/cli/client.mdx#publish-a-move-package): More details about using the CLI to publish a package.
- [Programmable Transaction Blocks](../../../concepts/transactions/prog-txn-blocks.mdx): PTBs are collections of transactions that are executed together.
- [Sui Client PTB CLI](../../../references/cli/ptb.mdx): The `client ptb` command allows you to specify the transactions for execution in a programmable transaction block directly from your CLI or through bash scripts.
- [App Examples](../app-examples.mdx): End-to-end examples that include smart contract logic and frontend code.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/first-app/client-tssdk.mdx
```
---
title: Client App with Sui TypeScript SDK
---

This exercise diverges from the example built in the previous topics in this section. Rather than adding a frontend to the running example, the instruction walks you through setting up dApp Kit in a React App, allowing you to connect to wallets, and query data from Sui RPC nodes to display in your app. You can use it to create your own frontend for the example used previously, but if you want to get a fully functional app up and running quickly, run the following command in a terminal or console to scaffold a new app with all steps in this exercise already implemented:

{@include: ../../../snippets/info-pnpm-required.mdx}

```sh
$ pnpm create @mysten/dapp --template react-client-dapp
```

or

```sh
$ yarn create @mysten/dapp --template react-client-dapp
```

## What is the Sui TypeScript SDK?

The Sui TypeScript SDK (@mysten/sui) provides all the low-level functionality needed to interact with Sui ecosystem from TypeScript. You can use it in any TypeScript or JavaScript project, including web apps, Node.js apps, or mobile apps written with tools like React Native that support TypeScript.

For more information on the Sui TypeScript SDK, see the [Sui TypeScript SDK documentation](https://sdk.mystenlabs.com/typescript).

## What is dApp Kit?

dApp Kit (@mysten/dapp-kit) is a collection of React hooks, components, and utilities that make building dApps on Sui straightforward. For more information on dApp Kit, see the [dApp Kit documentation](https://sdk.mystenlabs.com/dapp-kit).

## Installing dependencies

To get started, you need a React app. The following steps apply to any React, so you can follow the same steps to add dApp Kit to an existing React app. If you are starting a new project, you can use Vite to scaffold a new React app.

Run the following command in your terminal or console, and select React as the framework, and then select one of the TypeScript templates:

```sh npm2yarn
$ npm init vite
```

Now that you have a React app, you can install the necessary dependencies to use dApp Kit:

```sh npm2yarn
$ npm install @mysten/sui @mysten/dapp-kit @tanstack/react-query
```

## Setting up Provider components

To use all the features of dApp Kit, wrap your app with a couple of `Provider` components.

Open the root component that renders your app (the default location the Vite template uses is `src/main.tsx`) and integrate or replace the current code with the following.

The first `Provider` to set up is the `QueryClientProvider` from `@tanstack/react-query`. This `Provider` manages request state for various hooks in dApp kit. If you're already using `@tanstack/react-query`, dApp Kit can share the same `QueryClient` instance.

```ts
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')!).render(
	<React.StrictMode>
		<QueryClientProvider client={queryClient}>
			<App />
		</QueryClientProvider>
	</React.StrictMode>,
);
```

Next, set up the `SuiClientProvider`. This `Provider` delivers a `SuiClient` instance from `@mysten/sui` to all the hooks in dApp Kit. This provider manages which network dApp Kit connects to, and can accept configuration for multiple networks. This exercise connects to `devnet`.

```ts
import { SuiClientProvider } from '@mysten/dapp-kit';
import { getFullnodeUrl } from '@mysten/sui/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();
const networks = {
	devnet: { url: getFullnodeUrl('devnet') },
	mainnet: { url: getFullnodeUrl('mainnet') },
};

ReactDOM.createRoot(document.getElementById('root')!).render(
	<React.StrictMode>
		<QueryClientProvider client={queryClient}>
			<SuiClientProvider networks={networks} defaultNetwork="devnet">
				<App />
			</SuiClientProvider>
		</QueryClientProvider>
	</React.StrictMode>,
);
```

Finally, set up the `WalletProvider` from `@mysten/dapp-kit`, and import styles for the `dapp-kit` components.

```ts
import '@mysten/dapp-kit/dist/index.css';

import { SuiClientProvider, WalletProvider } from '@mysten/dapp-kit';
import { getFullnodeUrl } from '@mysten/sui/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();
const networks = {
	devnet: { url: getFullnodeUrl('devnet') },
	mainnet: { url: getFullnodeUrl('mainnet') },
};

ReactDOM.createRoot(document.getElementById('root')!).render(
	<React.StrictMode>
		<QueryClientProvider client={queryClient}>
			<SuiClientProvider networks={networks} defaultNetwork="devnet">
				<WalletProvider>
					<App />
				</WalletProvider>
			</SuiClientProvider>
		</QueryClientProvider>
	</React.StrictMode>,
);
```

## Connecting to a wallet

With all `Providers` set up, you can use dApp Kit hooks and components. To allow users to connect their wallets to your dApp, add a `ConnectButton`.

```ts
import { ConnectButton } from '@mysten/dapp-kit';

function App() {
	return (
		<div className="App">
			<header className="App-header">
				<ConnectButton />
			</header>
		</div>
	);
}
```

The `ConnectButton` component displays a button that opens a modal on click, enabling the user to connect their wallet. Upon connection, it displays their address, and provides the option to disconnect.

## Getting the connected wallet address

Now that you have a way for users to connect their wallets, you can start using the `useCurrentAccount` hook to get details about the connected wallet account.

```ts
import { ConnectButton, useCurrentAccount } from '@mysten/dapp-kit';

function App() {
	return (
		<div className="App">
			<header className="App-header">
				<ConnectButton />
			</header>

			<ConnectedAccount />
		</div>
	);
}

function ConnectedAccount() {
	const account = useCurrentAccount();

	if (!account) {
		return null;
	}

	return <div>Connected to {account.address}</div>;
}
```

## Querying data from Sui RPC nodes

Now that you have the account to connect to, you can query for objects the connected account owns:

```ts
import { useCurrentAccount, useSuiClientQuery } from '@mysten/dapp-kit';

function ConnectedAccount() {
	const account = useCurrentAccount();

	if (!account) {
		return null;
	}

	return (
		<div>
			<div>Connected to {account.address}</div>;
			<OwnedObjects address={account.address} />
		</div>
	);
}

function OwnedObjects({ address }: { address: string }) {
	const { data } = useSuiClientQuery('getOwnedObjects', {
		owner: address,
	});
	if (!data) {
		return null;
	}

	return (
		<ul>
			{data.data.map((object) => (
				<li key={object.data?.objectId}>
					<a href={`https://example-explorer.com/object/${object.data?.objectId}`}>
						{object.data?.objectId}
					</a>
				</li>
			))}
		</ul>
	);
}
```

You now have a dApp connected to wallets and can query data from RPC nodes.

## Related links

The next step from here is to start interacting with Move modules, constructing transaction blocks, and making Move calls. This exercise continues in the Counter end-to-end example.

- [End-to-End Example](../app-examples/e2e-counter.mdx): Continue this exercise by creating an app.
- [Sui 101](../sui-101.mdx): Learn the basics of the Sui network and how to interact with on-chain objects using Move.
- [Sui Move CLI](/references/cli/move.mdx): The `move` commands in the Sui CLI provide console or terminal interaction with the Move VM.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/first-app/write-package.mdx
```
---
title: Write a Move Package
description: The first step in getting a package on chain is to write the Move code that defines the logic of your package. The structure of a Move package is similar to those in Rust.
---

To begin, open a terminal or console at the location you plan to store your package. Use the `sui move new` command to create an empty Move package with the name `my_first_package`:

```sh
$ sui move new my_first_package
```

Running the previous command creates a directory with the name you provide (`my_first_package` in this case). The command populates the new directory with a skeleton Move project that consists of a `sources` directory and a `Move.toml` manifest file. Open the manifest with a text editor to review its contents:

{@inject: examples/move/first_package/Move.toml}

The manifest file contents include available sections of the manifest and comments that provide additional information. In Move, you prepend the hash mark (`#`) to a line to denote a comment.

- **[package]:** Contains metadata for the package. By default, the `sui move new` command populates only the `name` value of the metadata. In this case, the example passes `my_first_package` to the command, which becomes the name of the package. You can delete the first `#` of subsequent lines of the `[package]` section to provide values for the other available metadata fields.
- **[dependencies]:** Lists the other packages that your package depends on to run. By default, the `sui move new` command lists the `Sui` package on GitHub (Testnet version) as the lone dependency.
- **[addresses]:** Declares named addresses that your package uses. By default, the section includes the package you create with the `sui move new` command and an address of `0x0`. This value can be left as-is and indicates that [package addresses are automatically managed](../../../../concepts/sui-move-concepts/packages/automated-address-management) when published and upgraded.
- **[dev-dependencies]:** Includes only comments that describe the section.
- **[dev-addresses]:** Includes only comments that describe the section.

### Defining the package

You have a package now but it doesn't do anything. To make your package useful, you must add logic contained in `.move` source files that define _modules_. The `sui move new` command creates a .move file in the `sources` directory that defaults to the same name as your project (`my_first_package.move` in this case). For the purpose of this guide, rename the file to `example.move` and open it with a text editor.

Populate the `example.move` file with the following code:

{@inject: examples/move/first_package/sources/example.move#first noTests}

The comments in the preceding code highlight different parts of a typical Move source file.

- **Part 1: Imports** - Code reuse is a necessity in modern programming. Move supports this concept with `use` aliases that allow your module to refer to types and functions declared in other modules. In this example, the module imports from `object`, `transfer`, and `tx_context` modules, but it does not need to do so explicitly, because the compiler provides these `use` statements by default. These modules are available to the package because the `Move.toml` file defines the Sui dependency (along with the `sui` named address) where they are defined.

- **Part 2: Struct declarations** - Structs define types that a module can create or destroy. Struct definitions can include abilities provided with the `has` keyword. The structs in this example, for instance, have the `key` ability, which indicates that these structs are Sui objects that you can transfer between addresses. The `store` ability on the structs provides the ability to appear in other struct fields and be transferred freely.

- **Part 3: Module initializer** - A special function that is invoked exactly once when the module publishes.

- **Part 4: Accessor functions** - These functions allow the fields of the module's structs to be read from other modules.

After you save the file, you have a complete Move package.

## Related links

- [Build and Test Packages](./build-test.mdx): Continue this example to build and test your package to get it ready for publishing.
- [Sui Move CLI](../../../references/cli/move.mdx): Available Move commands the CLI provides.
- [Sui Move Book](https://move-book.com/): A comprehensive guide to the Move programming language and the Sui blockchain.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/first-app/build-test.mdx
```
---
title: Build and Test Packages
---

If you followed [Write a Move Package](./write-package.mdx), you have a basic module that you need to build. If you didn't, then either start with that topic or use your package, substituting that information where appropriate.

## Building your package

Make sure your terminal or console is in the directory that contains your package (`my_first_package` if you're following along). Use the following command to build your package:

```sh
$ sui move build
```

A successful build returns a response similar to the following:

```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING my_first_package
```

If the build fails, you can use the verbose error messaging in output to troubleshoot and resolve root issues.

Now that you have designed your asset and its accessor functions, it's time to test the package code before publishing.

## Testing a package {#testing-a-package}

Sui includes support for the Move testing framework. Using the framework, you can write unit tests that analyze Move code much like test frameworks for other languages, such as the built-in Rust testing framework or the JUnit framework for Java.

An individual Move unit test is encapsulated in a public function that has no parameters, no return values, and has the `#[test]` annotation. The testing framework executes such functions when you call the `sui move test` command from the package root (`my_move_package` directory as per the current running example):

```sh
$ sui move test
```

If you execute this command for the package created in [Write a Package](./write-package.mdx), you see the following output. Unsurprisingly, the test result has an `OK` status because there are no tests written yet to fail.

```sh
BUILDING Sui
BUILDING MoveStdlib
BUILDING my_first_package
Running Move unit tests
Test result: OK. Total tests: 0; passed: 0; failed: 0
```

To actually test your code, you need to add test functions. Start with adding a basic test function to the `example.move` file, inside the module definition:

{@inject: examples/move/first_package/sources/example.move#first-test}

As the code shows, the unit test function (`test_sword_create()`) creates a dummy instance of the `TxContext` struct and assigns it to `ctx`. The function then creates a sword object using `ctx` to create a unique identifier and assigns `42` to the `magic` parameter and `7` to `strength`. Finally, the test calls the `magic` and `strength` accessor functions to verify that they return correct values.

The function passes the dummy context, `ctx`, to the `object::new` function as a mutable reference argument (`&mut`), but passes `sword` to its accessor functions as a read-only reference argument, `&sword`.

Now that you have a test function, run the test command again:

```sh
$ sui move test
```

After running the `test` command, however, you get a compilation error instead of a test result:

```sh
error[E06001]: unused value without 'drop'
   ┌─ ./sources/example.move:59:65
   │
 9 │       public struct Sword has key, store {
   │                     ----- To satisfy the constraint, the 'drop' ability would need to be added here
   ·
52 │           let sword = Sword {
   │               ----- The local variable 'sword' still contains a value. The value does not have the 'drop' ability and must be consumed before the function returns
   │ ╭─────────────────────'
53 │ │             id: object::new(&mut ctx),
54 │ │             magic: 42,
55 │ │             strength: 7,
56 │ │         };
   │ ╰─────────' The type 'my_first_package::example::Sword' does not have the ability 'drop'
   · │
59 │           assert!(sword.magic() == 42 && sword.strength() == 7, 1);
   │                                                                   ^ Invalid return
```

The error message contains all the necessary information to debug the code. The faulty code is meant to highlight one of the Move language's safety features.

The `Sword` struct represents a game asset that digitally mimics a real-world item. Obviously, a real sword cannot simply disappear (though it can be explicitly destroyed), but there is no such restriction on a digital one. In fact, this is exactly what's happening in the `test` function - you create an instance of a `Sword` struct that simply disappears at the end of the function call. If you saw something disappear before your eyes, you'd be dumbfounded, too.

One of the solutions (as suggested in the error message), is to add the `drop` ability to the definition of the `Sword` struct, which would allow instances of this struct to disappear (be dropped). The ability to drop a valuable asset is not a desirable asset property in this case, so another solution is needed. Another way to solve this problem is to transfer ownership of the `sword`.

To get the test to work, we will need to use the `transfer` module, which is imported by default. Add the following lines to the end of the test function (after the `assert!` call) to transfer ownership of the `sword` to a freshly created dummy address:

{@inject: examples/move/first_package/sources/example.move#test-dummy noComments}

Run the test command again. Now the output shows a single successful test has run:

```sh
BUILDING MoveStdlib
BUILDING Sui
BUILDING my_first_package
Running Move unit tests
[ PASS    ] 0x0::example::test_sword_create
Test result: OK. Total tests: 1; passed: 1; failed: 0
```

:::tip

Use a filter string to run only a matching subset of the unit tests. With a filter string provided, the `sui move test` checks the fully qualified (`<address>::<module_name>::<fn_name>`) name for a match.

:::

Example:

```sh
$ sui move test sword
```

The previous command runs all tests whose name contains `sword`.

You can discover more testing options through:

```sh
$ sui move test -h
```

## Sui-specific testing

The previous testing example uses Move but isn't specific to Sui beyond using some Sui packages, such as `sui::tx_context` and `sui::transfer`. While this style of testing is already useful for writing Move code for Sui, you might also want to test additional Sui-specific features. In particular, a Move call in Sui is encapsulated in a Sui transaction, and you might want to test interactions between different transactions within a single test (for example, one transaction creating an object and the other one transferring it).

Sui-specific testing is supported through the `test_scenario` module that provides Sui-related testing functionality otherwise unavailable in pure Move and its testing framework.

The `test_scenario` module provides a scenario that emulates a series of Sui transactions, each with a potentially different user executing them. A test using this module typically starts the first transaction using the `test_scenario::begin` function. This function takes an address of the user executing the transaction as its argument and returns an instance of the `Scenario` struct representing a scenario.

An instance of the `Scenario` struct contains a per-address object pool emulating Sui object storage, with helper functions provided to manipulate objects in the pool. After the first transaction finishes, subsequent test transactions start with the `test_scenario::next_tx` function. This function takes an instance of the `Scenario` struct representing the current scenario and an address of a user as arguments.

Update your `example.move` file to include a function callable from Sui that implements `sword` creation. With this in place, you can then add a multi-transaction test that uses the `test_scenario` module to test these new capabilities. Put this functions after the accessors (Part 5 in comments).

{@inject: examples/move/first_package/sources/example.move#fun=sword_create noComments}

The code of the new functions uses struct creation and Sui-internal modules (`tx_context`) in a way similar to what you have seen in the previous sections. The important part is for the function to have correct signatures.

With the new function included, add another test function to make sure it behaves as expected.

{@inject: examples/move/first_package/sources/example.move#fun=test_sword_transactions}

There are some details of the new testing function to pay attention to. The first thing the code does is create some addresses that represent users participating in the testing scenario. The test then creates a scenario by starting the first transaction on behalf of the initial sword owner.

The initial owner then executes the second transaction (passed as an argument to the `test_scenario::next_tx` function), who then transfers the `sword` they now own to the final owner. In pure Move there is no notion of Sui storage; consequently, there is no easy way for the emulated Sui transaction to retrieve it from storage. This is where the `test_scenario` module helps - its `take_from_sender` function allows an address-owned object of a given type (`Sword`) executing the current transaction to be available for Move code manipulation. For now, assume that there is only one such object. In this case, the test transfers the object it retrieves from storage to another address.

:::tip

Transaction effects, such as object creation and transfer become visible only after a given transaction completes. For example, if the second transaction in the running example created a `sword` and transferred it to the administrator's address, it would only become available for retrieval from the administrator's address (via `test_scenario`, `take_from_sender`, or `take_from_address` functions) in the third transaction.

:::

The final owner executes the third and final transaction that retrieves the `sword` object from storage and checks if it has the expected properties. Remember, as described in [Testing a package](#testing-a-package), in the pure Move testing scenario, after an object is available in Move code (after creation or retrieval from emulated storage), it cannot simply disappear.

In the pure Move testing function, the function transfers the `sword` object to the fake address to handle the disappearing problem. The `test_scenario` package provides a more elegant solution, however, which is closer to what happens when Move code actually executes in the context of Sui - the package simply returns the `sword` to the object pool using the `test_scenario::return_to_sender` function. For scenarios where returning to the sender is not desirable or if you would like to simply destroy the object, the `test_utils` module also provides the generic `destroy<T>` function, that can be used on any type `T` regardless of its ability. It is advisable to check out other useful functions in the [`test_scenario`](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/test/test_scenario.move) and [`test_utils`](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/test/test_utils.move) modules as well.

Run the test command again to see two successful tests for our module:

```sh
BUILDING Sui
BUILDING MoveStdlib
BUILDING my_first_package
Running Move unit tests
[ PASS    ] 0x0::example::test_sword_create
[ PASS    ] 0x0::example::test_sword_transactions
Test result: OK. Total tests: 2; passed: 2; failed: 0
```

### Module initializers

Each module in a package can include a special initializer function that runs at publication time. The goal of an initializer function is to pre-initialize module-specific data (for example, to create singleton objects). The initializer function must have the following properties for it to execute at publication:

- Function name must be `init`.
- The parameter list must end with either a `&mut TxContext` or a `&TxContext` type.
- No return values.
- Private visibility.
- Optionally, the parameter list starts by accepting the module's one-time witness by value. See [One Time Witness](https://move-book.com/programmability/one-time-witness.html) in The Move Book for more information.

For example, the following `init` functions are all valid:

- `fun init(ctx: &TxContext)`
- `fun init(ctx: &mut TxContext)`
- `fun init(otw: EXAMPLE, ctx: &TxContext)`
- `fun init(otw: EXAMPLE, ctx: &mut TxContext)`

While the `sui move` command does not support publishing explicitly, you can still test module initializers using the testing framework by dedicating the first transaction to executing the initializer function.

The `init` function for the module in the running example creates a `Forge` object.

{@inject: examples/move/first_package/sources/example.move#fun=init noComments}

The tests you have so far call the `init` function, but the initializer function itself isn't tested to ensure it properly creates a `Forge` object. To test this functionality, add a `new_sword` function to take the forge as a parameter and to update the number of created swords at the end of the function. If this were an actual module, you'd replace the `sword_create` function with `new_sword`. To keep the existing tests from failing, however, we will keep both functions.

{@inject: examples/move/first_package/sources/example.move#fun=new_sword noComments}

Now, create a function to test the module initialization:

{@inject: examples/move/first_package/sources/example.move#fun=test_module_init}

As the new test function shows, the first transaction (explicitly) calls the initializer. The next transaction checks if the `Forge` object has been created and properly initialized. Finally, the admin uses the `Forge` to create a sword and transfer it to the initial owner.

You can refer to the source code for the package (with all the tests and functions properly adjusted) in the [first_package](https://github.com/MystenLabs/sui/tree/main/examples/move/first_package/sources/example.move) module in the `sui/examples` directory. You can also use the following toggle to review the complete code.

<details>
<summary>
`example.move` 
</summary>

{@inject: examples/move/first_package/sources/example.move}

</details>

## Related links

- [Publish a Package](./publish.mdx): Continue the example by publishing your package to the Sui network.
- [Package Upgrades](../../../concepts/sui-move-concepts/packages.mdx): Upgrading packages published on the Sui network.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/blackjack.mdx
```
---
title: Blackjack
description: Learn Sui using an example implementation of the popular casino game blackjack.
---

The following documentation goes through an example implementation of the popular casino game blackjack on Sui. This guide walks through its components, providing a detailed look at the module's functions, structures, constants, and their significance in the overall gameplay mechanism.

A deployed version of the blackjack game is online at [Mysten Blackjack](https://blackjack-sui.vercel.app/).

Building an on-chain blackjack game shares a lot of similarities with a coin flip game. This example covers the smart contracts (Move modules), backend logic (using serverless functions), and frontend logic.

:::info

For more details on building a backend and deploying to Sui, check out the [Coin Flip app example](./coin-flip.mdx).

You can also find the [full repository for this example here](https://github.com/MystenLabs/blackjack-sui).

:::

## Gameplay

In this single-player version of blackjack, the player competes against a dealer, which is automated by the system. The dealer is equipped with a public BLS key that plays a central role in the game's mechanics. The dealer's actions are triggered by HTTP requests to serverless functions. Players generate randomness for the game by interacting with their mouse on the screen, after which they place their bet to start the game. Upon initiating the game, a request is made to the backend (dealer), which processes it by signing and subsequently dealing two cards to the player and one to themselves.

The player has the option to 'Hit' or 'Stand.' Selecting 'Stand' triggers the dealer to draw cards until the total reaches 17 or higher. After the dealer stops, the smart contract steps in to compare the totals and declare the winner. On the other hand, choosing 'Hit' prompts the dealer to draw an additional card for the player.

Note that more complex blackjack rules, such as splitting, are considered out of scope for this example, and are therefore not implemented.

## Smart contracts

### Game module

The [`single_player_blackjack.move`](https://github.com/MystenLabs/blackjack-sui/blob/main/move/blackjack/sources/single_player_blackjack.move) module includes several constants that define game statuses and help track the game's progress:

- `IN_PROGRESS`
- `PLAYER_WON_STATUS`
- `HOUSE_WON_STATUS`
- `TIE_STATUS`

There are also constants for error handling, such as `EInvalidBlsSig`, `EInsufficientBalance`, and others, ensuring robust game mechanics.

Structs like `GameCreatedEvent`, `GameOutcomeEvent`, and `HitDoneEvent` capture the various events and actions within a game. The `HitRequest` and `StandRequest` structs ensure that a move (hit/stand) can be performed by the house only if the player has already requested it. `HouseAdminCap` and `HouseData` are crucial for maintaining the house's data, including balance and public key, while the `Game` struct contains all the necessary information about each game, such as player data, cards, and the current status.

The module's functions can be broadly categorized into initialization, game management, and utility functions. The `init` function sets up the house admin capability, while `initialize_house_data` prepares the house for the game by setting up the balance and public key. `place_bet_and_create_game` is the entry point for players to start a new game, involving a bet and random input. The functions `first_deal`, `hit`, and `stand` govern the core gameplay, handling the dealing of cards and player choices.

Utility functions like `get_next_random_card` and `get_card_sum` are essential for the game's mechanics, generating random cards and calculating hand values. The module also includes accessors for retrieving various pieces of game and house data.

For testing purposes, the module provides special functions like `get_house_admin_cap_for_testing`, `player_won_post_handling_for_test` and `house_won_post_handling_for_test`, ensuring that developers can thoroughly test the game mechanics and house data handling.

### Counter module

The next module, [`counter_nft.move`](https://github.com/MystenLabs/blackjack-sui/blob/main/move/blackjack/sources/counter_nft.move), introduces the Counter NFT, a key component in the game's mechanics. It serves as the [verifiable random function (VRF)](../cryptography/ecvrf.mdx) input, ensuring uniqueness in each game. The Counter NFT's value increases after each use, maintaining its distinctiveness for every new request. For first-time players, the creation of a Counter NFT is mandatory. To enhance user experience, the user interface can automate this process by integrating the Counter NFT's creation with the game initiation in a single transaction block. This seamless integration simplifies the process for the player, allowing them to focus on the gameplay. This counter serves the same purpose as the one in the [Coin Flip example](./coin-flip.mdx).

## Backend

The backend is used for all the transactions that are executed by the dealer. The backend can be completely stateless, and for that reason serverless functions are utilized. As a result, the corresponding code lies under the [app/src/app/api/ directory](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api).

### Directories structure

The backend code is split in the following sub directories:

- [games/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api/games):
  The main code of the backend endpoints. Each file that is named `route.ts` is served as an endpoint, in the path defined by the project structure (see [Route Segments on NextJS App Router](https://nextjs.org/docs/app/building-your-application/routing#route-segments) for details)
- [health/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api/health): A simple healthcheck endpoint to check the API availability
- [helpers/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api/helpers): Multiple helper functions used in various endpoints
- [services/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api/services): The core logic of the backend, that signs and executes the transactions on the Sui blockchain
- [utils/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api/utils): Reusable methods for signing the transactions as the dealer, and sponsoring them with Shinami, to avoid gas coins equivocation

### High-Level endpoints specification

| HTTP Method | Path                    | Description                                                   | Request Body                                      |
| ----------- | ----------------------- | ------------------------------------------------------------- | ------------------------------------------------- |
| GET         | `/api/health`           | A simple healthcheck endpoint to check the API availability   | txDigest                                          |
| POST        | `/api/games/{id}/deal`  | Executes the initial deal transaction after the game creation | txDigest                                          |
| POST        | `/api/games/{id}/hit`   | Executes a hit move                                           | txDigest, id of corresponding HitRequest object   |
| POST        | `/api/games/{id}/stand` | Executes a stand move                                         | txDigest, id of corresponding StandRequest object |

### Need of usage of waitForTransaction

An interesting aspect of developing a dApp on Sui, that is coupled to using a full node with/without a load balancer, and requires attention by the developer, is the occurrence of read-after-write and write-after-write cases.

#### Initial deal transaction

As an example, in the blackjack game, just after the create-game transaction that the user executes, the dealer executes the initial-deal transaction. This one accepts an argument and modifies the game object, meaning that you are using an object that was just created.

To ensure that the game object is available in the Full node that the dealer is using, we need to call waitForTransaction after the create-game transaction.

#### Hit and stand transactions

In the same way, every time you re-fetch the game object in the frontend, make sure that the previous transaction that modified the game object is already available in the Full node.

This leads to the need of exchanging the `txDigest` between the frontend and the backend, and use `waitForTransaction` on each write-after-write or read-after-write case.

## Frontend

The [`page` component](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/page.tsx), a central element of the blackjack game's frontend module, is structured to create an interactive and responsive gaming experience. Written in React, it integrates several features and functions to handle the game's logic and user interactions effectively.

### Directories structure

The frontend is a NextJS project, that follows the NextJS App Router [project structure](https://nextjs.org/docs/app/building-your-application/routing).
The main code of the frontend lies under the [app/src/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/) directory.
The main sub-directories are:

- [app/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/): The main code of the pages and the API endpoints.
- [components/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components): The reusable components of the app, organized in sub-directories.
- [hooks/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks): The custom hooks used in the app.
- [helpers/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/helpers), [utils/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/utils), [lib/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/lib): Multiple helper functions and utilities.
- [types/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/types): The types/interfaces used in the app.
- [styles/](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/styles): The global css files to style our app.

### Components and custom hooks for state management

- **Custom Hooks:** To keep the code as structured as possible, multiple custom hooks are utilized to manage the complex state of the game board at each step. The [useBlackjackGame](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useBlackjackGame.ts) custom hook encapsulates the game state and logic, exposing all the required information (with fields such as `game`, `isInitialDealLoading`), and the required functionality (with methods such as `handleCreateGame` and `handleHit`) to display and play the game. Multiple additional custom hooks, such as [useCreateBlackjackGame](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useCreateBlackjackGame.ts), and [useMakeMoveInBlackjackGame](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useMakeMoveInBlackjackGame.ts) are encapsulating their own piece of state and logic to make the code readable and maintainable.

- **Component for Game Initialization:** The [StartGame](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/StartGame.tsx) component is implemented to facilitate the creation of a new game. It renders the [CollectMouseRandomness](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/CollectMouseRandomness.tsx) to capture the randomness and uses the `handleCreateGame` function of the [useBlackjackGame](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useBlackjackGame.ts) hook to execute the create-game transaction.

- **Randomness Generation:** Fair game outcomes are also ensured by the [CollectMouseRandomness](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/CollectMouseRandomness.tsx) component. This component is using the [useMouseRandomness](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useMouseRandomness.ts) custom hook, and is in charge of capturing some user's mouse movements and generating a random bytes array. This array is converted to a hexadecimal string (`randomness`) and used in the create-game transaction.

- **Card Displaying and Management:** The [DealerCards](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/DealerCards.tsx) and the [PlayerCards](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/PlayerCards.tsx) components are used to display the total points and the cards owned by the dealer and the player respectively.

- **Game Actions:** The [GameActions](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/GameActions.tsx) component is used to display the Hit and Stand buttons, and trigger the corresponding actions, as they are exported by the [useBlackjackGame](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useBlackjackGame.ts) hook to execute the corresponding transactions.

- **BlackjackBanner**: The [BlackjackBanner](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/BlackjackBanner.tsx) component is used as a custom view to display when the player wins with a blackjack.

## Comparison: Blackjack and Coin Flip

### Similarities

- **Blockchain-Based Logic:** Both games are built on Sui, leveraging its capabilities for decentralized applications. The core game logic for each resides in Move modules, ensuring secure and verifiable gameplay.

- **State Management:** In both games, state management is crucial. For blackjack, this involves managing the player and dealer's hands and scores using React state hooks. In Satoshi Coin Flip, the state is managed through Move structs like `HouseData`, which track the house's balance and other game-related details.

- **Randomness and Fair Play:** Both games emphasize randomness for fairness. Blackjack uses a Counter NFT and player mouse movements to generate randomness, while Satoshi Coin Flip only uses a Counter NFT as a unique input for the [Verifiable Random Function (VRF)](../cryptography/ecvrf.mdx) in each game.

- **Smart Contract Interactions:** Each game involves smart contract interactions for game actions like placing bets, dealing cards (Blackjack), or making guesses (Coin Flip). These interactions are crucial for executing the game's logic on the blockchain.

### Differences

- **Game Mechanics and Complexity:** Blackjack is a more complex game with multiple actions (hit, stand, deal) and state updates, requiring a more dynamic frontend. In contrast, Satoshi Coin Flip has a simpler mechanic centered around a single bet and guess outcome.

- **User Interface (UI) Complexity:** The Blackjack game involves a more intricate UI to display cards, manage game states, and player interactions. Satoshi Coin Flip, being simpler in gameplay, requires a less complex UI.

- **Backend Processing:** In Blackjack, the dealer is automated (the machine), and the player's actions directly influence game outcomes. In the Coin Flip game, the house (smart contract) plays a more passive role, primarily in initializing and finalizing the game based on the player's guess.

- **Module Structure and Focus:** The Blackjack game focuses more on frontend interactions and real-time updates. The Satoshi Coin Flip game, delves into backend logic, with structures like `HouseCap` and `house_data` for initializing and managing game data securely on the blockchain.

- **Multi-Version Implementation:** The Satoshi Coin Flip game mentions two versions – one susceptible to MEV attacks and another that is resistant, indicating a focus on security and user experience variations. Such variations aren't implemented in Blackjack.

:::info

The complete app example can be found in [the blackjack-sui repo](https://github.com/MystenLabs/blackjack-sui).

:::

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/plinko.mdx
```
---
title: Plinko
description: Learn Sui through an example implementation of the popular casino game, Plinko.
---

Plinko is an example implementation of the popular casino game. The Plinko game on Sui incorporates advanced cryptographic techniques to ensure fairness and transparency. Players drop Plinko balls onto a pegged board, where they randomly fall into slots representing different multipliers. This document details the game's mechanics, cryptographic features, and the methodology for calculating trace paths and verifying signatures.

Building an on-chain Plinko game shares a lot of similarities with the [Coin Flip](./coin-flip.mdx) game and [Blackjack](./blackjack.mdx) game. For that reason, this example covers only the smart contracts (Move modules) and frontend logic.

:::info

You can find the source files for this example in the [Plinko repo](https://github.com/MystenLabs/plinko-poc/tree/main) on GitHub.

A version of the game is also deployed at [Mysten Plinko](https://plinko-poc.vercel.app/).

:::

## Gameplay

The Plinko game, implemented through smart contracts on the Sui blockchain, incorporates cryptographic techniques to ensure fairness and transparency. Utilizing a blend of BLS signatures, hash functions, and verifiable random function (VRF) inputs, the game calculates the trace path for each ball, determining the game's outcome based on the number of Plink balls a player chooses to drop.

The game mechanics involve a player starting a game by specifying the number of balls and staking a certain amount. The backend generates a BLS signature for the game's randomness source, which is verified on-chain to ensure it's untampered. The game uses a Counter NFT for each round to generate a unique VRF input, ensuring each game's randomness is distinct and cannot be predicted or repeated. The number of Plinko balls, chosen by the player, directly influences the game's complexity and potential payout, as each ball's final position is determined by traversing a cryptographic trace path generated from the hashed BLS signature extended to accommodate the total number of balls.

## Sequence diagram

```mermaid
sequenceDiagram
    participant Player as Player
    participant UI as Next.js Application
    participant API as Backend API
    participant Blockchain as Sui Blockchain

    Note over Player, Blockchain: Plinko Game Interaction Flow

    Player->>+UI: Places bet, selects number of balls, presses play
    UI->>Player: Displays game as pending, awaiting outcome
    UI->>+Blockchain: Sends bet and number of balls
    UI->>+Blockchain: Calls counter_nft::mint to produce vrf_input, calls plinko::start_game
    Note over Blockchain: Checks stakes, balances, creates and increments the counter, emits 'NewGame' event
    Blockchain-->>-UI: Returns gameId, vrfInput
    UI->>+API: POST /game/plinko/end with { gameId, vrfInput, numberOfBalls }
    Note over UI: Reads from the 'NewGame' event gameId, vrfInput
    Note over API: Signs vrfInput with house's private key
    API->>+Blockchain: Calls plinko::finish_game with signed vrfInput
    Note over Blockchain: Verifies signature, calculates outcome (payments, balls' trace paths), emits Outcome event
    Blockchain-->>-API: Returns game outcome event (trace paths, winnings)
    API-->>-UI: Sends game outcome (trace paths, winnings)
    UI-->>-Player: Displays game result, balls' descend, and winnings
```

## Move modules

Follow the comments in each module's code to understand the logic each creates.

### plinko::plinko

The `plinko::plinko` module combines various Sui blockchain features, such as coin handling, event emissions, and dynamic object fields, to create on-chain Plinko games.

```move title="plinko.move"
module plinko::plinko {
// === Imports ===
use sui::coin::{Self, Coin};
use sui::balance::Balance;
use sui::sui::SUI;
use sui::bls12381::bls12381_min_pk_verify;
use sui::event::emit;
use sui::hash::{blake2b256};
use sui::dynamic_object_field::{Self as dof};

// Import Counter NFT module
use plinko::counter_nft::Counter;

// Import HouseData module
use plinko::house_data::HouseData;

// === Errors ===
const EStakeTooLow: u64 = 0;
const EStakeTooHigh: u64 = 1;
const EInvalidBlsSig: u64 = 2;
const EInsufficientHouseBalance: u64 = 5;
const EGameDoesNotExist: u64 = 6;

// === Structs ===

/// Represents a game and holds the accrued stake.
public struct Game has key, store {
    id: UID,
    game_start_epoch: u64,
    stake: Balance<SUI>,
    player: address,
    // The VRF input used to generate the extended beacon
    vrf_input: vector<u8>,
    fee_bp: u16
}

// === Events ===

/// Emitted when a new game has started.
public struct NewGame has copy, drop {
    game_id: ID,
    player: address,
    vrf_input: vector<u8>,
    user_stake: u64,
    fee_bp: u16
}

/// Emitted when a game has finished.
public struct Outcome has copy, drop {
    game_id: ID,
    result: u64,
    player: address,
    // The trace path of the extended beacon
    trace: vector<u8>
}

// === Public Functions ===

/// Function used to create a new game. The player must provide a Counter NFT and the number of balls.
public fun start_game(counter: &mut Counter, num_balls: u64, coin: Coin<SUI>, house_data: &mut HouseData, ctx: &mut TxContext): ID {
    let fee_bp = house_data.base_fee_in_bp();
    let (id, new_game) = internal_start_game(counter, num_balls, coin, house_data, fee_bp, ctx);
    dof::add(house_data.borrow_mut(), id, new_game);
    id
}

/// finish_game Completes the game by calculating the outcome and transferring the funds to the player.
/// The player must provide a BLS signature of the VRF input and the number of balls to calculate the outcome.
/// It emits an Outcome event with the game result and the trace path of the extended beacon.
public fun finish_game(game_id: ID, bls_sig: vector<u8>, house_data: &mut HouseData, num_balls: u64, ctx: &mut TxContext): (u64, address, vector<u8>) {
    // Ensure that the game exists.
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);

    // Retrieves and removes the game from HouseData, preparing for outcome calculation.
    let Game {
        id,
        game_start_epoch: _,
        stake,
        player,
        vrf_input,
        fee_bp: _
    } = dof::remove<ID, Game>(house_data.borrow_mut(), game_id);

    object::delete(id);

    // Validates the BLS signature against the VRF input.
    let is_sig_valid = bls12381_min_pk_verify(&bls_sig, &house_data.public_key(), &vrf_input);
    assert!(is_sig_valid, EInvalidBlsSig);

    // Initialize the extended beacon vector and a counter for hashing.
    let mut extended_beacon = vector[];
    let mut counter: u8 = 0;

    // Extends the beacon until it has enough data for all ball outcomes.
    while (extended_beacon.length() < (num_balls * 12)) {
        // Create a new vector combining the original BLS signature with the current counter value.
        let mut hash_input = vector[];
        hash_input.append(bls_sig);
        hash_input.push_back(counter);
        // Generate a new hash block from the unique hash input.
        let block = blake2b256(&hash_input);
        // Append the generated hash block to the extended beacon.
        extended_beacon.append(block);
        // Increment the counter for the next iteration to ensure a new unique hash input.
        counter = counter + 1;
    };

    // Initializes variables for calculating game outcome.
    let mut trace = vector[];
    // Calculate the stake amount per ball
    let stake_per_ball = stake.value<SUI>() / num_balls;
    let mut total_funds_amount: u64 = 0;

    // Calculates outcome for each ball based on the extended beacon.
    let mut ball_index = 0;
    while (ball_index < num_balls) {
        let mut state: u64 = 0;
        let mut i = 0;
        while (i < 12) {
            // Calculate the byte index for the current ball and iteration.
            let byte_index = (ball_index * 12) + i;
            // Retrieve the byte from the extended beacon.
            let byte = extended_beacon[byte_index];
            // Add the byte to the trace vector
            trace.push_back<u8>(byte);
            // Count the number of even bytes
            // If even, add 1 to the state
            // Odd byte -> 0, Even byte -> 1
            // The state is used to calculate the multiplier index
            state = if (byte % 2 == 0) { state + 1 } else { state };
            i = i + 1;
        };

    // Calculate multiplier index based on state
    let multiplier_index = state % house_data.multiplier().length();
    // Retrieve the multiplier from the house data
    let result = house_data.multiplier()[multiplier_index];

    // Calculate funds amount for this particular ball
    // Divide by 100 to adjust for multiplier scale and SUI units
    let funds_amount_per_ball = (result * stake_per_ball)/100;
    // Add the funds amount to the total funds amount
    total_funds_amount = total_funds_amount + funds_amount_per_ball;
    ball_index = ball_index + 1;
};

// Processes the payout to the player and returns the game outcome.
let payout_balance_mut = house_data.borrow_balance_mut();
let payout_coin: Coin<SUI> = coin::take(payout_balance_mut, total_funds_amount, ctx);

payout_balance_mut.join(stake);

// transfer the payout coins to the player
transfer::public_transfer(payout_coin, player);
// Emit the Outcome event
emit(Outcome {
    game_id,
    result: total_funds_amount,
    player,
    trace
});

// return the total amount to be sent to the player, (and the player address)
(total_funds_amount, player, trace)


// === Public-View Functions ===

/// Returns the epoch in which the game started.
public fun game_start_epoch(game: &Game): u64 {
    game.game_start_epoch
}

/// Returns the total stake.
public fun stake(game: &Game): u64 {
    game.stake.value()
}

/// Returns the player's address.
public fun player(game: &Game): address {
    game.player
}

/// Returns the player's vrf_input bytes.
public fun vrf_input(game: &Game): vector<u8> {
    game.vrf_input
}

/// Returns the fee of the game.
public fun fee_in_bp(game: &Game): u16 {
    game.fee_bp
}

// === Admin Functions ===

/// Helper function to check if a game exists.
public fun game_exists(house_data: &HouseData, game_id: ID): bool {
    dof::exists_(house_data.borrow(), game_id)
}

/// Helper function to check that a game exists and return a reference to the game Object.
/// Can be used in combination with any accessor to retrieve the desired game field.
public fun borrow_game(game_id: ID, house_data: &HouseData): &Game {
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);
    dof::borrow(house_data.borrow(), game_id)
}

// === Private Functions ===

/// Internal helper function used to create a new game.
/// The player must provide a guess and a Counter NFT.
/// Stake is taken from the player's coin and added to the game's stake.
fun internal_start_game(counter: &mut Counter, num_balls: u64, coin: Coin<SUI>, house_data: &HouseData, fee_bp: u16, ctx: &mut TxContext): (ID, Game) {
    let user_stake = coin.value();
    // Ensure that the stake is not higher than the max stake.
    assert!(user_stake <= house_data.max_stake(), EStakeTooHigh);
    // Ensure that the stake is not lower than the min stake.
    assert!(user_stake >= house_data.min_stake(), EStakeTooLow);
    // Ensure that the house has enough balance to play for this game.
    assert!(house_data.balance() >= (user_stake*(house_data.multiplier()[0]))/100, EInsufficientHouseBalance);

    // Get the VRF input and increment the counter
    let vrf_input = counter.get_vrf_input_and_increment(num_balls);

    let id = object::new(ctx);
    let game_id = object::uid_to_inner(&id);

    // Create a new game object and emit a NewGame event.
    let new_game = Game {
        id,
        game_start_epoch: ctx.epoch(),
        stake: coin.into_balance<SUI>(),
        player: ctx.sender(),
        vrf_input,
        fee_bp
    };
    // Emit a NewGame event
    emit(NewGame {
        game_id,
        player: ctx.sender(),
        vrf_input,
        user_stake,
        fee_bp
    });

    (game_id, new_game)
}
}
```

#### Error codes

Error handling is integral to the module, with specific codes indicating various failure states or invalid operations:

- `EStakeTooLow`: Indicates that the stake provided is below the minimum threshold.
- `EStakeTooHigh`: Indicates that the stake exceeds the maximum allowed limit.
- `EInvalidBlsSig`: Denotes an invalid BLS signature.
- `EInsufficientHouseBalance`: Indicates the house does not have enough balance to cover the game's outcome.
- `EGameDoesNotExist`: Used when a referenced game cannot be found.

#### Events

- `NewGame`: Emitted when a new game starts, capturing essential details like game ID, player address, VRF input, stake, and fee basis points.
- `Outcome`: Emitted upon the conclusion of a game, detailing the outcome, including the game ID, result, player address, and a trace of the game's execution.

#### Structures

- `Game`: Represents an individual game session, holding information such as the game ID, epoch of game start, stake amount, player address, VRF input, and the fee basis points.

#### Entry functions

- `start_game`: Initiates a new Plinko game session, accepting parameters like a counter NFT, the number of balls selected by the player, stake, house data, and transaction context.
- `finish_game`: Calculates and finalizes the game outcome, traces the path the balls travel, and distributes the total funds to the player based on outcomes.

#### Accessors

Provide read-only access to the game's properties, such as:

- `game_start_epoch`
- `stake`
- `player`
- `vrf_input`
- `fee_in_bp`

#### Public helper functions

Include utilities like:

- `fee_amount`: Calculates the fee amount based on the stake and fee basis points.
- `game_exists`: Checks if a game exists within the house data.
- `borrow_game`: Retrieves a reference to a game object for further processing.

#### Internal helper functions

- `internal_start_game`: A core utility that facilitates the creation of a new game, ensuring compliance with stake limits, house balance sufficiency, and the generation of a unique game ID.

### plinko::house_data

The `plinko::house_data` module in the Plinko game is designed to manage the game's treasury and configurations. It's responsible for storing the house funds, setting the game parameters (like maximum and minimum stakes), and handling game fees. It also stores the house public key for verifying game outcomes. The module provides functions to adjust game settings, manage the house funds, and ensure the integrity and fairness of the game through cryptographic verification.

```move title="house_data.move"
module plinko::house_data {
// === Imports ===
use sui::balance::{Self, Balance};
use sui::sui::SUI;
use sui::coin::{Self, Coin};
use sui::package::{Self};

// === Errors ===
const ECallerNotHouse: u64 = 0;
const EInsufficientBalance: u64 = 1;


// === Structs ===

/// Configuration and Treasury shared object, managed by the house.
public struct HouseData has key {
    id: UID,
    // House's balance which also contains the accrued winnings of the house.
    balance: Balance<SUI>,
    // Address of the house or the game operator.
    house: address,
    // Public key used to verify the beacon produced by the back-end.
    public_key: vector<u8>,
    // Maximum stake amount a player can bet in a single game.
    max_stake: u64,
    // Minimum stake amount required to play the game.
    min_stake: u64,
    // The accrued fees from games played.
    fees: Balance<SUI>,
    // The default fee in basis points. 1 basis point = 0.01%.
    base_fee_in_bp: u16,
    // Multipliers used to calculate winnings based on the game outcome.
    multiplier: vector<u64>
}

/// A one-time use capability to initialize the house data;
/// created and sent to sender in the initializer.
public struct HouseCap has key {
    id: UID
}

/// Used as a one time witness to generate the publisher.
public struct HOUSE_DATA has drop {}

fun init(otw: HOUSE_DATA, ctx: &mut TxContext) {
    // Creating and sending the Publisher object to the sender.
    package::claim_and_keep(otw, ctx);

    // Creating and sending the HouseCap object to the sender.
    let house_cap = HouseCap {
        id: object::new(ctx)
    };

    transfer::transfer(house_cap, ctx.sender());
}

/// Initializer function that should only be called once and by the creator of the contract.
/// Initializes the house data object with the house's public key and an initial balance.
/// It also sets the max and min stake values, that can later on be updated.
/// Stores the house address and the base fee in basis points.
/// This object is involved in all games created by the same instance of this package.
public fun initialize_house_data(house_cap: HouseCap, coin: Coin<SUI>, public_key: vector<u8>, multiplier: vector<u64>, ctx: &mut TxContext) {
    assert!(coin.value() > 0, EInsufficientBalance);

    let mut house_data = HouseData {
        id: object::new(ctx),
        balance: coin.into_balance(),
        house: ctx.sender(),
        public_key,
        max_stake: 10_000_000_000, // 10 SUI = 10^9.
        min_stake: 1_000_000_000, // 1 SUI.
        fees: balance::zero(),
        base_fee_in_bp: 100, // 1% in basis points.
        multiplier: vector[]
    };

    house_data.set_multiplier_vector(multiplier);

    let HouseCap { id } = house_cap;
    object::delete(id);

    transfer::share_object(house_data);
}

// === Public-Mutative Functions ===

public fun update_multiplier_vector(house_data: &mut HouseData, v: vector<u64>, ctx: &mut TxContext) {
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);
    house_data.multiplier = vector[];
    house_data.set_multiplier_vector(v);
}

/// Function used to top up the house balance. Can be called by anyone.
/// House can have multiple accounts so giving the treasury balance is not limited.
public fun top_up(house_data: &mut HouseData, coin: Coin<SUI>, _: &mut TxContext) {
    coin::put(&mut house_data.balance, coin)
}

/// A function to withdraw the entire balance of the house object.
/// It can be called only by the house
public fun withdraw(house_data: &mut HouseData, ctx: &mut TxContext) {
    // Only the house address can withdraw funds.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    let total_balance = house_data.balance();
    let coin = coin::take(&mut house_data.balance, total_balance, ctx);
    transfer::public_transfer(coin, house_data.house());
}

/// House can withdraw the accumulated fees of the house object.
public fun claim_fees(house_data: &mut HouseData, ctx: &mut TxContext) {
    // Only the house address can withdraw fee funds.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    let total_fees = house_data.fees();
    let coin = coin::take(&mut house_data.fees, total_fees, ctx);
    transfer::public_transfer(coin, house_data.house());
}

/// House can update the max stake. This allows larger stake to be placed.
public fun update_max_stake(house_data: &mut HouseData, max_stake: u64, ctx: &mut TxContext) {
    // Only the house address can update the base fee.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    house_data.max_stake = max_stake;
}

/// House can update the min stake. This allows smaller stake to be placed.
public fun update_min_stake(house_data: &mut HouseData, min_stake: u64, ctx: &mut TxContext) {
    // Only the house address can update the min stake.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    house_data.min_stake = min_stake;
}

// === Public-View Functions ===

/// Returns the balance of the house.
public fun balance(house_data: &HouseData): u64 {
    house_data.balance.value()
}

/// Returns the address of the house.
public fun house(house_data: &HouseData): address {
    house_data.house
}

/// Returns the public key of the house.
public fun public_key(house_data: &HouseData): vector<u8> {
    house_data.public_key
}

/// Returns the max stake of the house.
public fun max_stake(house_data: &HouseData): u64 {
    house_data.max_stake
}

/// Returns the min stake of the house.
public fun min_stake(house_data: &HouseData): u64 {
    house_data.min_stake
}

/// Returns the fees of the house.
public fun fees(house_data: &HouseData): u64 {
    house_data.fees.value()
}

/// Returns the base fee.
public fun base_fee_in_bp(house_data: &HouseData): u16 {
    house_data.base_fee_in_bp
}

/// Returns the multiplier vector
public fun multiplier(house_data: &HouseData): vector<u64> {
    house_data.multiplier
}

// === Public-Friend Functions ===

/// Returns a reference to the house id.
public(package) fun borrow(house_data: &HouseData): &UID {
    &house_data.id
}

    /// Returns a mutable reference to the balance of the house.
public(package) fun borrow_balance_mut(house_data: &mut HouseData): &mut Balance<SUI> {
    &mut house_data.balance
}

/// Returns a mutable reference to the fees of the house.
public(package) fun borrow_fees_mut(house_data: &mut HouseData): &mut Balance<SUI> {
    &mut house_data.fees
}

/// Returns a mutable reference to the house id.
public(package) fun borrow_mut(house_data: &mut HouseData): &mut UID {
    &mut house_data.id
}

// === Private Functions ===

fun set_multiplier_vector(house_data: &mut HouseData, v: vector<u64>) {
    house_data.multiplier.append(v);
}

// === Test Functions ===

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(HOUSE_DATA {}, ctx);
}
}
```

#### Error codes

The module defines specific error codes to handle exceptional scenarios:

- `ECallerNotHouse`: Ensures that only the house (game operator) can perform certain operations.
- `EInsufficientBalance`: Indicates an insufficient balance for operations requiring a minimum fund level.

#### Structures

- `HouseData`: A key configuration object storing the house's operational parameters, including its balance, public key, stake limits, accumulated fees, base fee rate, and multiplier settings for game outcomes.
- `HouseCap`: A unique capability indicating the authority to initialize the house data.
- `HOUSE_DATA`: A one time witness for initializing house data, used once during the setup phase.

#### Initialization function

- `init`: Prepares the environment for the house, generating essential capabilities and objects for house data management.

#### Public functions

- `initialize_house_data`: Sets up the initial configuration for the house, including balance, public key, stake limits, and multipliers.
- `top_up`: Allows adding funds to the house's balance to support game operations.
- `withdraw`: Enables the house to withdraw its balance, a critical function with implications for the house's operational capacity.
- `claim_fees`: Permits the house to collect accumulated fees from game activities.
- `update_max_stake`: Adjusts the maximum stake limit for games.
- `update_min_stake`: Modifies the minimum stake requirement.
- `update_multiplier_vector`: Updates the multiplier vector used to calculate game outcomes.

#### Internal helper functions

- `set_multiplier_vector`: Internally used to set the initial multiplier vector.

#### Accessors

Provide read-only and mutable access to house data properties, enabling operations like querying balance, stake limits, fees, and modifying configurations within authorized contexts:

- `balance`: Returns the house's current balance.
- `house`: Retrieves the house's address.
- `public_key`: Fetches the public key associated with the house.
- `max_stake`, min_stake: Access the current stake limits.
- `fees`: Shows the accumulated fees from game operations.
- `base_fee_in_bp`: Provides the base fee rate in basis points.
- `multiplier`: Returns the multiplier vector used in game outcome calculations.

#### Test utilities

- `init_for_testing`: A utility function facilitating module testing by initializing house data within a test environment.

### plinko::counter_nft

The `plinko::counter_nft` module introduces a unique, non-transferable Counter NFT. This Counter object is pivotal for generating a distinct VRF input for each round of the game, thereby ensuring the randomness and fairness of game outcomes. It includes functionalities to create, increment, and destroy these Counter objects. Each Counter is tied to a unique game round and increments its count with each use, providing a fresh input for the game's randomness mechanism.

Unlike traditional NFTs, the Counter NFT is non-transferable, ensuring it remains tied to its original owner and serves its purpose without the risk of duplication or unauthorized transfer.

```move title="counter_nft.move"
module plinko::counter_nft {
// === Imports ===
use sui::bcs::{Self};

// === Structs ===

/// A Counter object serves as a unique, NFT
/// that increments with each use. It's designed to provide a unique
/// Verifiable Random Function (VRF) input for each round of the game,
/// ensuring the randomness and fairness of game outcomes.
public struct Counter has key {
    id: UID,
    // A numerical value that increments with each use of the Counter.
    // This incrementing behavior is critical for ensuring that each game round
    // receives a fresh, unique input for randomness generation.
    count: u64,
}

/// Deletes a counter object.
entry fun burn(self: Counter) {
    let Counter { id, count: _ } = self;
    object::delete(id);
}

/// Creates a new counter object. Used in combination with the transfer_to_sender method to provide the same
/// UX when creating a Counter NFT for the first time.
public fun mint(ctx: &mut TxContext): Counter {
    Counter {
        id: object::new(ctx),
        count: 0
    }
}

/// Transfers a counter object to the sender.
public fun transfer_to_sender(counter: Counter, ctx: &mut TxContext) {
    transfer::transfer(counter, ctx.sender());
}

/// Generates a unique VRF input by concatenating the Counter's ID, its current count, and the number of balls
/// selected by the player. This composite input ensures each game round has a distinct random seed.
/// The count is incremented after use to maintain uniqueness for subsequent rounds.
public fun get_vrf_input_and_increment(self: &mut Counter, num_balls: u64): vector<u8> {
    let mut vrf_input = object::id_bytes(self);
    let count_to_bytes = bcs::to_bytes(&self.count());
    let num_balls_to_bytes = bcs::to_bytes(&num_balls);
    vrf_input.append(count_to_bytes);
    vrf_input.append(num_balls_to_bytes);
    self.increment();
    vrf_input
}

/// Returns the current count of the counter object.
public fun count(self: &Counter): u64 {
    self.count
}

/// Internal function to increment the counter by 1.
fun increment(self: &mut Counter) {
    self.count = self.count + 1;
}

// === Test Functions ===

#[test_only]
public fun burn_for_testing(self: Counter) {
    self.burn();
}

#[test_only]
public fun get_vrf_input_for_testing(self: &mut Counter): vector<u8> {
    let vrf_input: vector<u8> = self.get_vrf_input_and_increment(1);
    vrf_input
}
}
```

#### Structures

- `Counter`: The core structure representing the Counter NFT, which includes a unique identifier (ID) and a `count` attribute. The count is instrumental in generating a unique VRF input for each game round, incrementing with each use to maintain uniqueness.

#### Key functions

- `mint`: Creates a new Counter NFT with an initial `count` of zero. This function is crucial for players initiating their first game, enabling the generation of a fresh VRF input.
- `transfer_to_sender`: Facilitates the transfer of a newly minted Counter NFT to the player's account, ensuring the player has control over their unique game input.
- `get_vrf_input_and_increment`: Generates the VRF input by combining the Counter NFT's ID and current count into a byte vector, then increments the count to prepare for the next game round. This function is central to the game's randomness mechanism, providing a dynamic and unpredictable input for each round.
- `burn`: Allows for the deletion of a Counter NFT. Use this function to remove a Counter NFT from the game ecosystem, ensuring that its unique contribution to game randomness is conclusively retired.

#### Internal functions

- `increment`: A helper function that increments the count of a Counter NFT by one. This internal mechanism ensures that each Counter NFT's count is always moving forward, reinforcing the uniqueness of each VRF input generated.

#### Testing utilities

- `burn_for_testing`: A test-only function that facilitates the burning of a Counter NFT within test environments. This utility supports the testing framework by allowing the simulation of Counter NFT lifecycle events without affecting the production environment.

## Deployment

Navigate to the [setup folder](https://github.com/MystenLabs/plinko-poc/tree/main/setup) of the Plinko repository and execute the `publish.sh` script. Refer to the [README instructions](https://github.com/MystenLabs/plinko-poc/blob/main/README.md) for deploying the smart contracts and testing them locally.


## Frontend

The `Plinko` component, a central element of the Plinko game's frontend module, is structured to create an interactive and responsive gaming experience. Written in React, it integrates several features and functions to handle the game's logic and user interactions effectively.

## State management and setup

- State hooks: The module uses React's `useState` to manage various game states, including `finalPaths`, `isPlaying`, `totalWon`, and more. These states are vital for tracking the current game status and updating the UI accordingly.

- Modal for game initialization: A modal is implemented to facilitate the creation of a new game. It captures the randomness and uses `handlePlayClick` to initiate the game with the backend.

## UI components and styling

The `MatterSim` and `PlinkoSettings` components are the foundation for the Plinko frontend. To see code for all components and source files, see the [Plinko repo](https://github.com/MystenLabs/plinko-poc/tree/main/app/src).  

### Simulation component

The [`MatterSim` component](https://github.com/MystenLabs/plinko-poc/blob/main/app/src/components/MatterSim.tsx) plays a pivotal role in the Plinko game by rendering the game board with a realistic physical representation of the dropping Plinko balls. It leverages the robust capabilities of [Matter.js](https://brm.io/matter-js/), a renowned physics engine, to simulate the intricate dynamics of the Plinko game's environment. 

```ts
...
import Matter, {
  Engine,
  Render,
  Runner,
  Bodies,
  Composite,
  Vector,
  Events,
  Body,
  Common,
} from "matter-js";
...
```

The randomness integral to the game's fairness and unpredictability, as detailed in the [`counter_nft` module](https://github.com/MystenLabs/plinko-poc/blob/main/plinko/sources/counter_nft.move), dictates the path of each ball dropped by the player. To align the Plinko balls' movement with the predetermined paths derived from on-chain data, `MatterSim` applies physics principles, such as gravity, to ensure natural ball descent. Additionally, to accurately guide the balls along these specific trajectories, `MatterSim` introduces subtle, custom forces. These adjustments are calibrated to not only ensure compliance with the paths determined by the game's underlying blockchain mechanics but also to maintain a visually coherent and physically plausible ball movement, to better simulate realism.

## Plinko settings component

The [`PlinkoSettings` component](https://github.com/MystenLabs/plinko-poc/blob/main/app/src/components/PlinkoSettings.tsx) is an integral part of the user interface in the Plinko game, enabling players to customize their gameplay experience according to their preferences. This React component allows users to select the number of Plinko balls they want to drop, set the bet size for each ball, and initiate the game round by pressing the **Play** button.

### Customization options

- `betSize` (per ball): Players can specify the amount they want to bet on each ball. This is a crucial feature that allows users to manage their risk and potential rewards.
- `numberOfBalls`: This setting lets players choose how many balls they want to play in a single round, adding a strategic layer to the game as the total bet size is a multiplication of the bet size per ball and the number of balls.

## User interaction and feedback

Game Initiation: After selecting the desired number of balls and setting the bet size for each, players can initiate a new game by pressing the **Play** button. This action starts the game, with the button becoming disabled during gameplay to prevent new games from being initiated until the current game concludes and the last ball has reached the end. Links are also provided for players to view game details on a Sui network explorer for transparency and engagement.

## Related links

- [Plinko repository](https://github.com/MystenLabs/plinko-poc/tree/main): The Plinko GitHub repository contains all the source files for this example.
- [Mysten Plinko](https://plinko-poc.vercel.app/): A hosted version of the Plinko game.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/auction.mdx
```
---
title: Auction
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/turnip-town.mdx
```
---
title: Turnip Town
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/weather-oracle.mdx
```
---
title: Sui Weather Oracle
description: Write a module (smart contract) in Move that fetches the weather data from the OpenWeather API every 10 minutes and updates the weather conditions for over 1,000 locations around the world.
---

This guide demonstrates writing a module (smart contract) in Move, deploying it on Devnet, and adding a backend, which fetches the weather data from the OpenWeather API every 10 minutes and updates the weather conditions for each city. The dApp created in this guide is called Sui Weather Oracle and it provides real-time weather data for over 1,000 locations around the world.

You can access and use the weather data from the OpenWeather API for various applications, such as randomness, betting, gaming, insurance, travel, education, or research. You can also mint a weather NFT based on the weather data of a city, using the `mint` function of the SUI Weather Oracle smart contract.

This guide assumes you have [installed Sui](../getting-started/sui-install.mdx) and understand Sui fundamentals.

## Move smart contract

As with all Sui dApps, a Move package on chain powers the logic of Sui Weather Oracle. The following instruction walks you through creating and publishing the module.

### Weather Oracle module

Before you get started, you must initialize a Move package. Open a terminal or console in the directory you want to store the example and run the following command to create an empty package with the name `weather_oracle`:

```sh
$ sui move new weather_oracle
```

With that done, it's time to jump into some code. Create a new file in the `sources` directory with the name `weather.move` and populate the file with the following code:

```rust title='weather.move'
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module oracle::weather {
    use std::string::String;
    use sui::dynamic_object_field as dof;
    use sui::package;
}
```

There are few details to take note of in this code:

1. The fourth line declares the module name as `weather` within the package `oracle`.
1. Seven lines begin with the `use` keyword, which enables this module to use types and functions declared in other modules.

Next, add some more code to this module:

```rust title='weather.move'
/// Define a capability for the admin of the oracle.
public struct AdminCap has key, store { id: UID }

/// // Define a one-time witness to create the `Publisher` of the oracle.
public struct WEATHER has drop {}

// Define a struct for the weather oracle
public struct WeatherOracle has key {
    id: UID,
    /// The address of the oracle.
    address: address,
    /// The name of the oracle.
    name: String,
    /// The description of the oracle.
    description: String,
}

public struct CityWeatherOracle has key, store {
    id: UID,
    geoname_id: u32, // The unique identifier of the city
    name: String, // The name of the city
    country: String, // The country of the city
    latitude: u32, // The latitude of the city in degrees
    positive_latitude: bool, // Whether the latitude is positive (north) or negative (south)
    longitude: u32, // The longitude of the city in degrees
    positive_longitude: bool, // Whether the longitude is positive (east) or negative (west)
    weather_id: u16, // The weather condition code
    temp: u32, // The temperature in kelvin
    pressure: u32, // The atmospheric pressure in hPa
    humidity: u8, // The humidity percentage
    visibility: u16, // The visibility in meters
    wind_speed: u16, // The wind speed in meters per second
    wind_deg: u16, // The wind direction in degrees
    wind_gust: Option<u16>, // The wind gust in meters per second (optional)
    clouds: u8, // The cloudiness percentage
    dt: u32 // The timestamp of the weather update in seconds since epoch
}

fun init(otw: WEATHER, ctx: &mut TxContext) {
    package::claim_and_keep(otw, ctx); // Claim ownership of the one-time witness and keep it

    let cap = AdminCap { id: object::new(ctx) }; // Create a new admin capability object
    transfer::share_object(WeatherOracle {
        id: object::new(ctx),
        address: ctx.sender(),
        name: b"SuiMeteo".to_string(),
        description: b"A weather oracle.".to_string(),
    });
    transfer::public_transfer(cap, ctx.sender()); // Transfer the admin capability to the sender.
}
```

- The first struct, `AdminCap`, is a capability.
- The second struct, `WEATHER`, is a one-time witness that ensures only a single instance of this `Weather` ever exists. See [One Time Witness](https://move-book.com/programmability/one-time-witness.html) in The Move Book for more information.
- The `WeatherOracle` struct works as a registry and stores the `geoname_id`s of the `CityWeatherOracle`s as dynamic fields. See [The Move Book](https://move-book.com/programmability/dynamic-fields.html) to learn more about dynamic fields.
- The `init` function creates and sends the `Publisher` and `AdminCap` objects to the sender. Also, it creates a [shared object](concepts/object-ownership/shared.mdx) for all the `CityWeatherOracle`s. See [Module Initializer](https://move-book.com/programmability/module-initializer.html) in The Move Book for more information.

So far, you've set up the data structures within the module.
Now, create a function that initializes a `CityWeatherOracle` and adds it as dynamic fields to the `WeatherOracle` object:

```rust title='weather.move'
public fun add_city(
    _: &AdminCap, // The admin capability
    oracle: &mut WeatherOracle, // A mutable reference to the oracle object
    geoname_id: u32, // The unique identifier of the city
    name: String, // The name of the city
    country: String, // The country of the city
    latitude: u32, // The latitude of the city in degrees
    positive_latitude: bool, // The whether the latitude is positive (north) or negative (south)
    longitude: u32, // The longitude of the city in degrees
    positive_longitude: bool, // The whether the longitude is positive (east) or negative (west)
    ctx: &mut TxContext // A mutable reference to the transaction context
) {
    dof::add(&mut oracle.id, geoname_id, // Add a new dynamic object field to the oracle object with the geoname ID as the key and a new city weather oracle object as the value.
        CityWeatherOracle {
            id: object::new(ctx), // Assign a unique ID to the city weather oracle object
            geoname_id, // Set the geoname ID of the city weather oracle object
            name,  // Set the name of the city weather oracle object
            country,  // Set the country of the city weather oracle object
            latitude,  // Set the latitude of the city weather oracle object
            positive_latitude,  // Set whether the latitude is positive (north) or negative (south)
            longitude,  // Set the longitude of the city weather oracle object
            positive_longitude,  // Set whether the longitude is positive (east) or negative (west)
            weather_id: 0, // Initialize the weather condition code to be zero
            temp: 0, // Initialize the temperature to be zero
            pressure: 0, // Initialize the pressure to be zero
            humidity: 0, // Initialize the humidity to be zero
            visibility: 0, // Initialize the visibility to be zero
            wind_speed: 0, // Initialize the wind speed to be zero
            wind_deg: 0, // Initialize the wind direction to be zero
            wind_gust: option::none(), // Initialize the wind gust to be none
            clouds: 0, // Initialize the cloudiness to be zero
            dt: 0 // Initialize the timestamp to be zero
        }
    );
}
```

The `add_city` function is a public function that allows the owner of the `AdminCap` of the Sui Weather Oracle smart contract to add a new `CityWeatherOracle`. The function requires the admin to provide a capability object that proves their permission to add a city. The function also requires a mutable reference to the oracle object, which is the main object that stores the weather data on the blockchain. The function takes several parameters that describe the city, such as the geoname ID, name, country, latitude, longitude, and positive latitude and longitude. The function then creates a new city weather oracle object, which is a sub-object that stores and updates the weather data for a specific city. The function initializes the city weather oracle object with the parameters provided by the admin, and sets the weather data to be zero or none. The function then adds a new dynamic object field to the oracle object, using the geoname ID as the key and the city weather oracle object as the value. This way, the function adds a new city to the oracle, and makes it ready to receive and update the weather data from the backend service.

If you want to delete a city from the Sui Weather Oracle, call the `remove_city` function of the smart contract. The `remove_city` function allows the admin of the smart contract to remove a city from the oracle. The function requires the admin to provide a capability object that proves their permission to remove a city. The function also requires a mutable reference to the oracle object, which is the main object that stores and updates the weather data on the blockchain. The function takes the geoname ID of the city as a parameter, and deletes the city weather oracle object for the city. The function also removes the dynamic object field for the city from the oracle object. This way, the function deletes a city from the oracle, and frees up some storage space on the blockchain.

```rust title='weather.move'
public fun remove_city(
    _: &AdminCap,
    oracle: &mut WeatherOracle,
    geoname_id: u32
    ) {
        let CityWeatherOracle {
            id,
            geoname_id: _,
            name: _,
            country: _,
            latitude: _,
            positive_latitude: _,
            longitude: _,
            positive_longitude: _,
            weather_id: _,
            temp: _,
            pressure: _,
            humidity: _,
            visibility: _,
            wind_speed: _,
            wind_deg: _,
            wind_gust: _,
            clouds: _,
            dt: _ } = dof::remove(&mut oracle.id, geoname_id);
        object::delete(id);
}
```

Now that you have implemented the `add_city` and `remove_city` functions, you can move on to the next step, which is to see how you can update the weather data for each city. The backend service fetches the weather data from the OpenWeather API every 10 minutes, and then passes the data to the `update` function of the Sui Weather Oracle smart contract. The `update` function takes the geoname ID and the new weather data of the city as parameters, and updates the city weather oracle object with the new data. This way, the weather data on the blockchain is always up to date and accurate.

```rust title='weather.move'
public fun update(
    _: &AdminCap,
    oracle: &mut WeatherOracle,
    geoname_id: u32,
    weather_id: u16,
    temp: u32,
    pressure: u32,
    humidity: u8,
    visibility: u16,
    wind_speed: u16,
    wind_deg: u16,
    wind_gust: Option<u16>,
    clouds: u8,
    dt: u32
) {
    let city_weather_oracle_mut = dof::borrow_mut<u32, CityWeatherOracle>(&mut oracle.id, geoname_id); // Borrow a mutable reference to the city weather oracle object with the geoname ID as the key
    city_weather_oracle_mut.weather_id = weather_id;
    city_weather_oracle_mut.temp = temp;
    city_weather_oracle_mut.pressure = pressure;
    city_weather_oracle_mut.humidity = humidity;
    city_weather_oracle_mut.visibility = visibility;
    city_weather_oracle_mut.wind_speed = wind_speed;
    city_weather_oracle_mut.wind_deg = wind_deg;
    city_weather_oracle_mut.wind_gust = wind_gust;
    city_weather_oracle_mut.clouds = clouds;
    city_weather_oracle_mut.dt = dt;
}
```

You have defined the data structure of the Sui Weather Oracle smart contract, but you need some functions to access and manipulate the data. Now, add some helper functions that read and return the weather data for a `WeatherOracle` object. These functions allow you to get the weather data for a specific city in the oracle. These functions also allow you to format and display the weather data in a user-friendly way.

```rust title='weather.move'
// --------------- Read-only References ---------------

/// Returns the `name` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_name(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): String {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.name
}
/// Returns the `country` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_country(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): String {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.country
}
/// Returns the `latitude` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_latitude(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u32 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.latitude
}
/// Returns the `positive_latitude` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_positive_latitude(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): bool {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.positive_latitude
}
/// Returns the `longitude` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_longitude(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u32 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.longitude
}
/// Returns the `positive_longitude` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_positive_longitude(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): bool {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.positive_longitude
}
/// Returns the `weather_id` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_weather_id(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u16 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.weather_id
}
/// Returns the `temp` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_temp(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u32 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.temp
}
/// Returns the `pressure` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_pressure(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u32 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.pressure
}
/// Returns the `humidity` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_humidity(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u8 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.humidity
}
/// Returns the `visibility` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_visibility(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u16 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.visibility
}
/// Returns the `wind_speed` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_wind_speed(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u16 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.wind_speed
}
/// Returns the `wind_deg` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_wind_deg(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u16 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.wind_deg
}
/// Returns the `wind_gust` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_wind_gust(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): Option<u16> {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.wind_gust
}
/// Returns the `clouds` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_clouds(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u8 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.clouds
}
/// Returns the `dt` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_dt(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u32 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.dt
}
```

Finally, add an extra feature that allows anyone to mint a `WeatherNFT` with the current conditions of a city by passing the geoname ID. The `mint` function is a public function that allows anyone to mint a weather NFT based on the weather data of a city. The function takes the `WeatherOracle` shared object and the geoname ID of the city as parameters, and returns a new `WeatherNFT` object for the city. The `WeatherNFT` object is a unique and non-fungible token that represents the weather of the city at the time of minting. The `WeatherNFT` object has the same data as the `CityWeatherOracle` object, such as the `geonameID`, `name`, `country`, `latitude`, `longitude`, `positive latitude` and `longitude`, `weather ID`, `temperature`, `pressure`, `humidity`, `visibility`, `wind speed`, `wind degree`, `wind gust`, `clouds`, and `timestamp`. The function creates the `WeatherNFT` object by borrowing a reference to the `CityWeatherOracle` object with the geoname ID as the key, and assigning a unique ID (`UID`) to the `WeatherNFT` object. The function then transfers the ownership of the `WeatherNFT` object to the sender of the transaction. This way, the function allows anyone to mint a weather NFT and own a digital representation of the weather of a city. You can use this feature to create your own collection of weather NFTs, or to use them for other applications that require verifiable and immutable weather data.

```rust title='weather.move'
public struct WeatherNFT has key, store {
    id: UID,
    geoname_id: u32,
    name: String,
    country: String,
    latitude: u32,
    positive_latitude: bool,
    longitude: u32,
    positive_longitude: bool,
    weather_id: u16,
    temp: u32,
    pressure: u32,
    humidity: u8,
    visibility: u16,
    wind_speed: u16,
    wind_deg: u16,
    wind_gust: Option<u16>,
    clouds: u8,
    dt: u32
}

public fun mint(
    oracle: &WeatherOracle,
    geoname_id: u32,
    ctx: &mut TxContext
): WeatherNFT {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&oracle.id, geoname_id);
    WeatherNFT {
        id: object::new(ctx),
        geoname_id: city_weather_oracle.geoname_id,
        name: city_weather_oracle.name,
        country: city_weather_oracle.country,
        latitude: city_weather_oracle.latitude,
        positive_latitude: city_weather_oracle.positive_latitude,
        longitude: city_weather_oracle.longitude,
        positive_longitude: city_weather_oracle.positive_longitude,
        weather_id: city_weather_oracle.weather_id,
        temp: city_weather_oracle.temp,
        pressure: city_weather_oracle.pressure,
        humidity: city_weather_oracle.humidity,
        visibility: city_weather_oracle.visibility,
        wind_speed: city_weather_oracle.wind_speed,
        wind_deg: city_weather_oracle.wind_deg,
        wind_gust: city_weather_oracle.wind_gust,
        clouds: city_weather_oracle.clouds,
        dt: city_weather_oracle.dt
    }
}
```

And with that, your `weather.move` code is complete.

## Deployment

{@include: ../../../snippets/initialize-sui-client-cli.mdx}

{@include: ../../../snippets/publish-to-devnet-with-coins.mdx}

## Backend

You have successfully deployed the Sui Weather Oracle smart contract on the blockchain. Now, it's time to create an Express backend that can interact with it. The Express backend performs the following tasks:

- Initialize the smart contract with 1,000 cities using the `add_city` function of the smart contract. The backend passes the geoname ID, name, country, latitude, longitude, and positive latitude and longitude of each city as parameters to the function.
- Fetch the weather data for each city from the OpenWeather API every 10 minutes, using the API key that you obtained from the website. The backend parses the JSON response and extracts the weather data for each city, such as the weather ID, temperature, pressure, humidity, visibility, wind speed, wind degree, wind gust, clouds, and timestamp.
- Update the weather data for each city on the blockchain, using the `update` function of the smart contract. The backend passes the geoname ID and the new weather data of each city as parameters to the function.

The Express backend uses the [Sui Typescript SDK](https://sdk.mystenlabs.com/typescript), a TypeScript library that enables you to interact with the Sui blockchain and smart contracts. With the Sui Typescript SDK, you can connect to the Sui network, sign and submit transactions, and query the state of the smart contract. You also use the OpenWeather API to fetch the weather data for each city and update the smart contract every 10 minutes. Additionally, you can mint weather NFTs, if you want to explore that feature of the smart contract.

### Initialize the project

First, initialize your backend project. To do this, you need to follow these steps:

- Create a new folder named `weather-oracle-backend` and navigate to it in your terminal.
- Run `npm init -y` to create a package.json file with default values.
- Run `npm install express --save` to install Express as a dependency and save it to your package.json file.
- Run `npm install @mysten/bcs @mysten/sui axios csv-parse csv-parser dotenv pino retry-axios --save` to install the other dependencies and save them to your package.json file. These dependencies are:
  - **@mysten/bcs**: a library for blockchain services.
  - **@mysten/sui**: a library for smart user interfaces.
  - **axios**: a library for making HTTP requests.
  - **csv-parse**: a library for parsing CSV data.
  - **csv-parser**: a library for transforming CSV data into JSON objects.
  - **dotenv**: a library for loading environment variables from a .env file.
  - **pino**: a library for fast and low-overhead logging.
  - **retry-axios**: a library for retrying failed axios requests.
- Create a new file named `init.ts`

```typescript title='init.ts'
import { SuiClient } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';
import * as dotenv from 'dotenv';

import { City } from './city';
import { get1000Geonameids } from './filter-cities';
import { latitudeMultiplier, longitudeMultiplier } from './multipliers';
import { getCities, getWeatherOracleDynamicFields } from './utils';
import { logger } from './utils/logger';

dotenv.config({ path: '../.env' });

const phrase = process.env.ADMIN_PHRASE;
const fullnode = process.env.FULLNODE!;
const keypair = Ed25519Keypair.deriveKeypair(phrase!);
const client = new SuiClient({
	url: fullnode,
});

const packageId = process.env.PACKAGE_ID;
const adminCap = process.env.ADMIN_CAP_ID!;
const weatherOracleId = process.env.WEATHER_ORACLE_ID!;
const moduleName = 'weather';

const NUMBER_OF_CITIES = 10;

async function addCityWeather() {
	const cities: City[] = await getCities();
	const thousandGeoNameIds = await get1000Geonameids();

	const weatherOracleDynamicFields = await getWeatherOracleDynamicFields(client, weatherOracleId);
	const geonames = weatherOracleDynamicFields.map(function (obj) {
		return obj.name;
	});

	let counter = 0;
	let transaction = new Transaction();
	for (let c in cities) {
		if (
			!geonames.includes(cities[c].geonameid) &&
			thousandGeoNameIds.includes(cities[c].geonameid)
		) {
			transaction.moveCall({
				target: `${packageId}::${moduleName}::add_city`,
				arguments: [
					transaction.object(adminCap), // adminCap
					transaction.object(weatherOracleId), // WeatherOracle
					transaction.pure(cities[c].geonameid), // geoname_id
					transaction.pure(cities[c].asciiname), // asciiname
					transaction.pure(cities[c].countryCode), // country
					transaction.pure(cities[c].latitude * latitudeMultiplier), // latitude
					transaction.pure(cities[c].latitude > 0), // positive_latitude
					transaction.pure(cities[c].longitude * longitudeMultiplier), // longitude
					transaction.pure(cities[c].longitude > 0), // positive_longitude
				],
			});

			counter++;
			if (counter === NUMBER_OF_CITIES) {
				await signAndExecuteTransaction(transaction);
				counter = 0;
				transaction = new Transaction();
			}
		}
	}
	await signAndExecuteTransaction(transaction);
}

async function signAndExecuteTransaction(transaction: Transaction) {
	transaction.setGasBudget(5000000000);
	await client
		.signAndExecuteTransaction({
			signer: keypair,
			transaction,
			requestType: 'WaitForLocalExecution',
			options: {
				showObjectChanges: true,
				showEffects: true,
			},
		})
		.then(function (res) {
			logger.info(res);
		});
}

addCityWeather();
```

The code of init.ts does the following:

- Imports the necessary modules and classes from the library, such as `Ed25519Keypair`, `SuiClient`, and `Transaction`.
- Imports the `dotenv` module to load environment variables from a .env file.
- Imports some custom modules and functions from the local files, such as `City`, `get1000Geonameids`, `getCities`, `getWeatherOracleDynamicFields`, and `logger`.
- Derives a key pair from a phrase stored in the `ADMIN_PHRASE` environment variable.
- Creates a sui client object that connects to a Full node specified by the `FULLNODE` environment variable.
- Reads some other environment variables, such as `PACKAGE_ID`, `ADMIN_CAP_ID`, `WEATHER_ORACLE_ID`, and `MODULE_NAME`, which are used to identify the weather oracle contract and its methods.
- Defines a constant `NUMBER_OF_CITIES`, which is the number of cities to be added to the weather oracle in each batch.
- Defines an async function `addCityWeather`, which does the following:
  - Gets an array of cities from the `getCities` function.
  - Gets an array of 1,000 geonameids from the `get1000Geonameids` function.
  - Gets an array of weather oracle dynamic fields from the `getWeatherOracleDynamicFields` function, which contains the geonameids of the existing cities in the weather oracle.
  - Initializes a counter and a transaction block object.
  - Loops through the cities array and checks if the city's geonameid is not in the weather oracle dynamic fields array and is in the 1,000 geonameids array.
  - If the condition is met, adds a `moveCall` to the transaction block, which calls the `add_city` method of the weather oracle contract with the city's information, such as `geonameid`, `asciiname`, `country`, `latitude`, and `longitude`.
  - Increments the counter and checks if it reaches the `NUMBER_OF_CITIES`. If so, calls another async function, `signAndExecuteTransaction`, with the transaction block as an argument, which signs and executes the transaction block on the blockchain and logs the result. The code then resets the counter and the transaction block.
  - After the loop ends, calls the `signAndExecuteTransaction` function again with the remaining transaction block.

You have now initialized the `WeatherOracle` shared object. The next step is to learn how to update them every 10 minutes with the latest weather data from the OpenWeatherMap API.

```typescript title='index.ts'
import { SuiClient } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';
import * as dotenv from 'dotenv';

import { City } from './city';
import { tempMultiplier, windGustMultiplier, windSpeedMultiplier } from './multipliers';
import { getWeatherData } from './openweathermap';
import { getCities, getWeatherOracleDynamicFields } from './utils';
import { logger } from './utils/logger';

dotenv.config({ path: '../.env' });

const phrase = process.env.ADMIN_PHRASE;
const fullnode = process.env.FULLNODE!;
const keypair = Ed25519Keypair.deriveKeypair(phrase!);
const client = new SuiClient({
	url: fullnode,
});

const packageId = process.env.PACKAGE_ID;
const adminCap = process.env.ADMIN_CAP_ID!;
const weatherOracleId = process.env.WEATHER_ORACLE_ID!;
const appid = process.env.APPID!;
const moduleName = 'weather';

const CHUNK_SIZE = 25;
const MS = 1000;
const MINUTE = 60 * MS;
const TEN_MINUTES = 10 * MINUTE;

async function performUpdates(
	cities: City[],
	weatherOracleDynamicFields: {
		name: number;
		objectId: string;
	}[],
) {
	let startTime = new Date().getTime();

	const geonames = weatherOracleDynamicFields.map(function (obj) {
		return obj.name;
	});
	const filteredCities = cities.filter((c) => geonames.includes(c.geonameid));

	for (let i = 0; i < filteredCities.length; i += CHUNK_SIZE) {
		const chunk = filteredCities.slice(i, i + CHUNK_SIZE);

		let transaction = await getTransaction(chunk);
		try {
			await client.signAndExecuteTransaction({
				signer: keypair,
				transaction,
			});
		} catch (e) {
			logger.error(e);
		}
	}

	let endTime = new Date().getTime();
	setTimeout(
		performUpdates,
		TEN_MINUTES - (endTime - startTime),
		cities,
		weatherOracleDynamicFields,
	);
}

async function getTransaction(cities: City[]) {
	let transaction = new Transaction();

	let counter = 0;
	for (let c in cities) {
		const weatherData = await getWeatherData(cities[c].latitude, cities[c].longitude, appid);
		counter++;
		if (weatherData?.main?.temp !== undefined) {
			transaction.moveCall({
				target: `${packageId}::${moduleName}::update`,
				arguments: [
					transaction.object(adminCap), // AdminCap
					transaction.object(weatherOracleId), // WeatherOracle
					transaction.pure(cities[c].geonameid), // geoname_id
					transaction.pure(weatherData.weather[0].id), // weather_id
					transaction.pure(weatherData.main.temp * tempMultiplier), // temp
					transaction.pure(weatherData.main.pressure), // pressure
					transaction.pure(weatherData.main.humidity), // humidity
					transaction.pure(weatherData.visibility), // visibility
					transaction.pure(weatherData.wind.speed * windSpeedMultiplier), // wind_speed
					transaction.pure(weatherData.wind.deg), // wind_deg
					transaction.pure(
						weatherData.wind.gust === undefined ? [] : [weatherData.wind.gust * windGustMultiplier],
						'vector<u16>',
					), // wind_gust
					transaction.pure(weatherData.clouds.all), // clouds
					transaction.pure(weatherData.dt), // dt
				],
			});
		} else logger.warn(`No weather data for ${cities[c].asciiname} `);
	}
	return transaction;
}

async function run() {
	const cities: City[] = await getCities();
	const weatherOracleDynamicFields: {
		name: number;
		objectId: string;
	}[] = await getWeatherOracleDynamicFields(client, weatherOracleId);
	performUpdates(cities, weatherOracleDynamicFields);
}

run();
```

The code in index.ts does the following:

- Uses `dotenv` to load some environment variables from a `.env` file, such as `ADMIN_PHRASE`, `FULLNODE`, `PACKAGE_ID`, `ADMIN_CAP_ID`, `WEATHER_ORACLE_ID`, `APPID`, and `MODULE_NAME`. These variables are used to configure some parameters for the code, such as the key pair, the client, and the target package and module.
- Defines some constants, such as `CHUNK_SIZE`, `MS`, `MINUTE`, and `TEN_MINUTES`. These constants are used to control the frequency and size of the updates that the code performs.
- Defines an async function called `performUpdates`, which takes two arguments: `cities` and `weatherOracleDynamicFields`. This function is the main logic of the code, and it does the following:
  - Filters the `cities` array based on the `weatherOracleDynamicFields` array, which contains the names and object IDs of the weather oracle dynamic fields that the code needs to update.
  - Loops through the filtered cities in chunks of `CHUNK_SIZE`, and for each chunk, it calls another async function called `getTransaction`, which returns a transaction block that contains the Move calls to update the weather oracle dynamic fields with the latest weather data from the OpenWeatherMap API.
  - Tries to sign and execute the transaction block using the client and keypair, and catches any errors that may occur.
  - Calculates the time it took to perform the updates, and sets a timeout to call itself again after `TEN_MINUTES` minus the elapsed time.
- The code defines another async function called `getTransaction`, which takes one argument: `cities`. This function does the following:
  - Creates a new transaction block object.
  - Loops through the `cities` array, and for each city, it calls another async function called `getWeatherData`, which takes the `latitude`, `longitude`, and `appid` as arguments, and returns the weather data for the city from the OpenWeatherMap API.
  - Checks if the weather data is valid, and if so, adds a Move call to the transaction block, which calls the `update` function of the target package and module, and passes the admin cap, the weather oracle id, the geoname id, and the weather data as arguments.
  - Returns the transaction block object.
- An async `run` function is defined, which does the following:
  - Calls another async function called `getCities`, which returns an array of city objects that contain information such as name, geoname id, latitude, and longitude.
  - Calls another async function called `getWeatherOracleDynamicFields`, which takes the package id, the module name, and the client as arguments, and returns an array of weather oracle dynamic field objects that contain information such as name and object id.
  - Calls the `performUpdates` function with the cities and weather oracle dynamic fields arrays as arguments.

Congratulations, you completed the Sui Weather Oracle tutorial. You can carry the lessons learned here forward when building your next Sui project.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/meta-pricing-oracle.mdx
```
---
title: Meta and Pricing Oracle
draft: true
---

Content coming soon
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/trustless-swap.mdx
```
---
title: Trustless Swap
description: An app that performs atomic swaps on Sui. Atomic swaps are similar to escrows but without requiring a trusted third party.
effort: large
---

{@include: ../../../snippets/app-examples-swap-source.mdx}

This guide demonstrates how to make an app that performs atomic swaps on Sui. Atomic swaps are similar to escrows but without requiring a trusted third party.

There are three main sections to this guide:

1. [Smart Contracts](#smart-contracts): The Move code that holds the state and perform the swaps.
1. [Backend](#backend): A service that indexes chain state to discover trades, and an API service to read this data.
1. [Frontend](#frontend): A UI that enables users to list objects for sale and to accept trades.

## What the guide teaches

- **Shared objects:** The guide teaches you how to use [shared objects](../../../concepts/object-ownership/shared.mdx), in this case to act as the escrow between two Sui users wanting to trade. Shared objects are a unique concept to Sui. Any transaction and any signer can modify it, given the changes meet the requirements set forth by the package that defined the type.
- **Composability:** The guide teaches you how to design your Move code in a way that enables full composability. In this app, the Move code that handles trading is completely unaware of the code that defines the objects it is trading and vice versa.

The guide also shows how to build an app that:

- **Is trustless:** Users do not have to trust (or pay) any third parties; the chain manages the swap.
- **Avoids rug-pulls:** Guarantees that the object a user wants to trade for isn't tampered with after initiating the trade.
- **Preserves liveness:** Users are able to pull out of the trade and reclaim their object at any time, in case the other party stops responding.

## What you need

Before getting started, make sure you have:

- [Installed the latest version of Sui](../getting-started/sui-install.mdx).
- [Configured a valid network environment](../../../references/cli/client.mdx#set-current-environment), as the guide has you deploy the module on Testnet.
- [Acquired Devnet or Testnet](../getting-started/get-coins.mdx) tokens for development purposes.
  :::tip
      
  {@include: ../../../snippets/faucet-online.mdx}

  :::
- Read the basics of [shared versus owned objects](../sui-101/shared-owned.mdx).

## Directory structure

To begin, create a new folder on your system titled `trading` that holds all your files. Inside that folder, create three more folders: `api`, `contracts`, and `frontend`. It's important to keep this directory structure as some helper scripts in this example target these directories by name. Different projects have their own directory structure, but it's common to split code into functional groups to help with maintenance.

:::checkpoint

- You have the latest version of Sui installed. If you run `sui --version` in your terminal or console, it responds with the currently installed version.
- Your active environment is pointing to the expected network. Run `sui client active-env` to make sure. If you receive a warning about a client and server API version mismatch, update Sui using the version in the relevant branch (`mainnet`, `testnet`, `devent`) of the Sui repo.
- Your active address has SUI. Run `sui client balance` in your terminal or console. If there is no balance, [acquire SUI](../getting-started/get-coins.mdx) from the faucet (not available in Mainnet).
- You have a directory to place the files you create in. The suggested names of the directories are important if you use the available helper functions later in the guide.

:::

## Smart contracts {#smart-contracts}

In this part of the guide, you write the Move contracts that perform the trustless swaps. The guide describes how to create the package from scratch, but you can use a fork or copy of the example code in the Sui repo to follow along instead. See [Write a Move Package](../first-app/write-package.mdx) to learn more about package structure and how to use the Sui CLI to scaffold a new project.

### Move.toml

To begin writing your smart contracts, create an `escrow` folder in your `contracts` folder (if using recommended directory names). Create a file inside the folder named `Move.toml` and copy the following code into it. This is the package manifest file. If you want to learn more about the structure of the file, see [Package Manifest](https://move-book.com/concepts/manifest.html) in The Move Book.

:::info

If you are targeting a network other than Testnet, be sure to update the `rev` value for the Sui dependency.

:::

{@inject: examples/trading/contracts/escrow/Move.toml}

### Locked and Key

With your manifest file in place, it's time to start creating the Move assets for this project. In your `escrow` folder, at the same level as your `Move.toml` file, create a `sources` folder. This is the common file structure of a package in Move. Create a new file inside `sources` titled `lock.move`. This file contains the logic that locks the object involved in a trade. The complete source code for this file follows and the sections that come after detail its components.

:::tip

Click the titles at the top of codeblocks to open the relevant source file in GitHub.

:::

<details>
<summary>
`lock.move`
</summary>
{@inject: examples/trading/contracts/escrow/sources/lock.move noComments}
</details>

After a trade is initiated, you don't want the trading party to modify the object they agreed to trade. Imagine you're trading in-game items and you agree to trade a weapon with all its attachments, and its owner strips all its attachments just before the trade.

In a traditional trade, a third party typically holds the items in escrow to make sure they are not tampered with before the trade completes. This requires either trusting that the third party won't tamper with it themselves, paying the third party to ensure that doesn't happen, or both.

In a trustless swap, however, you can use the safety properties of Move to force an item's owner to prove that they have not tampered with the version of the object that you agreed to trade, without involving anyone else.

This is done by requiring that an object that is available for trading is **locked** with a **single-use key**, and asking the owner to supply the key when finalizing the trade.

To tamper with the object would require unlocking it, which consumes the key. Consequently, there would no longer be a key to finish the trade.

{@inject: examples/trading/contracts/escrow/sources/lock.move#struct=Locked,Key noComments}

- The `Locked<T>` type stores the `ID` of the key that unlocks it, and its own `id`. The object being locked is added as a dynamic object field, so that it is still readable at its own ID off chain.
- The corresponding `Key` type only stores its own `id`.

The lock and key are made single-use by the signatures of the `lock` and `unlock` functions. `lock` accepts any object of type `T: store` (the `store` ability is necessary for storing it inside a `Locked<T>`), and creates both the `Locked<T>` and its corresponding `Key`:

<details>
<summary>
`lock` function in `lock.move`
</summary>
{@inject: examples/trading/contracts/escrow/sources/lock.move#fun=lock noComments}
</details>


The `unlock` function accepts the `Locked<T>` and `Key` by value (which consumes them), and returns the underlying `T` as long as the correct key has been supplied for the lock:

<details>
<summary>
`unlock` function in `lock.move`
</summary>
{@inject: examples/trading/contracts/escrow/sources/lock.move#variable=ELockKeyMismatch noComments}
{@inject: examples/trading/contracts/escrow/sources/lock.move#fun=unlock noTitle noComments}
</details>


Together, they ensure that a lock and key cannot have existed before the lock operation, and will not exist after a successful unlock – it is single use.

:::tip Additional resources

- [Move Package](https://move-book.com/concepts/packages.html) defined in The Move Book.
- Concepts: [Wrapped Objects](../../../concepts/versioning.mdx#wrapped-objects)

:::

### Testing Locked and Key

Move's type system guarantees that a given `Key` cannot be re-used (because `unlock` accepts it by value), but there are some properties that need to be confirmed with tests:

- A locked object can be unlocked with its key.
- Trying to unlock an object with the wrong key fails.

The test starts with a helper function for creating an object, it doesn't matter what kind of object it is, as long as it has the `store` ability. The test uses `Coin<SUI>`, because it comes with a `#[test_only]` function for minting:

{@inject: examples/trading/contracts/escrow/sources/lock.move#fun=test_coin noComments}

- All test-related functions and imports are annotated with `#[test_only]` to make sure they don't show up in the published package. This can also be done by separating tests into their own module – e.g. `lock_tests.move` – and marking that module as `#[test_only]`.
- The `test_scenario` module is used to provide access to a `&mut TxContext` in the test (necessary for creating new objects). Tests that don't need to simulate multiple transactions but still need access to a `TxContext` can use `sui::tx_context::dummy` to create a test context instead.

The first test works by creating an object to test, locking it and unlocking it – this should finish executing without aborting.
The last two lines exist to keep the Move compiler happy by cleaning up the test coin and test scenario objects, because values in Move are not implicitly cleaned up unless they have the `drop` ability.

{@inject: examples/trading/contracts/escrow/sources/lock.move#fun=test_lock_unlock noComments}

The other test is testing a failure scenario – that an abort happens. It creates two locked objects (this time the values are just `u64`s), and use the key from one to try and unlock the other, which should fail (specified using the `expected_failure` attribute).

Unlike the previous test, the same clean up is not needed, because the code is expected to terminate. Instead, add another abort after the code that you expect to abort (making sure to use a different code for this second abort).

{@inject: examples/trading/contracts/escrow/sources/lock.move#fun=test_lock_key_mismatch noComments}

:::tip Additional resources

- Concepts: [Test Scenario](../first-app/build-test.mdx#testing-a-package)
- [Drop ability](https://move-book.com/move-basics/drop-ability.html) defined in The Move Book.
- [Testing] Move code discussion in The Move Book.

:::

:::checkpoint

At this point, you have 
- A Move package consisting of a manifest file (`Move.toml`)
- A `lock.move` file in your `sources` folder. 

From your `escrow` folder, run `sui move test` in your terminal or console. If successful, you get a response similar to the following that confirms the package builds and your tests pass:

```
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING escrow
Running Move unit tests
[ PASS    ] escrow::lock::test_lock_key_mismatch
[ PASS    ] escrow::lock::test_lock_unlock
Test result: OK. Total tests: 2; passed: 2; failed: 0
```

You might notice that the Move compiler creates a `build` subfolder inside `escrow` upon a successful build. This folder contains your package's compiled bytecode, code from your package's dependencies, and various other files necessary for the build. At this point, it's enough to just be aware of these files. You don't need to fully understand the contents in `build`.

:::

### The Escrow protocol {#escrow}

Create a new file in your `escrow` folder titled `shared.move`. The code in this file creates the shared `Escrow` object and completes the trading logic. The complete source code for this file follows and the sections that come after detail its components.

<details>
<summary>
`shared.move`
</summary>
{@inject: examples/trading/contracts/escrow/sources/shared.move noComments}
</details>

Trading proceeds in three steps:

1. The first party locks the object they want to trade – this is already handled by the `lock` module you wrote earlier.
1. The second party puts their object up for escrow and registers their interest in the first party's object. This is handled by a new module – `escrow`.
1. The first party completes the trade by providing their locked object and the key to unlock it. Assuming all checks pass, this transfers their object to the second party and makes the second party's object available to them.

You can start by implementing steps two and three, by defining a new type to hold the escrowed object. It holds the `escrowed` object and an `id: UID` (because it's an object in its own right), but it also records the `sender` and intended `recipient` (to confirm they match when the trade happens), and it registers interest in the first party's object by recording the `ID` of the key that unlocks the `Locked<U>` that contains the object.

{@inject: examples/trading/contracts/escrow/sources/shared.move#struct=Escrow noComments singleSpace}

You also need to create a function for creating the `Escrow` object. The object is shared because it needs to be accessed by the address that created it (in case the object needs to be returned) and by the intended recipient (to complete the swap).

<details>
<summary>
`create` function in `shared.move`
</summary>
{@inject: examples/trading/contracts/escrow/sources/shared.move#noemit noComments}
</details>

If the second party stops responding, the first party can unlock their object. You need to create a function so the second party can recover their object in the symmetric case as well.

- It needs to check that the caller matches `sender`, because `Escrow` objects are shared and anybody can access them.
- It accepts the `Escrow` by value so that it can clean it up after extracting the escrowed object, reclaiming the storage rebate for the sender and cleaning up an unused object on chain.

<details>
<summary>
`return_to_sender` function in `shared.move`
</summary>
{@inject: examples/trading/contracts/escrow/sources/shared.move#fun=return_to_sender noComments}
</details>

Finally, you need to add a function to allow the first party to complete the trade.

- This function also accepts the `Escrow` by value because it consumes it after the swap is complete.
- It checks that the sender of the transaction is the intended recipient (the first party), and that the ID of the key that they provided matches the key specified when the object was escrowed. This ensures no tampering occurs, because this key can be provided only if it had not been used to unlock the object, which proves the object has not left its `Locked<U>` between the call to `create` and to `swap`. You can inspect the `lock` module to see that it cannot be modified while in there.
- The call to `unlock` further checks that the key matches the locked object that was provided.
- Instead of transferring the escrowed object to the recipient address, it is returned by the `swap` function. You can do this because you checked that the transaction sender is the recipient, and it makes this API more composable. Programmable transaction blocks (PTBs) provide the flexibility to decide whether to transfer the object as it is received or do something else with it.

<details>
<summary>
`swap` function in `shared.move`
</summary>
{@inject: examples/trading/contracts/escrow/sources/shared.move#variable=EMismatchedSenderRecipient,EMismatchedExchangeObject singleSpace noComments}
{@inject: examples/trading/contracts/escrow/sources/shared.move#fun=swap noComments noTitle}
</details>


:::tip Additional resources

- [Full source code](https://github.com/MystenLabs/sui/blob/705ee1ed3ce8cfadc4597c6facb6769d7dfb5896/examples/trading/contracts/escrow/sources/shared.move)
- Concepts: [Shared Objects](../../../concepts/object-ownership/shared)
- Concepts: [Shared Object Deletion](https://blog.sui.io/ephemeral-shared-objects/)
- Concepts: [PTBs](../../../concepts/transactions/prog-txn-blocks)

:::

### Testing

Tests for the `escrow` module are more involved than for `lock` – as they take advantage of `test_scenario`'s ability to simulate multiple transactions from different senders, and interact with shared objects.

The guide focuses on the test for a successful swap, but you can find a link to all the tests later on.

As with the lock test, start by creating a function to mint a test coin. You also create some constants to represent our transaction senders, `ALICE`, `BOB`, and `DIANE`.

{@inject: examples/trading/contracts/escrow/sources/shared.move#fun=test_coin noComments}

The test body starts with a call to `test_scenario::begin` and ends with a call to `test_scenario::end`. It doesn't matter which address you pass to `begin`, because you pick one of `ALICE` or `BOB` at the start of each new transaction you write, so set it to `@0x0`:

{@inject: examples/trading/contracts/escrow/sources/shared.move#test}

The first transaction is from `BOB` who creates a coin and locks it. You must remember the ID of the coin and the ID of the key, which you will need later, and then you transfer the locked object and the key itself to `BOB`, because this is what would happen in a real transaction: When simulating transactions in a test, you should only keep around primitive values, not whole objects, which would need to be written to chain between transactions.

Write these transactions inside the `test_successful_swap` function, between the call to `begin` and `end`.

{@inject: examples/trading/contracts/escrow/sources/shared.move#variable=i2 noComments}

Next, `ALICE` comes along and sets up the `Escrow`, which locks their coin. They register their interest for `BOB'`s coin by referencing `BOB`'s key's ID (`ik2`):

{@inject: examples/trading/contracts/escrow/sources/shared.move#variable=i1 noComments}

Finally, `BOB` completes the trade by calling `swap`. The `take_shared` function is used to simulate accepting a shared input. It uses type inference to know that the object must be an `Escrow`, and finds the last object of this type that was shared (by `ALICE` in the previous transaction). Similarly, use `take_from_sender` to simulate accepting owned inputs (in this case, `BOB`'s lock and key). The coin returned by `swap` is transferred back to `BOB`, as if it was called as part of a PTB, followed by a transfer command.

{@inject: examples/trading/contracts/escrow/sources/shared.move#bob noComments}

The rest of the test is designed to check that `ALICE` has `BOB`'s coin and vice versa. It starts by calling `next_tx` to make sure the effects of the previous transaction have been committed, before running the necessary checks.

{@inject: examples/trading/contracts/escrow/sources/shared.move#finish noComments}

:::tip Additional resources

- Guides: [Test Scenario](../../../guides/developer/first-app/build-test#testing-a-package)

:::

### Observability

The `escrow` Move package is now functional: You could publish it on chain and perform trustless swaps by creating transactions. Creating those transactions requires knowing the IDs of `Locked`, `Key`, and `Escrow` objects.

`Locked` and `Key` objects are typically owned by the transaction sender, and so can be queried through the Sui RPC, but `Escrow` objects are shared, and it is useful to be able to query them by their sender and recipient (so that users can see the trades they have offered and received).

Querying `Escrow` objects by their sender or recipient requires custom indexing, and to make it easy for the indexer to spot relevant transactions, add the following **events** to `escrow.move`:

{@inject: examples/trading/contracts/escrow/sources/shared.move#struct=EscrowCreated,EscrowSwapped,EscrowCancelled noComments}

Functions responsible for various aspects of the escrow's lifecycle emit these events. The custom indexer can then subscribe to transactions that emit these events and process only those, rather than the entire chain state:

<details>
<summary>
`emit` events included in functions from `shared.move`
</summary>
{@inject: examples/trading/contracts/escrow/sources/shared.move#use=sui::event}
{@inject: examples/trading/contracts/escrow/sources/shared.move#fun=create,swap,return_to_sender noTitle noComments}
</details>

:::tip Additional resources

- Concepts: [Events in The Move Book](https://move-book.com/programmability/events.html)
- Guide: [Using Events](../sui-101/using-events.mdx)

:::

:::checkpoint

You now have `shared.move` and `locked.move` files in your `sources` folder. From the parent `escrow` folder, run `sui move test` in your terminal or console. If successful, you get a response similar to the following that confirms the package builds and your tests pass: 

```
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING escrow
Running Move unit tests
[ PASS    ] escrow::lock::test_lock_key_mismatch
[ PASS    ] escrow::shared::test_mismatch_object
[ PASS    ] escrow::lock::test_lock_unlock
[ PASS    ] escrow::shared::test_mismatch_sender
[ PASS    ] escrow::shared::test_object_tamper
[ PASS    ] escrow::shared::test_return_to_sender
[ PASS    ] escrow::shared::test_return_to_sender_failed_swap
[ PASS    ] escrow::shared::test_successful_swap
Test result: OK. Total tests: 8; passed: 8; failed: 0
```

:::

### Next steps

Well done. You have written the Move package! 🚀

To turn this into a complete dApp, you need to create a frontend. However, for the frontend to be updated, it has to listen to the blockchain as escrows are made and swaps are fulfilled.

To achieve this, in the next step you create an indexing service.

## Backend indexer {#backend}

With the contract adapted to emit events, you can now write an indexer that keeps track of all active `Escrow` objects and exposes an API for querying objects by sender or recipient. 

The indexer is backed by a Prisma DB with the following schema:

<details>
<summary>
`schema.prisma`
</summary>
{@inject: examples/trading/api/prisma/schema.prisma}
</details>

The core of the indexer is an event loop, initialized in a function called `setupListeners`.

{@inject: examples/trading/api/indexer.ts}

The indexer queries events related to the `escrow` module, using a `queryEvent` filter, and keeps track of a cursor representing the latest event it has processed so it can resume indexing from the right place even if it is restarted. The filter is looking for any events whose type is from the `escrow` module of the Move package (see the `event-indexer.ts` code that follows).

The core event job works by polling: It queries RPC for events following its latest cursor and sends them to a callback for processing. If it detects more than one page of new events, it immediately requests the next page. Otherwise, the job waits for the next polling interval before checking again.

<details>
<summary>
`event-indexer.ts`
</summary>
{@inject: examples/trading/api/indexer/event-indexer.ts}
</details>

The callback is responsible for reading the event and updating the database accordingly. For demo purposes, SQLite is being used, and so you need to issue a separate `UPSERT` to the database for each escrowed object. In a production setting, however, you would want to batch requests to the database to optimize data flow.

<details>
<summary>
`escrow-handler.ts`
</summary>
{@inject: examples/trading/api/indexer/escrow-handler.ts}
</details>

:::tip Additional resources

- [Full source code](https://github.com/MystenLabs/sui/tree/705ee1ed3ce8cfadc4597c6facb6769d7dfb5896/examples/trading/api)
- Reference: [JSON-RPC](https://docs.sui.io/sui-api-ref)

:::


### API service

The data that the indexer captures can then be served over an API, so that a frontend can read it. Follow the next section to implement the API in TypeScript, to run on Node, using Express.

#### Query parameters

You want your API to accept the query string in the URL as the parameters for database `WHERE` query. Hence, you want a utility that can extract and parse the URL query string into valid query parameters for Prisma. With the `parseWhereStatement()` function, the callers filter the set of keys from the URL query string and transforms those corresponding key-value pairs into the correct format for Prisma.

<details>
<summary>
`parseWhereStatement` in `api-queries.ts`
</summary>
{@inject: examples/trading/api/utils/api-queries.ts#enum=WhereParamTypes}
{@inject: examples/trading/api/utils/api-queries.ts#type=WhereParam noTitle}
{@inject: examples/trading/api/utils/api-queries.ts#variable=parseWhereStatement noTitle}
</details>


#### Query pagination

Pagination is another crucial part to ensure your API returns sufficient and/or ordered chunk of information instead of all the data that might be the vector for a DDOS attack. Similar to **WHERE parameters**, define a set of keys in the URL query string to be accepted as valid pagination parameters. The `parsePaginationForQuery()` utility function helps to achieve this by filtering the pre-determined keys `sort`, `limit`, `cursor` and parsing corresponding key-value pairs into `ApiPagination` that Prisma can consume.

In this example, the `id` field of the model in the database as the cursor that allows clients to continue subsequent queries with the next page.

<details>
<summary>
`parsePaginationForQuery` in `api-queries.ts`
</summary>
{@inject: examples/trading/api/utils/api-queries.ts#type=ApiPagination}
{@inject: examples/trading/api/utils/api-queries.ts#variable=parsePaginationForQuery noTitle}
</details>

#### API endpoints

All the endpoints are defined in `server.ts`, particularly, there are two endpoints:

- `/locked` to query `Locked` objects.
- `/escrows` to query `Escrow` objects.

You define a list of valid query keys, such as `deleted`, `creator`, `keyId`, and `objectId` for `Locked` data and `cancelled`, `swapped`, `recipient`, and `sender` for `Escrow` data. Pass the URL query string into the pre-defined utilities to output the correct parameters that Prisma can use.

<details>
<summary>
`server.ts`
</summary>
{@inject: examples/trading/api/server.ts}
</details>

### Deployment {#deployment}

Now that you have an indexer and an API service, you can deploy your move package and start the indexer and API service.

1. Install dependencies by running `pnpm install --ignore-workspace` or `yarn install --ignore-workspace`.

2. Setup the database by running `pnpm db:setup:dev` or `yarn db:setup:dev`.

3. Deploy the Sui package

  <details>
    <summary>
      Deployment instructions
    </summary>
    {@include: ../../../snippets/initialize-sui-client-cli.mdx}

  Next, configure the Sui CLI to use `testnet` as the active environment. 

  Use the following command to list your available environments:

  ```sh
  $ sui client envs
  ```

  If you haven't already set up a `testnet` environment, do so by running the following command in a terminal or console:

  ```sh
  $ sui client new-env --alias testnet --rpc https://fullnode.testnet.sui.io:443
  ```

  Run the following command to activate the `testnet` environment:

  ```sh
  $ sui client switch --env testnet
  ```

  Before being able to publish your package to Testnet, you need Testnet SUI tokens. To get some, run the following command: 

  ```sh
  $ sui client faucet
  ```

  For other ways to get SUI in your Testnet account, see [Get SUI Tokens](/guides/developer/getting-started/get-coins).

  Now that you have an account with some Testnet SUI, you can deploy your contracts. 

  There are some helper functions to publish the smart contracts so you can create some demo data (for Testnet). The helper function to publish the smart contrqcts expects built smart contracts in both the `escrow` and `demo` directories. Run `sui move build` in both directories, if necessary. Be sure to update the Sui dependency in the manifest to point to the correct source based on your environment. 

  To publish the smart contracts and produce demo data: 

  1. Publish the smart contracts by running the following command from your `api` folder: 

      ```sh
      $ npx ts-node helpers/publish-contracts.ts
      ```

      If successful, `demo-contract.json` and `escrow-contract.json` are created in the backend root directory. These files contain the contract addresses and are used by the backend and frontend to interact with the contracts.

  2. Produce demo non-locked and locked objects

      ```sh
      $ npx ts-node helpers/create-demo-data.ts
      ```

  3. Produce demo escrows

      ```sh
      $ npx ts-node helpers/create-demo-escrows.ts
      ```

  If you want to reset the database (for a clean demo, for example), run `pnpm db:reset:dev && pnpm db:setup:dev` or `yarn db:reset:dev && yarn db:setup:dev`.
</details>

4. Run both the API and the indexer by running `pnpm dev` or `yarn dev`.

5. Visit [http://localhost:3000/escrows](http://localhost:3000/escrows) or [http://localhost:3000/locked](http://localhost:3000/locked)

:::checkpoint

You should now have an indexer running. 
- If you visit `localhost:3000`, you get a message that the service is running: `{"message":"🚀 API is functional 🚀"}`.
- If you visit `localhost:3000/escrows`, you see the demo escrow data the helper scripts created for you. Likewise, visiting `http://localhost:3000/locked` displays the raw JSON the script created for demo objects.

:::


### Next steps

With the code successfully deployed on Testnet, you can now [create a frontend](#frontend) to display the trading data and to allow users to interact with the Move modules.

## Frontend {#frontend}

In this final part of the app example, you build a frontend (UI) that allows end users to discover trades and interact with listed escrows.

### Prerequisites

{@include: ../../../snippets/app-examples-swap-source.mdx}

Before getting started, make sure you have:

- [Completed the smart contracts](#smart-contracts) and understand their design.
- [Implemented the backend](#backend) to learn how to index on-chain data and expose it through an API.
- [Deployed your smart contracts and started the backend indexer](#deployment).
- Installed [`pnpm`](https://pnpm.io/installation) or [`yarn`](https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable) to use as the package manager.

:::tip Additional resources

- Tooling: [Sui Typescript SDK](https://sdk.mystenlabs.com/typescript). For basic usage on how to interact with Sui with TypeScript.
- Tooling: [Sui dApp Kit](https://sdk.mystenlabs.com/dapp-kit). To learn basic building blocks for developing a dApp in the Sui ecosystem with React.js.
- Tooling: [`@mysten/dapp`](https://sdk.mystenlabs.com/dapp-kit/create-dapp). This is used within this project to quickly scaffold a React-based Sui dApp.

:::

### Overview

The UI design consists of three parts:

- A header containing the button allowing users to connect their wallet and navigate to other pages.
- A place for users to manage their owned objects to be ready for escrow trading called `Manage Objects`.
- A place for users to discover, create, and execute trades called `Escrows`.

### Scaffold a new app

The first step is to set up the client app. Run the following command to scaffold a new app from your `frontend` folder.

<Tabs groupId="packagemanager">
  <TabItem label="PNPM" value="pnpm">
    ```sh
    $ pnpm create @mysten/dapp --template react-client-dapp
    ```
  </TabItem>
  <TabItem label="Yarn" value="yarn">
    ```sh
    $ yarn create @mysten/dapp --template react-client-dapp
    ```
  </TabItem>
</Tabs>

When asked for a name for your dApp, provide one of your liking. The dApp scaffold gets created in a new directory with the name you provide. This is convenient to keep your working code separate from the example source code that might already populate this folder. The codeblocks that follow point to the code in the default example location. Be aware the path to your own code includes the dApp name you provide.

### Setting up import aliases

First, set up import aliases to make the code more readable and maintainable. This allows you to import files using `@/` instead of relative paths.

<details>
  <summary>
    Replace the content of `tsconfig.json` with the following:
  </summary>
  {@inject: examples/trading/frontend/tsconfig.json}
</details>

The paths option under `compilerOptions` is what defines the aliasing for TypeScript. Here, the alias `@/*` is mapped to the `./src/*` directory, meaning that any time you use `@/`, TypeScript resolves it as a reference to the `src` folder. This setup reduces the need for lengthy relative paths when importing files in your project.

<details>
  <summary>
    Replace the content of `vite.config.ts` with the following:
  </summary>
  {@inject: examples/trading/frontend/vite.config.ts}
</details>

Vite also needs to be aware of the aliasing to resolve imports correctly during the build process. In the `resolve.alias` configuration of `vite.config.ts`, we map the alias `@` to the `/src` directory.

### Adding Tailwind CSS

To streamline the styling process and keep the codebase clean and maintainable, this guide uses Tailwind CSS, which provides utility-first CSS classes to rapidly build custom designs. Run the following command from the base of your dApp project to add Tailwind CSS and its dependencies:

<Tabs groupId="packagemanager">
  <TabItem label="PNPM" value="pnpm">
    ```sh
    $ pnpm add tailwindcss@latest postcss@latest autoprefixer@latest
    ```
  </TabItem>
  <TabItem label="Yarn" value="yarn">
    ```sh
    $ yarn add tailwindcss@latest postcss@latest autoprefixer@latest
    ```
  </TabItem>
</Tabs>

Next, generate the Tailwind CSS configuration file by running the following:

```sh
$ npx tailwindcss init -p
```

<details>
  <summary>
    Replace the content of `tailwind.config.js` with the following:
  </summary>
  {@inject: examples/trading/frontend/tailwind.config.js}
</details>

<details>
  <summary>
    Add the `src/styles/` directory and add `base.css`: 
  </summary>
  {@inject: examples/trading/frontend/src/styles/base.css}
</details>

### Connecting your deployed package

First, deploy your package via the [scripts in the api directory](#deployment).

<details>
  <summary>
    Then, create a `src/constants.ts` file and fill it with the following:
  </summary>
  {@inject: examples/trading/frontend/src/constants.ts}
</details>

:::warning

If you create a dApp using a project name so that your `src` files are in a subfolder of `frontend`, be sure to add another nesting level (`../`) to the import statements.

:::

### Add helper functions and UI components

<details>
  <summary>
    Create a `src/utils/` directory and add the following file: 
  </summary>
  {@inject: examples/trading/frontend/src/utils/helpers.ts}
</details>

Create a `src/components/` directory and add the following components: 

<details>
  <summary>
    `ExplorerLink.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/ExplorerLink.tsx}
</details>

<details>
  <summary>
    `InfiniteScrollArea.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/InfiniteScrollArea.tsx}
</details>

<details>
  <summary>
    `Loading.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/Loading.tsx}
</details>

<details>
  <summary>
    `SuiObjectDisplay.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/SuiObjectDisplay.tsx}
</details>

Install the necessary dependencies:

<Tabs groupId="packagemanager">
  <TabItem label="PNPM" value="pnpm">
    ```sh
    $ pnpm add react-hot-toast
    ```
  </TabItem>
  <TabItem label="Yarn" value="yarn">
    ```sh
    $ yarn add react-hot-toast
    ```
  </TabItem>
</Tabs>


### Set up routing {#routing}

The imported template only has a single page. To add more pages, you need to set up routing.

First, install the necessary dependencies:

<Tabs groupId="packagemanager">
  <TabItem label="PNPM" value="pnpm">
    ```sh
    $ pnpm add react-router-dom
    ```
  </TabItem>
  <TabItem label="Yarn" value="yarn">
    ```sh
    $ yarn add react-router-dom
    ```
  </TabItem>
</Tabs>

<details>
  <summary>
    Then, create a `src/routes/` directory and add `index.tsx`. This file contains the routing configuration:
  </summary>
  {@inject: examples/trading/frontend/src/routes/index.tsx}
</details>

Add the following respective files to the `src/routes/` directory:

<details>
  <summary>
    `root.tsx`. This file contains the root component that is rendered on every page:
  </summary>
  {@inject: examples/trading/frontend/src/routes/root.tsx}
</details>

<details>
  <summary>
    `LockedDashboard.tsx`. This file contains the component for the `Manage Objects` page.
  </summary>
```tsx
export function LockedDashboard() {
  return (
    <div>
      <h1>Locked Dashboard</h1>
    </div>
  )
}
```
</details>

<details>
  <summary>
    `EscrowDashboard.tsx`. This file contains the component for the `Escrows` page.
  </summary>
```tsx
export function EscrowDashboard() {
  return (
    <div>
      <h1>Escrow Dashboard</h1>
    </div>
  )
}
```
</details>

<details>
  <summary>
  Update `src/main.tsx` by replacing the `App` component with the `RouterProvider` and replace `"dark"` with `"light"` in the `Theme` component:
  </summary>
  {@inject: examples/trading/frontend/src/main.tsx}
</details>

Note that `dApp Kit` provides a set of hooks for making query and mutation calls to the Sui blockchain. These hooks are thin wrappers around query and mutation hooks from `@tanstack/react-query`.

:::tip Additional resources

- Docs: [React Router](https://reactrouter.com/en/main). Used to navigate between different routes in the website.
- Docs: [TanStack Query](https://tanstack.com/query/latest/docs/framework/react/overview).

:::

<details>
  <summary>
    Create `src/components/Header.tsx`. This file contains the navigation links and the connect wallet button:
  </summary>
```tsx
import { ConnectButton } from "@mysten/dapp-kit";
import { SizeIcon } from "@radix-ui/react-icons";
import { Box, Container, Flex, Heading } from "@radix-ui/themes";
import { NavLink } from "react-router-dom";

const menu = [
  {
    title: "Escrows",
    link: "/escrows",
  },
  {
    title: "Manage Objects",
    link: "/locked",
  },
];

export function Header() {
  return (
    <Container>
      <Flex
        position="sticky"
        px="4"
        py="2"
        justify="between"
        className="border-b flex flex-wrap"
      >
        <Box>
          <Heading className="flex items-center gap-3">
            <SizeIcon width={24} height={24} />
            Trading Demo
          </Heading>
        </Box>

        <Box className="flex gap-5 items-center">
          {menu.map((item) => (
            <NavLink
              key={item.link}
              to={item.link}
              className={({ isActive, isPending }) =>
                `cursor-pointer flex items-center gap-2 ${
                  isPending
                    ? "pending"
                    : isActive
                      ? "font-bold text-blue-600"
                      : ""
                }`
              }
            >
              {item.title}
            </NavLink>
          ))}
        </Box>

        <Box className="connect-wallet-wrapper">
          <ConnectButton />
        </Box>
      </Flex>
    </Container>
  );
}
```
</details>

The dApp Kit comes with a pre-built React.js component called `ConnectButton` displaying a button to connect and disconnect a wallet. The connecting and disconnecting wallet logic is handled seamlessly so you don't need to worry about repeating yourself doing the same logic all over again.

:::checkpoint

At this point, you have a basic routing setup. Run your app and ensure you can:

- Navigate between the `Manage Objects` and `Escrows` pages.
- Connect and disconnect your wallet.

Note, the styles should be applied. The `Header` component should look like this: 

![Header component](./images/styles.png)

:::

### Type definitions

<details>
  <summary>
    All the type definitions are in `src/types/types.ts`. Create this file and add the following:
  </summary>
  {@inject: examples/trading/frontend/src/types/types.ts}
</details>

`ApiLockedObject` and `ApiEscrowObject` represent the `Locked` and `Escrow` indexed data model the indexing and API service return.

`EscrowListingQuery` and `LockedListingQuery` are the query parameters model to provide to the API service to fetch from the endpoints `/escrow` and `/locked` accordingly.

### Display owned objects

Now, display the objects owned by the connected wallet address. This is the `Manage Objects` page.

<details>
  <summary>
    First add this file `src/components/locked/LockOwnedObjects.tsx`: 
  </summary>
```tsx
import { useCurrentAccount, useSuiClientInfiniteQuery } from "@mysten/dapp-kit";
import { SuiObjectDisplay } from "@/components/SuiObjectDisplay";
import { InfiniteScrollArea } from "@/components/InfiniteScrollArea";

/**
 * A component that fetches all the objects owned by the connected wallet address
 * and allows the user to lock them, so they can be used in escrow.
 */
export function LockOwnedObjects() {
  const account = useCurrentAccount();

  const { data, fetchNextPage, isFetchingNextPage, hasNextPage, refetch } =
    useSuiClientInfiniteQuery(
      "getOwnedObjects",
      {
        owner: account?.address!,
        options: {
          showDisplay: true,
          showType: true,
        },
      },
      {
        enabled: !!account,
        select: (data) =>
          data.pages
            .flatMap((page) => page.data)
            .filter(
              // we're filtering out objects that don't have Display or image_url
              // for demo purposes. The Escrow contract works with all objects.
              (x) => !!x.data?.display && !!x.data?.display?.data?.image_url,
            ),
      },
    );

  return (
    <InfiniteScrollArea
      loadMore={() => fetchNextPage()}
      hasNextPage={hasNextPage}
      loading={isFetchingNextPage}
    >
      {data?.map((obj) => (
        <SuiObjectDisplay object={obj.data!}>
        </SuiObjectDisplay>
      ))}
    </InfiniteScrollArea>
  );
}
```
</details>

Fetch the owned objects directly from Sui blockchain using the `useSuiClientInfiniteQuery()` hook from `dApp Kit`. This hook is a thin wrapper around Sui blockchain RPC calls, reference the documentation to learn more about these [RPC hooks](https://sdk.mystenlabs.com/dapp-kit/rpc-hooks). Basically, supply the RPC endpoint you want to execute, in this case it's the [`getOwnedObjects` endpoint](https://docs.sui.io/sui-api-ref#suix_getownedobjects). Supply the connected wallet account as the `owner`. The returned data is stored inside the cache at query key `getOwnedObjects`. In a future step you invalidate this cache after a mutation succeeds, so the data will be re-fetched automatically.


<details>
  <summary>
    Next, update `src/routes/LockedDashboard.tsx` to include the `LockOwnedObjects` component:
  </summary>
```tsx
import { useState } from "react";
import { Tabs } from "@radix-ui/themes";
import { LockOwnedObjects } from "@/components/locked/LockOwnedObjects";

export function LockedDashboard() {
  const tabs = [
    {
      name: "Lock Owned objects",
      component: () => <LockOwnedObjects />,
    },
  ];

  const [tab, setTab] = useState(tabs[0].name);

  return (
    <Tabs.Root value={tab} onValueChange={setTab}>
      <Tabs.List>
        {tabs.map((tab, index) => {
          return (
            <Tabs.Trigger
              key={index}
              value={tab.name}
              className="cursor-pointer"
            >
              {tab.name}
            </Tabs.Trigger>
          );
        })}
      </Tabs.List>
      {tabs.map((tab, index) => {
        return (
          <Tabs.Content key={index} value={tab.name}>
            {tab.component()}
          </Tabs.Content>
        );
      })}
    </Tabs.Root>
  );
}
```
</details>

:::checkpoint

Run your app and ensure you can:

- View the owned objects of the connected wallet account.

If you don't see any objects, you might need to create some demo data or connect your wallet. You can mint objects after completing the next steps.

![Owned objects](./images/trustless-objects.png)

:::

### Execute transaction hook {#execute-transaction-hook}

In the frontend, you might need to execute a transaction block in multiple places, hence it's better to extract the transaction execution logic and reuse it everywhere. Let's create and examine the execute transaction hook.


<details>
  <summary>
    Create `src/hooks/useTransactionExecution.ts`:
  </summary>
  {@inject: examples/trading/frontend/src/hooks/useTransactionExecution.ts}
</details>

A `Transaction` is the input, sign it with the current connected wallet account, execute the transaction block, return the execution result, and finally display a basic toast message to indicate whether the transaction is successful or not.

Use the `useSuiClient()` hook from `dApp Kit` to retrieve the Sui client instance configured in `src/main.tsx`. The `useSignTransaction()` function is another hook from `dApp kit` that helps to sign the transaction block using the currently connected wallet. It displays the UI for users to review and sign their transactions with their selected wallet. To execute a transaction block, use the `executeTransaction()` on the Sui client instance of the Sui TypeScript SDK.

### Generate demo data

:::info

The full source code of the demo bear smart contract is available at [Trading Contracts Demo directory](https://github.com/MystenLabs/sui/tree/main/examples/trading/contracts/demo)

:::

You need a utility function to create a dummy object representing a real world asset so you can use it to test and demonstrate escrow users flow on the UI directly.

<details>
  <summary>
    Create `src/mutations/demo.ts`:
  </summary>
  {@inject: examples/trading/frontend/src/mutations/demo.ts}
</details>

As previously mentioned, this example uses `@tanstack/react-query` to query, cache, and mutate server state. Server state is data only available on remote servers, and the only way to retrieve or update this data is by interacting with these remote servers. In this case, it could be from an API or directly from Sui blockchain RPC.

When you execute a transaction call to mutate data on the Sui blockchain, use the `useMutation()` hook. The `useMutation()` hook accepts several inputs, however, you only need two of them for this example. The first parameter, `mutationFn`, accepts the function to execute the main mutating logic, while the second parameter, `onSuccess`, is a callback that runs when the mutating logic succeeds.

The main mutating logic includes executing a Move call of a package named `demo_bear::new` to create a dummy bear object and transferring it to the connected wallet account, all within the same `Transaction`. This example reuses the `executeTransaction()` hook from the [Execute Transaction Hook](#execute-transaction-hook) step to execute the transaction.

Another benefit of wrapping the main mutating logic inside `useMutation()` is that you can access and manipulate the cache storing server state. This example fetches the cache from remote servers by using query call in an appropriate callback. In this case, it is the `onSuccess` callback. When the transaction succeeds, invalidate the cache data at the cache key called `getOwnedObjects`, then `@tanstack/react-query` handles the re-fetching mechanism for the invalidated data automatically. Do this by using `invalidateQueries()` on the `@tanstack/react-query` configured client instance retrieved by `useQueryClient()` hook in the [Set up Routing](#routing) step.

Now the logic to create a dummy bear object exists. You just need to attach it into the button in the header.

<details>
  <summary>
    `Header.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/Header.tsx}
</details>

:::checkpoint

Run your app and ensure you can:

- Mint a demo bear object and view it in the `Manage Objects` tab.

![New bear](./images/trustless-new-bear.png)

:::

### Locking owned objects

To lock the object, execute the `lock` Move function identified by `{PACKAGE_ID}::lock::lock`. The implementation is similar to what's in previous mutation functions, use `useMutation()` from `@tanstack/react-query` to wrap the main logic inside it. The lock function requires an object to be locked and its type because our smart contract `lock` function is generic and requires type parameters. After creating a `Locked` object and its `Key` object, transfer them to the connected wallet account within the same transaction block.

It's beneficial to extract logic of locking owned objects into a separated mutating function to enhance discoverability and encapsulation.

<details>
  <summary>
    Create `src/mutations/locked.ts`:
  </summary>
```tsx
import { CONSTANTS } from "@/constants";
import { useTransactionExecution } from "@/hooks/useTransactionExecution";
import { useCurrentAccount } from "@mysten/dapp-kit";
import { SuiObjectData } from "@mysten/sui/client";
import { Transaction } from "@mysten/sui/transactions";
import { useMutation } from "@tanstack/react-query";
/**
 * Builds and executes the PTB to lock an object.
 */
export function useLockObjectMutation() {
  const account = useCurrentAccount();
  const executeTransaction = useTransactionExecution();

  return useMutation({
    mutationFn: async ({ object }: { object: SuiObjectData }) => {
      if (!account?.address)
        throw new Error("You need to connect your wallet!");
      const txb = new Transaction();

      const [locked, key] = txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::lock::lock`,
        arguments: [txb.object(object.objectId)],
        typeArguments: [object.type!],
      });

      txb.transferObjects([locked, key], txb.pure.address(account.address));

      return executeTransaction(txb);
    },
  });
}
```
</details>

Update `src/components/locked/LockOwnedObjects.tsx` to include the `useLockObjectMutation` hook:

<details>
  <summary>
    `LockOwnedObjects.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/locked/LockOwnedObjects.tsx}
</details>

:::checkpoint

Run your app and ensure you can:

- Lock an owned object. 

The object should disappear from the list of owned objects. You view and unlock locked objects in later steps.

![Lock bear](./images/trustless-lock-bear.png)

:::

### Display owned locked objects

Let's take a look at the **My Locked Objects** tab by examining `src/components/locked/OwnedLockedList.tsx`. Focus on the logic on how to retrieve this list.

<details>
  <summary>
    `OwnedLockedList.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/locked/OwnedLockedList.tsx}
</details>

This instance of `useSuiClientInfiniteQuery()` is similar to the one in the `LockOwnedObjects` component. The difference is that it fetches the locked objects instead of the owned objects. The `Locked` object is a struct type in the smart contract, so you need to supply the struct type to the query call as a `filter`. The struct type is usually identified by the format of `{PACKAGE_ID}::{MODULE_NAME}::{STRUCT_TYPE}`.

##### `LockedObject` and `Locked` component

The `<LockedObject />` (`src/components/locked/LockedObject.tsx`) component is mainly responsible for mapping an on-chain `SuiObjectData` `Locked` object to its corresponding `ApiLockedObject`, which is finally delegated to the `<Locked />` component for rendering. The `<LockedObject />` fetches the locked item object ID if the prop `itemId` is not supplied by using `dApp Kit` `useSuiClientQuery()` hook to call the `getDynamicFieldObject` RPC endpoint. Recalling that in this smart contract, the locked item is put into a dynamic object field.

<details>
  <summary>
    `LockedObject.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/locked/LockedObject.tsx}
</details>

The `<Locked />` (`src/components/locked/partials/Locked.tsx`) component is mainly responsible for rendering the `ApiLockedObject`. Later on, it will also consist of several on-chain interactions: unlock the locked objects and create an escrow out of the locked object.

<details>
  <summary>
    `Locked.tsx`
  </summary>
```tsx
import { useCurrentAccount, useSuiClientQuery } from "@mysten/dapp-kit";
import { SuiObjectDisplay } from "@/components/SuiObjectDisplay";
import { ExplorerLink } from "../../ExplorerLink";
import { ApiLockedObject } from "@/types/types";

/**
 * Prefer to use the `Locked` component only through `LockedObject`.
 *
 * This can also render data directly from the API, but we prefer
 * to also validate ownership from on-chain state (as objects are transferrable)
 * and the API cannot track all the ownership changes.
 */
export function Locked({
  locked,
  hideControls,
}: {
  locked: ApiLockedObject;
  hideControls?: boolean;
}) {
  const account = useCurrentAccount();

  const suiObject = useSuiClientQuery(
    "getObject",
    {
      id: locked.itemId,
      options: {
        showDisplay: true,
        showType: true,
        showOwner: true,
      },
    },
    {
      select: (data) => data.data,
    },
  );

  const getLabel = () => {
    if (locked.deleted) return "Deleted";
    if (hideControls) {
      if (locked.creator === account?.address) return "You offer this";
      return "You'll receive this if accepted";
    }
    return undefined;
  };

  const getLabelClasses = () => {
    if (locked.deleted)
      return "bg-red-50 rounded px-3 py-1 text-sm text-red-500";
    if (hideControls) {
      if (!!locked.creator && locked.creator === account?.address)
        return "bg-blue-50 rounded px-3 py-1 text-sm text-blue-500";
      return "bg-green-50 rounded px-3 py-1 text-sm text-green-700";
    }
    return undefined;
  };

  return (
    <SuiObjectDisplay
      object={suiObject.data!}
      label={getLabel()}
      labelClasses={getLabelClasses()}
    >
      <div className="p-4 pt-1 text-right flex flex-wrap items-center justify-between">
        {
          <p className="text-sm flex-shrink-0 flex items-center gap-2">
            <ExplorerLink id={locked.objectId} isAddress={false} />
          </p>
        }
      </div>
    </SuiObjectDisplay>
  );
}
```
</details>

Update `src/routes/LockedDashboard.tsx` to include the `OwnedLockedList` component:

<details>
  <summary>
    `LockedDashboard.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/routes/LockedDashboard.tsx}
</details>

:::checkpoint

Run your app and ensure you can:

- View the locked objects of the connected wallet account.

![My locked bears](./images/trustless-my-locked.png)

:::

### Unlocking owned objects

To unlock the object, execute the `unlock` Move function identified by `{PACKAGE_ID}::lock::unlock`. Call the `unlock` function supplying the `Locked` object, its corresponding `Key`, the struct type of the original object, and transfer the unlocked object to the current connected wallet account. Also, implement the `onSuccess` callback to invalidate the cache data at query key `locked` after one second to force `react-query` to re-fetch the data at corresponding query key automatically.

Unlocking owned objects is another crucial and complex on-chain action in this application. Hence, it's beneficial to extract its logic into separated mutating functions to enhance discoverability and encapsulation.

<details>
  <summary>
    `src/mutations/locked.ts`
  </summary>
  {@inject: examples/trading/frontend/src/mutations/locked.ts}
</details>

Update `src/components/locked/partials/Locked.tsx` to include the `useUnlockObjectMutation` hook:

<details>
  <summary>
    `Locked.tsx`
  </summary>
```tsx
import { useCurrentAccount, useSuiClientQuery } from "@mysten/dapp-kit";
import { SuiObjectDisplay } from "@/components/SuiObjectDisplay";
import { Button } from "@radix-ui/themes";
import {
  ArrowDownIcon,
  ArrowUpIcon,
  LockOpen1Icon,
} from "@radix-ui/react-icons";
import { ExplorerLink } from "../../ExplorerLink";
import { useState } from "react";
import { ApiLockedObject } from "@/types/types";
import { useUnlockMutation } from "@/mutations/locked";

/**
 * Prefer to use the `Locked` component only through `LockedObject`.
 *
 * This can also render data directly from the API, but we prefer
 * to also validate ownership from on-chain state (as objects are transferrable)
 * and the API cannot track all the ownership changes.
 */
export function Locked({
  locked,
  hideControls,
}: {
  locked: ApiLockedObject;
  hideControls?: boolean;
}) {
  const [isToggled, setIsToggled] = useState(false);
  const account = useCurrentAccount();
  const { mutate: unlockMutation, isPending } = useUnlockMutation();

  const suiObject = useSuiClientQuery(
    "getObject",
    {
      id: locked.itemId,
      options: {
        showDisplay: true,
        showType: true,
        showOwner: true,
      },
    },
    {
      select: (data) => data.data,
    },
  );

  const isOwner = () => {
    return !!locked.creator && account?.address === locked.creator;
  };

  const getLabel = () => {
    if (locked.deleted) return "Deleted";
    if (hideControls) {
      if (locked.creator === account?.address) return "You offer this";
      return "You'll receive this if accepted";
    }
    return undefined;
  };

  const getLabelClasses = () => {
    if (locked.deleted)
      return "bg-red-50 rounded px-3 py-1 text-sm text-red-500";
    if (hideControls) {
      if (!!locked.creator && locked.creator === account?.address)
        return "bg-blue-50 rounded px-3 py-1 text-sm text-blue-500";
      return "bg-green-50 rounded px-3 py-1 text-sm text-green-700";
    }
    return undefined;
  };

  return (
    <SuiObjectDisplay
      object={suiObject.data!}
      label={getLabel()}
      labelClasses={getLabelClasses()}
    >
      <div className="p-4 pt-1 text-right flex flex-wrap items-center justify-between">
        {
          <p className="text-sm flex-shrink-0 flex items-center gap-2">
            <ExplorerLink id={locked.objectId} isAddress={false} />
          </p>
        }
        {!hideControls && isOwner() && (
          <Button
            className="ml-auto cursor-pointer"
            disabled={isPending}
            onClick={() => {
              unlockMutation({
                lockedId: locked.objectId,
                keyId: locked.keyId,
                suiObject: suiObject.data!,
              });
            }}
          >
            <LockOpen1Icon /> Unlock
          </Button>
        )}
      </div>
    </SuiObjectDisplay>
  );
}
```
</details>

:::checkpoint

Run your app and ensure you can:

- Unlock a locked object.

![Unlock my locked bears](./images/trustless-unlock-bear.png)

:::

### Display locked objects to escrow

Update `src/routes/EscrowDashboard.tsx` to include the `LockedList` component:

<details>
  <summary>
    `EscrowDashboard.tsx`
  </summary>
```tsx
import { useState } from "react";
import { Tabs, Tooltip } from "@radix-ui/themes";
import { LockedList } from "../components/locked/ApiLockedList";
import { InfoCircledIcon } from "@radix-ui/react-icons";

export function EscrowDashboard() {
  const tabs = [
    {
      name: "Browse Locked Objects",
      component: () => (
        <LockedList
          params={{
            deleted: "false",
          }}
          enableSearch
        />
      ),
      tooltip: "Browse locked objects you can trade for.",
    },
  ];

  const [tab, setTab] = useState(tabs[0].name);

  return (
    <Tabs.Root value={tab} onValueChange={setTab}>
      <Tabs.List>
        {tabs.map((tab, index) => {
          return (
            <Tabs.Trigger
              key={index}
              value={tab.name}
              className="cursor-pointer"
            >
              {tab.name}
              <Tooltip content={tab.tooltip}>
                <InfoCircledIcon className="ml-3" />
              </Tooltip>
            </Tabs.Trigger>
          );
        })}
      </Tabs.List>
      {tabs.map((tab, index) => {
        return (
          <Tabs.Content key={index} value={tab.name}>
            {tab.component()}
          </Tabs.Content>
        );
      })}
    </Tabs.Root>
  );
}
```
</details>

Add `src/components/locked/ApiLockedList.tsx`:

<details>
  <summary>
    `ApiLockedList.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/locked/ApiLockedList.tsx}
</details>

This hook fetches all the non-deleted system `Locked` objects from the API in a paginated fashion. Then, it proceeds into fetching the on-chain state, to ensure the latest state of the object is displayed.

This component uses tanstack's `useInfiniteQuery` instead of `useSuiClientInfiniteQuery` since the data is being fetched from the example's API rather than Sui. 

<details>
  <summary>
    Add `src/hooks/useGetLockedObject.ts`
  </summary>
  {@inject: examples/trading/frontend/src/hooks/useGetLockedObject.ts}
</details>

:::checkpoint

Run your app and ensure you can:

- View the locked objects in the `Browse Locked Objects` tab in the `Escrows` page.

![Browse locked bears](./images/trustless-escrow-locked.png)

:::

### Create escrows

To create escrows, include a mutating function through the `useCreateEscrowMutation` hook in `src/mutations/escrow.ts`. It accepts the escrowed item to be traded and the `ApiLockedObject` from another party as parameters. Then, call the `{PACKAGE_ID}::shared::create` Move function and provide the escrowed item, the key id of the locked object to exchange, and the recipient of the escrow (locked object's owner).

<details>
  <summary>
    `escrow.ts`
  </summary>
```tsx
import { CONSTANTS } from "@/constants";
import { useTransactionExecution } from "@/hooks/useTransactionExecution";
import { ApiLockedObject } from "@/types/types";
import { useCurrentAccount } from "@mysten/dapp-kit";
import { SuiObjectData } from "@mysten/sui/client";
import { Transaction } from "@mysten/sui/transactions";
import { useMutation } from "@tanstack/react-query";

/**
 * Builds and executes the PTB to create an escrow.
 */
export function useCreateEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const executeTransaction = useTransactionExecution();

  return useMutation({
    mutationFn: async ({
      object,
      locked,
    }: {
      object: SuiObjectData;
      locked: ApiLockedObject;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");

      const txb = new Transaction();
      txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::create`,
        arguments: [
          txb.object(object.objectId!),
          txb.pure.id(locked.keyId),
          txb.pure.address(locked.creator!),
        ],
        typeArguments: [object.type!],
      });

      return executeTransaction(txb);
    },
  });
}
```
</details>

<details>
  <summary>
    Update `src/components/locked/partials/Locked.tsx` to include the `useCreateEscrowMutation` hook
  </summary>
  {@inject: examples/trading/frontend/src/components/locked/partials/Locked.tsx}
</details>

<details>
  <summary>
    Add `src/components/escrows/CreateEscrow.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/escrows/CreateEscrow.tsx}
</details>

:::checkpoint

Run your app and ensure you can:

- Create an escrow.

The object should disappear from the list of locked objects in the `Browse Locked Objects` tab in the `Escrows` page. You view and accept or cancel escrows in later steps.

![Start escrow](./images/trustless-start-escrow.png)

:::

### Cancel escrows

To cancel the escrow, create a mutation through the `useCancelEscrowMutation` hook in `src/mutations/escrow.ts`. The cancel function accepts the escrow `ApiEscrowObject` and its on-chain data. The `{PACKAGE_ID}::shared::return_to_sender` Move call is generic, thus it requires the type parameters of the escrowed object. Next, execute `{PACKAGE_ID}::shared::return_to_sender` and transfer the returned escrowed object to the creator of the escrow.

<details>
  <summary>
    `escrow.ts`
  </summary>
```tsx
import { CONSTANTS, QueryKey } from "@/constants";
import { useTransactionExecution } from "@/hooks/useTransactionExecution";
import { ApiEscrowObject, ApiLockedObject } from "@/types/types";
import { useCurrentAccount } from "@mysten/dapp-kit";
import { SuiObjectData } from "@mysten/sui/client";
import { Transaction } from "@mysten/sui/transactions";
import { useMutation, useQueryClient } from "@tanstack/react-query";

/**
 * Builds and executes the PTB to create an escrow.
 */
export function useCreateEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const executeTransaction = useTransactionExecution();

  return useMutation({
    mutationFn: async ({
      object,
      locked,
    }: {
      object: SuiObjectData;
      locked: ApiLockedObject;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");

      const txb = new Transaction();
      txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::create`,
        arguments: [
          txb.object(object.objectId!),
          txb.pure.id(locked.keyId),
          txb.pure.address(locked.creator!),
        ],
        typeArguments: [object.type!],
      });

      return executeTransaction(txb);
    },
  });
}

/**
 * Builds and executes the PTB to cancel an escrow.
 */
export function useCancelEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const executeTransaction = useTransactionExecution();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      escrow,
      suiObject,
    }: {
      escrow: ApiEscrowObject;
      suiObject: SuiObjectData;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");
      const txb = new Transaction();

      const item = txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::return_to_sender`,
        arguments: [txb.object(escrow.objectId)],
        typeArguments: [suiObject?.type!],
      });

      txb.transferObjects([item], txb.pure.address(currentAccount?.address!));

      return executeTransaction(txb);
    },

    onSuccess: () => {
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: [QueryKey.Escrow] });
      }, 1_000);
    },
  });
}
```
</details>

<details>
  <summary>
    Add `src/components/escrows/Escrow.tsx`
  </summary>
```tsx
import { useCurrentAccount, useSuiClientQuery } from "@mysten/dapp-kit";
import { SuiObjectDisplay } from "@/components/SuiObjectDisplay";
import { Button } from "@radix-ui/themes";
import {
  ArrowDownIcon,
  ArrowUpIcon,
  Cross1Icon,
} from "@radix-ui/react-icons";
import { CONSTANTS, QueryKey } from "@/constants";
import { ExplorerLink } from "../ExplorerLink";
import { useQuery } from "@tanstack/react-query";
import { useState } from "react";
import { ApiEscrowObject } from "@/types/types";
import {
  useCancelEscrowMutation,
} from "@/mutations/escrow";
import { useGetLockedObject } from "@/hooks/useGetLockedObject";
import { LockedObject } from "../locked/LockedObject";

/**
 * A component that displays an escrow and allows the user to accept or cancel it.
 * Accepts an `escrow` object as returned from the API.
 */
export function Escrow({ escrow }: { escrow: ApiEscrowObject }) {
  const account = useCurrentAccount();
  const [isToggled, setIsToggled] = useState(true);
  const { mutate: cancelEscrowMutation, isPending: pendingCancellation } =
    useCancelEscrowMutation();

  const suiObject = useSuiClientQuery("getObject", {
    id: escrow?.itemId,
    options: {
      showDisplay: true,
      showType: true,
    },
  });

  const lockedData = useQuery({
    queryKey: [QueryKey.Locked, escrow.keyId],
    queryFn: async () => {
      const res = await fetch(
        `${CONSTANTS.apiEndpoint}locked?keyId=${escrow.keyId}`,
      );
      return res.json();
    },
    select: (data) => data.data[0],
    enabled: !escrow.cancelled,
  });

  const { data: suiLockedObject } = useGetLockedObject({
    lockedId: lockedData.data?.objectId,
  });

  const getLabel = () => {
    if (escrow.cancelled) return "Cancelled";
    if (escrow.swapped) return "Swapped";
    if (escrow.sender === account?.address) return "You offer this";
    if (escrow.recipient === account?.address) return "You'll receive this";
    return undefined;
  };
  const getLabelClasses = () => {
    if (escrow.cancelled) return "text-red-500";
    if (escrow.swapped) return "text-green-500";
    if (escrow.sender === account?.address)
      return "bg-blue-50 rounded px-3 py-1 text-sm text-blue-500";
    if (escrow.recipient === account?.address)
      return "bg-green-50 rounded px-3 py-1 text-sm text-green-700";
    return undefined;
  };

  return (
    <SuiObjectDisplay
      object={suiObject.data?.data!}
      label={getLabel()}
      labelClasses={getLabelClasses()}
    >
      <div className="p-4 flex gap-3 flex-wrap">
        {
          <p className="text-sm flex-shrink-0 flex items-center gap-2">
            <ExplorerLink id={escrow.objectId} isAddress={false} />
          </p>
        }
        <Button
          className="ml-auto cursor-pointer bg-transparent text-black"
          onClick={() => setIsToggled(!isToggled)}
        >
          Details
          {isToggled ? <ArrowUpIcon /> : <ArrowDownIcon />}
        </Button>
        {!escrow.cancelled &&
          !escrow.swapped &&
          escrow.sender === account?.address && (
            <Button
              color="amber"
              className="cursor-pointer"
              disabled={pendingCancellation}
              onClick={() =>
                cancelEscrowMutation({
                  escrow,
                  suiObject: suiObject.data?.data!,
                })
              }
            >
              <Cross1Icon />
              Cancel request
            </Button>
          )}
        {isToggled && lockedData.data && (
          <div className="min-w-[340px] w-full justify-self-start text-left">
            {suiLockedObject?.data && (
              <LockedObject
                object={suiLockedObject.data}
                itemId={lockedData.data.itemId}
                hideControls
              />
            )}

            {!lockedData.data.deleted &&
              escrow.recipient === account?.address && (
                <div className="text-right mt-5">
                  <p className="text-xs pb-3">
                    When accepting the exchange, the escrowed item is
                    transferred to you and your locked item is transferred
                    to the sender.
                  </p>
                </div>
              )}
            {lockedData.data.deleted &&
              !escrow.swapped &&
              escrow.recipient === account?.address && (
                <div>
                  <p className="text-red-500 text-sm py-2 flex items-center gap-3">
                    <Cross1Icon />
                    The locked object has been deleted so you can't accept this
                    anymore.
                  </p>
                </div>
              )}
          </div>
        )}
      </div>
    </SuiObjectDisplay>
  );
}
```
</details>

<details>
  <summary>
    Add `src/components/escrows/EscrowList.tsx`
  </summary>
  {@inject: examples/trading/frontend/src/components/escrows/EscrowList.tsx}
</details>

<details>
  <summary>
    Update `src/routes/EscrowDashboard.tsx` to include the `EscrowList` component
  </summary>
```tsx
import { useState } from "react";
import { Tabs, Tooltip } from "@radix-ui/themes";
import { LockedList } from "../components/locked/ApiLockedList";
import { EscrowList } from "../components/escrows/EscrowList";
import { InfoCircledIcon } from "@radix-ui/react-icons";
import { useCurrentAccount } from "@mysten/dapp-kit";

export function EscrowDashboard() {
  const account = useCurrentAccount();
  const tabs = [
    {
      name: "Browse Locked Objects",
      component: () => (
        <LockedList
          params={{
            deleted: "false",
          }}
          enableSearch
        />
      ),
      tooltip: "Browse locked objects you can trade for.",
    },
    {
      name: "My Pending Requests",
      component: () => (
        <EscrowList
          params={{
            sender: account?.address,
            swapped: "false",
            cancelled: "false",
            
          }}
          enableSearch
        />
      ),
      tooltip: "Escrows you have initiated for third party locked objects.",
    },
  ];

  const [tab, setTab] = useState(tabs[0].name);

  return (
    <Tabs.Root value={tab} onValueChange={setTab}>
      <Tabs.List>
        {tabs.map((tab, index) => {
          return (
            <Tabs.Trigger
              key={index}
              value={tab.name}
              className="cursor-pointer"
            >
              {tab.name}
              <Tooltip content={tab.tooltip}>
                <InfoCircledIcon className="ml-3" />
              </Tooltip>
            </Tabs.Trigger>
          );
        })}
      </Tabs.List>
      {tabs.map((tab, index) => {
        return (
          <Tabs.Content key={index} value={tab.name}>
            {tab.component()}
          </Tabs.Content>
        );
      })}
    </Tabs.Root>
  );
}
```
</details>

:::checkpoint

Run your app and ensure you can:

- View the escrows in the `My Pending Requests` tab in the `Escrows` page.
- Cancel an escrow that you requested.

![Cancel escrow](./images/trustless-cancel-escrow.png)

:::

### Accept escrows

To accept the escrow, create a mutation through the `useAcceptEscrowMutation` hook in `src/mutations/escrow.ts`. The implementation should be fairly familiar to you now. The accept function accepts the escrow `ApiEscrowObject` and the locked object `ApiLockedObject`. The `{PACKAGE_ID}::shared::swap` Move call is generic, thus it requires the type parameters of the escrowed and locked objects. Query the objects details by using `multiGetObjects` on Sui client instance. Lastly, execute the `{PACKAGE_ID}::shared::swap` Move call and transfer the returned escrowed item to the connected wallet account. When the mutation succeeds, invalidate the cache to allow automatic re-fetch of the data.

<details>
  <summary>
    `escrow.ts`
  </summary>
```tsx
import { CONSTANTS, QueryKey } from "@/constants";
import { useTransactionExecution } from "@/hooks/useTransactionExecution";
import { ApiEscrowObject, ApiLockedObject } from "@/types/types";
import { useCurrentAccount, useSuiClient } from "@mysten/dapp-kit";
import { SuiObjectData } from "@mysten/sui/client";
import { Transaction } from "@mysten/sui/transactions";
import { useMutation, useQueryClient } from "@tanstack/react-query";

/**
 * Builds and executes the PTB to create an escrow.
 */
export function useCreateEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const executeTransaction = useTransactionExecution();

  return useMutation({
    mutationFn: async ({
      object,
      locked,
    }: {
      object: SuiObjectData;
      locked: ApiLockedObject;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");

      const txb = new Transaction();
      txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::create`,
        arguments: [
          txb.object(object.objectId!),
          txb.pure.id(locked.keyId),
          txb.pure.address(locked.creator!),
        ],
        typeArguments: [object.type!],
      });

      return executeTransaction(txb);
    },
  });
}

/**
 * Builds and executes the PTB to cancel an escrow.
 */
export function useCancelEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const executeTransaction = useTransactionExecution();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      escrow,
      suiObject,
    }: {
      escrow: ApiEscrowObject;
      suiObject: SuiObjectData;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");
      const txb = new Transaction();

      const item = txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::return_to_sender`,
        arguments: [txb.object(escrow.objectId)],
        typeArguments: [suiObject?.type!],
      });

      txb.transferObjects([item], txb.pure.address(currentAccount?.address!));

      return executeTransaction(txb);
    },

    onSuccess: () => {
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: [QueryKey.Escrow] });
      }, 1_000);
    },
  });
}

/**
 * Builds and executes the PTB to accept an escrow.
 */
export function useAcceptEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const client = useSuiClient();
  const executeTransaction = useTransactionExecution();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      escrow,
      locked,
    }: {
      escrow: ApiEscrowObject;
      locked: ApiLockedObject;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");
      const txb = new Transaction();

      const escrowObject = await client.multiGetObjects({
        ids: [escrow.itemId, locked.itemId],
        options: {
          showType: true,
        },
      });

      const escrowType = escrowObject.find(
        (x) => x.data?.objectId === escrow.itemId,
      )?.data?.type;

      const lockedType = escrowObject.find(
        (x) => x.data?.objectId === locked.itemId,
      )?.data?.type;

      if (!escrowType || !lockedType) {
        throw new Error("Failed to fetch types.");
      }

      const item = txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::swap`,
        arguments: [
          txb.object(escrow.objectId),
          txb.object(escrow.keyId),
          txb.object(locked.objectId),
        ],
        typeArguments: [escrowType, lockedType],
      });

      txb.transferObjects([item], txb.pure.address(currentAccount.address));

      return executeTransaction(txb);
    },

    onSuccess: () => {
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: [QueryKey.Escrow] });
      }, 1_000);
    },
  });
}
```
</details>

<details>
  <summary>
    Update `src/components/escrows/Escrow.tsx` to include the `useAcceptEscrowMutation` hook
  </summary>
  {@inject: examples/trading/frontend/src/components/escrows/Escrow.tsx}
</details>

<details>
  <summary>
    Update `src/routes/EscrowDashboard.tsx` to include the `EscrowList` component
  </summary>
  {@inject: examples/trading/frontend/src/routes/EscrowDashboard.tsx}
</details>

:::checkpoint

Run your app and ensure you can:

- Accept an escrow that someone else requested.

![Accept escrow](./images/trustless-accept-escrow.png)

:::

### Finished frontend

At this point, you have a fully functional frontend that allows users to discover trades and interact with listed escrows. The UI is designed to be user-friendly and intuitive, allowing users to easily navigate and interact with the application. Have fun exploring the app and testing out the different features!

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/tic-tac-toe.mdx
```
---
title: Tic-Tac-Toe
effort: small
---

:::info

You can view the [complete source code for this app example](https://github.com/MystenLabs/sui/tree/main/examples/tic-tac-toe) in the Sui repository.

:::

This guide covers three different implementations of the game tic-tac-toe on Sui. The first example utilizes a centralized admin that owns the board object and marks it on the users’ behalf. The second example utilizes a shared object that both users can mutate. And the third example utilizes a [multisig](https://docs.sui.io/guides/developer/cryptography/multisig), where instead of sharing the game board, it's in a 1-of-2 multisig of both users’ accounts.

The guide is divided into three parts that each cover a different implementation of the tic-tac-toe game board:

1. [Centralized game board](#owned.move): An admin service that tracks player moves and updates the game board.
1. [Shared game board](#shared.move): A shared object that allows players to directly update the game board.
1. [Multisig operated game board](#multisig): A multisig account that acts as the game admin, allowing either player to update the game board directly.

## What the guide teaches

- **Owned objects:** The guide teaches you how to use [owned objects](../../../concepts/object-ownership/address-owned.mdx), in this case to act as the game board in the centralized and multisig version of tic-tac-toe. Owned objects are objects that are owned by a single account and can only be modified by that account. In this case, the game board is owned by a game admin, who is responsible for updating the board with each player's move.
- **Shared objects:** The guide teaches you how to use [shared objects](../../../concepts/object-ownership/shared.mdx), in this case to act as the game board in the more decentralized version of tic-tac-toe. Shared objects are objects that can be modified by multiple accounts. In this case, the game board is shared between the two players, allowing them to update the board directly.
- **Multisig accounts:** The guide teaches you how to use [multisig accounts](https://sdk.mystenlabs.com/typescript/cryptography/multisig) to share ownership of the game board between two players. Multisig accounts are accounts that require a certain threshold of signatures to authorize a transaction. In this case, the game board is owned by a 1-of-2 multisig account.
- **Dynamic object fields:** The guide teaches you how to use dynamic object fields, in this case to transfer the actions of the players to the game board, which will be retrieved by the game admin. See [The Move Book](https://move-book.com/programmability/dynamic-object-fields.html) to learn more about dynamic object fields.

## What you need

Before getting started, make sure you have:

- [Installed the latest version of Sui](../getting-started/sui-install.mdx).
- Read the basics of [shared versus owned objects](../sui-101/shared-owned.mdx).

## Directory structure

To begin, create a new folder on your system titled `tic-tac-toe` that holds all your files.

In this folder, create the following subfolders: 
- `move` to hold the Move code for the game board.
  - `sources` to hold the Move source files.

<details>
  <summary>
    Add `Move.toml` to `tic-tac-toe/move/`
  </summary>
  {@inject: examples/tic-tac-toe/move/Move.toml}
</details>

:::checkpoint

- You have the latest version of Sui installed. If you run `sui --version` in your terminal or console, it responds with the currently installed version.
- You have a directory to place the files you create in. 
- You have created a `Move.toml` file in the `tic-tac-toe/move/` directory.

:::

## owned.move {#owned.move}

Create a new file in `tic-tac-toe/move/sources` titled `owned.move`. Later, you will update this file to contain the Move code for the game board in the centralized (and multisig) version of tic-tac-toe.

In this first example of tic-tac-toe, the `Game` object, including the game board, is controlled by a game admin.

{@inject: examples/tic-tac-toe/move/sources/owned.move#struct=Game noComments}

Ignore the `admin` field for now, as it is only relevant for the multisig approach.

Games are created with the `new` function:

{@inject: examples/tic-tac-toe/move/sources/owned.move#fun=new noComments}

Some things to note: 
- `MARK__` is a constant that represents an empty cell on the game board. `MARK_X` and `MARK_O` represent the two players' markers.
- The first player is sent a `TurnCap`, which gives them permission to take the next turn.
- This function creates and returns the `Game` object, it is up to its creator to send it to the game admin to own.

Because the players don’t own the game board object, they cannot directly mutate it. Instead, they indicate their move by creating a `Mark` object with their intended placement and send it to the game object using transfer to object:

{@inject: examples/tic-tac-toe/move/sources/owned.move#struct=Mark noComments}

When playing the game, the admin operates a service that keeps track of marks using events. When a request is received (`send_mark`), the admin tries to place the marker on the board (`place_mark`). Each move requires two steps (thus two transactions): one from the player and one from the admin. This setup relies on the admin's service to keep the game moving.

{@inject: examples/tic-tac-toe/move/sources/owned.move#fun=send_mark,place_mark noComments}

When a player sends a mark, a `Mark` object is created and is sent to the `Game` object. The admin then receives the mark and places it on the board. This is a use of dynamic object fields, where an object, `Game`, can hold other objects, `Mark`.

To view the entire source code, see the [owned.move source file](https://github.com/MystenLabs/sui/blob/main/examples/tic-tac-toe/move/sources/owned.move). You can find the rest of the logic, including how to check for a winner, as well as deleting the game board after the game concludes there.

<details>
<summary>
`owned.move`
</summary>
{@inject: examples/tic-tac-toe/move/sources/owned.move}
</details>

An alternative version of this game, shared tic-tac-toe, uses shared objects for a more straightforward implementation that doesn't use a centralized service. This comes at a slightly increased cost, as using shared objects is more expensive than transactions involving wholly owned objects.

## shared.move {#shared.move}

In the previous version, the admin owned the game object, preventing players from directly changing the gameboard, as well as requiring two transactions for each marker placement. In this version, the game object is a shared object, allowing both players to access and modify it directly, enabling them to place markers in just one transaction. However, using a shared object generally incurs extra costs because Sui needs to sequence the operations from different transactions. In the context of this game, where players are expected to take turns, this shouldn't significantly impact performance. Overall, this shared object approach simplifies the implementation compared to the previous method.

As the following code demonstrates, the `Game` object in this example is almost identical to the one before it. The only differences are that it does not include an `admin` field, which is only relevant for the multisig version of the game, and it does not have `store`, because it only ever exists as a shared object (so it cannot be transferred or wrapped).

{@inject: examples/tic-tac-toe/move/sources/shared.move#struct=Game noComments}

Take a look at the `new` function:

{@inject: examples/tic-tac-toe/move/sources/shared.move#fun=new noComments}

Instead of the game being sent to the game admin, it is instantiated as a shared object. The other notable difference is that there is no need to mint a `TurnCap` because the only two addresses that can play this game are `x` and `o`, and this is checked in the next function, `place_mark`:

{@inject: examples/tic-tac-toe/move/sources/shared.move#fun=place_mark noComments}

<details>
<summary>
`shared.move`
</summary>
{@inject: examples/tic-tac-toe/move/sources/shared.move}
</details>

## Multisig  {#multisig}

Multisig tic-tac-toe uses the same Move code as the owned version of the game, but interacts with it differently. Instead of transferring the game to a third party admin account, the players create a 1-of-2 multisig account to act as the game admin, so that either player can sign on behalf of the "admin". This pattern offers a way to share a resource between up to ten accounts without relying on consensus.

In this implementation of the game, the game is in a 1-of-2 multisig account that acts as the game admin. In this particular case, because there are only two players, the previous example is a more convenient use case. However, this example illustrates that in some cases, a multisig can replace shared objects, thus allowing transactions to bypass consensus when using such an implementation.

### Creating a multisig account

A multisig account is defined by the public keys of its constituent keypairs, their relative weights, and the threshold -- a signature is valid if the sum of weights of constituent keys having signed the signature exceeds the threshold. In our case, there are at most two constituent keypairs, they each have a weight of 1 and the threshold is also 1. A multisig cannot mention the same public key twice, so keys are deduplicated before the multisig is formed to deal with the case where a player is playing themselves:

```typescript title="examples/tic-tac-toe/ui/src/MultiSig.ts"
export function multiSigPublicKey(keys: PublicKey[]): MultiSigPublicKey {
  const deduplicated: { [key: string]: PublicKey } = {};
  for (const key of keys) {
    deduplicated[key.toSuiAddress()] = key;
  }

  return MultiSigPublicKey.fromPublicKeys({
    threshold: 1,
    publicKeys: Object.values(deduplicated).map((publicKey) => {
      return { publicKey, weight: 1 };
    }),
  });
}
```

<details>
<summary>
`MultiSig.ts`
</summary>
{@inject: examples/tic-tac-toe/ui/src/MultiSig.ts}
</details>

Note that an address on Sui can be derived from a public key (this fact is used in the previous example to deduplicate public keys based on their accompanying address), but the opposite is not true. This means that to start a game of multisig tic-tac-toe, players must exchange public keys, instead of addresses.

### Building a multisig transaction

When creating a multisig game, we make use of `owned::Game`'s `admin` field to store the multisig public key for the admin account. Later, it will be used to form the signature for the second transaction in the move. This does not need to be stored on-chain, but we are doing so for convenience so that when we fetch the `Game`'s contents, we get the public key as well:

```typescript title="examples/tic-tac-toe/ui/src/hooks/useTransactions.ts"
newMultiSigGame(player: PublicKey, opponent: PublicKey): Transaction {
  const admin = multiSigPublicKey([player, opponent]);
  const tx = new Transaction();

  const game = tx.moveCall({
    target: `${this.packageId}::owned::new`,
    arguments: [
      tx.pure.address(player.toSuiAddress()),
      tx.pure.address(opponent.toSuiAddress()),
      tx.pure(bcs.vector(bcs.u8()).serialize(admin.toRawBytes()).toBytes()),
    ],
  });

  tx.transferObjects([game], admin.toSuiAddress());

  return tx;
}
```

`useTransactions.ts` also contains functions to place, send, and receive marks, end the game, and burn completed games. These functions all return a `Transaction` object, which is used in the React frontend to execute the transaction with the appropriate signer.

<details>
<summary>
`useTransactions.ts`
</summary>
{@inject: examples/tic-tac-toe/ui/src/hooks/useTransactions.ts}
</details>

### Placing a mark

Placing a mark requires two transactions, just like the owned example, but they are both driven by one of the players. The first transaction is executed by the player as themselves, to send the mark to the game, and the second is executed by the player acting as the admin to place the mark they just sent. In the React frontend, this is performed as follows:

```typescript title="examples/tic-tac-toe/ui/src/pages/Game.tsx"
function OwnedGame({
  game,
  trophy,
  invalidateGame,
  invalidateTrophy,
}: {
  game: GameData;
  trophy: Trophy;
  invalidateGame: InvalidateGameQuery;
  invalidateTrophy: InvalidateTrophyQuery;
}): ReactElement {
  const adminKey = game.admin ? new MultiSigPublicKey(new Uint8Array(game.admin)) : null;

  const client = useSuiClient();
  const signAndExecute = useExecutor();
  const multiSignAndExecute = useExecutor({
    execute: ({ bytes, signature }) => {
      const multiSig = adminKey!!.combinePartialSignatures([signature]);
      return client.executeTransactionBlock({
        transactionBlock: bytes,
        signature: [multiSig, signature],
        options: {
          showRawEffects: true,
        },
      });
    },
  });

  const [turnCap, invalidateTurnCap] = useTurnCapQuery(game.id);
  const account = useCurrentAccount();
  const tx = useTransactions()!!;

  // ...

  const onMove = (row: number, col: number) => {
    signAndExecute(
      {
        tx: tx.sendMark(turnCap?.data!!, row, col),
        options: { showObjectChanges: true },
      },
      ({ objectChanges }) => {
        const mark = objectChanges?.find(
          (c) => c.type === 'created' && c.objectType.endsWith('::Mark'),
        );

        if (mark && mark.type === 'created') {
          const recv = tx.receiveMark(game, mark);
          recv.setSender(adminKey!!.toSuiAddress());
          recv.setGasOwner(account?.address!!);

          multiSignAndExecute({ tx: recv }, () => {
            invalidateGame();
            invalidateTrophy();
            invalidateTurnCap();
          });
        }
      },
    );
  };

  // ...
}
```

<details>
<summary>
`Game.tsx`
</summary>
{@inject: examples/tic-tac-toe/ui/src/pages/Game.tsx}
</details>

The first step is to get the multisig public key, which was written to `Game.admin` earlier. Then two executor hooks are created: The first is to sign and execute as the current player, and the second is to sign and execute as the multisig/admin account. After the wallet has serialized and signed the transaction the second executor creates a multisig from the wallet signature and executes the transaction with two signatures: Authorizing on behalf of the multisig and the wallet.

The reason for the two signatures is clearer when looking at the construction of the `recv` transaction: The multisig authorizes access to the `Game`, and the wallet authorizes access to the gas object. This is because the multisig account does not hold any coins of its own, so it relies on the player account to sponsor the transaction.

You can find an example React front-end supporting both the multi-sig and shared variants of the game in the [ui directory](https://github.com/MystenLabs/sui/blob/main/examples/tic-tac-toe/ui), and a CLI written in Rust in the [cli directory](https://github.com/MystenLabs/sui/blob/main/examples/tic-tac-toe/cli).

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/recaptcha.mdx
```
---
title: Prevent Bots
description: Write and deploy a smart contract in Move that uses reCAPTCHA to verify users are human (and not bots) before they interact with the contract.
draft: true
---

This guide shows you how to write and deploy a smart contract in Move that uses reCAPTCHA to verify users are human (and not bots) before they interact with the contract. CAPTCHA is a method of bot mitigation that requires you to pass a challenge test to prove that you are human. CAPTCHA tests are effective in preventing bots from performing tasks, but the tests can become annoying or frustrating for legitimate users if they are too difficult or frequent. reCAPTCHA is a form of CAPTCHA testing.

This guide assumes you have [installed Sui](../getting-started/sui-install.mdx) and understand Sui fundamentals.

## Move smart contract

As with all Sui dApps, a Move package on chain powers the logic of the reCAPTCHA module. The following instruction walks you through creating and publishing the module.

### reCAPTCHA module

Before you get started, you must initialize a Move package. Open a terminal or console in the directory you want to store the example and run the following command to create an empty package with the name `recaptcha`:

```sh
$ sui move new recaptcha
```

With that done, it's time to jump into some code. Create a new file in the `sources` directory with the name `recaptcha.move` and populate the file with the following code:

```rust title='recaptcha.move'
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module recaptcha::recaptcha {
    // Import the vector module for manipulating vectors.
    use std::vector;

    // Import the clock module for getting the current time.
    use sui::clock::Clock;
    // Import the dynamic_field module for adding custom fields to objects.
    use sui::dynamic_field as df;
    // Import the ed25519 module for verifying signatures.
    use sui::ed25519::ed25519_verify;
    // Import the event module for emitting events.
    use sui::event::emit;
    // Import the math module for performing mathematical operations.
    use sui::math;
    // Import the object module for creating and manipulating objects.
    use sui::object::{Self, UID};
    // Import the transfer module for sharing and transferring objects.
    use sui::transfer;
    // Import the tx_context module for accessing transaction information.
    use sui::tx_context::{sender, TxContext};

    /// Error code for transactions that violate the cooldown period.
    const EVerificationExpired: u64 = 0;
    /// Error code for invalid signatures.
    const EInvalidSignature: u64 = 1;
    /// Error code for senders that are not yet verified.
    const ENotYetVerified: u64 = 2;

    // Define a constant for the duration of the time window in milliseconds
    const TIME_WINDOW: u64 = 60_000;
}
```

There are few details to take note of in this code:

1. The fourth line declares the module name as `recaptcha` within the package `recaptcha`.
1. The next eight lines use the use keyword to import types and functions from other modules, such as `sui::clock::Clock`, `sui::dynamic_field as df`, `sui::ed25519::ed25519_verify`, `sui::event::emit,sui::math`, `sui::object::{Self, UID}`, `sui::transfer`, and `sui::tx_context::{sender, TxContext}`. These modules are needed for the implementation of the reCAPTCHA verification and the interaction logic.
1. The following three lines declare the error codes, namely: `EVerificationExpired`, `EInvalidSignature`, and `ENotYetVerified`, that are used to check the validity of the reCAPTCHA test result and the eligibility of the user. The error codes are also used in the unit tests to verify the correctness of the program.
1. The last line declares the constant `TIME_WINDOW`, which specifies the duration of the time window in milliseconds. The time window is the period of time that the user is eligible to interact with the smart contract after passing the reCAPTCHA test.

Next, add some more code to this module:

```rust title='recaptcha.move'
struct Interaction has copy, drop {
    sender: address, // The address of the sender
    timestamp_ms: u64, // The timestamp in milliseconds
}

// Define a struct for the registry object that has a key field
struct Registry has key {
    id: UID, // The unique identifier of the registry object
    window: u64, // The length of the time window in milliseconds
}

// Define a function for initializing the registry
fun init(ctx: &mut TxContext) {
    // Share the registry object with other participants
    transfer::share_object(
        Registry {
            id: object::new(ctx), // Create a new object with a unique id
            window: TIME_WINDOW, // Set the time window to the constant value
        }
    );
}
```

- The `Interaction` struct is used to define the data that is emitted as an event when a user successfully interacts with the smart contract. The `Interaction` event has two fields: the sender's address and the timestamp in milliseconds. The sender's address is the account that initiated the interaction, and the timestamp is the current time when the event is triggered.
- The `Registry` struct stores the mapping of the user’s address to the expiration time of the eligibility to interact with the smart contract. It also has a `window` field that specifies the length of the time window in milliseconds. The time window is the period of time that the user is eligible to interact with the smart contract after passing the reCAPTCHA test.
- The [`init` function](concepts/sui-move-concepts/init.mdx) creates a [shared object](concepts/object-ownership/shared.mdx) for the `Registry`. The function is called when the smart contract is deployed to the blockchain. The function creates a new registry object with a unique id and sets the time window to the constant value.

So far, you've set up the data structures within the module.
Now, create a function that verifies the message

```rust title='recaptcha.move'
/// @param registry: The registry object.
/// @param signature: 32-byte signature that is a point on the Ed25519 elliptic curve.
/// @param public_key: 32-byte signature that is a point on the Ed25519 elliptic curve.
/// @param msg: The message that we test the signature against.
public fun verify(
    registry: &mut Registry,
    signature: vector<u8>,
    public_key: vector<u8>,
    msg: vector<u8>,
    ctx: &mut TxContext
) {
    let verified = ed25519_verify(&signature, &public_key, &msg);
    assert!(verified, EInvalidSignature);

    if (!df::exists_with_type<address, u64>(&registry.id, sender(ctx))) {
        df::add<address, u64>(
            &mut registry.id,
            sender(ctx),
            msg_to_ts(&msg)
        );
    } else {
        let timestamp_ms = df::borrow_mut<address, u64>(&mut registry.id, sender(ctx));
        *timestamp_ms = msg_to_ts(&msg);
    }
}

/// Function to get the timestamp_ms from the message, which is a vector of bytes, and transform it to a u64.
public fun msg_to_ts(
    message: &vector<u8>
): u64 {
    let vec_length = vector::length(message);

    let (value, i) = (0u64, 0u8);
    while (i < 13) {
        let element = (*vector::borrow(message, vec_length - (i as u64) - 1) - 48 as u64); // '0' = 48
        value = value + element * math::pow(10, i); // 10^i
        i = i + 1;
    };
    value
}
```

The `verify` function is a public function that allows anyone to register themselves as non-bot using the function call. The function takes five parameters:

- `registry`: The registry object that stores the mapping of the user's address to the expiration time of the eligibility.
- `signature`: The 32-byte signature that is a point on the Ed25519 elliptic curve. The signature is generated by the oracle using its private key and the message that contains the user's address and the current timestamp.
- `public_key`: The 32-byte public key that is a point on the Ed25519 elliptic curve. The public key is the oracle's public key that is used to verify the signature.
- `msg`: The message that contains the user's address and the current timestamp. The message is encoded as a vector of bytes.
- `ctx`: The transaction context that provides information about the sender, the gas limit, and the gas price.

The function performs the following steps:

- It calls the `ed25519_verify` function from the `sui::ed25519` module to check if the signature is valid for the given public key and message. The `ed25519_verify` function returns a boolean value that indicates the validity of the signature.
- It asserts that the signature is valid, otherwise it aborts the execution with the error code `EInvalidSignature`.
- It checks if the user's address exists as a key in the dynamic field of the registry object. The dynamic field is a way of storing key-value pairs in an object without declaring them in advance and it can be accessed, modified, or deleted using the `sui::dynamic_field` module.
- If the user's address does not exist as a key in the dynamic field, it adds a new key-value pair to the dynamic field. The key is the user's address and the value is the expiration time of the eligibility. The expiration time is calculated by calling the `msg_to_ts` function that converts the message to a timestamp in milliseconds.
- If the user's address already exists as a key in the dynamic field, it updates the value of the key to the new expiration time of the eligibility.

Now that you have implemented `verify`, you can move on to the next step, which is to demonstrate how someone can interact with the contract. Write an `interact` function that checks whether the user is verified or not.

```rust title='recaptcha.move'
// Define a public function for interacting with the registry object
public fun interact(
    registry: &mut Registry,  // A mutable reference to the registry object
    clock: &Clock,  // A reference to the clock object
    ctx: &mut TxContext  // A mutable reference to the transaction context
) {
    // Check if there is an existing interaction history for the sender address with the registry object
    if (df::exists_with_type<address, u64>(&registry.id, sender(ctx))) {
        // Borrow a mutable reference to the interaction history object
        let timestamp_ms = df::borrow_mut<address, u64>(&mut registry.id, sender(ctx));
        // Get the current timestamp in milliseconds from the clock object
        let current_timestamp = sui::clock::timestamp_ms(clock);

        if (current_timestamp - *timestamp_ms <= registry.window) {
            emit(
                Interaction{
                    sender: sender(ctx),
                    timestamp_ms: sui::clock::timestamp_ms(clock)
                }
            );
        } else {
            abort EVerificationExpired
        }
    } else {
        abort ENotYetVerified
    }
}
```

The `interact` function is a public function that allows the user to interact with the smart contract after passing the reCAPTCHA test. The function is linked to the `verify` function, which verifies the reCAPTCHA test result and registers the user's eligibility to interact with the smart contract.
The function takes three parameters:

- `registry`: A mutable reference to the registry object that stores the mapping of the user's address to the expiration time of the eligibility.
- `clock`: A reference to the clock object that provides the current timestamp in milliseconds.
- `ctx`: A mutable reference to the transaction context that provides information about the sender, the gas limit, and the gas price.

The function performs the following steps:

- It checks if there is an existing interaction history for the sender address with the registry object. The interaction history is stored as a dynamic field in the registry object. The dynamic field is a way of storing key-value pairs in an object without declaring them in advance. The dynamic field can be accessed, modified, or deleted using the `sui::dynamic_field` module.
- If there is an existing interaction history, it borrows a mutable reference to the interaction history object. The interaction history object contains the expiration time of the eligibility in milliseconds.
- It gets the current timestamp in milliseconds from the clock object and compares it with the expiration time of the eligibility. If the current timestamp is within the time window of the eligibility, it emits an interaction event. The interaction event is a struct that contains the sender address and the timestamp in milliseconds. The interaction event can be used to implement the logic of the decentralized application, such as voting, bidding, or playing.
- If the current timestamp is outside the time window of the eligibility, it aborts the execution with the error code `EVerificationExpired`. This means that the user has to pass the reCAPTCHA test again to interact with the smart contract.
- If there is no existing interaction history, it aborts the execution with the error code `ENotYetVerified`. This means that the user has not passed the reCAPTCHA test yet and cannot interact with the smart contract.

And with that, your `recaptcha.move` code is complete.

## Deployment

{@include: ../../../snippets/initialize-sui-client-cli.mdx}

{@include: ../../../snippets/publish-to-devnet-with-coins.mdx}

The package should successfully deploy. Next, set up a backend server that verifies whether the user has successfully completed the reCAPTCHA challenge and then signs a message that should be passed to the `verify` function.

## Backend

To implement the backend for the reCAPTCHA, you need to create an `express` app that can handle HTTP requests and responses. You also need to install some dependencies, such as `@noble/ed25519`, `axios`, `cors`, `helmet`, `morgan`, and `dotenv`. These packages help you with cryptography, HTTP requests, cross-origin resource sharing, security, logging, and environment variables.

Here are the steps to create the backend:

1. Initialize a new project with `npm init -y`.
2. Install the dependencies with `npm install --save @noble/ed25519 axios cors helmet morgan dotenv` or `yarn add @noble/ed25519 axios cors helmet morgan dotenv`.
3. Create a file named `app.ts` and paste the following code.

```typescript title='app.ts'
import * as ed from '@noble/ed25519';
import axios from 'axios';
import cors from 'cors';
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';

import api from './api';
import MessageResponse from './interfaces/MessageResponse';
import * as middlewares from './middlewares';

require('dotenv').config();

const app = express();

app.use(morgan('dev'));
app.use(helmet());
app.use(cors());
app.use(express.json());

app.get<{}, MessageResponse>('/', (req, res) => {
	res.json({
		message: 'Express + TypeScript Server',
	});
});

interface RecaptchaApiResponse {
	success: boolean;
	challenge_ts: string; // timestamp of the challenge load (ISO format yyyy-MM-dd'T'HH:mm:ssZZ)
	hostname: string; // the hostname of the site where the reCAPTCHA was solved
	signature?: Uint8Array;
	pubKey?: Uint8Array;
	message?: Uint8Array;
	'error-codes'?: any[]; // optional
}

app.post('/verify-token', async (req, res) => {
	const now: number = Date.now();
	const privKey = process.env.SK!;

	const pubKey = await ed.getPublicKey(privKey);
	const { response, secret, userAddress } = req.body;

	console.log('userAddress: ' + userAddress);
	console.log('secret: ' + secret);
	console.log('response: ' + response);
	console.log('now: ' + now);
	console.log('privKey: ' + privKey);

	const message: string = stringToHex(userAddress.replace('0x', '').concat(now.toString()));

	console.log('message: ' + message);

	const signature = await ed.sign(message, privKey);
	const isValid = await ed.verify(signature, message, pubKey);

	console.log({ message, pubKey, signature, isValid });

	try {
		let axiosResponse = await axios.post<RecaptchaApiResponse>(
			`https://www.google.com/recaptcha/api/siteverify?secret=${secret}&response=${response}`,
		);
		console.log(axiosResponse.data);
		return res.status(200).json({
			success: axiosResponse.data.success,
			verificationInfo: axiosResponse.data,
			signature: Array.from(signature),
			pubKey: Array.from(pubKey),
			message: Array.from(Uint8Array.from(Buffer.from(message, 'hex'))),
		});
	} catch (error) {
		console.log(error);
		return res.status(500).json({
			success: false,
		});
	}
});

function stringToHex(str: string): string {
	let hex = '';
	for (let i = 0; i < str.length; i++) {
		const charCode = str.charCodeAt(i);
		const hexValue = charCode.toString(16);

		// Pad with zeros to ensure two-digit representation
		hex += hexValue.padStart(2, '0');
	}
	return hex;
}

app.use('/api/v1', api);

app.use(middlewares.notFound);
app.use(middlewares.errorHandler);

export default app;
```

4. Examine the code to see what it does.

- First, you import the modules that you need for your app.
- Next, you create an express app and use some middlewares to enhance its functionality. You use `morgan` for logging, `helmet` for security, `cors` for cross-origin resource sharing, and `express.json` for parsing JSON data.
- Then, you define a `GET` route for the root path (`/`) that returns a simple JSON message.
- After that, you define an interface for the reCAPTCHA API response. This is the data that you receive from Google when you verify the user's response token. It contains some fields such as `success`, `challenge_ts`, `hostname`, and `error-codes`. It also has some optional fields that you will add later, such as `signature`, `pubKey`, and `message`.
- Next, you define a `POST` route for the `/verify-token` path that handles the verification of the user's response token. This is the main logic of your backend. Here are the steps that you follow in this route:
  - Get the current time in milliseconds and store it in a variable named `now`.
  - Get the secret key from the environment variable `SK` and store it in a variable named `privKey`. This is the key that you use to sign your message and verify your identity to the smart contract.
  - Use the `@noble/ed25519` module to get the public key from the private key and store it in a variable named `pubKey`. This is the key that you share with the smart contract and the user.
  - Get the response token, the secret key, and the user's address from the request body and store them in variables named `response`, `secret`, and `userAddress`.
  - Log the values of these variables for debugging purposes.
  - Create a message that consists of the user's address (without the `0x` prefix) and the current time, and convert it to a hexadecimal string. Store it in a variable named `message`.
  - Use the `@noble/ed25519` module to sign the message with the private key and store the signature in a variable named `signature`.
  - Use the `@noble/ed25519` module to verify the signature with the message and the public key and store the result in a variable named `isValid`.
  - Log the values of these variables for debugging purposes.
  - Use the axios module to send a POST request to the reCAPTCHA API with the secret key and the response token as parameters. Store the response in a variable named `axiosResponse`.
  - Check if the response data has a success field and if it is true. If so, return a JSON object with the following fields:
    - `success`: true
    - `verificationInfo`: the response data from the reCAPTCHA API
    - `signature`: the signature converted to an array of numbers
    - `pubKey`: the public key converted to an array of numbers
    - `message`: the message converted to an array of numbers
  - If not, catch the error and return a JSON object with the following field:
    - `success`: false
- Next, define a helper function named `stringToHex` that takes a string as an input and returns a hexadecimal string as an output. This function is used to convert the message to a hexadecimal format.
- Finally, use some custom middlewares to handle not found and error cases, and export the app as a default module.

That's it! You have implemented the backend for the reCAPTCHA. To run the app, you can use `node app.ts` or `ts-node app.ts` if you have TypeScript installed. You can also use a tool like `nodemon` to automatically restart the app when you make changes. To test the app, you can use a tool like Postman or curl to send requests to the app and see the responses.

## Frontend

To implement the frontend for the reCAPTCHA, you need to create a react app that can render a user interface and interact with the backend and the smart contract. You also need to install some dependencies, such as `@mysten/dapp-kit`, `@mysten/sui`, `axios`, and `react-google-recaptcha`. These packages help you with wallet integration, transaction execution, HTTP requests, and reCAPTCHA rendering.

Here are the steps to create the frontend:

1. Initialize a new project with `pnpm create vite recaptcha-app --template react-ts`.
2. Install the dependencies with `pnpm install --save @mysten/dapp-kit @mysten/sui axios react-google-recaptcha`.
3. Create a file named `.env` and add the following environment variables:
   - `VITE_reCAPTCHA_SITE_KEY`: the site key that you get from Google when you register your site for reCAPTCHA
   - `VITE_reCAPTCHA_SECRET_KEY`: the secret key that you get from Google when you register your site for reCAPTCHA
   - `VITE_PACKAGE_ID`: the package ID of the smart contract that you want to interact with
   - `VITE_REGISTRY_ID`: the registry ID of the smart contract that you want to interact with
4. Create a file named `App.tsx` and paste the code you have provided.

```typescript title='App.tsx'
import './App.css';

import {
	ConnectButton,
	useCurrentAccount,
	useCurrentWallet,
	useSignAndExecuteTransaction,
} from '@mysten/dapp-kit';
import { Transaction } from '@mysten/sui/transactions';
import { SUI_CLOCK_OBJECT_ID } from '@mysten/sui/utils';
import Axios from 'axios';
import { useEffect, useState } from 'react';
import ReCAPTCHA from 'react-google-recaptcha';

interface RecaptchaApiResponse {
	success: boolean;
	challenge_ts: string; // timestamp of the challenge load (ISO format yyyy-MM-dd'T'HH:mm:ssZZ)
	hostname: string; // the hostname of the site where the reCAPTCHA was solved
	signature?: Uint8Array;
	pubKey?: Uint8Array;
	message?: Uint8Array;
	'error-codes'?: any[]; // optional
}

function App() {
	const { currentWallet } = useCurrentWallet();
	const { mutateAsync: signAndExecuteTransaction } = useSignAndExecuteTransaction();
	const currentAccount = useCurrentAccount();

	const SITE_KEY = import.meta.env.VITE_reCAPTCHA_SITE_KEY!;
	const SECRET_KEY = import.meta.env.VITE_reCAPTCHA_SECRET_KEY!;
	const packageId = import.meta.env.VITE_PACKAGE_ID!;
	const registryId = import.meta.env.VITE_REGISTRY_ID!;
	const moduleId: string = 'recaptcha';

	const [isRecaptchaValid, setRecaptchaValidation] = useState(false);

	const [verificationPassedOneTime, setVerificationPassedOneTime] = useState(false);

	const [message, setMessage] = useState(new Uint8Array());
	const [pubKey, setPubKey] = useState(new Uint8Array());
	const [signature, setSignature] = useState(new Uint8Array());

	const onChange = async (token: string | null) => {
		if (token === null) {
			setRecaptchaValidation(false);
		} else {
			const recaptchaApiResponse: RecaptchaApiResponse = await verifyToken(token);

			setRecaptchaValidation(true);

			if (!verificationPassedOneTime) setVerificationPassedOneTime(true);

			if (recaptchaApiResponse.message !== undefined) setMessage(recaptchaApiResponse.message);
			if (recaptchaApiResponse.pubKey !== undefined) setPubKey(recaptchaApiResponse.pubKey);
			if (recaptchaApiResponse.signature !== undefined)
				setSignature(recaptchaApiResponse.signature);
		}
	};

	async function verifyToken(token: string): Promise<RecaptchaApiResponse> {
		try {
			const response = await Axios.post(`https://bot-prevention-api.vercel.app/verify-token`, {
				response: token,
				secret: SECRET_KEY,
				userAddress: currentAccount?.address,
			});
			return response['data'];
		} catch (error) {
			console.log(error);
		}
		return {} as RecaptchaApiResponse;
	}

	useEffect(() => {
		// You can do something with `currentWallet` here.
	}, [currentWallet]);

	return (
		<div className="App">
			<ConnectButton />
			<div>
				<button
					disabled={!verificationPassedOneTime}
					onClick={async () => {
						const transaction = new Transaction();

						transaction.moveCall({
							target: `${packageId}::${moduleId}::interact`,
							arguments: [transaction.object(registryId), transaction.object(SUI_CLOCK_OBJECT_ID)],
						});

						console.log(
							await signAndExecuteTransaction({
								transaction: transaction,
							}),
						);
					}}
				>
					Interact
				</button>
			</div>

			<div>
				<button
					disabled={!isRecaptchaValid}
					onClick={async () => {
						const transaction = new Transaction();

						transaction.moveCall({
							target: `${packageId}::${moduleId}::verify`,
							arguments: [
								transaction.object(registryId),
								transaction.pure(signature),
								transaction.pure(pubKey),
								transaction.pure(message),
							],
						});

						console.log(
							await signAndExecuteTransaction({
								transaction,
							}),
						);
					}}
				>
					Verify
				</button>
			</div>

			<hr />
			<ReCAPTCHA sitekey={SITE_KEY} onChange={onChange} />
		</div>
	);
}

export default App;
```

5. Examine the code to see what it does.

- First, import the modules that you need for your app.
- Next, use hooks from `@mysten/dapp-kit` to get access to the current wallet, the current account, and the `signAndExecuteTransaction` function. These help you connect to the wallet and execute transactions on the blockchain.
- Then, define some constants for the site key, the secret key, the package ID, the registry ID, and the module ID. These are the values that you use to interact with the reCAPTCHA API and the smart contract.
- After that, define some state variables to store the status of the reCAPTCHA validation, the verification result, and the message, the public key, and the signature that you get from the backend. Use the `useState` hook from React to manage these state variables.
- Next, define a function named `onChange` that takes a token as an input and handles the change of the reCAPTCHA component. This function is triggered when the user completes the reCAPTCHA challenge. Here are the steps that you follow in this function:
  - Check if the token is null. If so, set the reCAPTCHA validation state to false.
  - If not, call the `verifyToken` function with the token as an argument and store the result in a variable named `recaptchaApiResponse`. This function sends a POST request to the backend and gets the verification result and the data that you need to interact with the smart contract.
  - Set the reCAPTCHA validation state to true.
  - Check if the `verificationPassedOneTime` state is false. If so, set it to true. This state is used to enable the interact button only once after the user passes the verification.
  - Check if the `recaptchaApiResponse` has the message, the `pubKey`, and the `signature` fields. If so, set the corresponding state variables with the values from the response.
- Next, define a function named `verifyToken` that takes a token as an input and returns a promise of the reCAPTCHA API response. This function is used to communicate with the backend. Here are the steps that you follow in this function:
  - Try to send a POST request to the backend URL with the token, the secret key, and the user's address as the body parameters. Use the `axios` module to send the request and store the response in a variable named `response`.
  - Return the data field of the response as the reCAPTCHA API response.
  - Catch any error and log it to the console.
  - Return an empty object as the default reCAPTCHA API response.
- Next, use the `useEffect` hook from React to run some code when the `currentWallet` state changes. In this case, you don't do anything, but you could add some logic here if you want to.
- Finally, return a JSX element that renders the app. The app consists of the following components:
  - A `ConnectButton` component from `@mysten/dapp-kit` that allows the user to connect to their wallet.
  - A button that allows the user to interact with the smart contract. This button is disabled unless the user passes the verification at least once. When the user clicks this button, create a new `Transaction` object from `@mysten/sui` and add a `moveCall` action that calls the `interact` function of the smart contract with the registry ID and the clock object ID as arguments. Then, use the `signAndExecuteTransaction` function from `@mysten/dapp-kit` to sign and execute the transaction block on the blockchain. You also log the result to the console.
  - A button that allows the user to verify their identity to the smart contract. This button is disabled unless the user passes the reCAPTCHA challenge. When the user clicks this button, create a new `Transaction` object from `@mysten/sui` and add a `moveCall` action that calls the verify function of the smart contract with the registry ID, the signature, the public key, and the message as arguments. Then, use the `signAndExecuteTransaction` function from `@mysten/dapp-kit` to sign and execute the transaction block on the blockchain. You also log the result to the console.
  - A `ReCAPTCHA` component from `react-google-recaptcha` that renders the reCAPTCHA widget. You pass the site key and the `onChange` function as props to this component.

That's it! You have implemented the frontend for the reCAPTCHA. To run the app, you can use `pnpm run dev`. To test the app, you can open the browser and go to the `localhost:5173` URL. You should see the app and can interact with the reCAPTCHA and the smart contract.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/reviews-rating.mdx
```
---
title: Review Rating
---

The following documentation goes through an example implementation of a review rating platform for the food service industry on Sui.
Unlike traditional review rating platforms that often do not disclose the algorithm used to rate reviews, this example uses an algorithm that is published on-chain for everyone to see and verify. The low gas cost of computation on Sui make it financially feasible to submit, score, and order all reviews on-chain.

## Personas

There are four actors in the typical workflow of the Reviews Rating example.

- Service: Review requester.
- Dashboard: Review hub.
- Reviewer: Review creator.
- Moderator: Review list editor.

```mermaid
sequenceDiagram
  Service ->> Dashboard: Add service to dashboard
  Service ->> Reviewer: Send proof of experience
  Reviewer ->> Service: Send review
  Service ->> Reviewer: Send reward
  Review reader ->> Service: Vote on review
  Moderator ->> Service: Remove abused review
```

### Service owners

Service owners are entities like restaurants that list their services on the platform. They want to attract more customers by receiving high-rated reviews for their services.

Service owners allocate a specific amount of SUI as a reward pool. Assets from the pool are used to provide rewards for high-rated reviews. A proof of experience (PoE) NFT confirms a reviewer used the service, which the reviewer can burn later to provide a verified review. Service owners provide their customers with unique identifiers (perhaps using QR codes) to identify individual reviewers.

### Reviewers

Reviewers are consumers of services that use the review system. Reviewers provide feedback in the form of comments that detail specific aspects of the service as well as a star rating to inform others. The reviews are rated, with the most effective reviews getting the highest rating. Service owners award the 10 highest rated reviews for their service. How often the rewards are distributed is up to the service owner's discretion; for example, the rewards can be distributed once a week or once a month.

### Review readers

Review readers access reviews to make informed decisions on selecting services. Readers rate reviews by casting votes. The review readers' ratings are factored into the algorithm that rates the reviews, with the authors of the highest-rated reviews getting rewarded. Although it is not implemented as part of this guide, this example could be extended to award review readers a portion of the rewards for casting votes for reviews.

### Moderators

Moderators monitor content of the reviews and can delete any reviews that contain inappropriate content.

The incentive mechanism for moderators is not implemented for this guide, but service owners can all pay into a pool that goes to moderators on a rolling basis. People can stake moderators to influence what portion of the reward each moderator gets, up to a limit (similar to how validators are staked on chain), and moderator decisions are decided by quorum of stake weight. This process installs incentives for moderators to perform their job well.

## How reviews are scored

The reviews are scored on chain using the following criteria:

- Intrinsic score (IS): Length of review content.
- Extrinsic score (ES): Number of votes a review receives.
- Verification multiplier (VM): Reviews with PoE receive a multiplier to improve rating.

```
Total Score = (IS + ES) * VM
```

## Smart contracts

There are several modules that create the backend logic for the example.

### dashboard.move

The `dashboard.move` module defines the `Dashboard` struct that groups services.

```move
/// Dashboard is a collection of services
public struct Dashboard has key, store {
    id: UID,
    service_type: String
}
```

The services are grouped by attributes, which can be cuisine type, geographical location, operating hours, Google Maps ID, and so on. To keep it basic, the example stores only `service_type` (for example, fast food, Chinese, Italian).

```move
/// Creates a new dashboard
public fun create_dashboard(
    service_type: String,
    ctx: &mut TxContext,
) {
    let db = Dashboard {
        id: object::new(ctx),
        service_type
    };
    transfer::share_object(db);
}

/// Registers a service to a dashboard
public fun register_service(db: &mut Dashboard, service_id: ID) {
    df::add(&mut db.id, service_id, service_id);
}
```

A `Dashboard` is a [shared object](../../../concepts/object-ownership/shared.mdx), so any service owner can register their service to a dashboard.
A service owner should look for dashboards that best match their service attribute and register.
A dynamic field stores the list of services that are registered to a dashboard. Learn more about dynamic fields in [The Move Book](https://move-book.com/programmability/dynamic-fields.html).
A service may be registered to multiple dashboards at the same time. For example, a Chinese-Italian fusion restaurant may be registered to both the Chinese and Italian dashboards.

:::info

See [Shared versus Owned Objects](../sui-101/shared-owned.mdx) for more information on the differences between object types.

:::

### review.move

This module defines the `Review` struct.

```move
/// Represents a review of a service
public struct Review has key, store {
    id: UID,
    owner: address,
    service_id: ID,
    content: String,
    // intrinsic score
    len: u64,
    // extrinsic score
    votes: u64,
    time_issued: u64,
    // proof of experience
    has_poe: bool,
    total_score: u64,
    overall_rate: u8,
}

/// Updates the total score of a review
fun update_total_score(rev: &mut Review) {
    rev.total_score = rev.calculate_total_score();
}

/// Calculates the total score of a review
fun calculate_total_score(rev: &Review): u64 {
    let mut intrinsic_score: u64 = rev.len;
    intrinsic_score = math::min(intrinsic_score, 150);
    let extrinsic_score: u64 = 10 * rev.votes;
    // VM = either 1.0 or 2.0 (if user has proof of experience)
    let vm: u64 = if (rev.has_poe) { 2 } else { 1 };
    (intrinsic_score + extrinsic_score) * vm
}
```

In addition to the content of a review, all the elements that are required to compute total score are stored in a `Review` object.

A `Review` is a [shared object](../../../concepts/object-ownership/shared.mdx), so anyone can cast a vote on a review and update its `total_score` field.
After `total_score` is updated, the [`update_top_reviews`](#casting-votes) function can be called to update the `top_reviews` field of the `Service` object.

### service.move

This module defines the `Service` struct that service owners manage.

```move
const MAX_REVIEWERS_TO_REWARD: u64 = 10;

/// Represents a service
public struct Service has key, store {
    id: UID,
    reward_pool: Balance<SUI>,
    reward: u64,
    top_reviews: vector<ID>,
    reviews: ObjectTable<ID, Review>,
    overall_rate: u64,
    name: String
}
```

#### Reward distribution

The same amount is rewarded to top reviewers, and the reward is distributed to 10 participants at most.
The pool of `SUI` tokens to be distributed to reviewers is stored in the `reward_pool` field, and the amount of `SUI` tokens awarded to each participant is configured in `reward` field.

#### Storage for reviews

Because anyone can submit a review for a service, `Service` is defined as a shared object. All the reviews are stored in the `reviews` field, which has `ObjectTable<ID, Review>` type. The `reviews` are stored as children of the shared object, but they are still accessible by their `ID`. See [Dynamic Collections](https://move-book.com/programmability/dynamic-collections.html#objecttable) in The Move Book for more information on `ObjectTables`.

In other words, anyone can go to a transaction explorer and find a review object by its object ID, but they won't be able to use a review as an input to a transaction by its object ID.

:::info

See [Dynamic Collections](https://move-book.com/programmability/dynamic-collections.html) in The Move Book for more information on the differences between `Table` and `ObjectTable`.

:::

The top rated reviews are stored in `top_reviews` field, which has `vector<ID>` type. A simple vector can store the top rated reviews because the maximum number of reviews that can be rewarded is 10.
The elements of `top_reviews` are sorted by the `total_score` of the reviews, with the highest rated reviews coming first. The vector contains the `ID` of the reviews, which can be used to retrieve content and vote count from the relevant `reviews`.

#### Casting votes

A reader can cast a vote on a review to rate it as follows:

```move
/// Upvotes a review and reorders top_reviews
public fun upvote(service: &mut Service, review_id: ID) {
    let review = &mut service.reviews[review_id];
    review.upvote();
    service.reorder(review_id, review.get_total_score());
}

/// Reorders top_reviews after a review is updated
/// If the review is not in top_reviews, it will be added if it is in the top 10
/// Otherwise, it will be reordered
fun reorder(
    service: &mut Service,
    review_id: ID,
    total_score: u64
) {
    let (contains, idx) = service.top_reviews.index_of(&review_id);
    if (!contains) {
        service.update_top_reviews(review_id, total_score);
    } else {
        service.top_reviews.remove(idx);
        let idx = service.find_idx(total_score);
        service.top_reviews.insert(review_id, idx);
    }
}

/// Updates top_reviews if necessary
fun update_top_reviews(
    service: &mut Service,
    review_id: ID,
    total_score: u64
) {
    if (service.should_update_top_reviews(total_score)) {
        let idx = service.find_idx(total_score);
        service.top_reviews.insert(review_id, idx);
        service.prune_top_reviews();
    };
}

/// Finds the index of a review in top_reviews
fun find_idx(service: &Service, total_score: u64): u64 {
    let mut i = service.top_reviews.length();
    while (0 < i) {
        let review_id = service.top_reviews[i - 1];
        if (service.get_total_score(review_id) > total_score) {
            break
        };
        i = i - 1;
    };
    i
}

/// Prunes top_reviews if it exceeds MAX_REVIEWERS_TO_REWARD
fun prune_top_reviews(
    service: &mut Service
) {
    let len = service.top_reviews.length();
    if (len > MAX_REVIEWERS_TO_REWARD) {
        service.top_reviews.pop_back();
    };
}
```

Whenever someone casts a vote on a review, the `total_score` of the review is updated and the `update_top_reviews` function updates the `top_reviews` field, as needed.
Casting a vote also triggers a reordering of the `top_reviews` field to ensure that the top rated reviews are always at the top.

#### Authorization

```move
/// A capability that can be used to perform admin operations on a service
struct AdminCap has key, store {
    id: UID,
    service_id: ID
}

/// Represents a moderator that can be used to delete reviews
struct Moderator has key {
    id: UID,
}
```

This example follows a capabilities pattern to manage authorizations.
For example, `SERVICE OWNERS` are given `AdminCap` and `MODERATORS` are given `Moderator` such that only they are allowed to perform privileged operations.

To learn more about the capabilities pattern, see [The Move Book](https://move-book.com/programmability/capability.html).

## Deployment

Navigate to the [setup folder](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/setup) of the repository and execute the `publish.sh` script. Refer to the [README instructions](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/README.md) for deploying the smart contracts.

## Frontend

The frontend module is written in React, and is structured to provide a responsive user experience for interacting with a review rating platform. The [`page` component](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/page.tsx) supports user log in as a `SERVICE OWNER`, a `MODERATOR`, or a `REVIEWER`. A `REVIEW READER` role is not implemented for this example, but a `REVIEWER` can also read reviews and cast votes.

### Directories structure

The frontend is a NextJS project, that follows the NextJS App Router [project structure](https://nextjs.org/docs/app/building-your-application/routing).
The main code of the frontend is located in the [app/src/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/) directory.

The main sub-directories are:

- [app/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/): The main code of the pages and the global styles.
- [components/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/components): The reusable components of the app, organized in sub-directories.
- [hooks/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/hooks): The custom hooks used in the app.
- [moderator/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/moderator): The pages for `MODERATOR`.
- [serviceOwner/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/serviceOwner): The pages for `SERVICE OWNER`.
- [types/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/types): The types/interfaces used in the app.
- [user/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/user): The pages for `REVIEWER`.

### Connect button

The Wallet Kit comes with a pre-built React.js component called `ConnectButton` that displays a button to connect and disconnect a wallet. The component handles connecting and disconnecting wallet logic.

Place the `ConnectButton` in the navigation bar for users to connect their wallets:

```ts title='src/app/components/navbar/Navbar.tsx'
import { ConnectButton } from '@mysten/wallet-kit';
import { usePathname } from 'next/navigation';

import { useAuthentication } from '@/app/hooks/useAuthentication';

export const Navbar = () => {
	const pathname = usePathname();
	console.log(pathname);
	const { user, handleLogout } = useAuthentication();

	return (
		<div
			className="grid grid-cols-12 w-full items-center p-[8px] h-[80px] border-b-gray-400 border-b-[1px] sticky top-0"
			style={{
				background: 'white',
			}}
		>
			<div className="col-span-3 flex space-x-3 items-center">
				<div className="text-red-600 text-2xl font-bold cursor-pointer" onClick={handleLogout}>
					Restaurant Reviews
				</div>
			</div>

			<div className="col-span-6 flex space-x-3 justify-center">
				{pathname !== '/' && (
					<h6 className="mb-4 text-2xl leading-none tracking-tight text-gray-400">
						logged in as{' '}
						<span className="underline underline-offset-3 decoration-8 decoration-blue-400 dark:decoration-blue-600">
							{user.role === 'user' && 'USER'}
							{user.role === 'serviceOwner' && 'SERVICE OWNER'}
							{user.role === 'moderator' && 'MODERATOR'}
						</span>
					</h6>
				)}
			</div>

			<div className="col-span-3 flex justify-end gap-[14px]">
				<ConnectButton />
			</div>
		</div>
	);
};
```

### Type definitions

All the type definitions are in `src/app/types/`.

`Review` and `Service` represent the review and service objects.

```ts title='src/app/types/Review.ts'
export interface Review {
	id: string;
	owner: string;
	service_id: string;
	content: string;
	len: number;
	votes: number;
	time_issued: number;
	has_poe: boolean;
	total_score: number;
}
```

```ts title='src/app/types/Service.ts'
export interface Service {
	id: string;
	name: string;
	stars: number;
	reward?: number;
	pool?: number;
}
```

### Execute transaction hook

In the frontend, you might need to execute a transaction block in multiple places, hence it's better to extract the transaction execution logic and reuse it everywhere. Let's examine the execute transaction hook.

```ts title='src/app/hooks/useSignAndExecuteTransaction.ts'
import { Transaction } from '@mysten/sui/transactions';
import { useWalletKit } from '@mysten/wallet-kit';
import { toast } from 'react-hot-toast';

import { useSui } from './useSui';

export const useSignAndExecuteTransaction = () => {
	const { executeSignedTransaction } = useSui();
	const { signTransaction } = useWalletKit();
	const handleSignAndExecuteTransaction = async (
		tx: Transaction,
		operation: String,
		setIsLoading: any,
	) => {
		return signTransaction({
			transaction: tx,
		})
			.then((signedTx: any) => {
				return executeSignedTransaction({
					signedTx,
					requestType: 'WaitForLocalExecution',
					options: {
						showEffects: true,
						showEvents: true,
					},
				})
					.then((resp) => {
						setIsLoading(false);
						console.log(resp);
						if (resp.effects?.status.status === 'success') {
							console.log(`${operation} operation successful`);
							toast.success(`${operation} operation successful`);
							return;
						} else {
							console.log(`${operation} operation failed`);
							toast.error(`${operation} operation failed.`);
							return;
						}
					})
					.catch((err) => {
						setIsLoading(false);
						console.log(`${operation} operation failed`);
						console.log(`${operation} error : `, err);
						toast.error(`Something went wrong, ${operation} operation failed.`);
					});
			})
			.catch((err) => {
				setIsLoading(false);
				console.log(`signing goes wrong ${operation} error : `, err);
				toast.error(`signing goes wrong, ${operation} operation failed.`);
			});
	};
	return { handleSignAndExecuteTransaction };
};
```

A `Transaction` is the input, sign it with the current connected wallet account, execute the transaction block, return the execution result, and finally display a basic toast message to indicate whether the transaction is successful or not.

Use the `useWalletKit()` hook from the Wallet Kit to retrieve the Sui client instance configured in `WalletKitProvider`. The `signTransaction()` function is another hook that helps to sign the transaction block using the currently connected wallet. It displays the UI for users to review and sign their transactions with their selected wallet. To execute a transaction block, the `executeSignedTransaction()` on the Sui client instance of the Sui TypeScript SDK. Use `react-hot-toast` as another dependency to toast transaction status to users.

### Components and custom hooks for state management

- Custom hooks: To keep the code as structured as possible, multiple custom hooks are utilized to manage the list of reviews associated with a service. The [useGetReviews](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useGetReviews.ts)
  custom hook encapsulates the service, exposing all the required information (with fields such as `nameOfService`, `listOfReviews`, `listOfStars`) to display the reviews in a table.
  Multiple additional custom hooks, such as [useDashboardCreation](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useDashboardCreation.ts), and [useServiceReview](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useServiceReview.ts) are encapsulating their own piece of state and logic to make the code readable and maintainable.

- Component for adding a new review: The [AddReview](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/components/review/AddReview.tsx) component is implemented to facilitate the creation of a new review. It is rendered by the [servicePage](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/service/[id]/page.tsx) to collect a review entry from a `USER` and uses the `signAndExecuteTransaction` function of the [useWalletKit] hook to execute the transaction.

- Proof of experience generation: PoE is an NFT that is minted by `SERVICE OWNER` for customers after they dine at the restaurant; customers can then burn the PoE to write a high-rated review later. Minting an NFT is facilitated by the [ownedServicePage](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/serviceOwner/ownedServices/page.tsx) component. This component is using the [useServicePoEGeneration](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useServicePoeGeneration.ts) custom hook.

- Delete a review: The moderator can delete a review that contains inappropriate content. [moderatorRemovePage](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/moderator/remove/[id]/[nft]/page.tsx) component is used to delete a review.

## Related links

[Reviews Rating repository](https://github.com/MystenLabs/sui/tree/main/examples/move/reviews_rating).

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/coin-flip.mdx
```
---
title: Coin Flip
description: Learn Sui through a coin flip dApp that covers the full end-to-end flow of building a Sui Move module and connecting it to a React Sui dApp.
---

This example walks you through building a coin flip dApp, covering the full end-to-end flow of building your Sui Move module and connecting it to your React Sui dApp. This coin flip dApp utilizes verifiable random functions (VRFs) to create a fair coin game on the Sui blockchain. The user (human) plays against the house (module) and places a bet on either heads or tails. The user then either receives double their bet, or gets nothing, depending on the outcome of the game.

The guide is split into two parts:

1. [Smart Contracts](#smart-contracts): The Move code that sets up the coin flip logic.
1. [Frontend](#frontend): A UI that enables the players to place bets and take profits, and the admin to manage the house. 

:::tip Additional resources

Source code locations for the smart contracts and frontend: 
- [Move package repository](https://github.com/MystenLabs/satoshi-coin-flip)
- [Frontend repository](https://github.com/sui-foundation/satoshi-coin-flip-frontend-example)

:::

## What the guide teaches

- **Shared objects:** The guide teaches you how to use [shared objects](concepts/object-ownership/shared.mdx), in this case to create a globally accessible `HouseData` object.
- **One-time witnesses:** The guide teaches you how to use [one-time witnesses](concepts/sui-move-concepts.mdx#one-time-witness) to ensure only a single instance of the `HouseData` object ever exists.
- **Asserts:** The guide teaches you how to use [asserts](https://move-book.com/move-basics/assert-and-abort.html?highlight=asserts#assert) to abort functions due to certain conditions not being met.
- **Address-owned objects:** The guide teaches you how to use [address-owned objects](concepts/object-ownership/address-owned.mdx) when necessary.
- **Events:** The guide teaches you how to emit events in your contracts, which can be used to track on-chain activity. For more information on events, see [Using Events](../sui-101/using-events.mdx) for practical usage of events on Sui or [Events in The Move Book](https://move-book.com/programmability/events.html) to learn about event structure and how to emit them in Move.
- **Storage rebates:** The guide shows you best practices regarding [storage fee rebates](concepts/tokenomics.mdx#storage-fund-rewards).
- **MEV attack protection:** The guide introduces you to [MEV attacks](https://github.com/MystenLabs/satoshi-coin-flip?tab=readme-ov-file#mev-attack-resistant-single-player-satoshi-smart-contract-flow), how to make your contracts MEV-resistant, and the trade-offs between protection and user experience.


## What you need

Before getting started, make sure you have:

- [Installed the latest version of Sui](../getting-started/sui-install.mdx).

## Smart contracts {#smart-contracts}

In this part of the guide, you write the Move contracts that manage the house and set up the coin-flip logic. The first step is to [set up a Move package](../first-app/write-package.mdx) for storing your Move modules.

:::info

To follow along with this guide, set your new Move package to `satoshi_flip`.

:::

### House module

This example uses several modules to create a package for the Satoshi Coin Flip game. The first module is `house_data.move`. You need to store the game's data somewhere, and in this module you create a [shared object](concepts/object-ownership/shared.mdx) for all house data.

Create a new file in the `sources` directory with the name `house_data.move` and populate the file with the following code:

```move title='house_data.move'
module satoshi_flip::house_data {

  use sui::balance::{Self, Balance};
  use sui::sui::SUI;
  use sui::coin::{Self, Coin};
  use sui::package::{Self};

  // Error codes
  const ECallerNotHouse: u64 = 0;
  const EInsufficientBalance: u64 = 1;

```

There are few details to take note of in this code:

1. The first line declares the module name as `house_data` within the package `satoshi_flip`.
1. Seven lines begin with the `use` keyword, which enables this module to use types and functions declared in other modules (in this case, they are all coming from the Sui standard library).
1. Two error codes. These codes are used in assertions and unit tests to ensure that the program is running as intended.

Next, add some more code to this module:

```move title='house_data.move'
  /// Configuration and Treasury object, managed by the house.
  public struct HouseData has key {
    id: UID,
    balance: Balance<SUI>,
    house: address,
    public_key: vector<u8>,
    max_stake: u64,
    min_stake: u64,
    fees: Balance<SUI>,
    base_fee_in_bp: u16
  }

  /// A one-time use capability to initialize the house data; created and sent
  /// to sender in the initializer.
  public struct HouseCap has key {
    id: UID
  }

  /// Used as a one time witness to generate the publisher.
  public struct HOUSE_DATA has drop {}

  fun init(otw: HOUSE_DATA, ctx: &mut TxContext) {
    // Creating and sending the Publisher object to the sender.
    package::claim_and_keep(otw, ctx);

    // Creating and sending the HouseCap object to the sender.
    let house_cap = HouseCap {
      id: object::new(ctx)
    };

    transfer::transfer(house_cap, ctx.sender());
  }
```

- The first struct, `HouseData`, stores the most essential information pertaining to the game.
- The second struct, `HouseCap`, is a capability that initializes the house data.
- The third struct, `HOUSE_DATA`, is a one-time witness that ensures only a single instance of this `HouseData` ever exists.
- The `init` function creates and sends the `Publisher` and `HouseCap` objects to the sender. See [Module Initializer](https://move-book.com/programmability/module-initializer.html) in The Move Book for more information.

So far, you've set up the data structures within the module. Now, create a function that initializes the house data and shares the `HouseData` object:

```move title='house_data.move'
  public fun initialize_house_data(house_cap: HouseCap, coin: Coin<SUI>, public_key: vector<u8>, ctx: &mut TxContext) {
    assert!(coin.value() > 0, EInsufficientBalance);

    let house_data = HouseData {
      id: object::new(ctx),
      balance: coin.into_balance(),
      house: ctx.sender(),
      public_key,
      max_stake: 50_000_000_000, // 50 SUI, 1 SUI = 10^9.
      min_stake: 1_000_000_000, // 1 SUI.
      fees: balance::zero(),
      base_fee_in_bp: 100 // 1% in basis points.
    };

    let HouseCap { id } = house_cap;
    object::delete(id);

    transfer::share_object(house_data);
  }
```

With the house data initialized, you also need to add some functions that enable some important administrative tasks for the house to perform:

```move title='house_data.move'
  public fun top_up(house_data: &mut HouseData, coin: Coin<SUI>, _: &mut TxContext) {
    coin::put(&mut house_data.balance, coin)
  }

  public fun withdraw(house_data: &mut HouseData, ctx: &mut TxContext) {
    // Only the house address can withdraw funds.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    let total_balance = balance(house_data);
    let coin = coin::take(&mut house_data.balance, total_balance, ctx);
    transfer::public_transfer(coin, house_data.house());
  }

  public fun claim_fees(house_data: &mut HouseData, ctx: &mut TxContext) {
    // Only the house address can withdraw fee funds.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    let total_fees = fees(house_data);
    let coin = coin::take(&mut house_data.fees, total_fees, ctx);
    transfer::public_transfer(coin, house_data.house());
  }

  public fun update_max_stake(house_data: &mut HouseData, max_stake: u64, ctx: &mut TxContext) {
    // Only the house address can update the base fee.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    house_data.max_stake = max_stake;
  }

  public fun update_min_stake(house_data: &mut HouseData, min_stake: u64, ctx: &mut TxContext) {
    // Only the house address can update the min stake.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    house_data.min_stake = min_stake;
  }
```

All of these functions contain an `assert!` call that ensures only the house can call them:

- `top_up`: Add to the balance of the house to ensure that there is enough SUI for future games.
- `withdraw`: Withdraw the entire balance of the house object.
- `claim_fees`: Withdraw the accumulated fees of the house object.
- `update_max_stake`, `update_min_stake`: Update the maximum and minimum stake allowed in the game, respectively.

You have established the data structure of this module, but without the appropriate functions this data is not accessible. Now add helper functions that return mutable references, read-only references, and test-only functions:

```move title='house_data.move'
  // --------------- Mutable References ---------------

  public(package) fun borrow_balance_mut(house_data: &mut HouseData): &mut Balance<SUI> {
    &mut house_data.balance
  }

  public(package) fun borrow_fees_mut(house_data: &mut HouseData): &mut Balance<SUI> {
    &mut house_data.fees
  }

  public(package) fun borrow_mut(house_data: &mut HouseData): &mut UID {
    &mut house_data.id
  }

  // --------------- Read-only References ---------------

  /// Returns a reference to the house id.
  public(package) fun borrow(house_data: &HouseData): &UID {
    &house_data.id
  }

  /// Returns the balance of the house.
  public fun balance(house_data: &HouseData): u64 {
    house_data.balance.value()
  }

  /// Returns the address of the house.
  public fun house(house_data: &HouseData): address {
    house_data.house
  }

  /// Returns the public key of the house.
  public fun public_key(house_data: &HouseData): vector<u8> {
    house_data.public_key
  }

  /// Returns the max stake of the house.
  public fun max_stake(house_data: &HouseData): u64 {
    house_data.max_stake
  }

  /// Returns the min stake of the house.
  public fun min_stake(house_data: &HouseData): u64 {
    house_data.min_stake
  }

  /// Returns the fees of the house.
  public fun fees(house_data: &HouseData): u64 {
    house_data.fees.value()
  }

  /// Returns the base fee.
  public fun base_fee_in_bp(house_data: &HouseData): u16 {
    house_data.base_fee_in_bp
  }

  // --------------- Test-only Functions ---------------

  #[test_only]
  public fun init_for_testing(ctx: &mut TxContext) {
    init(HOUSE_DATA {}, ctx);
  }
}
```

And with that, your `house_data.move` code is complete.

### Counter module

In the same `sources` directory, now create a file named `counter_nft.move`. A `Counter` object is used as the VRF input for every game that a player plays. First, populate the file with the following:

```move title='counter_nft.move'
module satoshi_flip::counter_nft {

  use sui::bcs::{Self};

  public struct Counter has key {
    id: UID,
    count: u64,
  }

  entry fun burn(self: Counter) {
    let Counter { id, count: _ } = self;
    object::delete(id);
  }

  public fun mint(ctx: &mut TxContext): Counter {
    Counter {
      id: object::new(ctx),
      count: 0
    }
  }

  public fun transfer_to_sender(counter: Counter, ctx: &mut TxContext) {
    transfer::transfer(counter, tx_context::sender(ctx));
  }
```

This might look familiar from the house module. You set the module name, import functions from the standard library, and initialize the `Counter` object. The `Counter` object has the `key` ability, but does not have `store` - this prevents the object from being transferable.

In addition, you create `mint` and `transfer_to_sender` functions used when the game is set up to create the `Counter` object (with an initial count of `0`) and transfer the object to the sender of the transaction. And finally a `burn` function to allow deletion of the `Counter`.

You have a `Counter` object, as well as functions that initialize and burn the object, but you need a way to increment the counter. Add the following code to the module:

```move title='counter_nft.move'
  public fun get_vrf_input_and_increment(self: &mut Counter): vector<u8> {
    let mut vrf_input = object::id_bytes(self);
    let count_to_bytes = bcs::to_bytes(&count(self));
    vrf_input.append(count_to_bytes);
    self.increment();
    vrf_input
  }

  public fun count(self: &Counter): u64 {
    self.count
  }

  fun increment(self: &mut Counter) {
    self.count = self.count + 1;
  }

  #[test_only]
  public fun burn_for_testing(self: Counter) {
    self.burn();
  }
}
```

The `get_vrf_input_and_increment` function is the core of this module. The function takes a mutable reference to the `Counter` object that the `mint` function creates, then appends the `Counter` object's current count to its ID and returns the result as a `vector<u8>`. The function then calls the internal `increment` function to increment the count by one.

This code also adds a `count` function that returns the current count, and a test-only function that calls the `burn` function.

### Game module

Lastly, you need a game module and object that can create a new game, distribute funds after the game, and potentially cancel games. Because this is a one-player game, create an [address-owned object](concepts/object-ownership/address-owned.mdx) rather than a [shared object](/concepts/object-ownership/shared.mdx).

Create the game module. In the `sources` directory, create a new file called `single_player_satoshi.move` and populate with the following:

```move title='single_player_satoshi.move'
module satoshi_flip::single_player_satoshi {
  use std::string::String;

  use sui::coin::{Self, Coin};
  use sui::balance::Balance;
  use sui::sui::SUI;
  use sui::bls12381::bls12381_min_pk_verify;
  use sui::event::emit;
  use sui::hash::{blake2b256};
  use sui::dynamic_object_field::{Self as dof};

  use satoshi_flip::counter_nft::Counter;
  use satoshi_flip::house_data::HouseData;

  const EPOCHS_CANCEL_AFTER: u64 = 7;
  const GAME_RETURN: u8 = 2;
  const PLAYER_WON_STATE: u8 = 1;
  const HOUSE_WON_STATE: u8 = 2;
  const CHALLENGED_STATE: u8 = 3;
  const HEADS: vector<u8> = b"H";
  const TAILS: vector<u8> = b"T";

  const EStakeTooLow: u64 = 0;
  const EStakeTooHigh: u64 = 1;
  const EInvalidBlsSig: u64 = 2;
  const ECanNotChallengeYet: u64 = 3;
  const EInvalidGuess: u64 = 4;
  const EInsufficientHouseBalance: u64 = 5;
  const EGameDoesNotExist: u64 = 6;

  public struct NewGame has copy, drop {
    game_id: ID,
    player: address,
    vrf_input: vector<u8>,
    guess: String,
    user_stake: u64,
    fee_bp: u16
  }

  public struct Outcome has copy, drop {
    game_id: ID,
    status: u8
  }
```

This code follows the same pattern as the others. First, you include the respective imports, although this time the imports are not only from the standard library but also include modules created previously in this example. You also create several constants (in upper case), as well as constants used for errors (Pascal case prefixed with `E`).

Lastly in this section, you also create structs for two events to emit. Indexers consume emitted events, which enables you to track these events through API services, or your own indexer. In this case, the events are for when a new game begins (`NewGame`) and for the outcome of a game when it has finished (`Outcome`).

Add a struct to the module:

```move title='single_player_satoshi.move'
  public struct Game has key, store {
    id: UID,
    guess_placed_epoch: u64,
    total_stake: Balance<SUI>,
    guess: String,
    player: address,
    vrf_input: vector<u8>,
    fee_bp: u16
  }
```

The `Game` struct represents a single game and all its information, including the epoch the player placed the bet (`guess_placed_epoch`), bet (`total_stake`), `guess`, address of the `player`, `vrf_input`, and the fee the house collects (`fee_bp`).

Now take a look at the main function in this game, `finish_game`:

```move title='single_player_satoshi.move'
  public fun finish_game(game_id: ID, bls_sig: vector<u8>, house_data: &mut HouseData, ctx: &mut TxContext) {
    // Ensure that the game exists.
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);

    let Game {
      id,
      guess_placed_epoch: _,
      mut total_stake,
      guess,
      player,
      vrf_input,
      fee_bp
    } = dof::remove<ID, Game>(house_data.borrow_mut(), game_id);

    object::delete(id);

    // Step 1: Check the BLS signature, if its invalid abort.
    let is_sig_valid = bls12381_min_pk_verify(&bls_sig, &house_data.public_key(), &vrf_input);
    assert!(is_sig_valid, EInvalidBlsSig);

    // Hash the beacon before taking the 1st byte.
    let hashed_beacon = blake2b256(&bls_sig);
    // Step 2: Determine winner.
    let first_byte = hashed_beacon[0];
    let player_won = map_guess(guess) == (first_byte % 2);

    // Step 3: Distribute funds based on result.
    let status = if (player_won) {
      // Step 3.a: If player wins transfer the game balance as a coin to the player.
      // Calculate the fee and transfer it to the house.
      let stake_amount = total_stake.value();
      let fee_amount = fee_amount(stake_amount, fee_bp);
      let fees = total_stake.split(fee_amount);
      house_data.borrow_fees_mut().join(fees);

      // Calculate the rewards and take it from the game stake.
      transfer::public_transfer(total_stake.into_coin(ctx), player);
      PLAYER_WON_STATE
    } else {
      // Step 3.b: If house wins, then add the game stake to the house_data.house_balance (no fees are taken).
      house_data.borrow_balance_mut().join(total_stake);
      HOUSE_WON_STATE
    };

    emit(Outcome {
      game_id,
      status
    });
  }
```

- First, the function makes sure the `Game` object exists, then deletes it, as after the game concludes the metadata is no longer needed. Freeing up unnecessary storage is not only recommended, but [incentivized through rebates on storage fees](concepts/tokenomics.mdx#storage-fund-rewards).
- In step 1, the function checks to see if the BLS signature is valid. This is to ensure the game is truly random.
- In step 2, the function checks to see if the player's guess, heads (`0`) or tails (`1`), is the same as that of the house. This is done by taking the first byte of the randomized vector and checking to see if it's divisible by two. If it is, it is heads, if it is not, it is tails.
- In step 3, if the player won, meaning the player's guess matched the results of the house, the logic transfers fees from the stake to the house, then distributes the rest of the principle plus an equal amount from the house's balance back to the player. If the player loses, the logic transfers the entire stake to the house, and takes no fees.
- Lastly, the game emits its outcome as an event.

Now add a function that handles game disputes:

```move title='single_player_satoshi.move'
  public fun dispute_and_win(house_data: &mut HouseData, game_id: ID, ctx: &mut TxContext) {
    // Ensure that the game exists.
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);

    let Game {
      id,
      guess_placed_epoch,
      total_stake,
      guess: _,
      player,
      vrf_input: _,
      fee_bp: _
    } = dof::remove(house_data.borrow_mut(), game_id);

    object::delete(id);

    let caller_epoch = ctx.epoch();
    let cancel_epoch = guess_placed_epoch + EPOCHS_CANCEL_AFTER;
    // Ensure that minimum epochs have passed before user can cancel.
    assert!(cancel_epoch <= caller_epoch, ECanNotChallengeYet);

    transfer::public_transfer(total_stake.into_coin(ctx), player);

    emit(Outcome {
      game_id,
      status: CHALLENGED_STATE
    });
  }
```

This function, `dispute_and_win`, ensures that no bet can live in “purgatory”. After a certain amount of time passes, the player can call this function and get all of their funds back.

The rest of the functions are accessors and helper functions used to retrieve values, check if values exist, initialize the game, and so on:

```move title='single_player_satoshi.move'
  // --------------- Read-only References ---------------

  public fun guess_placed_epoch(game: &Game): u64 {
    game.guess_placed_epoch
  }

  public fun stake(game: &Game): u64 {
    game.total_stake.value()
  }

  public fun guess(game: &Game): u8 {
    map_guess(game.guess)
  }

  public fun player(game: &Game): address {
    game.player
  }

  public fun vrf_input(game: &Game): vector<u8> {
    game.vrf_input
  }

  public fun fee_in_bp(game: &Game): u16 {
    game.fee_bp
  }

  // --------------- Helper functions ---------------

  /// Public helper function to calculate the amount of fees to be paid.
  public fun fee_amount(game_stake: u64, fee_in_bp: u16): u64 {
    ((((game_stake / (GAME_RETURN as u64)) as u128) * (fee_in_bp as u128) / 10_000) as u64)
  }

  /// Helper function to check if a game exists.
  public fun game_exists(house_data: &HouseData, game_id: ID): bool {
    dof::exists_(house_data.borrow(), game_id)
  }

  /// Helper function to check that a game exists and return a reference to the game Object.
  /// Can be used in combination with any accessor to retrieve the desired game field.
  public fun borrow_game(game_id: ID, house_data: &HouseData): &Game {
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);
    dof::borrow(house_data.borrow(), game_id)
  }

  /// Internal helper function used to create a new game.
  fun internal_start_game(guess: String, counter: &mut Counter, coin: Coin<SUI>, house_data: &mut HouseData, fee_bp: u16, ctx: &mut TxContext): (ID, Game) {
    // Ensure guess is valid.
    map_guess(guess);
    let user_stake = coin.value();
    // Ensure that the stake is not higher than the max stake.
    assert!(user_stake <= house_data.max_stake(), EStakeTooHigh);
    // Ensure that the stake is not lower than the min stake.
    assert!(user_stake >= house_data.min_stake(), EStakeTooLow);
    // Ensure that the house has enough balance to play for this game.
    assert!(house_data.balance() >= user_stake, EInsufficientHouseBalance);

    // Get the house's stake.
    let mut total_stake = house_data.borrow_balance_mut().split(user_stake);
    coin::put(&mut total_stake, coin);

    let vrf_input = counter.get_vrf_input_and_increment();

    let id = object::new(ctx);
    let game_id = object::uid_to_inner(&id);

    let new_game = Game {
      id,
      guess_placed_epoch: ctx.epoch(),
      total_stake,
      guess,
      player: ctx.sender(),
      vrf_input,
      fee_bp
    };

    emit(NewGame {
      game_id,
      player: ctx.sender(),
      vrf_input,
      guess,
      user_stake,
      fee_bp
    });

    (game_id, new_game)
  }

  /// Helper function to map (H)EADS and (T)AILS to 0 and 1 respectively.
  /// H = 0
  /// T = 1
  fun map_guess(guess: String): u8 {
    let heads = HEADS;
    let tails = TAILS;
    assert!(guess.bytes() == heads || guess.bytes() == tails, EInvalidGuess);

    if (guess.bytes() == heads) {
      0
    } else {
      1
    }
  }
}
```

## Finished package

This represents a basic example of a coin flip backend in Move. The game module, `single_player_satoshi`, is prone to MEV attacks, but the user experience for the player is streamlined. Another example game module, `mev_attack_resistant_single_player_satoshi`, exists that is MEV-resistant, but has a slightly downgraded user experience (two player-transactions per game).

You can read more about both versions of the game, and view the full source code for all the modules in the [Satoshi Coin Flip repository](https://github.com/MystenLabs/satoshi-coin-flip).

Now that you have written our contracts, it's time to deploy them.

### Deployment {#deployment}

{@include: ../../../snippets/initialize-sui-client-cli.mdx}

Next, configure the Sui CLI to use `testnet` as the active environment, as well. If you haven't already set up a `testnet` environment, do so by running the following command in a terminal or console:

```sh
$ sui client new-env --alias testnet --rpc https://fullnode.testnet.sui.io:443
```

Run the following command to activate the `testnet` environment:

```sh
$ sui client switch --env testnet
```

{@include: ../../../snippets/publish-to-devnet-with-coins.mdx}

The output of this command contains a `packageID` value that you need to save to use the package.

Partial snippet of CLI deployment output.

```sh
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                           │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                         │
│  ┌──                                                                                                     │
│  │ ObjectID: 0x17e9468127384cfff5523940586f5617a75fac8fd93f143601983523ae9c9f31                          │
│  │ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            │
│  │ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         │
│  │ ObjectType: 0x2::package::UpgradeCap                                                                  │
│  │ Version: 75261540                                                                                     │
│  │ Digest: 9ahkhuGYTNYi5GucCqmUHyBuWoV2R3rRqBu553KBPVv8                                                  │
│  └──                                                                                                     │
│  ┌──                                                                                                     │
│  │ ObjectID: 0xa01d8d5ba121e7771547e749a787b4dd9ff8cc32e341c898bab5d12c46412a23                          │
│  │ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            │
│  │ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         │
│  │ ObjectType: 0x2::package::Publisher                                                                   │
│  │ Version: 75261540                                                                                     │
│  │ Digest: Ba9VU2dUqg3NHkwQ4t5AKDLJQuiFZnnxvty2xREQKWm9                                                  │
│  └──                                                                                                     │
│  ┌──                                                                                                     │
│  │ ObjectID: 0xfa1f6edad697afca055749fedbdee420b6cdba3edc2f7fd4927ed42f98a7e63a                          │
│  │ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            │
│  │ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         │
│  │ ObjectType: 0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8::house_data::HouseCap  │
│  │ Version: 75261540                                                                                     │
│  │ Digest: 5326hf6zWgdiNgr63wvwKkhUNtnTFkp82e9vfS5QHy3n                                                  │
│  └──                                                                                                     │
│ Mutated Objects:                                                                                         │
│  ┌──                                                                                                     │
│  │ ObjectID: 0x0e4eb516f8899e116a26f927c8aaddae8466c8cdc3822f05c15159e3a8ff8006                          │
│  │ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            │
│  │ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                            │
│  │ Version: 75261540                                                                                     │
│  │ Digest: Ezmi94kWCfjRzgGTwnXehv9ipPvYQ7T6Z4wefPLRQPPY                                                  │
│  └──                                                                                                     │
│ Published Objects:                                                                                       │
│  ┌──                                                                                                     │
│  │ PackageID: 0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8                         │
│  │ Version: 1                                                                                            │
│  │ Digest: 5XbJkgx8RSccxaHoP3xinY2fMMhwKJ7qoWfp349cmZBg                                                  │
│  │ Modules: counter_nft, house_data, single_player_satoshi                                               │
│  └──                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

Save the `PackageID` and the `ObjectID` of the `HouseCap` object you receive in your own response to [connect to your frontend](#connecting-your-package).

In this case, the `PackageID` is `0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8` and the `HouseCap` ID is `0xfa1f6edad697afca055749fedbdee420b6cdba3edc2f7fd4927ed42f98a7e63a`.

### Next steps

Well done. You have written and deployed the Move package! 🚀

To turn this into a complete dApp, you need to [create a frontend](#frontend).

## Frontend {#frontend}

In this final part of the dApp example, you build a frontend (UI) that allows end users to place bets and take profits, and lets the admin manage the house.

:::info

To skip building the frontend and test out your newly deployed package, use the provided [Satoshi Coin Flip Frontend Example repository](https://github.com/sui-foundation/satoshi-coin-flip-frontend-example) and follow the instructions in the example's `README.md` file

:::

### Prerequisites

Before getting started, make sure you have:

- [Deployed the complete `satoshi_flip` Move package](#smart-contracts) and understand its design.
- Installed [`pnpm`](https://pnpm.io/installation) or [`yarn`](https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable) to use as the package manager.

:::tip Additional resources

- Tooling: [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript) for basic usage on how to interact with Sui using TypeScript.
- Tooling: [Sui dApp Kit](https://sdk.mystenlabs.com/dapp-kit) to learn basic building blocks for developing a dApp in the Sui ecosystem with React.js.
- Tooling: [`@mysten/dapp`](https://sdk.mystenlabs.com/dapp-kit/create-dapp), used within this project to quickly scaffold a React-based Sui dApp.

:::

### Overview

The UI of this example demonstrates how to use the dApp Kit instead of serving as a production-grade product, so the Player and the House features are in the same UI to simplify the process. In a production solution, your frontend would only contain functionality dedicated to the Player, with a backend service carrying out the interactions with House functions in the smart contracts.

The UI has two columns:

- First column is dedicated to the Player, and all Player-related features live there
- Second column is dedicated to the House, and all House-related features live there

### Scaffold a new app

The first step is to set up the client app. Run the following command to scaffold a new app.

```sh
$ pnpm create @mysten/dapp --template react-client-dapp
```

or

```sh
$ yarn create @mysten/dapp --template react-client-dapp
```

### Project folder structure

Structure the project folder according to the UI layout, meaning that all Player-related React components reside in the `containers/Player` folder, while all House-related React components reside in the `containers/House` folder.

### Connecting your deployed package {#connecting-your-package}

Add the `packageId` value you saved from [deploying your package](#deployment) to a new `src/constants.ts` file in your project:

```ts
export const PACKAGE_ID =
  "0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8";
export const HOUSECAP_ID =
  "0xfa1f6edad697afca055749fedbdee420b6cdba3edc2f7fd4927ed42f98a7e63a";
```

### Exploring the code

The UI interacts with the [Single Player smart contract](guides/developer/app-examples/coin-flip.mdx#game-module) variant of the game. This section walks you through each step in the smart contract flow and the corresponding frontend code.

:::info

The following frontend code snippets include only the most relevant sections. Refer to the [Satoshi Coin Flip Frontend Example repository](https://github.com/sui-foundation/satoshi-coin-flip-frontend-example) for complete source code.

:::

As is common in other React projects, `App.tsx` is where you implement the outer layout:

```typescript title='App.tsx'
import { ConnectButton, useCurrentAccount } from '@mysten/dapp-kit';
import { InfoCircledIcon } from '@radix-ui/react-icons';
import { Box, Callout, Container, Flex, Grid, Heading } from '@radix-ui/themes';

import { HOUSECAP_ID, PACKAGE_ID } from './constants';
import { HouseSesh } from './containers/House/HouseSesh';
import { PlayerSesh } from './containers/Player/PlayerSesh';

function App() {
  const account = useCurrentAccount();
  return (
    <>
      <Flex
        position="sticky"
        px="4"
        py="2"
        justify="between"
        style={{
          borderBottom: '1px solid var(--gray-a2)',
        }}
      >
        <Box>
          <Heading>Satoshi Coin Flip Single Player</Heading>
        </Box>

        <Box>
          <ConnectButton />
        </Box>
      </Flex>
      <Container>
        <Heading size="4" m={'2'}>
          Package ID: {PACKAGE_ID}
        </Heading>
        <Heading size="4" m={'2'}>
          HouseCap ID: {HOUSECAP_ID}
        </Heading>

        <Callout.Root mb="2">
          <Callout.Icon>
            <InfoCircledIcon />
          </Callout.Icon>
          <Callout.Text>
            You need to connect to wallet that publish the smart contract package
          </Callout.Text>
        </Callout.Root>

        {!account ? (
          <Heading size="4" align="center">
            Please connect wallet to continue
          </Heading>
        ) : (
          <Grid columns="2" gap={'3'} width={'auto'}>
            <PlayerSesh />
            <HouseSesh />
          </Grid>
        )}
      </Container>
    </>
  );
}

export default App;
```

Like other dApps, you need a "connect wallet" button to enable connecting users' wallets. dApp Kit contains a pre-made `ConnectButton` React component that you can reuse to help users onboard.

`useCurrentAccount()` is a React hook the dApp Kit also provides to query the current connected wallet; returning `null` if there isn't a wallet connection. Leverage this behavior to prevent a user from proceeding further if they haven't connected their wallet yet.

After ensuring that the user has connected their wallet, you can display the two columns described in the previous section: `PlayerSesh` and `HouseSesh` components.

Okay, that's a good start to have an overview of the project. Time to move to initializing the `HouseData` object. All the frontend logic for calling this lives in the `HouseInitialize.tsx` component. The component includes UI code, but the logic that executes the transaction follows:

```typescript title='containers/House/HouseInitialize.tsx'
<form
  onSubmit={(e) => {
    e.preventDefault();

    // Create new transaction
    const txb = new Transaction();
    // Split gas coin into house stake coin
    // SDK will take care for us abstracting away of up-front coin selections
    const [houseStakeCoin] = txb.splitCoins(txb.gas, [
      MIST_PER_SUI * BigInt(houseStake),
    ]);
    // Calling smart contract function
    txb.moveCall({
      target: `${PACKAGE_ID}::house_data::initialize_house_data`,
      arguments: [
        txb.object(HOUSECAP_ID),
        houseStakeCoin,
        // This argument is not an on-chain object, hence, we must serialize it using `bcs`
        // https://sdk.mystenlabs.com/typescript/transaction-building/basics#pure-values
        txb.pure(
          bcs
            .vector(bcs.U8)
            .serialize(curveUtils.hexToBytes(getHousePubHex())),
        ),
      ],
    });

    execInitializeHouse(
      {
        transaction: txb,
        options: {
          showObjectChanges: true,
        },
      },
      {
        onError: (err) => {
          toast.error(err.message);
        },
        onSuccess: (result: SuiTransactionBlockResponse) => {
          let houseDataObjId;


          result.objectChanges?.some((objCh) => {
            if (
              objCh.type === "created" &&
              objCh.objectType === `${PACKAGE_ID}::house_data::HouseData`
            ) {
              houseDataObjId = objCh.objectId;
              return true;
            }
          });

          setHouseDataId(houseDataObjId!);

          toast.success(`Digest: ${result.digest}`);
        },
      },
    );
  }}
```

To use a [programmable transaction block](/concepts/transactions/prog-txn-blocks.mdx) (PTB) in Sui, create a `Transaction`. To initiate a Move call, you must know the global identifier of a public function in your smart contract. The global identifier usually takes the following form:

```
${PACKAGE_ID}::${MODULE_NAME}::${FUNCTION_NAME}
```

In this example, it is:

```
${PACKAGE_ID}::house_data::initialize_house_data
```

There are a few parameters that you need to pass into `initialize_house_data()` Move function: the `HouseCap` ID, the House stake, and the House BLS public key:

- Import the `HouseCap` ID from `constants.ts`, which you set up in the previous section.
- Use `Transaction::splitCoin` for the House stake to create a new coin with a defined amount split from the Gas Coin `txb.gas`. Think of the gas coin as one singular coin available for gas payment from your account (which might cover the entire remaining balance of your account). This is useful for Sui payments - instead of manually selecting the coins for gas payment or manually splitting/merging to have the coin with correct amount for your Move call, the gas coin is the single entry point for this, with all the heavy lifting delegated to the SDK behind the scenes.
- Pass the BLS public key as bytes `vector<u8>`. When providing inputs that are not on-chain objects, serialize them as BCS using a combination of `txb.pure` and `bcs` imported from `@mysten/sui/bcs`.

Now sign and execute the transaction block. dApp Kit provides a React hook `useSignAndExecuteTransaction()` to streamline this process. This hook, when executed, prompts the UI for you to approve, sign, and execute the transaction block. You can configure the hook with the `showObjectChanges` option to return the newly-created `HouseData` shared object as the result of the transaction block. This `HouseData` object is important as you use it as input for later Move calls, so save its ID somewhere.

Great, now you know how to initialize the `HouseData` shared object. Move to the next function call.

In this game, the users must create a `Counter` object to start the game. So there should be a place in the Player column UI to list the existing `Counter` object information for the player to choose. It seems likely that you will reuse the fetching logic for the `Counter` object in several places in your UI, so it's good practice to isolate this logic into a React hook, which you call `useFetchCounterNft()` in `useFetchCounterNft.ts`:

```typescript title='containers/Player/useFetchCounterNft.ts'
import { useCurrentAccount, useSuiClientQuery } from '@mysten/dapp-kit';

import 'react';

import { PACKAGE_ID } from '../../constants';

// React hook to fetch CounterNFT owned by connected wallet
// This hook is to demonstrate how to use `@mysten/dapp-kit` React hook to query data
// besides using SuiClient directly
export function useFetchCounterNft() {
  const account = useCurrentAccount();

  if (!account) {
    return { data: [] };
  }

  // Fetch CounterNFT owned by current connected wallet
  // Only fetch the 1st one
  const { data, isLoading, isError, error, refetch } = useSuiClientQuery(
    'getOwnedObjects',
    {
      owner: account.address,
      limit: 1,
      filter: {
        MatchAll: [
          {
            StructType: `${PACKAGE_ID}::counter_nft::Counter`,
          },
          {
            AddressOwner: account.address,
          },
        ],
      },
      options: {
        showOwner: true,
        showType: true,
      },
    },
    { queryKey: ['CounterNFT'] },
  );

  return {
    data: data && data.data.length > 0 ? data?.data : [],
    isLoading,
    isError,
    error,
    refetch,
  };
}
```

This hook logic is very basic: if there is no current connected wallet, return empty data; otherwise, fetch the `Counter` object and return it. dApp Kit provides a React hook, `useSuiClientQuery()`, that enables interaction with [Sui RPC](references/sui-api.mdx) methods. Different RPC methods require different parameters. To fetch the object owned by a known address, use the [`getOwnedObjects` query](/sui-api-ref#suix_getownedobjects).

Now, pass the address of the connected wallet, as well as the global identifier for the `Counter`. This is in similar format to the global identifier type for function calls:

`${PACKAGE_ID}::counter_nft::Counter`

That's it, now put the hook into the UI component `PlayerListCounterNft.tsx` and display the data:

```typescript title='containers/Player/PlayerListCounterNft.tsx'
export function PlayerListCounterNft() {
  const { data, isLoading, error, refetch } = useFetchCounterNft();
  const { mutate: execCreateCounterNFT } = useSignAndExecuteTransaction();

  return (
    <Container mb={'4'}>
      <Heading size="3" mb="2">
        Counter NFTs
      </Heading>

      {error && <Text>Error: {error.message}</Text>}

      <Box mb="3">
        {data.length > 0 ? (
          data.map((it) => {
            return (
              <Box key={it.data?.objectId}>
                <Text as="div" weight="bold">
                  Object ID:
                </Text>
                <Text as="div">{it.data?.objectId}</Text>
                <Text as="div" weight="bold">
                  Object Type:
                </Text>
                <Text as="div">{it.data?.type}</Text>
              </Box>
            );
          })
        ) : (
          <Text>No CounterNFT Owned</Text>
        )}
      </Box>
    </Container>
  );
}
```

For the case when there is no existing `Counter` object, mint a new `Counter` for the connected wallet. Also add the minting logic into `PlayerListCounterNft.tsx` when the user clicks the button. You already know how to build and execute a Move call with `TransactionBlock` and `initialize_house_data()`, you can implement a similar call here.

As you might recall with `Transaction`, outputs from the transaction can be inputs for the next transaction. Call `counter_nft::mint()`, which returns the newly created `Counter` object, and use it as input for `counter_nft::transfer_to_sender()` to transfer the `Counter` object to the caller wallet:

```typescript title='containers/Player/PlayerListCounterNft.tsx'
const txb = new Transaction();
const [counterNft] = txb.moveCall({
  target: `${PACKAGE_ID}::counter_nft::mint`,
});
txb.moveCall({
  target: `${PACKAGE_ID}::counter_nft::transfer_to_sender`,
  arguments: [counterNft],
});

execCreateCounterNFT(
  {
    transaction: txb,
  },
  {
    onError: (err) => {
      toast.error(err.message);
    },
    onSuccess: (result) => {
      toast.success(`Digest: ${result.digest}`);
      refetch?.();
    },
  },
);
```

Great, now you can create the game with the created `Counter` object. Isolate the game creation logic into `PlayerCreateGame.tsx`. There is one more thing to keep in mind - to flag an input as an on-chain object, you should use `txb.object()` with the corresponding object ID.

```typescript title='containers/Player/PlayerCreateGame.tsx'
// Create new transaction
const txb = new Transaction();

// Player stake
const [stakeCoin] = txb.splitCoins(txb.gas, [MIST_PER_SUI * BigInt(stake)]);

// Create the game with CounterNFT
txb.moveCall({
  target: `${PACKAGE_ID}::single_player_satoshi::start_game`,
  arguments: [
    txb.pure.string(guess),
    txb.object(counterNFTData[0].data?.objectId!),
    stakeCoin,
    txb.object(houseDataId),
  ],
});

execCreateGame(
  {
    transaction: txb,
  },
  {
    onError: (err) => {
      toast.error(err.message);
    },
    onSuccess: (result: SuiTransactionBlockResponse) => {
      toast.success(`Digest: ${result.digest}`);
    },
  },
);
```

One final step remains: settle the game. There are a couple of ways you can use the UI to settle the game:

1. Create a Settle Game button and pass all the necessary arguments to the `single_player_satoshi::finish_game()` Move call.
1. Settle the game automatically through an events subscription. This example uses this path to teach good practices on events and how to subscribe to them.

:::info

Event subscriptions are deprecated. To learn future-safe methods to work with events, see [Using Events](../sui-101/using-events.mdx).

:::

All of this logic is in `HouseFinishGame.tsx`:

```typescript title='containers/House/HouseFinishGame.tsx'
// This component will help the House to automatically finish the game whenever new game is started
export function HouseFinishGame() {
  const suiClient = useSuiClient();
  const { mutate: execFinishGame } = useSignAndExecuteTransactionBlock();

  const [housePrivHex] = useContext(HouseKeypairContext);
  const [houseDataId] = useContext(HouseDataContext);

  useEffect(() => {
    // Subscribe to NewGame event
    const unsub = suiClient.subscribeEvent({
      filter: {
        MoveEventType: `${PACKAGE_ID}::single_player_satoshi::NewGame`,
      },
      onMessage(event) {
        console.log(event);
        const { game_id, vrf_input } = event.parsedJson as {
          game_id: string;
          vrf_input: number[];
        };

        toast.info(`NewGame started ID: ${game_id}`);

        console.log(housePrivHex);

        try {
          const houseSignedInput = bls.sign(
            new Uint8Array(vrf_input),
            curveUtils.hexToBytes(housePrivHex),
          );

          // Finish the game immediately after new game started
          const txb = new Transaction();
          txb.moveCall({
            target: `${PACKAGE_ID}::single_player_satoshi::finish_game`,
            arguments: [
              txb.pure.id(game_id),
              txb.pure(bcs.vector(bcs.U8).serialize(houseSignedInput)),
              txb.object(houseDataId),
            ],
          });
          execFinishGame(
            {
              transaction: txb,
            },
            {
              onError: (err) => {
                toast.error(err.message);
              },
              onSuccess: (result: SuiTransactionBlockResponse) => {
                toast.success(`Digest: ${result.digest}`);
              },
            },
          );
        } catch (err) {
          console.error(err);
        }
      },
    });

    return () => {
      (async () => (await unsub)())();
    };
  }, [housePrivHex, houseDataId, suiClient]);

  return null;
}
```

To get the underlying `SuiClient` instance from the SDK, use `useSuiClient()`. You want to subscribe to events whenever the `HouseFinishGame` component loads. To do this, use the React hook `useEffect()` from the core React library.

`SuiClient` exposes a method called `subscribeEvent()` that enables you to subscribe to a variety of event types. `SuiClient::subscribeEvent()` is actually a thin wrapper around the RPC method [`suix_subscribeEvent`](/sui-api-ref#suix_subscribeevent).

The logic is that whenever a new game starts, you want to settle the game immediately. The necessary event to achieve this is the Move event type called `single_player_satoshi::NewGame`. If you inspect the parsed payload of the event through `event.parsedJson`, you can see the corresponding event fields declared in the smart contract. In this case, you just need to use two fields, the Game ID and the VRF input.

The next steps are similar to the previous Move calls, but you have to use the BLS private key to sign the VRF input and then pass the Game ID, signed VRF input and `HouseData` ID to the `single_player_satoshi::finish_game()` Move call.

Last but not least, remember to unsubscribe from the event whenever the `HouseFinishGame` component dismounts. This is important as you might not want to subscribe to the same event multiple times.

Congratulations, you completed the frontend. You can carry the lessons learned here forward when using the dApp Kit to build your next Sui project.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/oracle.mdx
```
---
title: Oracles
---

Oracles are services that connect on-chain smart contracts with off-chain data. Blockchains are inherently isolated from outside sources for the purpose of security and reliability. Sui is no different, which means your projects cannot directly fetch real-world information, like stock prices, weather data, or sports scores. Oracles provide a bridge between the blockchain and external data sources, pulling in this information and making it available to smart contracts in a secure and verifiable way.

## Oracles available for the Sui network

The guides in this section demonstrate how to create basic oracle services for your Sui projects. As your needs become more advanced, you might consider integrating third-party services to perform the heavy lifting. There are several oracle services available for the Sui network:

| Service | Description |
| --- | --- | 
| [**Pyth**](https://www.pyth.network/) | Pyth is a blockchain oracle for market data. Check the [Sui guide](https://docs.pyth.network/price-feeds/use-real-time-data/sui) on the Pyth website to learn how to integrate into your Sui projects. |
| [**Stork**](https://www.stork.network/) | Stork is an open data marketplace designed to address the limitations of traditional blockchain oracles. Check the [Stork documentation](https://docs.stork.network/) for implementation details. |
| [**Supra**](https://supra.com/data) | Supra is a decentralized oracle network designed to connect blockchain smart contracts with real-world data, enhancing the functionality of decentralized applications (dApps) across various blockchain ecosystems. Check the [Index Fund](https://docs.supra.com/dev-resources/guides/move/building-a-crypto-index-fund-smart-contract-on-sui-blockchain-move) and [Crowdfunding](https://docs.supra.com/dev-resources/guides/move/crowdfunding-smart-contracts-on-sui-blockchain-move) examples for how to integrate with Sui. |
| [**Switchboard**](https://switchboard.xyz/) | Switchboard is a permissionless oracle network that seamlessly connects dApps to real-world data. Check the [On Sui](https://docs.switchboard.xyz/product-documentation/data-feeds/sui) guide for integration details. |

## Oracle guides

The following guides demonstrate how to build oracles on the Sui network. Currently, there is one guide but more are planned.

- [Sui Weather Oracle](./weather-oracle.mdx): Fetches weather data from OpenWeather API to provide real-time weather data for 1,000+ locations around the world.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/app-examples/e2e-counter.mdx
```
---
title: Distributed Counter
description: An app that allows users to create counters that anyone can increment, but only the owner can reset.
effort: small
---

This example walks you through building a basic distributed counter app, covering the full end-to-end flow of building your Sui Move module and connecting it to your React Sui dApp. The app allows users to create counters that anyone can increment, but only the owner can reset. 

The guide is split into two parts:

1. [Smart Contracts](#smart-contracts): The Move code that sets up the `Counter` structure and logic.
1. [Frontend](#frontend): A UI that enables users to create, increment, and reset `Counter` objects.

:::tip Additional resources

[Example source code](https://github.com/MystenLabs/sui/blob/60bb8bdc274b9e5706fd916cd84c13f81e832529/sdk/create-dapp/templates/react-e2e-counter)

:::

## What the guide teaches

- **Shared objects:** The guide teaches you how to use [shared objects](../../../concepts/object-ownership/shared.mdx), in this case to create globally accessible `Counter` objects.
- **Programmable transaction blocks (PTBs):** You learn how to use PTBs to interact with your Move module from your frontend.

## What you need

Before getting started, make sure you have:

- [Installed the latest version of Sui](../getting-started/sui-install.mdx).

## Directory structure

To begin, create a new folder on your system titled `react-e2e-counter` to hold all your project files. You can name this directory differently, but the rest of the guide references this file structure. Inside that folder, create two more folders: `move` and `src`. Inside the `move` folder, create a `counter` directory. Finally, create a `sources` folder inside `counter`. Different projects have their own directory structure, but it's common to split code into functional groups to help with maintenance. See [Write a Move Package](../first-app/write-package.mdx) to learn more about package structure and how to use the Sui CLI to scaffold a new project.

:::checkpoint

- You have the latest version of Sui installed. If you run `sui --version` in your terminal or console, it responds with the currently installed version.
- Your active environment is pointing to the expected network. Run `sui client active-env` to make sure. If you receive a warning about a client and server API version mismatch, update Sui using the version in the relevant branch (`mainnet`, `testnet`, `devent`) of the Sui repo.
- Your active address has SUI. Run `sui client balance` in your terminal or console. If there is no balance, [acquire SUI](../getting-started/get-coins.mdx) from the faucet (not available in Mainnet).
- You have a directory to place the files you create in. The top-level directory is named `react-e2e-counter` if you want to match the directory structure in this guide. 

:::

:::tip
    
{@include: ../../../snippets/faucet-online.mdx}

:::

## Smart contracts {#smart-contracts}

In this part of the guide, you write the Move contracts that create, increment, and reset counters.

### Move.toml

To begin writing your smart contracts, create a file inside `react-e2e-counter/move/counter` named `Move.toml` and copy the following code into it. This is the package manifest file. If you want to learn more about the structure of the file, see [Package Manifest](https://move-book.com/concepts/manifest.html) in The Move Book.

:::info

If you are targeting a network other than Testnet, be sure to update the `rev` value for the Sui dependency.

:::

{@inject: github:MystenLabs/ts-sdks/packages/create-dapp/templates/react-e2e-counter/move/counter/Move.toml}

### `Counter` struct

To begin creating the smart contract that defines the on-chain counter, create a `counter.move` file inside your `react-e2e-counter/move/counter` folder. Define the module that holds your smart contract logic.

```move
module counter::counter {
  // Code goes here
}
```

Add the `Counter` struct and elements described in the following sections to the module. 

{@inject: github:MystenLabs/ts-sdks/packages/create-dapp/templates/react-e2e-counter/move/counter/sources/counter.move#struct=Counter noComments}

- The `Counter` type stores the address of its `owner`, its current `value`, and its own `id`.

### Creating `Counter`

{@inject: github:MystenLabs/ts-sdks/packages/create-dapp/templates/react-e2e-counter/move/counter/sources/counter.move#fun=create noComments}

In the `create` function, a new `Counter` object is created and [shared](../../../concepts/object-ownership/shared.mdx). 

### Incrementing and resetting `Counter`

{@inject: github:MystenLabs/ts-sdks/packages/create-dapp/templates/react-e2e-counter/move/counter/sources/counter.move#fun=increment noComments}

The `increment` function accepts a mutable reference to any shared `Counter` object and increments its `value` field.

{@inject: github:MystenLabs/ts-sdks/packages/create-dapp/templates/react-e2e-counter/move/counter/sources/counter.move#fun=set_value noComments}

The `set_value` function accepts a mutable reference to any shared `Counter` object, the `value` to set its `value` field, and the `ctx` which contains the `sender` of the transaction. The `Counter` `owner` is the only one that can run this function.

:::tip Additional resources

Learn more about taking [object references as input](https://move-book.com/move-basics/references.html)

:::

## Finished package

The final module should look like this

{@inject: github:MystenLabs/ts-sdks/packages/create-dapp/templates/react-e2e-counter/move/counter/sources/counter.move noComments}

:::checkpoint

Your smart contract is complete. You should be able to run the `sui move build` command from `react-e2e-counter/move/counter` and receive a response similar to the following:
```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING counter
```
You always run `sui move build` at the same level as your `Move.toml` file. After a successful build, you now have a `build` folder inside `react-e2e-counter/move/counter`.

:::

### Deployment {#deployment}

{@include: ../../../snippets/initialize-sui-client-cli.mdx}

Next, configure the Sui CLI to use `testnet` as the active environment, as well. If you haven't already set up a `testnet` environment, do so by running the following command in a terminal or console:

```sh
$ sui client new-env --alias testnet --rpc https://fullnode.testnet.sui.io:443
```

Run the following command to activate the `testnet` environment:

```sh
$ sui client switch --env testnet
```

{@include: ../../../snippets/publish-to-devnet-with-coins.mdx}

The output of this command contains a `packageID` value that you need to save to use the package.

Partial snippet of CLI deployment output.

```sh
╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                   │
├──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x7530c33e4cf3345236601d69303e3fab84efc294194a810dc1cfea13c009e77f                  │
│  │ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                    │
│  │ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 ) │
│  │ ObjectType: 0x2::package::UpgradeCap                                                          │
│  │ Version: 47482286                                                                             │
│  │ Digest: 5aEez7HkJ82Xs5ZArPHJF6Ty38UtprsCvEiyy22hBVRE                                          │
│  └──                                                                                             │
│ Mutated Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x0fcc6d770d80aa409a9645e78ac4810be6400919ac7f507bddd2f9d279da509f                  │
│  │ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                    │
│  │ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 ) │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 47482286                                                                             │
│  │ Digest: A6TH6ja5TM4S6nZBwB14AB17ZgixCijYX1aNMGHF3syv                                          │
│  └──                                                                                             │
│ Published Objects:                                                                               │
│  ┌──                                                                                             │
│  │ PackageID: 0x7b6a8f5782e57cd948dc75ee098b73046a79282183d51eefb83d31ec95c312aa                 │
│  │ Version: 1                                                                                    │
│  │ Digest: FKAZc1cmQ9FUYudDQBjZPTb1uXDnekKRUbAALuVnwURC                                          │
│  │ Modules: counter                                                                              │
│  └──                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
```

Store the `PackageID` value you receive in your own response to [connect to your frontend](#connecting-your-package).

### Next steps

Well done. You have written and deployed the Move package! 🚀

To turn this into a complete dApp, you need to [create a frontend](#frontend).


## Frontend {#frontend}

In this final part of the app example, you build a frontend (UI) that allows end users to create, increment, and reset `Counter` objects.


:::info

To skip building the frontend and test out your newly deployed package, create this example using the following template and follow the instructions in the template's `README.md` file: 

<Tabs groupId="packagemanager">
  <TabItem label="PNPM" value="pnpm">
    ```sh
    $ pnpm create @mysten/dapp --template react-e2e-counter
    ```
  </TabItem>
  <TabItem label="Yarn" value="yarn">
    ```sh
    $ yarn create @mysten/dapp --template react-e2e-counter
    ```
  </TabItem>
</Tabs>

:::

### Prerequisites

Before getting started, make sure you have:

- [Deployed the complete `counter` Move module](#smart-contracts) and understand its design.
- Installed [`pnpm`](https://pnpm.io/installation) or [`yarn`](https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable) to use as the package manager.

:::tip Additional resources

- Tooling: [Sui Typescript SDK](https://sdk.mystenlabs.com/typescript) for basic usage on how to interact with Sui using Typescript.
- Tooling: [Sui dApp Kit](https://sdk.mystenlabs.com/dapp-kit) to learn basic building blocks for developing a dApp in the Sui ecosystem with React.js.
- Tooling: [`@mysten/dapp`](https://sdk.mystenlabs.com/dapp-kit/create-dapp), used within this project to quickly scaffold a React-based Sui dApp.

:::

### Overview

The UI design consists of two parts:

- A button for users to create new `Counter` objects
- A `Counter` UI for users to view the `value`, and to increment and reset the `Counter` object.


### Scaffold a new app

The first step is to set up the client app. Run the following command to scaffold a new app.

<Tabs groupId="packagemanager">
  <TabItem label="PNPM" value="pnpm">
    ```sh
    $ pnpm create @mysten/dapp --template react-client-dapp
    ```
  </TabItem>
  <TabItem label="Yarn" value="yarn">
    ```sh
    $ yarn create @mysten/dapp --template react-client-dapp
    ```
  </TabItem>
</Tabs>

### Install new dependencies

This app uses the `react-spinners` package for icons. Install it by running the following command:

<Tabs groupId="packagemanager">
  <TabItem label="PNPM" value="pnpm">
    ```sh
    $ pnpm add react-spinners
    ```
  </TabItem>
  <TabItem label="Yarn" value="yarn">
    ```sh
    $ yarn add react-spinners
    ```
  </TabItem>
</Tabs>

### Connecting your deployed package {#connecting-your-package}

<details>
  <summary>
    Add the `packageId` value you saved from [deploying your package](#deployment) to a new `src/constants.ts` file in your project:
  </summary>
  ```ts
    export const DEVNET_COUNTER_PACKAGE_ID = "0xTODO";
    export const TESTNET_COUNTER_PACKAGE_ID = "0x7b6a8f5782e57cd948dc75ee098b73046a79282183d51eefb83d31ec95c312aa";
    export const MAINNET_COUNTER_PACKAGE_ID = "0xTODO";
  ```
</details>

<details>
  <summary>
    Update the `src/networkConfig.ts` file to include the `packageID` constants.
  </summary>
  {@inject: github:MystenLabs/ts-sdks/packages/create-dapp/templates/react-e2e-counter/src/networkConfig.ts noComments}
</details>

### Creating `Counter`

You need a way to create a new `Counter` object. 

<details>
  <summary>
    Create `src/CreateCounter.tsx` and add the following code:
  </summary>
  ```tsx
    import { Button, Container } from "@radix-ui/themes";
    import { useState } from "react";
    import ClipLoader from "react-spinners/ClipLoader";

    export function CreateCounter({
      onCreated,
    }: {
      onCreated: (id: string) => void;
    }) {
      const [waitingForTxn, setWaitingForTxn] = useState(false);

      function create() {
        // TODO
      }

      return (
        <Container>
          <Button
            size="3"
            onClick={() => {
              create();
            }}
            disabled={waitingForTxn}
          >
            {waitingForTxn ? <ClipLoader size={20} /> : "Create Counter"}
          </Button>
        </Container>
      );
    }
  ```
</details>

This component renders a button that enables the user to create a counter. Now, update your `create` function so that it calls the `create` function from your Move module.

<details>
  <summary>
    Update the `create` function in the `src/CreateCounter.tsx` file:
  </summary>
  {@inject: github:MystenLabs/ts-sdks/packages/create-dapp/templates/react-e2e-counter/src/CreateCounter.tsx noComments}
</details>

The `create` function now creates a new Sui `Transaction` and calls the `create` function from your Move module. The PTB is then signed and executed via the `useSignAndExecuteTransaction` hook. The `onCreated` callback is called with the new counter's ID when the transaction is successful.

### Set up routing

Now that your users can create counters, you need a way to route to them. Routing in a React app can be complex, but this example keeps it basic. 

<details>
  <summary>
    Set up your `src/App.tsx` file so that you render the `CreateCounter` component by default, and if you want to display a specific counter you can put its ID into the hash portion of the URL.
  </summary>
  ```tsx
    import { ConnectButton, useCurrentAccount } from "@mysten/dapp-kit";
    import { isValidSuiObjectId } from "@mysten/sui/utils";
    import { Box, Container, Flex, Heading } from "@radix-ui/themes";
    import { useState } from "react";
    import { CreateCounter } from "./CreateCounter";

    function App() {
      const currentAccount = useCurrentAccount();
      const [counterId, setCounter] = useState(() => {
        const hash = window.location.hash.slice(1);
        return isValidSuiObjectId(hash) ? hash : null;
      });

      return (
        <>
          <Flex
            position="sticky"
            px="4"
            py="2"
            justify="between"
            style={{
              borderBottom: "1px solid var(--gray-a2)",
            }}
          >
            <Box>
              <Heading>dApp Starter Template</Heading>
            </Box>

            <Box>
              <ConnectButton />
            </Box>
          </Flex>
          <Container>
            <Container
              mt="5"
              pt="2"
              px="4"
              style={{ background: "var(--gray-a2)", minHeight: 500 }}
            >
              {currentAccount ? (
                counterId ? (
                  null
                ) : (
                  <CreateCounter
                    onCreated={(id) => {
                      window.location.hash = id;
                      setCounter(id);
                    }}
                  />
                )
              ) : (
                <Heading>Please connect your wallet</Heading>
              )}
            </Container>
          </Container>
        </>
      );
    }

    export default App;
  ```
</details>

This sets up your app to read the hash from the URL, and get the counter's ID if the hash is a valid object ID. Then, if you have a counter ID, it renders a `Counter` (which you define in the next step). If you don't have a counter ID, then it renders the `CreateCounter` button from the previous step. When a counter is created, you update the URL, and set the counter ID.

Currently, the `Counter` component doesn't exist, so the app displays an empty page if you navigate to a counter ID.

:::checkpoint

At this point, you have a basic routing setup. Run your app and ensure you can:

- Create a new counter.
- See the counter ID in the URL.

The `create counter` button should look like this: 

![Create Counter Button](./images/distributed-create-counter-button.png)

:::

### Building your counter user interface

Create a new file: `src/Counter.tsx`.

For your counter, you want to display three elements:

- The current count, which you fetch from the object using the `getObject` RPC method.
- An increment button, which calls the `increment` Move function.
- A reset button, which calls the `set_value` Move function with `0`. This is only shown if the current user owns the counter.

<details>
  <summary>
    Add the following code to your `src/Counter.tsx` file:
  </summary>
  ```tsx
    import {
      useCurrentAccount,
      useSuiClientQuery,
    } from "@mysten/dapp-kit";
    import { SuiObjectData } from "@mysten/sui/client";
    import { Button, Flex, Heading, Text } from "@radix-ui/themes";
    import { useState } from "react";
    import ClipLoader from "react-spinners/ClipLoader";


    export function Counter({ id }: { id: string }) {
      const currentAccount = useCurrentAccount();
      const { data, isPending, error, refetch } = useSuiClientQuery("getObject", {
        id,
        options: {
          showContent: true,
          showOwner: true,
        },
      });

      const [waitingForTxn, setWaitingForTxn] = useState("");

      const executeMoveCall = (method: "increment" | "reset") => {
        // TODO
      };

      if (isPending) return <Text>Loading...</Text>;

      if (error) return <Text>Error: {error.message}</Text>;

      if (!data.data) return <Text>Not found</Text>;

      const ownedByCurrentAccount =
        getCounterFields(data.data)?.owner === currentAccount?.address;

      return (
        <>
          <Heading size="3">Counter {id}</Heading>

          <Flex direction="column" gap="2">
            <Text>Count: {getCounterFields(data.data)?.value}</Text>
            <Flex direction="row" gap="2">
              <Button
                onClick={() => executeMoveCall("increment")}
                disabled={waitingForTxn !== ""}
              >
                {waitingForTxn === "increment" ? (
                  <ClipLoader size={20} />
                ) : (
                  "Increment"
                )}
              </Button>
              {ownedByCurrentAccount ? (
                <Button
                  onClick={() => executeMoveCall("reset")}
                  disabled={waitingForTxn !== ""}
                >
                  {waitingForTxn === "reset" ? (
                    <ClipLoader size={20} />
                  ) : (
                    "Reset"
                  )}
                </Button>
              ) : null}
            </Flex>
          </Flex>
        </>
      );
    }
    function getCounterFields(data: SuiObjectData) {
      if (data.content?.dataType !== "moveObject") {
        return null;
      }

      return data.content.fields as { value: number; owner: string };
    }
  ```
</details>

This snippet has a few new concepts to examine. It uses the `useSuiClientQuery` hook to make the `getObject` RPC call. This returns a data object representing your counter. dApp Kit doesn't know which fields your counter object has, so define a `getCounterFields` helper that gets the counter fields, and adds a type-cast so that you can access the expected `value` and `owner` fields in your component.

The code also adds an `executeMoveCall` function that still needs implementing. This works just like the `create` function you used to create the counter. Instead of using a callback prop like you did for `CreateCounter`, you can use the refetch provided by `useSuiClientQuery` to reload your `Counter` object after you've executed your PTB.

<details>
  <summary>
    Update the `executeMoveCall` function in the `src/Counter.tsx` file:
  </summary>
  {@inject: github:MystenLabs/ts-sdks/packages/create-dapp/templates/react-e2e-counter/src/Counter.tsx noComments}
</details>

### Updating the routing

Now that you have a `Counter` component, you need to update your `App` component to render it when you have a counter ID.

<details>
  <summary>
    Update the `src/App.tsx` file to render the `Counter` component when you have a counter ID:
  </summary>
  {@inject: github:MystenLabs/ts-sdks/packages/create-dapp/templates/react-e2e-counter/src/App.tsx noComments}
</details>

:::checkpoint

At this point, you have the complete app! Run it and ensure you can:

- Create counters
- Increment and reset counters

The `Counter` component should look like this:

![Counter Component](./images/distributed-counter-ui.png)

:::
```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/coin/regulated.mdx
```
---
title: Regulated Coin and Deny List
description: You can create regulated coins on Sui, such as stablecoins. These coins are similar to other coins, like SUI, but include the ability to control access to the coin using a deny list.
---

You can create regulated coins on Sui, such as [stablecoins](../stablecoins.mdx). These coins are similar to other coins, like SUI, but include the ability to control access to the coin using a deny list. 

When creating standard coins, you call the `create_currency` function in the `coin` package of the Sui framework, whether directly or via an SDK. When you create regulated coins, you call the `create_regulated_currency_v2` function in that same package instead. The `create_regulated_currency_v2` function actually leverages the `create_currency` function to create the coin, but adds an additional step that produces a `DenyCapV2` and transfers it to the publisher of the regulated coin package. The bearer of the transferrable `DenyCapV2` object can control access to the coin through a deny list. 

## DenyList

The `DenyList` is a singleton, shared object that the bearer of a `DenyCapV2` can access to specify a list of addresses that are unable to use a Sui core type. The initial use case for `DenyList`, however, focuses on limiting access to coins of a specified type. This is useful when creating a regulated coin on Sui that requires the ability to block certain addresses from using it as inputs to transactions. Regulated coins on Sui satisfy any regulations that require the ability to prevent known bad actors from having access to those coins.

:::info

The `DenyList` object is a system object that has the address `0x403`. You cannot create it yourself.

:::

To learn about the features available, see the [Coin standard](../../../standards/coin.mdx) documentation and the `coin` module in the <a href="/references/framework/sui/coin" data-noBrokenLinkCheck='true'>Sui framework</a>.

## Regulated coin example

The regulated coin example is in the `examples/regulated-coin` directory of the Sui repo. The example provides both TypeScript- and Rust-based command line access to an on-chain package that demonstrates some of the features of regulated coins on Sui.

## Prerequisites

This topic assumes you are accessing the code from your own fork of the Sui repo. To run the example project, you must have [Sui installed](../getting-started/sui-install.mdx).

You need at least one Sui address to publish the contract to the network. At least one additional address is helpful if you want to transfer or test the deny list capability for the regulated coins.

You do not need a Sui wallet to use this project, but having one available might help you visualize results.

This example assumes you're familiar with publishing packages on Sui and the Move language. For more detailed guides on example dApps, see [App Examples](../app-examples.mdx). For more more information on the Move language, see [The Move Book](https://move-book.com/).

## Publishing to a network

You publish the smart contract to a network the same way as any other package. See [Publish a Package](../first-app/publish.mdx) if you would like more details on the publishing process. 

The example includes a `publish.sh` file that you can run to automate the publishing. The script assumes you are publishing to the Testnet network, so be sure to update it before running if you plan to run on a local network or Devnet.

The publish script also creates the necessary `.env` files in each of the frontend folders. If you don't use the script, you must create the `.env` file manually and provide the values for the variables the frontend expects to find. Even if you use the script, you must provide the `ADMIN_SECRET_KEY` and it's value.

:::warning

Take care not to expose the secret key for your address to the public.

:::

| Constant name | Description |
| --- | --- |
| `PACKAGE_ID` | Object ID of the package you publish. This data is part of the response that Sui provides on publish. |
| `ADMIN_SECRET_KEY` | The secret key for the address that publishes the package. You can use `sui keytool export --key-identity <SUI-ADDRESS>` or a wallet UI to get the value. Take care not to expose the value to the public. |
| `ADMIN_ADDRESS` | The address that publishes the contract. |
| `DENY_CAP_ID` | Deny capability object ID. This data is part of the response that Sui provides on publish. |
| `TREASURY_CAP_ID` | The treasury cap object ID that allows the bearer to mint new coins. This data is part of the response that Sui provides on publish. |
| `MODULE_NAME` | The name of the module you publish. |
| `COIN_NAME` | The name of your regulated coin.  |
| `SUI_FULLNODE_URL` | The URL to the Full node network that will process transactions. For Testnet this value is `https://fullnode.testnet.sui.io:443`. |

## Smart contract

The example uses a single file to create the smart contract for the project (`regulated_coin.move`). The contract defines the regulated coin when you publish it to the network. The treasury capability (`TreasuryCap`) and deny capability (`DenyCapV2`) are transferred to the address that publishes the contract. The `TreasuryCap` permits the bearer to mint or burn coins (`REGULATED_COIN` in this example), and the `DenyCapV2` bearer can add and remove addresses from the list of unauthorized users. 

<details>
<summary>
`regulated_coin.move`
</summary>
{@inject: examples/regulated-coin/move/sources/regulated_coin.move}
</details>

### Creating regulated coins

The Sui Coin standard provides a `create_regulated_currency_v2` function to create regulated coins. This function actually uses `create_currency` to mint a coin, but extends the function by also creating and transferring a `DenyCapV2` capability. The `DenyCapV2` bearer can add and remove addresses from a list that controls, or regulates, access to the coin. This ability is a requirement for assets like stablecoins.

The TypeScript and Rust clients handle the call to the `coin` package's `mint` function. The `coin` package also includes a `mint_and_transfer` function you could use to perform the same task, but the composability of minting the coin in one command and transferring with another is preferable. Using two explicit commands allows you to implement future logic between the minting of the coin and the transfer. The structure of programmable transaction blocks means you're still making and paying for a single transaction on the network.

<Tabs groupId="code-language">

<TabItem label="TypeScript" value="typescript">
{@inject: examples/regulated-coin/ts-client/src/main.ts#mint}
</TabItem>

<TabItem label="Rust" value="rust">
{@inject: examples/regulated-coin/rust-client/src/tx_run/coin.rs#mint}
</TabItem>

</Tabs>

For all `Coin` functions available, see the Sui framework [`coin` module documentation](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/coin.md). The following functions are the most common. 

<details>
<summary>
  `coin::mint<T>`
</summary>
{@inject: crates/sui-framework/packages/sui-framework/sources/coin.move#fun=mint}
</details>
<details>
<summary>
  `coin::mint_balance<T>`
</summary>
{@inject: crates/sui-framework/packages/sui-framework/sources/coin.move#fun=mint_balance}
</details>
<details>
<summary>
  `coin::mint_and_transfer<T>`
</summary>
{@inject: crates/sui-framework/packages/sui-framework/sources/coin.move#fun=mint_and_transfer}
</details>
<details>
<summary>
  `coin::burn<T>`
</summary>
{@inject: crates/sui-framework/packages/sui-framework/sources/coin.move#fun=burn}
</details>

### Manage deny list

For the ability to manage the addresses assigned to the deny list for your coin, the frontend code provides a few additional functions. These additions call the `deny_list_v2_add` and `deny_list_v2_remove` functions in the `coin` module.

If you add an address to the deny list, you might notice that you can still send tokens to that address. If so, that's because the address is still able to receive coins until the end of the epoch in which you called the function. If you try to send the regulated coin from the now blocked address, your attempt results in an error. After the next epoch starts, the address can no longer receive the coins, either. If you remove the address, it can receive coins immediately but must wait until the epoch after removal before the address can include the coins as transaction inputs.

To use these functions, you pass the address you want to either add or remove. The frontend function then calls the relevant move module in the framework, adding the `DenyList` object (`0x403`) and your `DenyCap` object ID. You receive the `DenyCap` ID at the time of publishing the smart contract. In this example, you add that value to the `.env` file that the frontend function reads from.

<Tabs groupId="code-language">

<TabItem label="TypeScript" value="typescript">
{@inject: examples/regulated-coin/ts-client/src/main.ts#deny}
</TabItem>

<TabItem label="Rust" value="rust">
{@inject: examples/regulated-coin/rust-client/src/tx_run/deny.rs#deny}
</TabItem>

</Tabs>

## Related links

- [Closed Loop Token standard](../../../standards/closed-loop-token.mdx): Details for the standard used to create tokens on Sui.
- [Source code](https://github.com/MystenLabs/sui/tree/main/examples/regulated-coin): The source code in GitHub for this example.
- [In-Game Tokens](./in-game-token.mdx): Example of how to create tokens for use as in-game currency.
- [Loyalty Tokens](./loyalty.mdx): Example of how to create tokens that reward brand or service loyalty on the Sui network.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/coin/in-game-token.mdx
```
---
title: In-Game Currency
---

Using the Sui [Closed-Loop Token](../../../standards/closed-loop-token.mdx) standard, you can create in-game currency (such as gems or diamonds in mobile games) that you can grant to players for their actions or make available to purchase. You mint the tokens on Sui, but players can only use the tokens within the economy of the game itself. These types of tokens are usually not transferrable and you would typically mint them in predefined amounts to maintain scarcity and game balance.

The following example creates an in-game currency called a GEM, which represents a certain number of SUI. In the example, the user can buy fungible GEMs using SUI, which can then be used as currency within the game. Use the code comments to follow the logic of the example.

## Example 

The Sui repo hosts a basic example of creating in-game currency. The Move modules that create the economy of the example are in the gems.move source file.

### Module examples::sword

The `examples::sword` module creates one of the objects, a `sword`, that has in-game value. The module assigns a value in GEMs (the other valuable in-game item) to the sword. The module also provides the logic for trading GEMs to receive a sword. 

{@inject: examples/move/token/sources/gems.move#module=examples::sword noComments}

### Module examples::gem

The `examples::gem` module creates the in-game currency, GEMs. Users spend SUI to purchase GEMs, which can then be traded for swords. The module defines three groups of GEMs (small, medium, and large), with each group representing a different in-game value. Constants hold both the value of each package and the actual number of GEMs the groups contain. 

The module's `init` function uses `coin::create_currency` to create the GEM. The `init` function, which runs only the one time when the module publishes, also sets the policies for the in-game currency, freezes the metadata for the coin, and transfers the policy capability to the publisher of the package. 

{@inject: examples/move/token/sources/gems.move#fun=init noComments}

The module handles the purchase of GEMs with the `buy_gems` function. 

{@inject: examples/move/token/sources/gems.move#fun=buy_gems noComments}

Use the following toggle to control the display of the complete module. 

<details>
<summary>
`examples::gem` module in `gems.move`
</summary>

{@inject: examples/move/token/sources/gems.move#module=examples::gem noComments}

</details>

### Complete code 

Toggle display of the complete source for this example, including comments, or use the link in the [Related links](#related-links) section to view the project source on GitHub.

<details>
<summary>
`gems.move`
</summary>

{@inject: examples/move/token/sources/gems.move}

</details>

## Related links

- [Closed Loop Token standard](../../../standards/closed-loop-token.mdx): Details for the standard used to create tokens on Sui.
- [Source code](https://github.com/MystenLabs/sui/blob/main/examples/move/token/sources/gems.move): The source code in GitHub for this example.
- [Loyalty Tokens](./loyalty.mdx): Example of how to create tokens that are valid only for a specific service, useful in loyalty reward programs.
- [Regulated Coin and Deny List](./regulated.mdx): Example of how to create regulated coins on the Sui network.

```

../../Downloads/sui-stuff/sui-main/docs/content/guides/developer/coin/loyalty.mdx
```
---
title: Loyalty Tokens
---

Using the Sui [Closed-Loop Token](../../../standards/closed-loop-token.mdx) standard, you can create tokens that are valid only for a specific service, like an airline that wants to grant tokens to frequent flyers to purchase tickets or upgrades. 

The following example demonstrates the creation of a loyalty token that bearers can use to make purchases in a digital gift shop.

## Example

The Loyalty Token example illustrates a loyalty token that is created with the Closed Loop Token standard. If you were to implement this example, the Admin would send `LOYALTY` tokens to the users of your service as a reward for their loyalty. The example creates a `GiftShop` where holders can spend `LOYALTY` tokens to buy `Gift`s.

### examples::loyalty

The loyalty.move source file contains the `examples::loyalty` module code that creates the loyalty token. The module includes the one-time witness (OTW) that creates the coin (with the same name as the module, `LOYALTY`), possesses only the `drop` ability, and has no fields. These are the characteristics of a OTW, which ensures the `LOYALTY` type has a single instance.

{@inject: examples/move/token/sources/loyalty.move#struct=loyalty noComments}

The `init` function of the module uses the `LOYALTY` OTW to create the token. All `init` functions run one time only at the package publish event. The initializer function makes use of the OTW `LOYALTY` type defined previously in its call to `create_currency`. The function also defines a policy, sending both the policy capability and treasury capability to the address associated with the publish event. The holder of these transferrable capabilities can mint new `LOYALTY` tokens and modify their policies.

{@inject: examples/move/token/sources/loyalty.move#fun=init noComments}

The `LOYALTY` minting function is called `reward_user`. As mentioned previously, the holder of the `TreasuryCap` can call this function to mint new loyalty tokens and send them to the desired address. The function uses the `token::mint` function to create the token and `token::transfer` to send it to the intended recipient. 

{@inject: examples/move/token/sources/loyalty.move#fun=reward_user noComments}

Finally, the example includes a `buy_a_gift` function to handle the redemption of `LOYALTY` tokens for `Gift` types. The function ensures the gift price matches the number of loyalty tokens spent, then uses the `token::spend` function to handle the treasury bookkeeping. 

{@inject: examples/move/token/sources/loyalty.move#fun=buy_a_gift noComments}

### Complete code 

Toggle display of the complete source for this example, including comments, or use the link in the [Related links](#related-links) section to view the project source on GitHub.

<details>
<summary>
`loyalty.move`
</summary>

{@inject: examples/move/token/sources/loyalty.move}

</details>

## Related links

- [Closed Loop Token standard](../../../standards/closed-loop-token.mdx): Details for the standard used to create tokens on Sui.
- [Source code](https://github.com/MystenLabs/sui/blob/main/examples/move/token/sources/loyalty.move): The source code in GitHub for this example.
- [In-Game Tokens](./in-game-token.mdx): Example of how to create tokens for use as in-game currency.
- [Regulated Coin and Deny List](./regulated.mdx): Example of how to create regulated coins on the Sui network.
```

../../Downloads/sui-stuff/sui-main/docs/content/references/sui-move.mdx
```
---
title: Move References
---

{@include: ../snippets/move-summary.mdx}

- [Sui Framework](./framework.mdx): Provides `cargo doc`-generated content for core Sui modules. 
- [The Move Book](https://move-book.com): A definitive guide for learning the Move language on Sui. 
- [The Move Reference](https://move-book.com/reference): Architecture and syntax reference for the Move language.
```

../../Downloads/sui-stuff/sui-main/docs/content/references/fullnode-protocol.mdx
```
---
title: Sui Full Node gRPC
description: The Sui Full node gRPC protocol is available on all Sui Full nodes.
beta: devnet, testnet, mainnet
---

import Protocol from "../../site/src/components/Protocol";

Sui Full node gRPC API will replace the JSON-RPC on Full nodes, such that JSON-RPC will be deprecated when gRPC API is generally available.

<Protocol />

```

../../Downloads/sui-stuff/sui-main/docs/content/references/framework.mdx
```
---
title: Sui Framework
description: The Sui framework libraries include Move modules that provide the logic for Sui and its standards. A Rust process creates the documentation for the modules directly from comments in the code.
---

import DocCardList from '@theme/DocCardList';

The documentation in this section is created from the Rust `cargo doc` process. The process builds the content from comments in the source code.   

## Framework documentation

The child pages to this topic describe the module members for the following libraries:

<DocCardList/>

## Source code

You can find the source code for these Move modules in the [crates/sui-framework/packages](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages) directory in the `sui` repository on GitHub. As previously mentioned, the comments included in the code provide context for the logic defined.

## Crate documentation

You can review the raw `cargo doc` output of the following documentation in the `sui` repository. The .md files are located in the `crates/sui-framework/docs` directory. Online, they are located at https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/docs.

## Build documentation locally

The most recent documentation is always available in the `main` branch of the `sui` repository. You shouldn't need to build the documentation locally, but if the need arises you can:

1. Open a terminal or console to the `sui/crates/sui-framework` directory.
1. Run `cargo doc --workspace --exclude "sui-benchmark" --no-deps`.
1. The docs are built to `crates/sui-framework/docs` into their respective subdirectories.

:::info

If the `cargo doc` process does not work as expected, try running `cargo clean` before attempting again. 

:::

```

../../Downloads/sui-stuff/sui-main/docs/content/references/exchange-integration-guide.mdx
```
---
title: Exchange Integration Guide
sidebar_label: Exchange Integration
slug: /exchange-integration-guide
---

This topic describes how to integrate SUI, the token native to the Sui network, into a cryptocurrency exchange. The specific requirements and processes to implement an integration vary between exchanges. Rather than provide a step-by-step guide, this topic provides information about the primary tasks necessary to complete an integration. After the guidance about how to configure an integration, you can also find information and code samples related to staking on the Sui network.

## Requirements to configure a SUI integration {#requirements-sui-integration}

The requirements to configure a SUI integration include:

- A Sui Full node. You can operate your own Sui Full node or use a Full node from a node operator.
- Suggested minimum hardware to run a Sui Full node:
  - CPUs: 8 physical cores / 16 vCPUs
  - RAM: 128 GB
  - Storage (SSD): 4 TB NVMe drive

For best results, run Sui Full nodes on Linux. Sui supports the Ubuntu and Debian distributions. You can also fun a Full node on macOS.

## Configure a Sui Full node {#configure-full-node}

You can set up and configure a Sui Full node using Docker or directly from source code in the Sui GitHub repository.

### Install a Sui Full node using Docker {#full-node-docker}

Run the command in this section using the same branch of the repository for each. Replace `branch-name` with the branch you use. For example, use `devnet` to use the Sui Devnet network, or use `testnet` to use the Sui Testnet network. You must download all files to, and run all commands from, the same folder location.

1.  Install [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/). Docker Desktop version installs Docker Compose.
1.  Install dependencies for Linux:
    ```sh
    $ apt update \
    && apt install -y --no-install-recommends \
    tzdata \
    ca-certificates \
    build-essential \
    pkg-config \
    cmake
    ```
1.  Download the docker-compose.yaml file:
    ```sh
    $ wget https://github.com/MystenLabs/sui/blob/branch-name/docker/fullnode/docker-compose.yaml
    ```
1.  Download the fullnode-template.yaml file:
    ```sh
    $ wget https://github.com/MystenLabs/sui/raw/branch-name/crates/sui-config/data/fullnode-template.yaml
    ```
1.  Download the genesis.blob file:
    ```sh
    $ wget https://github.com/MystenLabs/sui-genesis/raw/main/branch-name/genesis.blob
    ```
1.  Start the Full node. The -d switch starts it in the background (detached mode).
    ```sh
    $ docker-compose up -d
    ```

## Install a Sui Full node from source {#install-full-node-source}

Use the steps in this section to install and configure a Sui Full node directly from the Sui GitHub repository. These steps use [Cargo](https://doc.rust-lang.org/cargo/), the Rust package manager.

1.  Install prerequisites for Sui.
1.  Clone the Sui repository:
    ```sh
    $ git clone https://github.com/MystenLabs/sui.git -b branch-name
    ```
    Replace `branch-name` with the branch to use. You should use the same branch for all commands.
1.  Change directories to /sui:
    ```sh
    $ cd sui
    ```
1.  Copy the fullnode.yaml template:
    ```sh
    $ cp crates/sui-config/data/fullnode-template.yaml fullnode.yaml
    ```
1.  Download the genesis.blob file:
    ```sh
    $ wget https://github.com/MystenLabs/sui-genesis/raw/main/branch-name/genesis.blob
    ```
    Change branch-name to the same branch you used for previous commands.
1.  Optionally, if you installed Sui to a path other than the default, modify the fullnode.yaml file to use the path you used. Update the path to the folder where you installed sui-fullnode for the `db-path` and `genesis-file-location` as appropriate:
    `db-path: "/db-files/sui-fullnode-folder"`
    `genesis-file-location: "/sui-fullnode-folder/genesis.blob"`
1.  Start you Sui Full node:
    ```sh
    $ cargo run --release --bin sui-node -- --config-path fullnode.yaml
    ```

## Set up Sui addresses {#setup-sui-addresses}

Sui addresses do not require on-chain initialization, you can spend from an address if it corresponds to your private key. You can derive a 32-byte Sui address by hashing the signature scheme flag byte concatenated with public key bytes `flag || pubkey` using the [BLAKE2b](https://www.blake2.net/) (256 bits output) hashing function.

Currently, Sui address supports these signature schemes: pure Ed25519, Secp256k1, Secp256r1 and Multisig. The corresponding flag bytes are 0x00, 0x01, 0x02, 0x03 respectively.

The following code sample demonstrates how to derive a Sui address in Rust:

```rust
let flag = 0x00; // 0x00 = ED25519, 0x01 = Secp256k1, 0x02 = Secp256r1, 0x03 = MultiSig
// Hash the [flag, public key] bytearray using Blake2b
let mut hasher = DefaultHash::default();
hasher.update([flag]);
hasher.update(pk);
let arr = hasher.finalize();
let sui_address_string = hex::encode(arr);
```

## Displaying addresses {#displaying-addresses}

Sui supports both addresses with and without a 0x prefix. Sui recommends that you always include the 0x prefix in API calls and when you display user addresses.

## Track balance changes for an address {#track-balance-changes}

You can track balance changes by calling `sui_getBalance` at predefined intervals. This call returns the total balance for an address. The total includes any coin or token type, but this document focuses on SUI. You can track changes in the total balance for an address between subsequent `sui_getBalance` requests.

The following bash example demonstrates how to use `sui_getBalance` for address 0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3. If you use a network other than Devnet, replace the value for `rpc` with the URL to the appropriate Full node.

```sh
rpc="https://fullnode.devnet.sui.io:443"
address="0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3"
data="{\"jsonrpc\": \"2.0\", \"method\": \"sui_getBalance\", \"id\": 1, \"params\": [\"$address\"]}"
curl -X POST -H 'Content-type: application/json' --data-raw "$data" $rpc
```

The response is a JSON object that includes the totalBalance for the address:

```json
{
  "jsonrpc": "2.0",
  "result": {
    "coinType": "0x2::sui::SUI",
    "coinObjectCount": 40,
    "totalBalance": 10000000000,
    "lockedBalance": {}
  },
  "id": 1
}
```

The following example demonstrates using sui_getBalance in Rust:

```rust
use std::str::FromStr;
use sui_sdk::types::base_types::SuiAddress;
use sui_sdk::{SuiClient, SuiClientBuilder};


#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
   let sui = SuiClientBuilder::default().build(
      "https://fullnode.devnet.sui.io:443",
   ).await.unwrap();
   let address = SuiAddress::from_str("0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3")?;
   let objects = sui.read_api().get_balance(address).await?;
   println!("{:?}", objects);
   Ok(())
}
```

## Use events to track balance changes for an address {#events-balance-changes}

You can also track the balance for an address by subscribing to all of the events emitted from it. Use a filter to include only the events related to SUI coins, such as when the address acquires a coin or pays for a gas fee.
The following example demonstrates how to filter events for an address using bash and cURL:

```sh
rpc="https://fullnode.devnet.sui.io:443"
address="0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3"
data="{\"jsonrpc\": \"2.0\", \"id\":1, \"method\": \"sui_getEvents\", \"params\": [{\"Recipient\": {\"AddressOwner\": \"0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3\"}}, null, null, true ]}"
curl -X POST -H 'Content-type: application/json' --data-raw "$data" $rpc
```

The response can include a large number of events. Add pagination to the response using the `nextCursor` key in the request. You can determine the corresponding `txDigest` and `eventSeq` from the `id` field of a transaction.

You can add the `txDigest` value instead of the first `null` within the `params`. The second `null` is an integer that defines how many results (up to 1000) to return and the `true` means ascending order. You can use the `nextCursor` so the response starts from a desired point.

The `id` field of any transaction looks like:

```json
"id": {
  "txDigest": "GZQN9pE3Zr9ZfLzBK1BfVCXtbjx5xKMxPSEKaHDvL3E2",
  "eventSeq": 6019
}
```

With this data, create a `nextCursor` as follows:

```sh
nextCursor : {"txDigest": "GZQN9pE3Zr9ZfLzBK1BfVCXtbjx5xKMxPSEKaHDvL3E2","eventSeq": 6019}
```

## Blocks vs Checkpoints {#blocks-vs-checkpoints}

Sui is a DAG-based blockchain and uses checkpoints for node synchronization and global transaction ordering. Checkpoints differ from blocks in the following ways:

- Sui creates checkpoints and adds finalized transactions. Note that transactions are finalized even before they are included in a checkpoint
- Checkpoints do not fork, roll back, or reorganize.
- Sui creates about four checkpoints every second. Find the most up-to-date statistic on the [Sui public dashboard](https://metrics.sui.io/public-dashboards/4ceb11cc210d4025b122294586961169).

### Checkpoint API operations {#checkpoint-api-operations}

Sui Checkpoint API operations include:

- [sui_getCheckpoint](/sui-api-ref#sui_getCheckpoint) - Retrieves the specified checkpoint.
- [sui_getLatestCheckpointSequenceNumber](/sui-api-ref#sui_getLatestCheckpointSequenceNumber) - Retrieves the sequence number of the most recently executed checkpoint.
- sui_getCheckpoints - Retrieves a paginated list of checkpoints that occurred during the specified interval. Pending a future release.

## SUI Balance transfer {#sui-balance-transfer}

To transfer a specific amount of SUI between addresses, you need a SUI token object with that specific value. In Sui, everything is an object, including SUI tokens. The amount of SUI in each SUI token object varies. For example, an address could own 3 SUI tokens with different values: one of 0.1 SUI, a second of 1.0 SUI, and a third with 0.005 SUI. The total balance for the address equals the sum of the values of the individual SUI token objects, in this case, 1.105 SUI.

You can merge and split SUI token objects to create token objects with specific values. To create a SUI token worth .6 SUI, split the token worth 1 SUI into two token objects worth .6 SUI and .4 SUI.

To transfer a specific amount of SUI, you need a SUI token worth that specific amount. To get a SUI token with that specific value, you might need to split or merge existing SUI tokens. Sui supports several methods to accomplish this, including some that do not require you to manually split or merge coins.

## Sui API operations for transfers {#api-operations-transfers}

Sui supports the following API operations related to transferring SUI between addresses:

- [sui_transferObject](/sui-api-ref#sui_transferObject)
  Because SUI tokens are objects, you can transfer SUI tokens just like any other object. This method requires a gas token, and is useful in niche cases only.

- [sui_payAllSui](/sui-api-ref#sui_payAllSui)
  This method accepts an array of SUI token IDs. It merges all existing tokens into one, deducts the gas fee, then sends the merged token to the recipient address.

  The method is especially useful if you want to transfer all SUI from an address. To merge together all coins for an address, set the recipient as the same address. This is a native Sui method so is not considered a transaction in Sui.

- [sui_paySui](/sui-api-ref#sui_paySui)
  This operation accepts an array of SUI token IDs, an array of amounts, and an array of recipient addresses.

  The amounts and recipients array map one to one. Even if you use only one recipient address, you must include it for each amount in the amount array.

  The operation merges all of the tokens provided into one token object and settles the gas fees. It then splits the token according to the amounts in the amounts array and sends the first token to the first recipient, the second token to the second recipient, and so on. Any remaining SUI on the token stays in the source address.

  The benefits of this method include: no gas fees for merging or splitting tokens, and the abstracted token merge and split. The `sui_paySui` operation is a native function, so the merge and split operations are not considered Sui transactions. The gas fees for them match typical transactions on Sui.You can use this operation to split coins in your own address by setting the recipient as your own address. Note that the total value of the input coins must be greater than the total value of the amounts to send.

- [sui_pay](/sui-api-ref#sui_pay)
  This method is similar to sui_paySui, but it accepts any kind of coin or token instead of only SUI. You must include a gas token, and all of the coins or tokens must be the same type.

- [sui_transferSui](/sui-api-ref#sui_transferSui)
  This method accepts only one SUI token object and an amount to send to the recipient. It uses the same token for gas fees, so the amount to transfer must be strictly less than the value of the SUI token used.

## Signing Transactions {#signing-transactions}

Please refer to Sui Signatures for more details on signature validity requirements.

## SUI Staking {#sui-staking}

The Sui blockchain uses a Delegated Proof-of-Stake mechanism (DPoS). This allows SUI token holders to stake their SUI tokens to any validator of their choice. When someone stakes their SUI tokens, it means those tokens are locked for the entire epoch. Users can withdraw their stake at any time, but new staking requests become active only at the start of the next epoch.

SUI holders who stake their tokens to validators earn rewards for helping secure the Sui network. Sui determines rewards for staking based on stake rewards on the network, and distributes them at the end of each epoch.

The total voting power in the Sui Network is always 10,000. The voting power of each individual validator is similar to basis points. For example, a voting power of 101 = 1.01%. Sui's quorum threshold (number of votes needed to confirm a transaction) is 6,667 (which is greater than 2/3). The voting power for a single validator is capped at 1,000 (10%) regardless of how much stake the validator has.

## Staking functions {#staking-functions}

Sui supports the following API operations related to staking. You can find the source code in the [sui_system](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-system/sources/sui_system.move) module.

- `request_add_stake`
  Add user stake to a validator's staking pool.

```move
public fun request_add_stake(
   self: &mut SuiSystemState,
   stake: Coin<SUI>,
   validator_address: address,
   ctx: &mut TxContext,
) {
   validator_set::request_add_stake(
       &mut self.validators,
       validator_address,
       coin::into_balance(stake),
       option::none(),
       ctx,
   );
}
```

- `request_add_stake_mul_coin`
  Add user stake to a validator's staking pool using multiple coins.

```move
public fun request_add_stake_mul_coin(
   self: &mut SuiSystemState,
   delegate_stakes: vector<Coin<SUI>>,
   stake_amount: option::Option<u64>,
   validator_address: address,
   ctx: &mut TxContext,
) {
   let balance = extract_coin_balance(delegate_stakes, stake_amount, ctx);
   validator_set::request_add_stake(&mut self.validators, validator_address, balance, option::none(), ctx);
}
```

- `request_add_stake_with_locked_coin`
  Add user stake to a validator's staking pool using a locked SUI coin.

```move
public fun request_add_stake_with_locked_coin(
   self: &mut SuiSystemState,
   stake: LockedCoin<SUI>,
   validator_address: address,
   ctx: &mut TxContext,
) {
   let (balance, lock) = locked_coin::into_balance(stake);
   validator_set::request_add_stake(&mut self.validators, validator_address, balance, option::some(lock), ctx);
}
```

- `request_withdraw_stake`
  Withdraw some portion of a user stake from a validator's staking pool.

```move
public fun request_withdraw_stake(
   self: &mut SuiSystemState,
   delegation: &mut Delegation,
   staked_sui: &mut StakedSui,
   principal_withdraw_amount: u64,
   ctx: &mut TxContext,
) {
   validator_set::request_withdraw_stake(
       &mut self.validators,
       delegation,
       staked_sui,
       principal_withdraw_amount,
       ctx,
   );
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/references/cli.mdx
```
---
title: Sui CLI
description: Sui provides command line tools to interact with the network, its features, and the Move programming language. Individual command groups are referred to as Sui Client CLI, Sui Keytool CLI, Sui Move CLI, and Sui Validator CLI.
---

Sui provides a command line interface (CLI) tool to interact with the Sui network, its features, and the Move programming language. The complete suite of tools is called the Sui CLI, with commands grouped together by feature. Each group of commands is commonly referred to by its top-level command: Sui Client CLI, Sui Keytool CLI, Sui Move CLI, and Sui Validator CLI.

{@include: ../snippets/cli-check-install.mdx}

## Update CLI

To get the latest version of the CLI, you can run the following command from a terminal or console. Be sure to replace `<BRANCH-NAME>` with `main`, `devnet`, `testnet`, or `mainnet` to get the desired version. For more information on the branches available, see [Sui Environment Setup](./contribute/sui-environment.mdx).

```sh
$ cargo install --locked --git https://github.com/MystenLabs/sui.git --branch <BRANCH-NAME> --features tracing sui
```

:::info

The `tracing` feature is important as it adds Move test coverage and debugger support in the Sui CLI. Unless it is enabled you will not be able to use these two features.

:::

## Sui CLI commands

There are a number of top-level commands available, but the five most useful to users are the following. Use the `help` flag for the commands that are not documented yet. For example, `sui validator --help`.

- **[Sui Client CLI](./cli/client.mdx):** Use the `sui client` commands to interact with the Sui network.
- **[Sui Client PTB CLI](./cli/ptb.mdx):** Use the `sui client ptb` command to build and execute PTBs.
- **[Sui Keytool CLI](./cli/keytool.mdx):** Use the `sui keytool` commands to access cryptography utilities.
- **[Sui Move CLI](./cli/move.mdx):** Use the `sui move` commands to work with the Move programming language.
- **[Sui Validator CLI](./cli/validator.mdx):** Use the `sui validator` commands to access tools useful for Sui validators.

```

../../Downloads/sui-stuff/sui-main/docs/content/references/sui-sdks.mdx
```
---
title: Sui and Community SDKs
description: Collection of SDKs and utilities for developing on Sui using various programming languages.
---

Sui provides developer kits that act as wrappers for the Sui API. The Sui community broadens the code coverage with its own set of developer kits targeting the Sui blockchain. 

## Sui SDKs

<Cards>
<Card title="dApp Kit" href="https://sdk.mystenlabs.com/dapp-kit">
    A web frontend SDK that interacts with the Sui API. It is available as an NPM package.
</Card>
<Card title="Rust SDK" href="./rust-sdk">
    SDK configuration and examples of using the Sui API with Rust, using the `sui-sdk` crate.
</Card>
<Card title="Rust SDK Auto-generated Docs" href="https://mystenlabs.github.io/sui/sui_sdk/index.html">
    Auto-generated documentation for the `sui-sdk` crate in the Sui repository.
</Card>
<Card title="TypeScript SDK" href="https://sdk.mystenlabs.com/typescript">
    TypeScript SDK for integrating Sui in your TS dApps.
</Card>
<Card title="zkSend SDK" href="https://sdk.mystenlabs.com/zksend">
    zkSend SDK to enable you to incorporate Stashed functionality.
</Card>
</Cards>

## Community SDKs

:::info 

While the community projects are expertly developed, their maintenance and community support vary. You might want to research a project's history and support level before committing to using its utilities. 

:::

<Cards>
<Card title="dApp Kit (Vue)" href="https://github.com/SuiFansCN/suiue">
    Sui dApp Kit for the Vue framework.
</Card>
<Card title="Dart SDK" href="https://github.com/mofalabs/sui">
    A cross-platform Sui SDK for mobile, web, and desktop.
</Card>
<Card title="Go SDK" href="https://github.com/block-vision/sui-go-sdk">
    SDK for developing for Sui using Golang.
</Card>
<Card title="Kotlin SDK" href="https://github.com/mcxross/ksui">
    Ksui is a collection of Kotlin Multiplatform JSON-RPC wrapper and crypto utilities for interacting with a Sui Full node.
</Card>
<Card title="Python SDK" href="https://github.com/FrankC01/pysui">
    pysui is a Python client for developing on the Sui blockchain. 
</Card>
<Card title="Swift SDK" href="https://github.com/opendive/suikit">
    SuiKit is a Swift SDK natively designed for developing on the Sui blockchain.
</Card>
</Cards>

```

../../Downloads/sui-stuff/sui-main/docs/content/references/sui-framework-reference.mdx
```
---
title: Sui Framework Reference
slug: /sui-framework-reference
---

The Sui Framework includes the core on-chain libraries for Move developers. You can view the [Sui Framework Reference docs](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/docs) in Markdown format in the Sui GitHub repo.

```

../../Downloads/sui-stuff/sui-main/docs/content/references/rust-sdk.mdx
```
---
title: Rust SDK
description: The Sui Rust SDK provides Rust wrappers around the Sui API. Using the SDK, you can interact with Sui networks using the Rust programming language.
---

The Sui Rust SDK crate is in the [**crates\sui-sdk** directory](https://github.com/MystenLabs/sui/tree/main/crates/sui-sdk) of the Sui repository.

{@include: ../../../crates/sui-sdk/README.md}

```

../../Downloads/sui-stuff/sui-main/docs/content/references/sui-graphql.mdx
```
---
title: GraphQL for Sui RPC (Alpha)
sidebar_label: GraphQL (Beta)
description: GraphQL is a public service for the Sui RPC that enables you to efficiently interact with the Sui network.
beta: devnet, testnet, mainnet
---

GraphQL for the Sui RPC is a public service that enables interacting with the Sui [network](https://sui.io/networkinfo).

To get started with GraphQL for the Sui RPC, check out the [Getting Started](../guides/developer/getting-started/graphql-rpc.mdx) guide. If you'd like to learn more about the concepts used in the GraphQL service, check out the [GraphQL](../concepts/graphql-rpc.mdx) for Sui RPC concepts page.

:::info

{@include: ../snippets/data-serving-msg.mdx}

{@include: ../snippets/data-serving-gql-alpha.mdx}

:::

## Key Types

All GraphQL API elements are accessible via the left sidebar, the following are good starting points to explore from.

- "Queries" lists all top-level queries for reading the chain state, from reading details about addresses and objects to <a href="/references/sui-api/sui-graphql/reference/api/queries/dry-run-transaction-block" data-noBrokenLinkCheck='true'>dryRunTransactionBlock</a>, which has an execution-like interface but does not modify the chain.
- "Mutations" lists operations that can modify chain state, like <a href="/references/sui-api/sui-graphql/reference/api/mutations/execute-transaction-block" data-noBrokenLinkCheck='true'>executeTransactionBlock</a>.
- <a href="/references/sui-api/sui-graphql/reference/types/objects/object" data-noBrokenLinkCheck='true'>Object</a> is the type representing all on-chain objects (Move values and packages).
- <a href="/references/sui-api/sui-graphql/reference/types/objects/address" data-noBrokenLinkCheck='true'>Address</a> corresponds to account addresses (derived from the public keys of signatures that sign transactions) and can be used to query the objects owned by these accounts and the transactions they have signed or been affected by.
- <a href="/references/sui-api/sui-graphql/reference/types/objects/owner" data-noBrokenLinkCheck='true'>Owner</a> represents any entity that can own a <a href="/references/sui-api/sui-graphql/reference/types/objects/move-object" data-noBrokenLinkCheck='true'>MoveObject</a> to handle cases where it is not known whether the owner is an <a href="/references/sui-api/sui-graphql/reference/types/objects/object" data-noBrokenLinkCheck='true'>Object</a> or an <a href="/references/sui-api/sui-graphql/reference/types/objects/address" data-noBrokenLinkCheck='true'>Address</a> (for example, from the perspective of a Move object looking at its owner).

## Related links

- [GraphQL migration](../guides/developer/advanced/graphql-migration.mdx): Migrating to GraphQL guides you through migrating Sui RPC projects from JSON-RPC to GraphQL.  
- [GraphQL quick-start](../guides/developer/getting-started/graphql-rpc.mdx): Querying Sui RPC with GraphQL gets you started using GraphQL to query the Sui RPC for on-chain data.
- [GraphQL concepts](../concepts/graphql-rpc.mdx): GraphQL for Sui RPC examines the elements of GraphQL that you should know to get the most from the service.

```

../../Downloads/sui-stuff/sui-main/docs/content/references/sui-compared.mdx
```
---
title: Comparison
slug: /sui-compared
---

This page summarizes how Sui compares with existing blockchains and is intended for potential adopters of Sui to decide whether it fits their use cases. See How Sui Works for an introduction to the Sui architecture.

Here are Sui's key features:

- [Causal order vs. total order](#causal-order-vs-total-order) enables massively parallel execution
- Sui's variant of Move and its object-centric data model make composable objects/NFTs possible
- The blockchain-oriented [Move programming language](https://github.com/MystenLabs/awesome-move) eases the developer experience

## Traditional blockchains {#traditional-blockchains}

Traditional blockchain validators collectively build a shared accumulator: a cryptographically binding representation of the state of the blockchain, a chain to which they add increments over time, called blocks. In blockchains that offer deterministic finality, every time validators want to make an incremental addition to the blockchain, i.e., a block proposal, they sequence the proposal. This protocol lets them form an agreement over the current state of the chain, whether the proposed increment is valid, and what the state of the chain will be after the new addition.

This method of maintaining common state over time has known practical success over the last 14 years or so, using a wealth of theory from the last 50 years of research in the field of Byzantine Fault Tolerant distributed systems.

Yet it is inherently sequential: increments to the chain are added one at a time, like pearls on a string. In practice, this approach pauses the influx of transactions (often stored in a "mempool"), while the current block is under consideration.

## Sui's approach to validating new transactions {#validating}

A large number transactions do not have complex interdependencies with each other, since they operate on disconnected parts of the state. Often financial users just want to send an asset to a recipient, and the only data required to gauge whether this simple transaction is admissible is a fresh view of the sender's address. Hence Sui takes the approach of only taking a lock - or "stopping the world" - for the relevant piece of data rather than the whole chain -- in this case, the address of the sender, which can only send one transaction at a time.

Sui further expands this approach to more involved transactions that may explicitly depend on multiple elements under their sender's control, using an object model and leveraging Move's strong ownership model. By requiring that dependencies be explicit, Sui applies a "multi-lane" approach to transaction validation, making sure those independent transaction flows can progress without impediment from the others.

This doesn't mean that Sui as a platform never orders transactions with respect to each other, or that it allows owners to affect only their owned microcosm of objects. Sui also processes transactions that have an effect on some shared state in a rigorous, consensus-ordered manner. See the [State-of-the-art consensus](#state-of-the-art-consensus) section for details on the consensus engine.

## A collaborative approach to transaction submission {#tx-submission}

Sui validates transactions individually, rather than batching them in the traditional blocks. The key advantage of this approach is low latency; each successful transaction quickly obtains a certificate of finality that proves to anyone that the transaction will persists its effects on the Sui network.

But the process of submitting a transaction is a bit more involved. That little more work occurs on the network. (With bandwidth getting cheaper, this is less of a concern.) Whereas a usual blockchain can accept a bunch of transactions from the same author in a fire-and-forget mode, Sui transaction submission follows these steps:

1.  Sender broadcasts a transaction to all Sui validators.
1.  Sui validators send individual votes on this transaction to the sender.
1.  Each vote has a certain weight since each validator has weight based upon the rules of [Proof of Stake](https://en.wikipedia.org/wiki/Proof_of_work).
1.  Sender collects a Byzantine-resistant-majority of these votes into a _certificate_ and broadcasts it to all Sui validators.
1.  The validators execute the transaction and sign the results. When the client receives a Byzantine-resistant-majority of the results _finality_ is reached, ie., assurance the transaction will not be dropped (revoked).
1.  Optionally, the sender assembles the votes to a certificate detailing the effects of the transaction.

While those steps demand more of the sender, performing them efficiently can still yield a cryptographic proof of finality with minimum latency. Aside from crafting the original transaction itself, the session management for a transaction does not require access to any private keys and can be delegated to a third party.

## A different approach to state {#state}

Because Sui focuses on managing specific objects rather than a single aggregate of state, it also reports on them in a unique way:

- Every object in Sui has a unique version number.
- Every new version is created from a transaction that may involve several dependencies, themselves versioned objects.

As a consequence, a Sui Validator can exhibit a causal history of an object, showing its history since genesis. Sui explicitly makes the bet that in many cases, the ordering of that causal history with the causal history of another object is irrelevant; and in the few cases where this information is relevant, Sui makes this relationship explicit in the data.

## Causal order vs. total order {#causal-order-vs-total-order}

Unlike most existing blockchain systems (and as the reader may have guessed from the description of write requests above), Sui does not always impose a total order on the transactions submitted by clients, with shared objects being the exception. Instead, many transactions are _causally_ ordered--if a transaction `T1` produces output objects `O1` that are used as input objects in a transaction `T2`, a validator must execute `T1` before it executes `T2`. Note that `T2` need not use these objects directly for a causal relationship to exist--e.g., `T1` might produce output objects which are then used by `T3`, and `T2` might use `T3`'s output objects. However, transactions with no causal relationship can be processed by Sui validators in any order.

## State-of-the-art consensus {#state-of-the-art-consensus}

[Mysticeti](https://arxiv.org/pdf/2310.14821) represents the latest variant of decades of work on multi-proposer, high-throughput consensus algorithms that reaches throughput more than 400,000 transactions per second on a WAN, with production cryptography and permanent storage.

## Where Sui excels {#where-sui-excels}

This section summarizes the main advantages of Sui with respect to traditional blockchains.

### High performance {#high-performance}

Sui's main selling point is its unprecedented performance. The following bullet points summarize the main performance benefits of Sui with respect to traditional blockchains:

- Sui forgoes consensus for many transactions while other blockchains always totally order them. Causally ordering transactions allows Sui to massively parallelize the execution of many transactions; this reduces latency and allows validators to take advantage of all their CPU cores.
- Sui pushes the complexity at the edges: the client is involved in a number of protocol steps. This minimizes the interactions between validators and keeps their code simpler and more efficient. Sui always gives the possibility to offload most of the client's workload to a Sui Gateway service for better user experience. In contrast, traditional blockchains follow a fire-and-forget model where clients monitor the blockchain state to assess the success of their transaction submission.
- Sui operates at network speed without waiting for system timeouts between protocol steps. This significantly reduces latency when the network is good and not under attack. In contrast, the security of a number of traditional blockchains (including most proof-of-work based blockchains) need to wait for predefined timeouts before committing transactions.
- Sui can take advantage of more machines per validator to increase its performance. Traditional blockchains are often designed to run on a single machine per validator (or even on a single CPU).

### Performance under faults {#performance-under-faults}

Sui runs a leaderless protocol to process simple transactions (i.e. containing only owned objects). As a result, faulty validators do not impact performance in any significant way. For transactions involving shared objects, Sui employs a state-of-the-art consensus protocol requiring no [view-change sub-protocol](https://pmg.csail.mit.edu/papers/osdi99.pdf) and thus experiences only slight performance degradations. In contrast, most leader-based blockchains experiencing even a single validator's crash see their throughput fall and their latency increase (often by more than one order of magnitude).

### Security assumptions {#security-assumptions}

Contrary to many traditional blockchains, Sui does not make strong synchrony assumptions on the network. This means that Sui maintains its security properties under bad network conditions (even excessively bad), network splits/partitions, or even powerful DoS attacks targeted on the validators. Sustained network attacks on synchronous blockchains (i.e., most proof-of-work based blockchains) can lead to double-spend of resources and deadlocks.

### Efficient local read operations {#local-read-operations}

The reading process of Sui enormously differs from other blockchains. Users interested in only a handful of objects and their history perform authenticated reads at a low granularity and low latency. Sui creates a narrow family tree of objects starting from the genesis, allowing it to read only objects tied to the sender of the transaction. Users requiring a global view of the system (e.g., to audit the system) can take advantage of checkpoints to improve performance.

In traditional blockchains, families are ordered with respect to each other to totally order transactions. This then requires querying a massive blob for the precise information needed. Disk I/O can become a performance bottleneck.

### Easier developer experience {#easier-developer-experience}

Sui provides these benefits to developers:

- Move and object-centric data model (enables composable objects/NFTs)
- Asset-centric programming model
- Easier developer experience

## Engineering trade-offs {#engineering-trade-offs}

This section presents the main disadvantages of Sui with respect to traditional blockchains.

### Design complexity {#design-complexity}

While traditional blockchains require implementing only a single consensus protocol, Sui requires two protocols: (i) a protocol based on Byzantine Consistent Broadcast to handle simple transactions, and (ii) a consensus protocol to handle transactions with shared objects. This means the Sui team needs to maintain a much larger codebase.

Transactions involving shared objects require a little overhead (adding two extra round trips - 200ms for well-connected clients using a Sui Gateway service) before submitting it to the consensus protocol. This overhead is required to securely compose the two protocols described above. Other blockchains can instead directly submit the transaction to the consensus protocol. Note the finality for shared object transactions is still in the 2-3 second range even with this overhead.

Building an efficient synchronizer is harder in Sui than in traditional blockchains. The synchronizer sub-protocol allows validators to update each other by sharing data, and it allows slow validators to catch up. Building an efficient synchronizer for traditional blockchains is no easy task, but still simpler than in Sui.

### Sequential writes in the simple case {#sequential-writes}

Traditional blockchains totally order all client transactions with respect to each other. This design requires reaching consensus across validators, which is effective but slow.

As mentioned in previous sections, Sui forgoes consensus for many transactions to reduce their latency. In this manner, Sui enables multi-lane processing and eliminates head-of-line blocking. All other transactions no longer need to wait for the completion of the first transaction's increment in a single lane. Sui provides a lane of the appropriate breadth for each transaction. Simple transactions require viewing only the sender address, which greatly improves the system's capacity.

The downside of allowing head-of-line blocking on the sender for these simple transactions is that the sender can send only one transaction at a time. As a result, it is imperative the transactions finalize quickly.

### Complex total queries {#complex-total-queries}

Sui can make total queries more difficult than in traditional blockchains since it does not always impose total order of transactions. Total queries are fairly rare with respect to local reads (see above) but useful in some scenarios. For example, a new validator joins the network and needs to download the total state to disk, or an auditor wishes to audit the entire blockchain.

Sui mitigates this with checkpoints. A checkpoint is established every time an increment is added to a blockchain resulting from a certified transaction. Checkpoints work much like a [write ahead log](https://en.wikipedia.org/wiki/Write-ahead_logging) that stores state prior to full execution of a program. The calls in that program represent a smart contract in a blockchain. A checkpoint contains not only the transactions but also commitments to the state of the blockchain before and after the transactions.

Sui uses the state commitment that arrives upon epoch change. Sui requires a single answer from the multiple validators and leverages an accessory protocol to derive the hash representing the state of the blockchain. This protocol consumes little bandwidth and does not impede the ingestion of transactions. Validators produce checkpoints at every epoch change. Sui requires the validators to also produce checkpoints even more frequently. So users may use these checkpoints to audit the blockchain with some effort.

## Conclusion {#conclusion}

In summary, Sui provides significant performance and usability enhancements. It introduces an innovative fastpath consensus for simple send transactions and utilizes a state-of-the-art consensus protocol that leads the industry with its low latency and high throughput.
```

../../Downloads/sui-stuff/sui-main/docs/content/references/sui-api.mdx
```
---
title: Sui RPC
---

:::info

{@include: ../snippets/data-serving-msg.mdx}

:::

_SuiJSON_ is a JSON-based format with restrictions that allow Sui to align JSON inputs more closely with Move call arguments.

This table shows the restrictions placed on JSON types to make them SuiJSON compatible:

| JSON    | SuiJSON Restrictions                         | Move Type Mapping                                                                        |
| ------- | -------------------------------------------- | ---------------------------------------------------------------------------------------- |
| Number  | Must be unsigned integer                     | u8, u6, u32, u64 (encoded as String), u128 (encoded as String), u256 (encoded as String) |
| String  | No restrictions                              | Vector`<u8>`, Address, ObjectID, TypeTag, Identifier, Unsigned integer (256 bit max)     |
| Boolean | No restrictions                              | Bool                                                                                     |
| Array   | Must be homogeneous JSON and of SuiJSON type | Vector                                                                                   |
| Null    | Not allowed                                  | N/A                                                                                      |
| Object  | Not allowed                                  | N/A                                                                                      |

## Type coercion reasoning {#type-coercion-reasoning}

Due to the loosely typed nature of JSON/SuiJSON and the strongly typed nature of Move types, you sometimes need to overload SuiJSON types to represent multiple Move types.

For example `SuiJSON::Number` can represent both _u8_ and _u32_. This means you have to coerce and sometimes convert types.

Which type you coerce depends on the expected Move type. For example, if the Move function expects a u8, you must have received a `SuiJSON::Number` with a value less than 256. More importantly, you have no way to easily express Move addresses in JSON, so you encode them as hex strings prefixed by `0x`.

Additionally, Move supports u128 and u256 but JSON doesn't. As a result Sui allows encoding numbers as strings.

## Type coercion rules {#type-coercion-rules}

|      Move Type      |                                                                                                                                         SuiJSON Representations                                                                                                                                          |                                                                          Valid Examples                                                                           |                                                                                                             Invalid Examples                                                                                                              |
| :-----------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|        Bool         |                                                                                                                                                   Bool                                                                                                                                                   |                                                                            true, false                                                                            |                                                                                                                                                                                                                                           |
|         u8          |                                                                                            Supports 3 formats: Unsigned number < 256. Decimal string with value < 256. One byte hex string prefixed with 0x.                                                                                             |                                                                           7 "70" "0x43"                                                                           |                    -5: negative not allowed 3.9: float not allowed NaN: not allowed 300: U8 must be less than 256 " 9": Spaces not allowed in string "9A": Hex num must be prefixed with 0x "0x09CD": Too large for U8                    |
|         u16         |                                                                                      Three formats are supported Unsigned number < 65536. Decimal string with value < 65536. Two byte hex string prefixed with 0x.                                                                                       |                                                                         712 "570" "0x423"                                                                         |             -5: negative not allowed 3.9: float not allowed NaN: not allowed 98342300: U16 must be less than 65536 " 19": Spaces not allowed in string "9EA": Hex num must be prefixed with 0x "0x049C1D": Too large for U16              |
|         u32         |                                                                                 Three formats are supported Unsigned number < 4294967296. Decimal string with value < 4294967296. One byte hex string prefixed with 0x.                                                                                  |                                                                   9823247 "987120" "0x4BADE93"                                                                    |     -5: negative not allowed 3.9: float not allowed NaN: not allowed 123456789123456: U32 must be less than 4294967296 " 9": Spaces not allowed in string "9A": Hex num must be prefixed with 0x "0x3FF1FF9FFDEFF": Too large for U32     |
|         u64         |                                                                                                   Supports two formats Decimal string with value < U64::MAX. Up to 8 byte hex string prefixed with 0x.                                                                                                   |                                                                    "747944370" "0x2B1A39A15E"                                                                     |                                                                                123434: Although this is a valid U64 number, it must be encoded as a string                                                                                |
|        u128         |                                                                                               Two formats are supported Decimal string with value < U128::MAX. Up to 16 byte hex string prefixed with 0x.                                                                                                |                                                          "74794734937420002470" "0x2B1A39A1514E1D8A7CE"                                                           |                                                                                 34: Although this is a valid U128 number, it must be encoded as a string                                                                                  |
|        u256         |                                                                                               Two formats are supported Decimal string with value < U256::MAX. Up to 32 byte hex string prefixed with 0x.                                                                                                |                                         "747947349374200024707479473493742000247" "0x2B1762FECADA39753FCAB2A1514E1D8A7CE"                                         |                                              123434: Although this is a valid U256 number, it must be encoded as a string 0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de                                              |
|       Address       |                                                                                                                                   32 byte hex string prefixed with 0x                                                                                                                                    |                                               "0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de"                                                |                                0xbc33: string too short bc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de: missing 0x prefix 0xG2B1A39A1514E1D8A7CE45919CFEB4FEE70B4E01: invalid hex char G                                |
|      ObjectID       |                                                                                                                                   32 byte hex string prefixed with 0x                                                                                                                                    |                                               "0x1b879f00b03357c95a908b7fb568712f5be862c5cb0a5894f62d06e9098de6dc"                                                |                                                                                                             Similar to above                                                                                                              |
|     Identifier      | Typically used for module and function names. Encoded as one of the following: A String whose first character is a letter and the remaining characters are letters, digits or underscore. A String whose first character is an underscore, and there is at least one further letter, digit or underscore |                                               "function", "\_function", "some_name", "\_\_\_\_some_name", "Another"                                               |                         "\_": missing trailing underscore, digit or letter, "8name": cannot start with digit, ".function": cannot start with period, " ": cannot be empty space, "func name": cannot have spaces                          |
| Vector`<Move Type>` / Option`<Move Type>` |                                                                                  Homogeneous vector of aforementioned types including nested vectors of primitive types (only "flat" vectors of ObjectIDs are allowed)                                                                                   | [1,2,3,4]: simple U8 vector [[3,600],[],[0,7,4]]: nested U32 vector ["0x2B1A39A1514E1D8A7CE45919CFEB4FEE", "0x2B1A39A1514E1D8A7CE45919CFEB4FEF"]: ObjectID vector | [1,2,3,false]: not homogeneous JSON [1,2,null,4]: invalid elements [1,2,"7"]: although Sui allows encoding numbers as strings meaning this array can evaluate to [1,2,7], the array is still ambiguous so it fails the homogeneity check. |
|    Vector`<u8>`     |                                                                                                            For convenience, Sui allows: U8 vectors represented as UTF-8 (and ASCII) strings.                                                                                                             |                                                      "√®ˆbo72 √∂†∆˚–œ∑π2ie": UTF-8 "abcdE738-2 \_=?": ASCII                                                      |                                                                                                                                                                                                                                           |

```

../../Downloads/sui-stuff/sui-main/docs/content/references/sui-glossary.mdx
```
---
title: Glossary
slug: /sui-glossary
---

Find terms used in Sui defined below.

### Causal history {#causal-history}

Causal history is the relationship between an object in Sui and its direct predecessors and successors. This history is essential to the causal order Sui uses to process transactions. In contrast, other blockchains read the entire state of their world for each transaction,
introducing latency.

### Causal order {#causal-order}

[Causal order](https://www.scattered-thoughts.net/writing/causal-ordering/) is a representation of the relationship between transactions and the objects they produce, laid out as dependencies. Validators cannot execute a transaction dependent on objects created by a prior transaction that has not finished. Rather than total order, Sui uses causal order (a partial order).

### Certificate {#certificate}

A certificate is the mechanism proving a transaction was approved or certified. Validators vote on transactions, and aggregators collect a Byzantine-resistant-majority of these votes into a certificate and broadcasts it to all Sui validators, thereby ensuring finality.

### Epoch {#epoch}

Operation of the Sui network is temporally partitioned into non-overlapping, fixed-duration epochs. During a particular epoch, the set of validators participating in the network is fixed.

### Equivocation {#equivocation}

Equivocation in blockchains is the malicious action of dishonest actors giving conflicting information for the same message, such as inconsistent or duplicate voting.

### Eventual consistency {#eventual-consistency}

[Eventual consistency](https://en.wikipedia.org/wiki/Eventual_consistency) is the consensus model employed by Sui; if one honest validator
certifies the transaction, all of the other honest validators will too eventually.

### Finality {#finality}

[Finality](https://medium.com/mechanism-labs/finality-in-blockchain-consensus-d1f83c120a9a) is the assurance a transaction will not be revoked. This stage is considered closure for an exchange or other blockchain transaction.

### Gas {#gas}

[Gas](https://ethereum.org/en/developers/docs/gas/) refers to the computational effort required for executing operations on the Sui network. In Sui, gas is paid with the network's native currency SUI. The cost of executing a transaction in SUI units is referred to as the transaction fee.

### Genesis {#genesis}

Genesis is the initial act of creating accounts and gas objects for a Sui network. Sui provides a `genesis` command that allows users to create and inspect the genesis object setting up the network for operation.

### Multi-writer objects {#multi-writer-objects}

Multi-writer objects are objects that are owned by more than one address. Transactions affecting multi-writer objects require consensus in Sui. This contrasts with transactions affecting only single-writer objects, which require only a confirmation of the owner's address contents.

### Object {#object}

The basic unit of storage in Sui is object. In contrast to many other blockchains, where storage is centered around address and each address contains a key-value store, Sui's storage is centered around objects. Sui objects have one of the following primary states:

- _Immutable_ - the object cannot be modified.
- _Mutable_ - the object can be changed.

Further, mutable objects are divided into these categories:

- _Owned_ - the object can be modified only by its owner.
- _Shared_ - the object can be modified by anyone.

Immutable objects do not need this distinction because they have no owner.

### Proof-of-stake {#proof-of-stake}

[Proof-of-stake](https://en.wikipedia.org/wiki/Proof_of_stake) is a blockchain consensus mechanism where the voting weights of validators or validators is proportional to a bonded amount of the network's native currency (called their stake in the network). This mitigates [Sybil attacks](https://en.wikipedia.org/wiki/Sybil_attack) by forcing bad actors to gain a large stake in the blockchain first.

### Single-writer objects {#single-writer-objects}

Single-writer objects are owned by one address. In Sui, transactions affecting only single-writer objects owned by the same address may proceed with only a verification of the sender's address, greatly speeding transaction times. These are _simple transactions_. See Single-Writer Apps for example applications of this simple transaction model.

### Smart contract {#smart-contract}

A [smart contract](https://en.wikipedia.org/wiki/Smart_contract) is an agreement based upon the protocol for conducting transactions in a blockchain. In Sui, smart contracts are written in the [Move](https://github.com/MystenLabs/awesome-move) programming language.

### Sui {#sui}

Sui refers to the Sui blockchain, and the [Sui open source project](https://github.com/MystenLabs/sui/) as a whole.

### SUI {#sui-1}

SUI is the native token to the Sui network.

### Total order {#total-order}

[Total order](https://en.wikipedia.org/wiki/Total_order) refers to the ordered presentation of the history of all transactions processed by a traditional blockchain up to a given time. This is maintained by many blockchain systems, as the only way to process transactions. In contrast, Sui uses a causal (partial) order wherever possible and safe.

### Transaction {#transaction}

A transaction in Sui is a change to the blockchain. This may be a _simple transaction_ affecting only single-writer, single-address objects, such as minting an NFT or transferring an NFT or another token. These transactions may bypass the consensus protocol in Sui.

More _complex transactions_ affecting objects that are shared or owned by multiple addresses, such as asset management and other DeFi use cases, do go through consensus.

### Transfer {#transfer}

A transfer is switching the owner address of a token to a new one via command in Sui. This is accomplished via the Sui CLI client command line interface. It is one of the more common of many commands available in the CLI client.

### Validator {#validator}

A validator in Sui plays a passive role analogous to the more active role of validators and minors in other blockchains. In Sui, validators do not continuously participate in the consensus protocol but are called into action only when receiving a transaction or
certificate.

```

../../Downloads/sui-stuff/sui-main/docs/content/references/ide/debugger.mdx
```
---
title: Move Trace Debugger
description: Debug Move execution traces directly in VS Code to understand how your code executes.
---

The [Move Trace Debugger](https://marketplace.visualstudio.com/items?itemName=mysten.move-trace-debug) extension for Visual Studio Code provides a familiar debugging interface for Move unit tests. You can step through code execution, track local variable values, and set line breakpoints to understand how your Move code executes.

## Install

:::info 
You must have the [Move extension](./move.mdx) installed to use the debugger. The Move extension includes the Move Trace Debugger so you should not need to install it separately. The install instructions are included for rare cases where an individual install might be necessary.
:::

The Move Trace Debugger extension is available in the Visual Studio Code Marketplace. Search for `Move Trace Debugger` in the **Extensions** view, or press <kbd>Ctrl</kbd> + <kbd>P</kbd> or <kbd>⌘</kbd> + <kbd>P</kbd> and type `ext install mysten.move-trace-debug`.

Alternatively, run `code --install-extension mysten.move-trace-debug` to install the extension from the command line.

## Usage

:::tip[Tracing]

To use the debugger, you must also have the `sui` binary installed with the `tracing` feature flag enabled. The `sui` binaries in release tarballs, Homebrew, and Chocolatey have this feature enabled. See [Install Sui](../../guides/developer/getting-started/sui-install.mdx) for more information, including how to build from source.

:::

Debugging a Move unit test is a two-step process:

**I. Generate execution traces**
   1. Open the command palette (<kbd>Shift</kbd> + <kbd>⌘</kbd> + <kbd>P</kbd> on macOS, <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> on Windows/Linux).
   1. Run the `Move: Trace Move test execution` command.

      ![Move Trace generation in the command palette](./images/trace_palette.png)
   1. The extension displays a filter prompt. Either type a filter string to target specific tests or leave the field blank to run all tests and press <kbd>Enter</kbd>.

      ![Move Trace generation filter string](./images/filter_string.png)
   1. Find the generated traces in the `traces` directory.

**II. Start debugging**
   1. Open the Move file containing your test.
   1. Select **Run** -> **Start Debugging** from the menu.

      ![Start debugging](./images/start_debugging.png)
   1. If the file has multiple tests, select the specific test from the dropdown menu.

      ![Test selection](./images/test_selection.png)


## Features

Currently, the Move Trace Debugger supports basic forward debugging through test execution traces.

Support for reverse debugging and watch expressions is not currently available.

### Stepping through code execution

Move Trace Debugger supports standard debugging features like step over, step into, step out, continue, and stop. You can step through normal code and Move macros. 

![Stepping through code execution](./images/debugger_running.png)

### Tracking variable values  

Move Trace Debugger supports displaying the values of primitive types, Move structs, and references.

At present, the debugger doesn't support setting watch points on variables.

![Variable values](./images/variables.png)
```

../../Downloads/sui-stuff/sui-main/docs/content/references/ide/move.mdx
```
---
title: Move Analyzer VS Code Extension
sidebar_label: Move Analyzer
description: The Move extension provides language support features like code navigation, completion, and diagnostics for Move source code.
---

The Move Analyzer extension for Visual Studio Code provides language support features for the Move programming language. It enables syntax highlighting, code completion, and advanced features like definition linking and type checking.

## Install

You can install the Move extension from the Visual Studio Code Marketplace:

1. Open VS Code.
1. Open the **Extensions** view (<kbd>⇧</kbd> + <kbd>⌘</kbd> + <kbd>X</kbd> on macOS, <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>X</kbd> on Windows/Linux).
1. Search for `mysten.move`.
1. Click **Install** on the Move extension by Mysten Labs.

Alternative install methods include:

  - Use <kbd>Ctrl</kbd> + <kbd>P</kbd> or <kbd>⌘</kbd> + <kbd>P</kbd> and type `ext install mysten.move`.
  - Use the command line: 

      ```sh
      $ code --install-extension mysten.move
      ```

The following extensions are included in the Move extension install:

- [Move Syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax)
- [Move Trace Debugger](https://marketplace.visualstudio.com/items?itemName=mysten.move-trace-debug)

### Install move-analyzer

The Move extension attempts to install the appropriate `move-analyzer` binary for your platform. If this doesn't work, or you prefer to install it manually, build it with Cargo:

```sh
$ cargo install --git https://github.com/MystenLabs/sui.git sui-move-lsp
```

By default, the Move extension expects to find the `move-analyzer` binary in `~/.sui/bin`. You can either copy the binary to this location, or configure the extension to use a different path. 

## Features

The Move extension supports most Language Server Protocol features, as well as basic commands for building, testing, and tracing Move code.

### Build, test, and trace

The Move extension installs command palette commands for building, testing, and tracing Move code. 

![Move commands in the command palette](./images/commands.png)

These commands find the `Move.toml` file for the open Move source file and open a terminal to run the appropriate `sui move` command.

To generate a trace, you must have a trace-capable `sui` binary. See [Debugger](./debugger.mdx) for more information.

### Syntax highlighting

The [Move Syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax) extension provides syntax highlighting.

### Hover information

Hovering over identifiers shows type information, struct fields and attributes, and docstrings (if any) for the identifier. This works for all Move symbols including macros. 

- Hover over structs to see structure and definition.

  ![Struct hoverover](./images/hover_struct.png)

- Hover over functions for details and definition.

  ![Function hoverover](./images/hover_fun.png)

- Hover over macros for their functionality.

  ![Macro hoverover](./images/hover_macros.png)

### Code completion

The Move extension autocompletes upon a dot operator, displaying the available methods and fields for the type.

![Code completion](./images/dot_completion.png)

The Move extension also autocompletes after a `::` operator.

![Type completion](./images/colon_completion.png)

Finally, the Move extension provides "inlay hints," where the plugin automatically inserts the correct type after a variable declaration, unpack, function parameters, and other places.

![Inlay hints](./images/inlay_hint.png)

### Navigation

The Move extension supports `go-to-definition` navigation for all Move symbols including types, functions, and macros, as long as the type was present when `move-analyzer` last built the file. 

The extension also supports `find-references` for functions, macros, constants, and types.
```

../../Downloads/sui-stuff/sui-main/docs/content/references/cli/client.mdx
```
---
title: Sui Client CLI
description: The Sui Client CLI provides command-level access to interact with the Sui network.
---

The Sui CLI `client` command provides command-level access to interact with the Sui network. Typical uses for `sui client` include publishing Move smart contracts, getting the information of an object, executing transactions, or managing addresses.

{@include: ../../snippets/cli-check-install.mdx}

## Commands

The following list itemizes all the available subcommands for the `sui client` command.

```
Usage: sui client [OPTIONS] [COMMAND]

Commands:
  active-address              Default address used for commands when none specified
  active-env                  Default environment used for commands when none specified
  addresses                   Obtain the Addresses managed by the client
  balance                     List the coin balance of an address
  call                        Call Move function
  chain-identifier            Query the chain identifier from the rpc endpoint
  dynamic-field               Query a dynamic field by its address
  envs                        List all Sui environments
  execute-signed-tx           Execute a Signed Transaction. This is useful when the user prefers to sign elsewhere and use this command to execute
  execute-combined-signed-tx  Execute a combined serialized SenderSignedData string
  faucet                      Request gas coin from faucet. By default, it will use the active address and the active network
  gas                         Obtain all gas objects owned by the address. An address' alias can be used instead of the address
  merge-coin                  Merge two coin objects into one coin
  new-address                 Generate new address and keypair with keypair scheme flag {ed25519 | secp256k1 | secp256r1} with optional derivation path, default to m/44'/784'/0'/0'/0' for ed25519 or m/54'/784'/0'/0/0
                                  for secp256k1 or m/74'/784'/0'/0/0 for secp256r1. Word length can be { word12 | word15 | word18 | word21 | word24} default to word12 if not specified
  new-env                     Add new Sui environment
  object                      Get object info
  objects                     Obtain all objects owned by the address. It also accepts an address by its alias
  pay                         Pay coins to recipients following specified amounts, with input coins. Length of recipients must be the same as that of amounts
  pay-all-sui                 Pay all residual SUI coins to the recipient with input coins, after deducting the gas cost. The input coins also include the coin for gas payment, so no extra gas coin is required
  pay-sui                     Pay SUI coins to recipients following following specified amounts, with input coins. Length of recipients must be the same as that of amounts. The input coins also include the coin for
                                  gas payment, so no extra gas coin is required
  publish                     Publish Move modules
  split-coin                  Split a coin object into multiple coins
  switch                      Switch active address and network(e.g., devnet, local rpc server)
  tx-block                    Get the effects of executing the given transaction block
  transfer                    Transfer object
  transfer-sui                Transfer SUI, and pay gas with the same SUI coin object. If amount is specified, only the amount is transferred; otherwise the entire object is transferred
  upgrade                     Upgrade Move modules
  verify-bytecode-meter       Run the bytecode verifier on the package
  verify-source               Verify local Move packages against on-chain packages, and optionally their dependencies
  profile-transaction         Profile the gas usage of a transaction. Unless an output filepath is not specified, outputs a file `gas_profile_{tx_digest}_{unix_timestamp}.json` which can be opened in a flamegraph
                                  tool such as speedscope
  replay-transaction          Replay a given transaction to view transaction effects. Set environment variable MOVE_VM_STEP=1 to debug
  replay-batch                Replay transactions listed in a file
  replay-checkpoint           Replay all transactions in a range of checkpoints
  help                        Print this message or the help of the given subcommand(s)

Options:
      --client.config <CONFIG>  Sets the file storing the state of our user accounts (an empty one will be created if missing)
      --json                    Return command outputs in json format
  -y, --yes
  -h, --help                    Print help
```

## JSON output

Append the `--json` flag to commands to format responses in JSON instead of the more human-friendly default Sui CLI output. This can be useful for extremely large datasets, for example, as those results can have a troublesome display on smaller screens. In these cases, the `--json` flag is useful.

## Examples

The following examples demonstrate some of the most often used commands.

### List available network environments

Use the `sui client envs` command to find the network environments set up in the CLI. The information for these environments is also stored in the client.yaml file in the Sui configuration directory (`~/.sui/sui_config`).

```sh
╭────────┬────────────────────────────────────┬────────╮
│ alias  │ url                                │ active │
├────────┼────────────────────────────────────┼────────┤
│ devnet │ https://fullnode.devnet.sui.io:443 │ *  	   │
╰────────┴────────────────────────────────────┴────────╯
```

### Create network environment

Use `client new-env` to add details for a new network environment. This example creates an environment pointer to Sui Mainnet. Setting the `alias` value makes referencing the environment less prone to typographical errors. After running this command, Sui updates your client.yaml file in `~/.sui/sui_config` with the new information.

```
$ sui client new-env --alias=mainnet --rpc https://fullnode.mainnet.sui.io:443

Added new Sui env [mainnet] to config.
```

### Set current environment

Use the `sui client switch` command to change the current network. This example switches the current network to `mainnet`.

```sh
$ sui client switch --env mainnet
```
```sh
Active environment switched to [mainnet]
```

If you run `sui client envs` after this command, you see the asterisk in the `active` column on the `mainnet` row of the table.

### Get current active address

Use the `sui client active-address` command to reveal the current address. The CLI uses the current active address to execute address-specific CLI commands (like `sui client objects`) when you don't provide them with a Sui address value.

```sh
$ sui client active-address
```
```sh
0x514692f08249c3e9951234ce29074695840422564bff85e424b56de462913e0d
```

### Request a SUI coin from faucet

If you use one of the standard public RPCs (for example, `fullnode.devnet.sui.io:443`), you can use the `faucet` command to request gas coins. If you use a custom faucet service, then pass in the URL to the faucet using the `--url` option.
The `faucet` command works for a local network, as well. If you start your network with a custom faucet port, include the `--url` option. 

```sh
$ sui client faucet
```
```sh
Request successful. It can take up to 1 minute to get the coin. Run sui client gas to check your gas coins.
```

### Get objects owned by an address

Use `sui client objects` to list summary information about the objects the current active address owns. You can provide a Sui address value to the command to list objects for a particular address. This example lists objects for the current active address.

```sh
$ sui client objects 0x36df11369cf00ecf0be68d6ba965b0abe2e883bc5245911e3a29ebfa0aaf6b69
```
```sh
╭───────────────────────────────────────────────────────────────────────────────────────╮
| ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f  │ │
│ │ version	   │  33363559                                                        	  │ │
│ │ digest 	   │  IY7/qsIJhliQL0uxwSzNYu0SMcn5AMsqQklSGngn1V0=                    	  │ │
│ │ objectType │  0x0000..0002::coin::Coin                                        	  │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  0xfffe59fb6f78b1ced7f6537e69a205cc45d105270857bfd66332f9a627a38ae0  │ │
│ │ version	   │  33370864                                                            │ │
│ │ digest     │  b+tKChvujbCk/UCm8L+lflyb6Vjt7beB+uz6+ahUHmM=                    	  │ │
│ │ objectType │  0x0000..0002::coin::Coin                                        	  │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
╰───────────────────────────────────────────────────────────────────────────────────────╯
```

### Get complete object information

Use `sui client object <OBJECT-ID>` to list object information for the ID you provide. This example displays the information for a Coin object.

```sh
$ sui client object 0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f
```
```sh
╭───────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ objectId  	  │  0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f                                             	  │
│ version   	  │  33363559                                                                                                       	  │
│ digest    	  │  3FzvXJVVVcXb9H6dEXdARaY9EmxXyyNFduet3X4eYV4x                                                                   	  │
│ objType   	  │  0x2::coin::Coin<0x2::sui::SUI>                                                                                 	  │
│ ownerType 	  │  AddressOwner                                                                                                   	  │
│ prevTx    	  │  ES2RQThjRE5u8rwiUEnhcnMoLA3cHeEGYJ8Pq98tmyAc                                                                   	  │
│ storageRebate │  988000                                                                                                         	  │
│ content   	  │ ╭───────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────╮ │
│           	  │ │ dataType      	  │  moveObject                                                                            	    │ │
│           	  │ │ type          	  │  0x2::coin::Coin<0x2::sui::SUI>                                                       	    │ │
│           	  │ │ hasPublicTransfer │  true                                                                                    	  │ │
│           	  │ │ fields        	  │ ╭─────────┬───────────────────────────────────────────────────────────────────────────────╮ │ │
│           	  │ │               	  │ │ balance │  530076676                                                                	  │ │ │
│           	  │ │               	  │ │ id  	  │ ╭────┬──────────────────────────────────────────────────────────────────────╮ │ │ │
│           	  │ │               	  │ │     	  │ │ id │  0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f  │ │ │ │
│           	  │ │               	  │ │     	  │ ╰────┴──────────────────────────────────────────────────────────────────────╯ │ │ │
│           	  │ │               	  │ ╰─────────┴───────────────────────────────────────────────────────────────────────────────╯ │ │
│           	  │ ╰───────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────╯ │
╰───────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Get dynamic fields of an object

Use the `sui client dynamic-field <DYNAMIC-FIELD-ID>` command to list the details of the dynamic field with the ID you provide.

```sh
$ sui client dynamic-field 0x5
```
```sh
╭─────────────┬───────────────────────────────────────────────────────────────────────────────────────────╮
│ hasNextPage │  false                                                                                	  │
│ nextCursor  │  0x5b890eaf2abcfa2ab90b77b8e6f3d5d8609586c3e583baf3dccd5af17edf48d1                   	  │
│ data     	  │ ╭───────────────────────────────────────────────────────────────────────────────────────╮ │
│         	  │ │ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │ │
│         	  │ │ │ name   	   │ ╭───────┬───────╮                                                	  │ │ │
│         	  │ │ │        	   │ │ type  │  u64  │                                                	  │ │ │
│         	  │ │ │        	   │ │ value │  2	 │                                                	    │ │ │
│         	  │ │ │        	   │ ╰───────┴───────╯                                                	  │ │ │
│         	  │ │ │ bcsName	   │  LQM2cdzDY3                                                      	  │ │ │
│         	  │ │ │ type   	   │  DynamicField                                                    	  │ │ │
│         	  │ │ │ objectType │  0x3::sui_system_state_inner::SuiSystemStateInnerV2              	  │ │ │
│         	  │ │ │ objectId   │  0x5b890eaf2abcfa2ab90b77b8e6f3d5d8609586c3e583baf3dccd5af17edf48d1  │ │ │
│         	  │ │ │ version	   │  112                                                             	  │ │ │
│         	  │ │ │ digest 	   │  HMrm1KNKjq3GfB1cWTRdvRo8gk7auhgvoZXaVoyEHqUR                    	  │ │ │
│         	  │ │ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │ │
│         	  │ ╰───────────────────────────────────────────────────────────────────────────────────────╯ │
╰─────────────┴───────────────────────────────────────────────────────────────────────────────────────────╯
```

### Send SUI or objects

In this example, let's see how to transfer SUI or transfer an object from one address to another. First of all, there two main commands for sending SUI or transferring objects: `pay` and `transfer`. 
Both `pay` and `transfer` have a few sister commands: `pay-sui`, `pay-all-sui`, `transfer-sui`. 

The differences between these commands are:
- commands that end in `-sui` deal with Sui's native coin, and they use the input coints to pay for gas and for transferring SUI or the object.
- `pay-` commands typically deal with coins and handle gas smashing for you, whereas `transfer` commands can handle the transfer of any object that has public transfer, meaning any object that has the `store` ability. 
- `pay` commands allow you to send coins to multiple recipients, whereas `transfer` commands only accept one recipient.
- `pay-all-sui` is a special case of `pay-sui` that offers a way to transfer the entire balance after smashing.
- `transfer-sui` is a legacy command and has been entirely superseded by `pay-sui` or `pay-all-sui` depending on whether an amount is specified or not.

Assume you have two addresses:

```sh
╭───────────────────┬────────────────────────────────────────────────────────────────────┬────────────────╮
│ alias             │ address                                                            │ active address │
├───────────────────┼────────────────────────────────────────────────────────────────────┼────────────────┤
│ hungry-spodumene  │ 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea │ *              │
│ eloquent-amber    │ 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 │                │
╰───────────────────┴────────────────────────────────────────────────────────────────────┴────────────────╯
````

Address `hungry-spodumene` has a few coins:

```sh
$ sui client gas hungry-spodumene
```
```sh
╭────────────────────────────────────────────────────────────────────┬────────────────────┬──────────────────╮
│ gasCoinId                                                          │ mistBalance (MIST) │ suiBalance (SUI) │
├────────────────────────────────────────────────────────────────────┼────────────────────┼──────────────────┤
│ 0x205972830acd8264a38b9a1776a1b72a1ae626fa23a4d1f12249349ce3b83c06 │ 200000000000       │ 200.00           │
│ 0x56d76420a5bc7d356e3930e6a2ddc61cbbc0c87ea5c5f3cc3ac5952b4d52be5a │ 200000000000       │ 200.00           │
│ 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 │ 200000000000       │ 200.00           │
│ 0xe373de9bdbd3dbd4f5f707f144c83af74a181cdb3903a953ee366f48e33865c7 │ 200000000000       │ 200.00           │
│ 0xf7adb6aeb18eb409c03fe88cc31711b61a65333e0fdd88c1815d4ec75f713f31 │ 200000000000       │ 200.00           │
╰────────────────────────────────────────────────────────────────────┴────────────────────┴──────────────────╯
```

You want to send 0.5 SUI to `eloquent-amber`. Given that you have a few gas coins, you can use `pay`. If only one gas coin exists, then you need to use `transfer-sui` or `pay-sui`, or you would need to split the coin first to have another coin to use for paying gas. In this case, let's use the `pay-sui` command as you do not need to provide a separate gas coin to be used for the gas fees. In the command below, you set the recipient to be `eloquent-amber`, which coin to use to transfer SUI from, and the amount of SUI to transfer.

{@include: ../../snippets/info-gas-budget.mdx}

```sh
$ sui client pay-sui --recipients eloquent-amber --input-coins 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 --amounts 500000000 --gas-budget 5000000
```

The result is:

```sh
Transaction Digest: AsWkciVhLHeCmqVipjjyAA7Hv5y87pFjHS59K8m4zBJV
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                             │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                   │
│ Gas Owner: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                │
│ Gas Budget: 5000000 MIST                                                                                     │
│ Gas Price: 1000 MIST                                                                                         │
│ Gas Payment:                                                                                                 │
│  ┌──                                                                                                         │
│  │ ID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                                    │
│  │ Version: 2                                                                                                │
│  │ Digest: 9MEH7kr1YkBDx7pdUPCDnVb3FtPz9UZVeWmCot5Dhxqr                                                      │
│  └──                                                                                                         │
│                                                                                                              │
│ Transaction Kind: Programmable                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Input Objects                                                                                            │ │
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │
│ │ 0   Pure Arg: Type: address, Value: "0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976" │ │
│ │ 1   Pure Arg: Type: u64, Value: "500000000"                                                              │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│ ╭──────────────────────╮                                                                                     │
│ │ Commands             │                                                                                     │
│ ├──────────────────────┤                                                                                     │
│ │ 0  SplitCoins:       │                                                                                     │
│ │  ┌                   │                                                                                     │
│ │  │ Coin: GasCoin     │                                                                                     │
│ │  │ Amounts:          │                                                                                     │
│ │  │   Input  1        │                                                                                     │
│ │  └                   │                                                                                     │
│ │                      │                                                                                     │
│ │ 1  TransferObjects:  │                                                                                     │
│ │  ┌                   │                                                                                     │
│ │  │ Arguments:        │                                                                                     │
│ │  │   Result 0        │                                                                                     │
│ │  │ Address: Input  0 │                                                                                     │
│ │  └                   │                                                                                     │
│ ╰──────────────────────╯                                                                                     │
│                                                                                                              │
│ Signatures:                                                                                                  │
│    eZc/iFO3i4Y8Le92zu9q75jILs+yg0sSXd1yPV9Dta+knH99VfkSCnzNQG1KbXSvY24wexmVtiuU6NkfudbiAQ==                  │
│                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: AsWkciVhLHeCmqVipjjyAA7Hv5y87pFjHS59K8m4zBJV                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 0                                                                                 │
│                                                                                                   │
│ Created Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241                         │
│  │ Owner: Account Address ( 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 )  │
│  │ Version: 3                                                                                     │
│  │ Digest: Fq3maqq3pShgKw58Ssm8cS2j1pspfhanedVK2MMxfQWQ                                           │
│  └──                                                                                              │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                         │
│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │
│  │ Version: 3                                                                                     │
│  │ Digest: GFB9mpxTP4z6CCShTbvD58FYxtu9G4mnxN3JtFeRupM3                                           │
│  └──                                                                                              │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                         │
│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │
│  │ Version: 3                                                                                     │
│  │ Digest: GFB9mpxTP4z6CCShTbvD58FYxtu9G4mnxN3JtFeRupM3                                           │
│  └──                                                                                              │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 1976000 MIST                                                                     │
│    Computation Cost: 1000000 MIST                                                                 │
│    Storage Rebate: 978120 MIST                                                                    │
│    Non-refundable Storage Fee: 9880 MIST                                                          │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    GThyjtRFysBgVppXDc9iduNPzB2bLteXBnJcBEYXz4vG                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────╮
│ No transaction block events │
╰─────────────────────────────╯

╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                   │
├──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241                  │
│  │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                    │
│  │ Owner: Account Address ( 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 ) │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 3                                                                                    │
│  │ Digest: Fq3maqq3pShgKw58Ssm8cS2j1pspfhanedVK2MMxfQWQ                                          │
│  └──                                                                                             │
│ Mutated Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                  │
│  │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                    │
│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea ) │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 3                                                                                    │
│  │ Digest: GFB9mpxTP4z6CCShTbvD58FYxtu9G4mnxN3JtFeRupM3                                          │
│  └──                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Balance Changes                                                                                   │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                              │
│  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: -501997880                                                                             │
│  └──                                                                                              │
│  ┌──                                                                                              │
│  │ Owner: Account Address ( 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 )  │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: 500000000                                                                              │
│  └──                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯

```

Check the gas for the sender and the recipient's coins using `sui client gas <address>`. The sender now has 199.49 SUI for that gas coin that was used. 0.5 SUI was transferred, and the remaining 0.01 SUI paid the gas fees.
```sh
$ sui client gas
```
```sh
╭────────────────────────────────────────────────────────────────────┬────────────────────┬──────────────────╮
│ gasCoinId                                                          │ mistBalance (MIST) │ suiBalance (SUI) │
├────────────────────────────────────────────────────────────────────┼────────────────────┼──────────────────┤
│ 0x205972830acd8264a38b9a1776a1b72a1ae626fa23a4d1f12249349ce3b83c06 │ 200000000000       │ 200.00           │
│ 0x56d76420a5bc7d356e3930e6a2ddc61cbbc0c87ea5c5f3cc3ac5952b4d52be5a │ 200000000000       │ 200.00           │
│ 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 │ 199498002120       │ 199.49           │
│ 0xe373de9bdbd3dbd4f5f707f144c83af74a181cdb3903a953ee366f48e33865c7 │ 200000000000       │ 200.00           │
│ 0xf7adb6aeb18eb409c03fe88cc31711b61a65333e0fdd88c1815d4ec75f713f31 │ 200000000000       │ 200.00           │
╰────────────────────────────────────────────────────────────────────┴────────────────────┴──────────────────╯
```
```sh
$ sui client gas eloquent-amber
```
```sh
╭────────────────────────────────────────────────────────────────────┬────────────────────┬──────────────────╮
│ gasCoinId                                                          │ mistBalance (MIST) │ suiBalance (SUI) │
├────────────────────────────────────────────────────────────────────┼────────────────────┼──────────────────┤
│ 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241 │ 500000000          │ 0.50             │
╰────────────────────────────────────────────────────────────────────┴────────────────────┴──────────────────╯
```

If you want to transfer the whole object, you can use `sui client pay-all-sui` or `sui client transfer-sui` (without passing the amount): 
```sh
$ sui client pay-sui --recipient eloquent-amber --input-coins 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 --gas-budget 5000000
```
or
```sh
$ sui client transfer-sui --to eloquent-amber --sui-coin-object-id 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 --gas-budget 5000000
```

Then check the gas for `eloquent-amber` again:
```sh
$ sui client gas eloquent-amber
```
```sh
╭────────────────────────────────────────────────────────────────────┬────────────────────┬──────────────────╮
│ gasCoinId                                                          │ mistBalance (MIST) │ suiBalance (SUI) │
├────────────────────────────────────────────────────────────────────┼────────────────────┼──────────────────┤
│ 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241 │ 500000000          │ 0.50             │
│ 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 │ 199496992240       │ 199.49           │
╰────────────────────────────────────────────────────────────────────┴────────────────────┴──────────────────╯
```


### Replay a transaction

Use the `sui client replay-transaction --tx-digest <TRANSACTION-DIGEST>` to re-execute a transaction locally and show the transaction effects.
This command will fetch the transaction dependencies from the Full node specified in the client env. For transactions that happened quite far in
the past, it is advised to set the client Full node to one that has non-pruned chain data for that transaction.
This will also verify that the resulting effects from the locally executed transaction match the effects of the transaction stored on-chain.

You can add additional flags `--gas-info` and `--ptb-info` to this command to see more information about the transaction.

```sh
$ sui client replay-transaction --tx-digest 51MzJP2Uesvza8vXGpPCGbfLrY6UCfdvdoErN1z4oXPW
```
```sh
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: 51MzJP2Uesvza8vXGpPCGbfLrY6UCfdvdoErN1z4oXPW                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 237                                                                               │
│                                                                                                   │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x0000000000000000000000000000000000000000000000000000000000000006                         │
│  │ Owner: Shared                                                                                  │
│  │ Version: 20303014                                                                              │
│  │ Digest: 3FyU88FpFFa2mhDFJWcabwQNdfaVaWvvnbjkfErD6AgJ                                           │
│  └──                                                                                              │
│                                                                                                   │
│ Shared Objects:                                                                                   │
│  ┌──                                                                                              │
│  │ ID: 0x0000000000000000000000000000000000000000000000000000000000000006                         │
│  │ Version: 20303013                                                                              │
│  │ Digest: 7uGV3aHa9NDAWLX1UUyV1DG7wAuhfFkzSGo514wtco1C                                           │
│  └──                                                                                              │
│                                                                                                   │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: 0x0000000000000000000000000000000000000000000000000000000000000000                         │
│  │ Owner: Account Address ( 0x0000000000000000000000000000000000000000000000000000000000000000 )  │
│  │ Version: 0                                                                                     │
│  │ Digest: 11111111111111111111111111111111                                                       │
│  └──                                                                                              │
│                                                                                                   │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 0                                                                                │
│    Computation Cost: 0                                                                            │
│    Storage Rebate: 0                                                                              │
│    Non-refundable Storage Fee: 0                                                                  │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    EvDLzYeKbrxDNHJomgrr2zwAJ7FJDtb2uNwfbonF2uGK                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
Execution finished successfully. Local and on-chain effects match.
```

Use `sui client replay-batch --path <FILEPATH>` to replay several transactions listed in a newline-separated file. This
will verify that all transactions local execution results match the effects on-chain.

### Profile a transaction

Use the `sui client profile-transaction --tx-digest <TRANSACTION-DIGEST>` command to re-execute a transaction locally
and produce a gas profile. Similar to the `replay` command, this command fetches the transaction dependencies from the
Full node specified in the client environment that are needed to execute the transaction. During the local execution of the transaction,
this command records all the Move function invocations and the gas cost breakdown for each invocation.

To enable the profiler, you must either install or build the Sui Client binary locally with the `--features tracing` flag if it has not already been built with that feature enabled.

```sh
$ cargo install --locked --git https://github.com/MystenLabs/sui.git --branch <BRANCH-NAME> --features tracing sui
```

The command outputs a profile to the current working directory in the format `gas_profile_{tx_digest}_{unix_timestamp}.json`.
You can include the optional flag `--profile-output </PATH/OUTPUT.json>` to write the profile to `/PATH/OUTPUT_{tx_digest}_{unix_timestamp}.json` instead.
Use [speedscope](https://www.speedscope.app/) to inspect the profile.

To install speedscope run

```sh
$ npm install -g speedscope
```

To open a profile in speedscope run

```sh
$ speedscope <PATH/PROFILE-OUTPUT-FILE>
```

When looking at the profile in speedscope, there are three different views available from the top left menu: **Timer Order**,
**Left Heavy**, and **Sandwich**. In each view, each bar's vertical width corresponds to the percentage of gas consumption incurred by the function,
and you can hover your mouse over a bar or click a bar to see the computation units accrued by the function invocation. The transaction's total computation units, along with the storage computation units, are multiplied by the gas price to determine the gas cost of the transaction based on a tier system.

**Time Order** shows the callstack of function invocations from left to right in the order
of invocation, while **Left Heavy** combines repeated sequences of nested invocations into a single combined call stack. **Left Heavy** 
displays these sequences from left to right by total incurred gas consumption per combined call stack. This is useful when there have
been hundreds of repeated calls to the same function to quickly observe the total gas consumption over all calls to that function.
In both these views, you can click the top section and drag to zoom in and out over different sections of the profile.

**Sandwich** view shows a list of discrete values that correspond to gas consumption per function, with **Total** showing
gas cost incurred in all the functions called by the function, and **Self** showing the gas cost done by only the given function.

Observing a transaction's gas consumption provides useful insight of expected gas cost usage of a smart contract.
When developing a smart contract, you can [run a local network](../../guides/developer/getting-started/local-network.mdx) and publish the package to the local network. Then create a transaction that calls
your published smart contract, and finally run the profiler on the transaction to see a breakdown of the gas cost.

## Publish a Move package

One of the main uses of the `sui client` command is to publish smart contracts on the Sui network. This example switches the current environment to the Devnet network, then builds, tests, and publishes one of the existing Move examples available in the Sui repository: [sui/examples/move](https://github.com/MystenLabs/sui/tree/main/examples/move)

This example also makes use of `sui move` commands. To learn more about those commands, see [Sui Move CLI](./move.mdx).

1. Open a terminal or console to the root of your local Sui repository and navigate to the `move_tutorial` example.
    ```sh
    $ cd examples/move/first_package
    ```
1. Switch to the Devnet network. This command uses an alias, so the `devnet` value might be different for you, depending on the alias name set in your configuration (use `sui client envs` for a list of your defined networks and their aliases).
    ```sh
    $ sui client switch --env devnet
    ```
1. Use `sui move build` to build the package. You must run this command at the same level as the package manifest file ([Move.toml](https://move-book.com/concepts/manifest.html)).
    ```sh
    $ sui move build
    ```
    The console responds with the status of the build.
    ```sh
    INCLUDING DEPENDENCY Sui
    INCLUDING DEPENDENCY MoveStdlib
    BUILDING first_package
    ```
1. Use `sui move test` to run the unit tests.
    ```sh
    $ sui move test
    ```
    The console responds with updates of its progress.
    ```sh
    INCLUDING DEPENDENCY Sui
    INCLUDING DEPENDENCY MoveStdlib
    BUILDING first_package
    Running Move unit tests
    [ PASS    ] 0x0::example::test_module_init
    [ PASS    ] 0x0::example::test_sword_transactions
    Test result: OK. Total tests: 2; passed: 2; failed: 0
     ```
1. Use the `sui client verify-bytecode-meter` to check if the module passes the bytecode meter.
    ```sh
    $ sui client verify-bytecode-meter
    ```
    The console responds with the maximum allowed values, as well as the amount the package uses.
    ```sh
    Running bytecode verifier for 1 modules
    ╭──────────────────────────────────╮
    │ Module will pass metering check! │
    ├────────┬────────────┬────────────┤
    │        │ Module     │ Function   │
    │ Max    │ 16000000   │ 16000000   │
    │ Used   │ 4565       │ 4565       │
    ╰────────┴────────────┴────────────╯
    ```
1. Use `sui client gas` to verify that the active address has a gas coin for paying gas. 
    ```sh
    $ sui client gas
    ```
    In the case of this example, the console responds with the information that the address is coinless.
    ```sh
    No gas coins are owned by this address
    ```
1. If you need coins, use `sui client faucet` (not available for Mainnet). For more information on getting gas tokens, see [Get Sui Tokens](/guides/developer/getting-started/get-coins.mdx).
    ```sh
    $ sui client faucet
    ```
1. Use `sui client gas` to verify the current active address received the coins.
    ```sh
    $ sui client gas
    ```
    ```sh
    ╭────────────────────────────────────────────────────────────────────┬─────────────╮
    │ gasCoinId                                                          │ gasBalance  │
    ├────────────────────────────────────────────────────────────────────┼─────────────┤
    │ 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8 │ 10000000000 │
    ╰────────────────────────────────────────────────────────────────────┴─────────────╯
    ```
1. Use `sui client publish` to publish the package, being sure to set an appropriate value for the `gas-budget` flag if you're using an older version of Sui. The console responds with the details of the publish. You can use `sui client object <OBJECT-ID>` to check the details of any of the objects from the process.
    ```sh
    $ sui client publish --gas-budget 100000000 .
    ```
    ```sh
     Transaction Digest: ABPd7v8BxLkcyHvX8Jt1SbneQRwzE9WzcEoptT2RDNVF
    ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
    │ Transaction Data                                                                                             │
    ├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                   │
    │ Gas Owner: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                │
    │ Gas Budget: 5000000000 MIST                                                                                  │
    │ Gas Price: 1000 MIST                                                                                         │
    │ Gas Payment:                                                                                                 │
    │  ┌──                                                                                                         │
    │  │ ID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                                    │
    │  │ Version: 2                                                                                                │
    │  │ Digest: GZQwvpxLeTciVboEWeC8EZ2KYYU9o6XoBtW6LrA5Si1h                                                      │
    │  └──                                                                                                         │
    │                                                                                                              │
    │ Transaction Kind: Programmable                                                                               │
    │ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
    │ │ Input Objects                                                                                            │ │
    │ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │
    │ │ 0   Pure Arg: Type: address, Value: "0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea" │ │
    │ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
    │ ╭─────────────────────────────────────────────────────────────────────────╮                                  │
    │ │ Commands                                                                │                                  │
    │ ├─────────────────────────────────────────────────────────────────────────┤                                  │
    │ │ 0  Publish:                                                             │                                  │
    │ │  ┌                                                                      │                                  │
    │ │  │ Dependencies:                                                        │                                  │
    │ │  │   0x0000000000000000000000000000000000000000000000000000000000000001 │                                  │
    │ │  │   0x0000000000000000000000000000000000000000000000000000000000000002 │                                  │
    │ │  └                                                                      │                                  │
    │ │                                                                         │                                  │
    │ │ 1  TransferObjects:                                                     │                                  │
    │ │  ┌                                                                      │                                  │
    │ │  │ Arguments:                                                           │                                  │
    │ │  │   Result 0                                                           │                                  │
    │ │  │ Address: Input  0                                                    │                                  │
    │ │  └                                                                      │                                  │
    │ ╰─────────────────────────────────────────────────────────────────────────╯                                  │
    │                                                                                                              │
    │ Signatures:                                                                                                  │
    │    x437h/JxDAba2zkx4a2kEfz6iaXQ08T7+inyP5YkbmlSB5K7IYasM6onckjYDB19FNM1ZNqXm1z13VyTmDHXCw==                  │
    │                                                                                                              │
    ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
    ╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
    │ Transaction Effects                                                                               │
    ├───────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Digest: ABPd7v8BxLkcyHvX8Jt1SbneQRwzE9WzcEoptT2RDNVF                                              │
    │ Status: Success                                                                                   │
    │ Executed Epoch: 0                                                                                 │
    │                                                                                                   │
    │ Created Objects:                                                                                  │
    │  ┌──                                                                                              │
    │  │ ID: 0x569828cc4e134ccccd7408def18b80af1465ac791fd4ef40483f6b16e2f00d95                         │
    │  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │
    │  │ Version: 3                                                                                     │
    │  │ Digest: 4iD7ZhsFS9iFuszqxBSEL6xZdcnWG76WGgU4D5PH1PeL                                           │
    │  └──                                                                                              │
    │  ┌──                                                                                              │
    │  │ ID: 0xde670ae990c8f20fd53e9f597a0da056bdb634175176602658e9da2c2ec9cb93                         │
    │  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │
    │  │ Version: 3                                                                                     │
    │  │ Digest: AV27tn7ePXhdDyDV9TCkSQZA3mkMei9DV63AmB4DEjGN                                           │
    │  └──                                                                                              │
    │  ┌──                                                                                              │
    │  │ ID: 0xe1d9d66b7a19b27ebda338a52593cd10e728f666f34ecd30a7cc2ad3fed186da                         │
    │  │ Owner: Immutable                                                                               │
    │  │ Version: 1                                                                                     │
    │  │ Digest: 4bzxMQgcSZoKzppNiRtQwAWDBvCgjr18gQi2H8Yk1tQZ                                           │
    │  └──                                                                                              │
    │ Mutated Objects:                                                                                  │
    │  ┌──                                                                                              │
    │  │ ID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                         │
    │  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │
    │  │ Version: 3                                                                                     │
    │  │ Digest: 46rvdbXkw5qqsBYbUGChzgFatJAYPmarPmFHgRRJiiU9                                           │
    │  └──                                                                                              │
    │ Gas Object:                                                                                       │
    │  ┌──                                                                                              │
    │  │ ID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                         │
    │  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │
    │  │ Version: 3                                                                                     │
    │  │ Digest: 46rvdbXkw5qqsBYbUGChzgFatJAYPmarPmFHgRRJiiU9                                           │
    │  └──                                                                                              │
    │ Gas Cost Summary:                                                                                 │
    │    Storage Cost: 9978800                                                                          │
    │    Computation Cost: 1000000                                                                      │
    │    Storage Rebate: 978120                                                                         │
    │    Non-refundable Storage Fee: 9880                                                               │
    │                                                                                                   │
    │ Transaction Dependencies:                                                                         │
    │    891Qjq6qDZ6SzAJiAg3CEaHobXrpDL5bAy2o45ZJPTuB                                                   │
    │    ESHcS3y3VCuaCVmWkKDx3EXX3icfPtj4bHhk86gaGWdo                                                   │
    ╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
    ╭─────────────────────────────╮
    │ No transaction block events │
    ╰─────────────────────────────╯
    ╭────────────────────────────────────────────────────────────────────────────────────────────────────╮
    │ Object Changes                                                                                     │
    ├────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Created Objects:                                                                                   │
    │  ┌──                                                                                               │
    │  │ ObjectID: 0x569828cc4e134ccccd7408def18b80af1465ac791fd4ef40483f6b16e2f00d95                    │
    │  │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                      │
    │  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )   │
    │  │ ObjectType: 0xe1d9d66b7a19b27ebda338a52593cd10e728f666f34ecd30a7cc2ad3fed186da::example::Forge  │
    │  │ Version: 3                                                                                      │
    │  │ Digest: 4iD7ZhsFS9iFuszqxBSEL6xZdcnWG76WGgU4D5PH1PeL                                            │
    │  └──                                                                                               │
    │  ┌──                                                                                               │
    │  │ ObjectID: 0xde670ae990c8f20fd53e9f597a0da056bdb634175176602658e9da2c2ec9cb93                    │
    │  │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                      │
    │  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )   │
    │  │ ObjectType: 0x2::package::UpgradeCap                                                            │
    │  │ Version: 3                                                                                      │
    │  │ Digest: AV27tn7ePXhdDyDV9TCkSQZA3mkMei9DV63AmB4DEjGN                                            │
    │  └──                                                                                               │
    │ Mutated Objects:                                                                                   │
    │  ┌──                                                                                               │
    │  │ ObjectID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                    │
    │  │ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                      │
    │  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )   │
    │  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                      │
    │  │ Version: 3                                                                                      │
    │  │ Digest: 46rvdbXkw5qqsBYbUGChzgFatJAYPmarPmFHgRRJiiU9                                            │
    │  └──                                                                                               │
    │ Published Objects:                                                                                 │
    │  ┌──                                                                                               │
    │  │ PackageID: 0xe1d9d66b7a19b27ebda338a52593cd10e728f666f34ecd30a7cc2ad3fed186da                   │
    │  │ Version: 1                                                                                      │
    │  │ Digest: 4bzxMQgcSZoKzppNiRtQwAWDBvCgjr18gQi2H8Yk1tQZ                                            │
    │  │ Modules: example                                                                                │
    │  └──                                                                                               │
    ╰────────────────────────────────────────────────────────────────────────────────────────────────────╯
    ╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
    │ Balance Changes                                                                                   │
    ├───────────────────────────────────────────────────────────────────────────────────────────────────┤
    │  ┌──                                                                                              │
    │  │ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  │
    │  │ CoinType: 0x2::sui::SUI                                                                        │
    │  │ Amount: -10000680                                                                              │
    │  └──                                                                                              │
    ╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
    ```

## Help

Each command has its own help section. For example, `sui client call --help` displays the following prompt:

```sh
Call Move function

Usage: sui client call [OPTIONS] --package <PACKAGE> --module <MODULE> --function <FUNCTION>

Options:
      --package <PACKAGE>               Object ID of the package, which contains the module
      --module <MODULE>                 The name of the module in the package
      --function <FUNCTION>             Function name in module
      --type-args <TYPE_ARGS>...        Type arguments to the generic function being called. All must be specified, or the call will fail
      --args <ARGS>...                  Simplified ordered args like in the function syntax ObjectIDs, Addresses must be hex strings
      --gas <GAS>                       ID of the gas object for gas payment. If not provided, a gas object with at least gas_budget value will be selected
      --gas-budget <GAS_BUDGET>         An optional gas budget for this transaction (in MIST). If gas budget is not provided, the tool will first perform a dry
                                        run to estimate the gas cost, and then it will execute the transaction. Please note that this incurs a small cost in
                                        performance due to the additional dry run call
      --dry-run                         Perform a dry run of the transaction, without executing it
      --dev-inspect                     Perform a dev inspect
      --serialize-unsigned-transaction  Instead of executing the transaction, serialize the bcs bytes of the unsigned transaction data (TransactionData) using
                                        base64 encoding, and print out the string <TX_BYTES>. The string can be used to execute transaction with `sui client
                                        execute-signed-tx --tx-bytes <TX_BYTES>`
      --serialize-signed-transaction    Instead of executing the transaction, serialize the bcs bytes of the signed transaction data (SenderSignedData) using
                                        base64 encoding, and print out the string <SIGNED_TX_BYTES>. The string can be used to execute transaction with `sui
                                        client execute-combined-signed-tx --signed-tx-bytes <SIGNED_TX_BYTES>`
      --json                            Return command outputs in json format
  -h, --help                            Print help
  -V, --version                         Print version
```

```

../../Downloads/sui-stuff/sui-main/docs/content/references/cli/validator.mdx
```
---
title: Sui Validator CLI
---

The Sui CLI `validator` command provides command-level access to validator features of the Sui network.

## Commands

Typing `sui validator --help` into your terminal or console displays the following information on available commands.

```sh
Usage: sui validator [OPTIONS] [COMMAND]

Commands:
  make-validator-info          	 
  become-candidate             	 
  join-committee               	 
  leave-committee              	 
  display-metadata             	 
  update-metadata              	 
  update-gas-price              	Update gas price that is used to calculate Reference Gas Price
  report-validator              	Report or un-report a validator
  serialize-payload-pop         	Serialize the payload that is used to generate Proof of Possession. This is useful to take the payload offline for an Authority protocol
                                    	keypair to sign
  display-gas-price-update-raw-txn  Print out the serialized data of a transaction that sets the gas price quote for a validator
  help                          	Print this message or the help of the given subcommand(s)

Options:
  	--client.config <CONFIG>  Sets the file storing the state of our user accounts (an empty one will be created if missing)
  	--json                	Return command outputs in json format
  -y, --yes                	 
  -h, --help                	Print help
```

## Examples

The following examples demonstrate some of the most often used commands. 

### Update gas price for next epoch

```sh
$ sui validator  update-gas-price 500
```


<details>
  <summary>
  Toggle output
  </summary>

```sh
----- Transaction Digest ----
A8z83EqjmgwRNFV6sme6A5tTTTQPjiLgiW76neyvhLud

----- Transaction Data ----
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                                                                                                                                                                                                                                                                                                                                                   	 │
├────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: 0xf...3d9                                                                                                                                                                                                                                                                                                                                                         	                                                         │
│ Gas Owner: 0xf...3d9                                                                                                                                                                                                                                                                                                                                                      	                                                         │
│ Gas Budget: 200000000 MIST                                                                                                                                                                                                                                                                                                                                                                                                         	 │
│ Gas Price: 1000 MIST                                                                                                                                                                                                                                                                                                                                                                                                               	 │
│ Gas Payment:                                                                                                                                                                                                                                                                                                                                                                                                                       	 │
│  ┌──                                                                                                                                                                                                                                                                                                                                                                                                                               	 │
│  │ ID: 0x8...19e                                                                                                                                                                                                                                                                                                                                                          	                                                         │
│  │ Version: 1                                                                                                                                                                                                                                                                                                                                                                                                                      	 │
│  │ Digest: 8UEiGYe3KL3S6JPs8uP2sbbx7sMCtzi8yJJ6SyTe9V1x                                                                                                                                                                                                                                                                                                                                                                            	 │
│  └──                                                                                                                                                                                                                                                                                                                                                                                                                               	 │
│                                                                                                                                                                                                                                                                                                                                                                                                                                    	 │
│ Transaction Kind : Programmable                                                                                                                                                                                                                                                                                                                                                                                                    	 │
│ Inputs: [Object(SharedObject { object_id: 0x0...005, initial_shared_version: SequenceNumber(1), mutable: true }), Object(ImmOrOwnedObject { object_id: 0x4...dbe, version: SequenceNumber(1), digest: o#82z9UUX9iD2Mq9zvciD56kmmDYqjF3iwaFadi3Mk16eJ }), Pure(SuiPureValue { value_type: Some(U64), value: "500" })]                                                                                                                   │
│ Commands: [                                                                                                                                                                                                                                                                                                                                                                                                                        	 │
│   MoveCall(0x0...003::sui_system::request_set_gas_price(Input(0),Input(1),Input(2))),                                                                                                                                                                                                                                                                                     	                                                         │
│ ]                                                                                                                                                                                                                                                                                                                                                                                                                                  	 │
│                                                                                                                                                                                                                                                                                                                                                                                                                                    	 │
│                                                                                                                                                                                                                                                                                                                                                                                                                                    	 │
│ Signatures:                                                                                                                                                                                                                                                                                                                                                                                                                        	 │
│	j2FE7GNkHm9+ey0zTQrgfaTXJgGu1vYWmivrVxbUfP56vIrxMFA4XxqEyw7Q8pM1FR+JDPgCsE1kgZRGH6TZDg==                                                                                                                                                                                                                                                                                                                                        	 │
│                                                                                                                                                                                                                                                                                                                                                                                                                                    	 │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
----- Transaction Effects ----
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                           	│
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: A8z83EqjmgwRNFV6sme6A5tTTTQPjiLgiW76neyvhLud                                          	│
│ Status: Success                                                                               	│
│ Executed Epoch: 5                                                                             	│
│                                                                                               	│
│ Mutated Objects:                                                                              	│
│  ┌──                                                                                          	│
│  │ ID: 0x0...005                     	                                                            │
│  │ Owner: Shared                                                                              	│
│  │ Version: 16                                                                                	│
│  │ Digest: ER2L6MxrqKNAsaRd9pWdMwvLzXG3ocGQnytnP9s5QLeh                                       	│
│  └──                                                                                          	│
│  ┌──                                                                                          	│
│  │ ID: 0x4...dbe                     	                                                            │
│  │ Owner: Account Address ( 0xf45...3d9 )                                                         │
│  │ Version: 16                                                                                	│
│  │ Digest: 4yDkecsKPe8SnacWdECmq1yVDt7MzvpXCxbRGs74PGaB                                       	│
│  └──                                                                                          	│
│  ┌──                                                                                          	│
│  │ ID: 0x5...8d1                     	                                                            │
│  │ Owner: Object ID: ( 0x000...005 )   	                                                        │
│  │ Version: 16                                                                                	│
│  │ Digest: BBu5zHWWX7nnb1XcFu5VLVnKZEU6AqRRarDDjEeBtqWy                                       	│
│  └──                                                                                          	│
│  ┌──                                                                                          	│
│  │ ID: 0x8...19e                     	                                                            │
│  │ Owner: Account Address ( 0xf45...3d9 )                                                         │
│  │ Version: 16                                                                                	│
│  │ Digest: 4WQp6FYctutMFzf6f2EX68xut71AMubewJ6c7GxpzX7e                                       	│
│  └──                                                                                          	│
│                                                                                               	│
│ Shared Objects:                                                                               	│
│  ┌──                                                                                          	│
│  │ ID: 0x0...005                     	                                                            │ 
│  │ Version: 15                                                                                	│
│  │ Digest: 6vdobiuiDQpJguDxVbbMNW5ddRqEFkP67C3FWrAVYYuZ                                       	│
│  └──                                                                                          	│
│                                                                                               	│
│ Gas Object:                                                                                   	│
│  ┌──                                                                                          	│
│  │ ID: 0x8...19e                     	                                                            │
│  │ Owner: Account Address ( 0xf45...3d9 )                                                         │
│  │ Version: 16                                                                                	│
│  │ Digest: 4WQp6FYctutMFzf6f2EX68xut71AMubewJ6c7GxpzX7e                                       	│
│  └──                                                                                          	│
│                                                                                               	│
│ Gas Cost Summary:                                                                             	│
│	Storage Cost: 31479200                                                                     	    │
│	Computation Cost: 1000000                                                                  	    │
│	Storage Rebate: 0                                                                          	    │
│	Non-refundable Storage Fee: 0                                                              	    │
│                                                                                               	│
│ Transaction Dependencies:                                                                     	│
│	2gqHgPZbjTkDWM9GnVuWU5kT9z2SWN2ggwK3ryxf8aUX                                               	    │
│	EmW6DhJWRACNZAvupiTNVacZFLoZxbNJ88mrKVv9DeiJ                                               	    │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

</details>


### Set gas price for the next epoch

{@include: ../../snippets/info-gas-budget.mdx}

```sh
$ sui validator request_set_gas_price --args 0x5 \"42\" --gas-budget GAS-BUDGET-AMOUNT>
```

### Display the validator information

```sh
$ sui validator display-metadata 0x3...de5
```


<details>
  <summary>
  Toggle output
  </summary>

```sh
0x3...de5's valdiator status: Active
SuiValidatorSummary {
	sui_address: 0x3...de5,
	protocol_pubkey_bytes: [
    	167,
    	93,
    	42,
    	177,
    	79,
    	244,
    	192,
    	168,
    	26,
    	242,
    	55,
    	119,
    	232,
    	131,
    	191,
    	112,
    	92,
    	219,
    	204,
    	109,
    	234,
    	107,
    	124,
    	116,
    	79,
    	200,
    	221,
    	159,
    	185,
    	142,
    	173,
    	161,
    	122,
    	214,
    	113,
    	183,
    	240,
    	124,
    	205,
    	8,
    	157,
    	110,
    	31,
    	85,
    	16,
    	106,
    	16,
    	34,
    	9,
    	254,
    	125,
    	36,
    	83,
    	125,
    	35,
    	231,
    	245,
    	203,
    	204,
    	43,
    	137,
    	70,
    	229,
    	201,
    	64,
    	157,
    	189,
    	203,
    	220,
    	222,
    	1,
    	121,
    	138,
    	139,
    	41,
    	108,
    	106,
    	57,
    	116,
    	212,
    	208,
    	249,
    	215,
    	18,
    	22,
    	237,
    	214,
    	179,
    	71,
    	192,
    	93,
    	89,
    	255,
    	51,
    	56,
    	158,
	],
	network_pubkey_bytes: [
    	118,
    	14,
    	165,
    	223,
    	145,
    	150,
    	130,
    	74,
    	212,
    	160,
    	218,
    	170,
    	134,
    	2,
    	206,
    	72,
    	228,
    	87,
    	35,
    	114,
    	40,
    	217,
    	206,
    	35,
    	29,
    	194,
    	81,
    	61,
    	186,
    	215,
    	56,
    	215,
	],
	worker_pubkey_bytes: [
    	84,
    	171,
    	204,
    	100,
    	81,
    	92,
    	16,
    	207,
    	151,
    	167,
    	70,
    	138,
    	104,
    	92,
    	100,
    	75,
    	53,
    	47,
    	212,
    	209,
    	92,
    	2,
    	109,
    	120,
    	66,
    	146,
    	180,
    	116,
    	144,
    	22,
    	139,
    	57,
	],
	proof_of_possession_bytes: [
    	137,
    	134,
    	236,
    	79,
    	232,
    	146,
    	206,
    	45,
    	136,
    	245,
    	8,
    	42,
    	114,
    	154,
    	128,
    	148,
    	60,
    	137,
    	214,
    	92,
    	177,
    	46,
    	118,
    	246,
    	37,
    	159,
    	183,
    	233,
    	122,
    	49,
    	121,
    	227,
    	136,
    	76,
    	48,
    	122,
    	119,
    	187,
    	194,
    	169,
    	114,
    	7,
    	16,
    	225,
    	104,
    	211,
    	100,
    	198,
	],
	name: "Staked",
	description: "The leading provider of staking infrastructure",
	image_url: "https://avatars.githubusercontent.com/u/38704373",
	project_url: "https://staked.us/",
	net_address: "/dns/sui-mainnet.prod-eks-eu-west-1.staked.cloud/tcp/8080/http",
	p2p_address: "/dns/sui-mainnet-udp.prod-eks-eu-west-1.staked.cloud/udp/8084",
	primary_address: "/dns/sui-mainnet-udp.prod-eks-eu-west-1.staked.cloud/udp/8081",
	worker_address: "/dns/sui-mainnet-udp.prod-eks-eu-west-1.staked.cloud/udp/8082",
	next_epoch_protocol_pubkey_bytes: None,
	next_epoch_proof_of_possession: None,
	next_epoch_network_pubkey_bytes: None,
	next_epoch_worker_pubkey_bytes: None,
	next_epoch_net_address: None,
	next_epoch_p2p_address: None,
	next_epoch_primary_address: None,
	next_epoch_worker_address: None,
	voting_power: 53,
	operation_cap_id: 0x4...217,
	gas_price: 1000,
	commission_rate: 1000,
	next_epoch_stake: 42223548570491465,
	next_epoch_gas_price: 1000,
	next_epoch_commission_rate: 1000,
	staking_pool_id: 0xc...932,
	staking_pool_activation_epoch: Some(
    	0,
	),
	staking_pool_deactivation_epoch: None,
	staking_pool_sui_balance: 42926894529549497,
	rewards_pool: 1047712965206377,
	pool_token_balance: 41704322845739375,
	pending_stake: 0,
	pending_total_sui_withdraw: 703345959058032,
	pending_pool_token_withdraw: 683314441220777,
	exchange_rates_id: 0x5...65d,
	exchange_rates_size: 231,
```
</details>

### Report a bad / non-performant validator

```sh
$ sui validator report-validator  0xf...3d9
```


<details>
  <summary>
  Toggle output
  </summary>


```sh
----- Transaction Digest ----
8jVYrpuRBmdSLP37MsQGRqUqE3kE2m8XiSS4TG4aJwXf

----- Transaction Data ----
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 │
├────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: 0xf...3d9                                                                                                                                                                                                                                                                                                                                                                                                                             	                                                         │
│ Gas Owner: 0xf...3d9                                                                                                                                                                                                                                                                                                                                                                                                                          	                                                         │
│ Gas Budget: 200000000 MIST                                                                                                                                                                                                                                                                                                                                                                                                                                                                             	 │
│ Gas Price: 1000 MIST                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   	 │
│ Gas Payment:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           	 │
│  ┌──                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   	 │
│  │ ID: 0x8...19e                                                                                                                                                                                                                                                                                                                                                                                                                              	                                                         │
│  │ Version: 16                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         	 │
│  │ Digest: 4WQp6FYctutMFzf6f2EX68xut71AMubewJ6c7GxpzX7e                                                                                                                                                                                                                                                                                                                                                                                                                                                	 │
│  └──                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   	 │
│                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 │
│ Transaction Kind : Programmable                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 │
│ Inputs: [Object(SharedObject { object_id: 0x0...005, initial_shared_version: SequenceNumber(1), mutable: true }), Object(ImmOrOwnedObject { object_id: 0x4...dbe, version: SequenceNumber(16), digest: o#4yDkecsKPe8SnacWdECmq1yVDt7MzvpXCxbRGs74PGaB }), Pure(SuiPureValue { value_type: Some(Address), value: "0xf...3d9" })]                                                                                                                                                                            │
│ Commands: [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            	 │
│   MoveCall(0x0...003::sui_system::report_validator(Input(0),Input(1),Input(2))),                                                                                                                                                                                                                                                                                                                                                              	                                                         │
│ ]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      	 │
│                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 │
│                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 │
│ Signatures:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            	 │
│	7lJ9ezA1qjGk7nyFCESgLlg/tkVSy46dDkRgJzwgWP3qA+kAjJV8YVWFjJf2r6aLgWgCZCKnka9bkcp1V5jBAA==                                                                                                                                                                                                                                                                                                                                                                                                            	 │
│                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
----- Transaction Effects ----
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                                                                                                                                                                                                                              	   │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: 8jVYrpuRBmdSLP37MsQGRqUqE3kE2m8XiSS4TG4aJwXf                                                                                                                                                                                                                                             	   │
│ Status: Failure { error: "MoveAbort(MoveLocation { module: ModuleId { address: 0000000000000000000000000000000000000000000000000000000000000003, name: Identifier(\"sui_system_state_inner\") }, function: 16, instruction: 12, function_name: Some(\"report_validator_impl\") }, 3) in command 0" } │
│ Executed Epoch: 8                                                                                                                                                                                                                                                                                	   │
│                                                                                                                                                                                                                                                                                                  	   │
│ Mutated Objects:                                                                                                                                                                                                                                                                                 	   │
│  ┌──                                                                                                                                                                                                                                                                                             	   │
│  │ ID: 0x0...005                                                                                                                                                                                                                        	                                                           │
│  │ Owner: Shared                                                                                                                                                                                                                                                                                 	   │
│  │ Version: 25                                                                                                                                                                                                                                                                                   	   │
│  │ Digest: 5N5zyTyFCqAkyz44FGrpr6cYdXcwk4eUCHKzyAZqehMB                                                                                                                                                                                                                                          	   │
│  └──                                                                                                                                                                                                                                                                                             	   │
│  ┌──                                                                                                                                                                                                                                                                                             	   │
│  │ ID: 0x4...dbe                                                                                                                                                                                                                        	                                                           │
│  │ Owner: Account Address ( 0xf...3d9 )                                                                                                                                                                                                 	                                                           │
│  │ Version: 25                                                                                                                                                                                                                                                                                       │
│  │ Digest: HCEr5bcJhKo5jfRx2gsXxGSkpcq6tm8nFGSxxwoPpkNz                                                                                                                                                                                                                                          	   │
│  └──                                                                                                                                                                                                                                                                                             	   │
│  ┌──                                                                                                                                                                                                                                                                                             	   │
│  │ ID: 0x8...19e                                                                                                                                                                                                                        	                                                           │
│  │ Owner: Account Address ( 0xf...3d9 )                                                                                                                                                                                                 	                                                           │
│  │ Version: 25                                                                                                                                                                                                                                                                                   	   │
│  │ Digest: BTzMmVABwEKXoiLsTZ79Li97Eo6HPtNtWTvib8Eq1yrH                                                                                                                                                                                                                                          	   │
│  └──                                                                                                                                                                                                                                                                                             	   │
│                                                                                                                                                                                                                                                                                                  	   │
│ Shared Objects:                                                                                                                                                                                                                                                                                  	   │
│  ┌──                                                                                                                                                                                                                                                                                             	   │
│  │ ID: 0x0...005                                                                                                                                                                                                                        	                                                      	   │
│  │ Version: 24                                                                                                                                                                                                                                                                                   	   │
│  │ Digest: BiS4pKAX3KGXbJrk4oZijy6ggKHDZJd9qPUDWxLEoNR1                                                                                                                                                                                                                                          	   │
│  └──                                                                                                                                                                                                                                                                                             	   │
│                                                                                                                                                                                                                                                                                                  	   │
│ Gas Object:                                                                                                                                                                                                                                                                                      	   │
│  ┌──                                                                                                                                                                                                                                                                                             	   │
│  │ ID: 0x8...19e                                                                                                                                                                                                                        	                                                      	   │
│  │ Owner: Account Address ( 0xf...3d9 )                                                                                                                                                                                                 	                                                      	   │
│  │ Version: 25                                                                                                                                                                                                                                                                                   	   │
│  │ Digest: BTzMmVABwEKXoiLsTZ79Li97Eo6HPtNtWTvib8Eq1yrH                                                                                                                                                                                                                                          	   │
│  └──                                                                                                                                                                                                                                                                                             	   │
│                                                                                                                                                                                                                                                                                                  	   │
│ Gas Cost Summary:                                                                                                                                                                                                                                                                                	   │
│	Storage Cost: 4195200                                                                                                                                                                                                                                                                         	   │
│	Computation Cost: 1000000                                                                                                                                                                                                                                                                     	   │
│	Storage Rebate: 31164408                                                                                                                                                                                                                                                                      	   │
│	Non-refundable Storage Fee: 314792                                                                                                                                                                                                                                                            	   │
│                                                                                                                                                                                                                                                                                                  	   │
│ Transaction Dependencies:                                                                                                                                                                                                                                                                        	   │
│	2gqHgPZbjTkDWM9GnVuWU5kT9z2SWN2ggwK3ryxf8aUX                                                                                                                                                                                                                                                  	   │
│	A8z83EqjmgwRNFV6sme6A5tTTTQPjiLgiW76neyvhLud                                                                                                                                                                                                                                                  	   │
│	B8p4pVC5pzFQRVpZ73nZfAWMt7sL4iH4x4AbDviYWuzF                                                                                                                                                                                                                                                  	   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

</details>


## Help

Each command has its own help section. For example `sui validator report-validator --help` will display the following prompt:

```sh
$ sui validator report-validator --help
```
```sh
Report or un-report a validator

Usage: sui validator report-validator [OPTIONS] <reportee-address>

Arguments:
  <reportee-address>  The Sui Address of the validator is being reported or un-reported

Options:
  	--operation-cap-id <operation-cap-id>  Optional when sender is reporter validator itself and it holds the Cap object. Required when sender is not the reporter validator itself.
                                         	Validator's OperationCap ID can be found by using the `display-metadata` subcommand
  	--undo-report <undo-report>        	If true, undo an existing report [possible values: true, false]
  	--gas-budget <gas-budget>          	Gas budget for this transaction
  	--json                             	Return command outputs in json format
  -h, --help                             	Print help
```

```

../../Downloads/sui-stuff/sui-main/docs/content/references/cli/keytool.mdx
```
---
title: Sui Keytool CLI
description: The Sui Keytool CLI has commands for managing and generating addresses, working with private keys, signatures, or zkLogin. 
---

The Sui CLI `keytool` command provides several command-level access for the management and generation of addresses, as well as working with private keys, signatures, or zkLogin. For example, a user could export a private key from the Sui Wallet and import it into the local Sui CLI wallet using the `sui keytool import [...]` command.

{@include: ../../snippets/cli-check-install.mdx}

## Commands

```
Usage: sui keytool [OPTIONS] <COMMAND>

Commands:
  convert                           	Convert private key from legacy formats (e.g. Hex or Base64) to Bech32 encoded 33 byte `flag || private key` begins with `suiprivkey`
  decode-or-verify-tx                   Given a Base64 encoded transaction bytes, decode its components. If a signature is provided, verify the signature against the transaction 
  											and output the result.
  decode-multi-sig                  	Given a Base64 encoded MultiSig signature, decode its components. If tx_bytes is passed in, verify the multisig
  generate                          	Generate a new keypair with key scheme flag {ed25519 | secp256k1 | secp256r1} with optional derivation path, default to
                                        	m/44'/784'/0'/0'/0' for ed25519 or m/54'/784'/0'/0/0 for secp256k1 or m/74'/784'/0'/0/0 for secp256r1. Word length can be { word12 |
                                        	word15 | word18 | word21 | word24} default to word12 if not specified
  import                            	Add a new key to sui.keystore using either the input mnemonic phrase or a private key (from the Wallet), the key scheme flag {ed25519 |
                                        	secp256k1 | secp256r1} and an optional derivation path, default to m/44'/784'/0'/0'/0' for ed25519 or m/54'/784'/0'/0/0 for secp256k1
                                        	or m/74'/784'/0'/0/0 for secp256r1. Supports mnemonic phrase of word length 12, 15, 18`, 21, 24
  list                              	List all keys by its Sui address, Base64 encoded public key, key scheme name in sui.keystore
  load-keypair                      	This reads the content at the provided file path. The accepted format can be [enum SuiKeyPair] (Base64 encoded of 33-byte `flag ||
                                        	privkey`) or `type AuthorityKeyPair` (Base64 encoded `privkey`). This prints out the account keypair as Base64 encoded `flag ||
                                        	privkey`, the network keypair, worker keypair, protocol keypair as Base64 encoded `privkey`
  multi-sig-address                 	To MultiSig Sui Address. Pass in a list of all public keys `flag || pk` in Base64. See `keytool list` for example public keys
  multi-sig-combine-partial-sig     	Provides a list of participating signatures (`flag || sig || pk` encoded in Base64), threshold, a list of all public keys and a list of
                                        	their weights that define the MultiSig address. Returns a valid MultiSig signature and its sender address. The result can be used as
                                        	signature field for `sui client execute-signed-tx`. The sum of weights of all signatures must be >= the threshold
  multi-sig-combine-partial-sig-legacy
  show                              	Read the content at the provided file path. The accepted format can be [enum SuiKeyPair] (Base64 encoded of 33-byte `flag || privkey`)
                                        	or `type AuthorityKeyPair` (Base64 encoded `privkey`). It prints its Base64 encoded public key and the key scheme flag
  sign                              	Create signature using the private key for the given address in sui keystore. Any signature commits to a [struct IntentMessage]
                                        	consisting of the Base64 encoded of the BCS serialized transaction bytes itself and its intent. If intent is absent, default will be
                                        	used
  sign-kms                          	Creates a signature by leveraging AWS KMS. Pass in a key-id to leverage Amazon KMS to sign a message and the base64 pubkey. Generate
                                        	PubKey from pem using MystenLabs/base64pemkey Any signature commits to a [struct IntentMessage] consisting of the Base64 encoded of the
                                        	BCS serialized transaction bytes itself and its intent. If intent is absent, default will be used
  unpack                            	This takes [enum SuiKeyPair] of Base64 encoded of 33-byte `flag || privkey`). It outputs the keypair into a file at the current
                                        	directory where the address is the filename, and prints out its Sui address, Base64 encoded public key, the key scheme, and the key
                                        	scheme flag
  zk-login-sign-and-execute-tx      	Given the max_epoch, generate an OAuth url, ask user to paste the redirect with id_token, call salt server, then call the prover
                                        	server, create a test transaction, use the ephemeral key to sign and execute it by assembling to a serialized zkLogin signature
  zk-login-enter-token              	A workaround to the above command because sometimes token pasting does not work. All the inputs required here are printed from the
                                        	command above
  zk-login-sig-verify               	Given a zkLogin signature, parse it if valid. If tx_bytes provided, it verifies the zkLogin signature based on provider and its latest
                                        	JWK fetched. Example request: sui keytool zk-login-sig-verify --sig $SERIALIZED_ZKLOGIN_SIG --tx-bytes $TX_BYTES --provider Google
                                        	--curr-epoch 10
  help                              	Print this message or the help of the given subcommand(s)

Options:
  	--keystore-path <KEYSTORE_PATH>
  	--json                       	Return command outputs in json format
  -h, --help                       	Print help
```

## JSON output

Append the `--json` flag to commands to format responses in JSON instead of the more human friendly default Sui CLI output. This can be useful for extremely large datasets, for example, as those results can have a troublesome display on smaller screens. In these cases, the `--json` flag is useful. 

## Examples

The following examples demonstrate some of the most often used commands. 

### List the key pairs in the local wallet

Use the `sui keytool list` command to output all the Sui addresses that exist in the `~/.sui/sui_config/sui.keystore` file in a readable format. 


```sh
$ sui keytool list
```
```sh
╭────────────────────────────────────────────────────────────────────────────────────────────╮
│ ╭─────────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ suiAddress      │  0x3047f142a84297a42a65fb0a8c7a716d9d1b0bd0413d6bfa5ddfec45df175235  │ │
│ │ publicBase64Key │  AHsXwcxaWNaNtCIIszwu7V2G6HO8aNM1598w/8y0zI5q                        │ │
│ │ keyScheme       │  ed25519                                                             │ │
│ │ flag            │  0                                                                   │ │
│ │ peerId          │  7b17c1cc5a58d68db42208b33c2eed5d86e873bc68d335e7df30ffccb4cc8e6a    │ │
│ ╰─────────────────┴──────────────────────────────────────────────────────────────────────╯ │
│ ╭─────────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ suiAddress      │  0x514692f08249c3e9957799ce29074695840422564bff85e424b56de462913e0d  │ │
│ │ publicBase64Key │  AKJCGi8R8TslhYdO2OHIjI6rbr+to1eR+vlOjigLY6SX                        │ │
│ │ keyScheme       │  ed25519                                                             │ │
│ │ flag            │  0                                                                   │ │
│ │ peerId          │  a2421a2f11f13b2585874ed8e1c88c8eab6ebfada35791faf94e8e280b63a497    │ │
│ ╰─────────────────┴──────────────────────────────────────────────────────────────────────╯ │
╰────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Generate a new key pair and store it in a file

To generate a new key pair with the `ed25519` scheme, use the `sui keytool generate ed25519` command. For other schemes, see `sui keytool generate –help`. The key pair file is saved to the current directory with its filename being the address. The content of the file is a Base64 encoded string of 33-byte `flag || privkey`. 

```sh
$ sui keytool generate ed25519
```
```sh
╭─────────────────┬───────────────────────────────────────────────────────────────────────────────────╮
│ suiAddress      │  0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25               │
│ publicBase64Key │  AKTAGf9iv0JqeLXXlsr4PUzBXb9VY8lK7xiZMS50GSu6                                     │
│ keyScheme       │  ed25519                                                                          │
│ flag            │  0                                                                                │
│ mnemonic        │  cushion price ability recall payment embody kid media rude mosquito chalk broom  │
│ peerId          │  a4c019ff62bf426a78b5d796caf83d4cc15dbf5563c94aef1899312e74192bba                 │
╰─────────────────┴───────────────────────────────────────────────────────────────────────────────────╯
```

### Show the key pair data from a file

Use `sui keytool show [filename]` to show the key pair data that is stored in a file. For example, the previous command generated a file named `0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25.key`. 

```sh
$ sui keytool show 0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25.key
```
```sh
╭─────────────────┬──────────────────────────────────────────────────────────────────────╮
│ suiAddress      │  0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25  │
│ publicBase64Key │  AC+AKTAGf9iv0JqeLXXlsr4PUzBXb9VY8lK7xiZMS50GSu6                     │
│ keyScheme       │  ed25519                                                             │
│ flag            │  0                                                                   │
│ peerId          │  a4c019ff62bf426a78b5d796caf83d4cc15dbf5563c94aef1899312e74192bba    │
╰─────────────────┴──────────────────────────────────────────────────────────────────────╯
```

### Sign a transaction

```sh
$ sui keytool sign --data AAABACBRRpLwgknD6ZV3mc4pB0aVhAQiVkv/heQktW3kYpE+DQEBAQABAAAwR/FCqEKXpCpl+wqMenFtnRsL0EE9a/pd3+xF3xdSNQEaEUeErlBmGWxz3Bh+9BZh2mzayodzsri7xIZNDHRA3wIAAAAAAAAAILsR2d1FIZ5+ADDYZtJ2e9CWlpAxsGd4Y2rZrjlyTUF1MEfxQqhCl6QqZfsKjHpxbZ0bC9BBPWv6Xd/sRd8XUjXoAwAAAAAAAICWmAAAAAAAAA== --address 0x3047f142a84297a42a65fb0a8c7a716d9d1b0bd0413d6bfa5ddfec45df175235
```
```sh
╭──────────────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ suiAddress   │ 0x3047f142a84297a42a65fb0a8c7a716d9d1b0bd0413d6bfa5ddfec45df175235                                                                                               │
│ rawTxData    │ AAABACBRRpLwgknD6ZV3mc4pB0aVhAQiVkv/heQktW3kYpE+DQEBAQABAAAwR/FCqEKXpCpl+wqMenFtnRsL0EE9a/pd3+xF3xdSNQEaEUeErlBmGWxz3Bh+9BZh2mzayodzsri7xIZNDHRA3wIAAAAAAAAAILsR │
│              │ 2d1FIZ5+ADDYZtJ2e9CWlpAxsGd4Y2rZrjlyTUF1MEfxQqhCl6QqZfsKjHpxbZ0bC9BBPWv6Xd/sRd8XUjXoAwAAAAAAAICWmAAAAAAAAA==                                                     │
│ intent       │ ╭─────────┬─────╮                                                                                                                                                │
│              │ │ scope   │  0  │                                                                                                                                                │
│              │ │ version │  0  │                                                                                                                                                │
│              │ │ app_id  │  0  │                                                                                                                                                │
│              │ ╰─────────┴─────╯                                                                                                                                                │
│ rawIntentMsg │ AAAAAAABACBRRpLwgknD6ZV3mc4pB0aVhAQiVkv/heQktW3kYpE+DQEBAQABAAAwR/FCqEKXpCpl+wqMenFtnRsL0EE9a/pd3+xF3xdSNQEaEUeErlBmGWxz3Bh+9BZh2mzayodzsri7xIZNDHRA3wIAAAAAAAAA │
│              │ ILsR2d1FIZ5+ADDYZtJ2e9CWlpAxsGd4Y2rZrjlyTUF1MEfxQqhCl6QqZfsKjHpxbZ0bC9BBPWv6Xd/sRd8XUjXoAwAAAAAAAICWmAAAAAAAAA==                                                 │
│ digest       │ +B8Cbr16HfOVT50DoN/QF8HB0+oznm8KAYy8Rm+TQFo=                                                                                                                     │
│ suiSignature │ ANucBEl9TIE0uv+w965DvOjlfDUll7NUtIpJgRhPc3D3y3EtZ4cvaNbm8i5pc7TNIov/qI0FhzIYf2J6PbqoNQ57F8HMWljWjbQiCLM8Lu1dhuhzvGjTNeffMP/MtMyOag==                             │
╰──────────────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
 ```

## Help

Each command has its own help section. For example `sui keytool sign –help` displays the following prompt:

```sh
$ sui keytool sign --help
```
```sh
Create signature using the private key for the given address in sui keystore. Any signature commits to a [struct IntentMessage] consisting of the Base64 encoded of the BCS serialized
transaction bytes itself and its intent. If intent is absent, default will be used

Usage: sui keytool sign [OPTIONS] --address <ADDRESS> --data <DATA>

Options:
  	--address <ADDRESS>  
  	--data <DATA>   	 
  	--json           	Return command outputs in json format
  	--intent <INTENT>    
  -h, --help           	Print help
```

```

../../Downloads/sui-stuff/sui-main/docs/content/references/cli/ptb.mdx
```
---
title: Sui Client PTB CLI
description: The Sui Client PTB CLI enables a user to construct a PTB and execute it from the command line or a file.
---

The `client ptb` command allows you to specify the transactions for execution in a programmable transaction block (PTB) directly from your CLI or through bash scripts.

:::warning

The examples in this document were tested using a `bash` shell environment. Your experience might vary depending on how your shell interprets the input values (for example, zsh requires quotes around passed values in brackets: "[]"; whereas bash accepts them without quotes). On Windows, you might need to add even more quotes around arguments passed (for example, `--assign "forge @<FORGE-ID>"`).

:::

## Commands

The following list itemizes all the available args for the `sui client ptb` command. Use the `--help` for a long help version that includes some examples on how to use this command.

```
Build, preview, and execute programmable transaction blocks. Depending on your shell, you might have to use quotes around arrays or other passed values. Use --help to see examples for how to use the core functionality of this
command.

Usage: sui client ptb [OPTIONS]

Options:
      --assign <NAME> <VALUE>
          Assign a value to a variable name to use later in the PTB.
           If only a name is supplied, the result of the last transaction is bound to that name.
           If a name and value are supplied, then the name is bound to that value.

          Examples:
           --assign MYVAR 100
           --assign X [100,5000]
           --split-coins gas [1000, 5000, 75000]
           --assign new_coins # bound new_coins to the result of previous transaction

      --dry-run
          Perform a dry run of the PTB instead of executing it.

      --gas-coin <ID>
          The object ID of the gas coin to use. If not specified, it will try to use the first gas coin that it finds that has at least the requested gas-budget balance.

      --gas-budget <MIST>
          An optional gas budget for this PTB (in MIST). If gas budget is not provided, the tool will first perform a dry run to estimate the gas cost, and then it will execute the transaction. Please note that this incurs a small
          cost in performance due to the additional dry run call.

      --make-move-vec <TYPE> <[VALUES]>
          Given n-values of the same type, it constructs a vector. For non objects or an empty vector, the type tag must be specified.

          Examples:
           --make-move-vec <u64> []
           --make-move-vec <u64> [1, 2, 3, 4]
           --make-move-vec <std::option::Option<u64>> [none,none]
           --make-move-vec <sui::coin::Coin<sui::sui::SUI>> [gas]

      --merge-coins <INTO_COIN> <[COIN OBJECTS]>
          Merge N coins into the provided coin.

          Examples:
           --merge-coins @coin_object_id [@coin_obj_id1, @coin_obj_id2]

      --move-call <PACKAGE::MODULE::FUNCTION> <TYPE_ARGS> <FUNCTION_ARGS>
          Make a move call to a function.

          Examples:
           --move-call std::option::is_none <u64> none
           --assign a none
           --move-call std::option::is_none <u64> a

      --split-coins <COIN> <[AMOUNT]>
          Split the coin into N coins as per the given array of amounts.

          Examples:
           --split-coins gas [1000, 5000, 75000]
           --assign new_coins # bounds the result of split-coins command to variable new_coins
           --split-coins @coin_object_id [100]

      --transfer-objects <[OBJECTS]> <TO>
          Transfer objects to the specified address.

          Examples:
           --transfer-objects [obj1, obj2, obj3] @address

           --split-coins gas [1000, 5000, 75000]
           --assign new_coins # bound new_coins to result of split-coins to use next
           --transfer-objects [new_coins.0, new_coins.1, new_coins.2] @to_address

      --publish <MOVE_PACKAGE_PATH>
          Publish the Move package. It takes as input the folder where the package exists.

          Examples:
           --move-call sui::tx_context::sender
           --assign sender
           --publish "."
           --assign upgrade_cap
           --transfer-objects "[upgrade_cap]" sender

      --upgrade <MOVE_PACKAGE_PATH>
          Upgrade the move package. It takes as input the folder where the package exists.

      --preview
          Preview the list of PTB transactions instead of executing them.

      --serialize-unsigned-transaction
          Instead of executing the transaction, serialize the bcs bytes of the unsigned transaction data using base64 encoding.

      --serialize-signed-transaction
          Instead of executing the transaction, serialize the bcs bytes of the signed transaction data using base64 encoding.

      --summary
          Show only a short summary (digest, execution status, gas cost). Do not use this flag when you need all the transaction data and the execution effects.

      --warn-shadows
          Enable shadow warning when the same variable name is declared multiple times. Off by default.

      --json
          Return command outputs in json format.

  -h, --help
          Print help (see a summary with '-h')
```

## Design philosophy and concepts

The main philosophy behind the CLI PTB support is to enable a user to build and execute a PTB from the command line. Bash scripts can be used to construct and execute the PTB just as you would do from the command line, providing great flexibility when it comes to automating different tasks.

Besides using existing [traditional PTB](/concepts/transactions/prog-txn-blocks/) related concepts, we introduce a few new and important concepts for this command.

:::warning

All the following examples were tested using a `bash` shell environment and your experience may vary depending on how your shell interprets the input values (e.g., zsh requires to pass values in brackets by adding quotes around it: "[]"; bash accepts them without quotes).

:::

### Types

Sometimes, CLI PTBs require that you specify the type of a value or variable. For instance, in the following example you must provide the `<u64>` type when calling the `0x1::option::is_none` function.

```sh
$ sui client ptb \
--assign my_variable none \
--move-call 0x1::option::is_none "<u64>" my_variable \
--gas-budget 50000000
```

To pass in multiple types, delimit them with a comma:

```sh
...
--move-call package::module::function "<u64,u8,u256>" \
...
```

### Strings

CLI PTBs support string literals as inputs, which will be encoded as pure values that can be used as inputs to `vector<u8>`, `std::ascii::String` and `std::string::String` parameters. The following example previews a transaction block that passes the string `"Hello, world"` to a function `m::f` in a package `$PKG` (its ID is held in an environment variable).

```sh
$ sui client ptb --move-call "$PKG::m::f" '"Hello, world"' --gas-budget 10000000 --preview
```

:::warning

Double-quoted string literals tend to also be valid syntax for shells (like `bash`), so when inputting PTBs on the command-line, remember to wrap the entire string in single-quotes so that its double-quotes are interpreted literally, as in the previous example.

:::

### Addresses and Object IDs

{@include: ../../snippets/address-prefix.mdx}

Here are some examples for `transfer-objects` and `gas-coin`:

```sh
$ sui client ptb --transfer-objects "[ARRAY_OF_OBJECTS]" @0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331 --gas-coin @0x00002819ee07a66e53800495ccf5eeade8a02054a2e0827546c70e4b226f0495
```

### Vectors

CLI PTBs support vectors of serializable types as input (which includes all the primitive types, `ID`s, and `Option`s). Vectors are represented as a comma-separated list of values in square brackets prefixed with `vector`.

```sh
$ sui client ptb --move-call "$PKG::m::f" vector[1, 2, 3]
```

Example above illustrates a vector of integer values. Depending on the type of the vector, you can pass any supported type:

```sh
--move-call package::module::function vector[@0x1, @0x2, @0x3] # vector<address>
--move-call package::module::function vector[none, none]       # vector<Option<T>>
--move-call package::module::function vector["1", "2", "3"]    # vector<String>
```

### Option

Options are represented as `none` or `some(value)`. The value can be any supported primitive type, `ID`, or `Option`.

```sh
$ sui client ptb --move-call "0x1::option::destroy_some" some(2)
```

For `none`, you can use the `none` keyword. For `some`, you can use the `some` keyword followed by the value.

```sh
$ sui client ptb --move-call "0x1::option::destroy_none" none
```

### Addresses

### Assign

Use the `--assign` argument to bind values to variables. There are two ways you can use it:

- assign a value to a variable
- assign a variable to the result of the previous command

Let's look at the first case where you assign a value to a variable. You want to check if some variable's value is `none`. Call the `0x1::option::is_none` function from the Move standard library, and pass in the variable name:

```sh
$ sui client ptb \
--assign my_variable none \
--move-call 0x1::option::is_none "<u64>" my_variable \
--gas-budget 50000000
```

:::tip

CLI PTB uses name resolution for common packages like `sui`, `std`, `deepbook`, so you can use them directly instead of their addresses: `0x2`, `0x1`, or `0xdee9`.

:::

In the second case, if a previous command outputs some result, you can bound it to a variable for later access. Let's see an example where you want a new coin with 1000 MIST, which you can achieve by using the `split-coins` command. After you do that, you want to transfer the new coin to another address. Without the `--assign` argument, you couldn't instruct the CLI to transfer that new coin object as you would not have a way to refer to it.

```sh
$ sui client ptb \
--split-coins gas "[1000]" \
--assign coin \
--transfer-objects "[coin]" @recipient_address \
--gas-budget 50000000
```

:::tip

If you build a complex PTB, use the `--preview` flag to display the PTB transaction list instead of executing it.

:::

## Examples

The following examples demonstrate how to use the `client ptb` command.

:::tip

When a PTB is executed, the output contains all the relevant information (transaction data, gas cost, effects, object changes, and so on). Use `--summary` to get a short summary when you do not need all the data. For complex PTBs, you can use `--preview` to display the PTB transaction list instead of executing it.

:::

### Move call

When needing to execute a Move call, use the `--move-call` transaction to call a specific function from a package. The CLI PTB supports name resolution for common packages like `sui`, `std`, `deepbook`, so you can use both `0x1::option::is_none` as well as `std::option::is_none` for passing the function name.

```sh
--assign A none
--move-call std::option::is_none "<u64>" A
```

To call a specific function from a specific package, you can use the following call:

```sh
--move-call PACKAGE_ADDR::MODULE::FUNCTION "<TYPE>" FUNC_ARG1 FUNC_ARG2 ...
```

### Publish

Publishing a package is one of the most important commands you need when working with Sui. While the CLI has a standalone `publish` command, PTBs also support publishing and upgrading packages. One main difference is that with `sui client ptb`, you must explicitly transfer the `UpgradeCap` object that is returned when creating a package, or destroy it with a call to [`make_immutable`](/concepts/sui-move-concepts/packages.mdx). Here is an example on how to publish a Move project on chain using the `sui client ptb` command. It makes a call to the `sui::tx_context::sender` to acquire the sender and assigns the result of that call to the `sender` variable, and then calls the publish command. The result of `publish` is bounded to `upgrade_cap` variable, and then this object is transferred to the sender.

```sh
$ sui client ptb \
--move-call sui::tx_context::sender \
--assign sender \
--publish "." \
--assign upgrade_cap \
--transfer-objects "[upgrade_cap]" sender \
--gas-budget 100000000
```

### Split, destroy, and merge coins

The following example showcases how to split a gas coin into multiple coins, make a move call to destroy one or more of the new coins, and finally merge the coins that were not destroyed back into the gas coin. It also showcases how to use framework name resolution (for example, `sui::coin` instead of `0x2::coin`) and how to refer to different values in an array using the `.` syntax.

```sh
# Split off from gas
--split-coins gas "[0,1,2,3]"
--assign coins
--move-call sui::coin::destroy_zero<sui::sui::SUI> coins.0
# Can further split a split coin (and through variable bindings/result accesses)
--split-coins coins.1 "[0,0]"
--assign zcoins
# Destroy both new coins
--move-call sui::coin::destroy_zero<sui::sui::SUI> zcoins.0
--move-call sui::coin::destroy_zero<sui::sui::SUI> zcoins.1
# Can merge the split coins back
--merge-coins gas "[coins.1, coins.2, coins.3]"
--gas-budget 10000000
```

### Transfer objects

This example creates three new coins from gas and transfers them to a different address.

```sh
--assign to_address @0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331 \
--split-coins gas "[1,2,3]" \
--assign s \
--transfer-objects "[s.0, s.1, s.2]" to_address \
--gas-budget 10000000
```

:::info

You can also pass an alias (without the '@') instead of an address.

:::

## Reserved words

You cannot use the following words for variable names:

- `address`
- `bool`
- `vector`
- `some`
- `none`
- `gas`
- `u8`
- `u16`
- `u32`
- `u64`
- `u128`
- `u256`

## JSON output

Append the `--json` flag to commands to format responses in JSON instead of the more human-friendly default Sui CLI output. This can be useful for extremely large datasets, for example, as those results can have a troublesome display on smaller screens. In these cases, the `--json` flag is useful.

```

../../Downloads/sui-stuff/sui-main/docs/content/references/cli/move.mdx
```
---
title: Sui Move CLI
description: The Sui CLI move command provides commands for working with Move source code directly from a terminal or console.
---

The Sui CLI `move` command provides several commands for working with Move source code. A typical usage of `sui move` is to compile and test the Move code, or to generate a new Move project by using `sui move new project_name`, which creates the needed directories and the `Move.toml` file.

{@include: ../../snippets/cli-check-install.mdx}

## Commands

Typing `sui move --help` into your terminal or console displays the following information on available commands.

```
Usage: sui move [OPTIONS] <COMMAND>

Commands:
  build
  coverage 	  Inspect test coverage for this package. A previous test run with the `--coverage` flag must have previously been run
  disassemble
  manage-package  Record addresses (Object IDs) for where this package is published on chain (this command sets variables in Move.lock)
  migrate         Migrate to Move 2024 for the package at `path`. If no path is provided defaults to current directory
  new             Create a new Move package with name `name` at `path`. If `path` is not provided the package will be created in the directory `name`
  test     	  Run Move unit tests in this package
  help            Print this message or the help of the given subcommand(s)

Options:
  -p, --path <PACKAGE_PATH>                 	Path to a package which the command should be run with respect to
  -d, --dev                                 	Compile in 'dev' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used if this flag is set. This flag is useful for
                                            	development of packages that expose named addresses that are not set to a specific value
  	--test                                	Compile in 'test' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used along with any code in the 'tests' directory
  	--doc                                 	Generate documentation for packages
  	--abi                                 	Generate ABIs for packages
  	--install-dir <INSTALL_DIR>           	Installation directory for compiled artifacts. Defaults to current directory
  	--force                               	Force recompilation of all packages
  	--fetch-deps-only                     	Only fetch dependency repos to MOVE_HOME
  	--skip-fetch-latest-git-deps          	Skip fetching latest git dependencies
  	--default-move-flavor <DEFAULT_FLAVOR>	Default flavor for move compilation, if not specified in the package's config
  	--default-move-edition <DEFAULT_EDITION>  Default edition for move compilation, if not specified in the package's config
  	--dependencies-are-root               	If set, dependency packages are treated as root packages. Notably, this will remove warning suppression in dependency packages
  -h, --help                                	Print help
  -V, --version                             	Print version
```

## Examples

The following examples demonstrate some of the most often used commands.

### Create a new Move project

To create a new Move project that automatically adds the necessary dependencies in a `Move.toml` file, run `sui move new [<PROJECT-NAME>]`.

```sh
$ sui move new smart_contract_test
```
```sh
$ ls -l smart_contract_test
```
```sh
Move.toml
Sources
```
Display the contents of Move.toml file.

```sh
$ cat smart_contract_test/Move.toml
```

```sh
[package]
name = "smart_contract_test"
version = "0.0.1"

[dependencies]
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }

[addresses]
smart_contract_test = "0x0"
```

### Build a Move project

Use `sui move build` at the root of your Move project to build the package.

```sh
$ sui move build
```
```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING smart_contract_test
```

### Run tests in a Move project

Use `sui move test` to run the tests in a Move package.

```sh
$ sui move test
```
```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING smart_contract_test
Running Move unit tests
Test result: OK. Total tests: 0; passed: 0; failed: 0
```

### Get test coverage for a module


:::caution

This command currently only works on debug builds of the CLI.  Please build the CLI from source to use it.

:::


This example uses [`first_package`](https://github.com/MystenLabs/sui/tree/main/examples/move/first_package) Move package.

To get a summary of the test coverage, you must first run the `sui move test --coverage` command, and then the `sui move coverage summary --test` to get a summary of the test coverage in the example project.

```sh
$ sui move test --coverage
```
```sh
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING first_package
Running Move unit tests
[ PASS    ] 0x0::example::test_module_init
[ PASS    ] 0x0::example::test_sword_transactions
Test result: OK. Total tests: 2; passed: 2; failed: 0

$ sui move coverage summary --test
+-------------------------+
| Move Coverage Summary   |
+-------------------------+
Module 0000000000000000000000000000000000000000000000000000000000000000::example
>>> % Module coverage: 92.81
+-------------------------+
| % Move Coverage: 92.81  |
+-------------------------+
```

## Help

Each command has its own help section. For example `sui move build --help` displays the following prompt:

```sh
$ sui move build --help
```
```sh
Usage: sui move build [OPTIONS]

Options:
  -p, --path <PACKAGE_PATH>                     Path to a package which the command should be run with respect to
      --with-unpublished-dependencies           Include the contents of packages in dependencies that haven't been published (only relevant when dumping
                                                bytecode as base64)
      --dump-bytecode-as-base64                 Whether we are printing in base64
  -d, --dev                                     Compile in 'dev' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used if this flag is set. This
                                                flag is useful for development of packages that expose named addresses that are not set to a specific value
      --ignore-chain                            Don't specialize the package to the active chain when dumping bytecode as Base64. This allows building to
                                                proceed without a network connection or active environment, but it will not be able to automatically determine
                                                the addresses of its dependencies
      --generate-struct-layouts                 If true, generate struct layout schemas for all struct types passed into `entry` functions declared by modules
                                                in this package These layout schemas can be consumed by clients (e.g., the TypeScript SDK) to enable
                                                serialization/deserialization of transaction arguments and events
      --test                                    Compile in 'test' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used along with any code in
                                                the 'tests' directory
      --doc                                     Generate documentation for packages
      --install-dir <INSTALL_DIR>               Installation directory for compiled artifacts. Defaults to current directory
      --force                                   Force recompilation of all packages
      --fetch-deps-only                         Only fetch dependency repos to MOVE_HOME
      --skip-fetch-latest-git-deps              Skip fetching latest git dependencies
      --default-move-flavor <DEFAULT_FLAVOR>    Default flavor for move compilation, if not specified in the package's config
      --default-move-edition <DEFAULT_EDITION>  Default edition for move compilation, if not specified in the package's config
      --dependencies-are-root                   If set, dependency packages are treated as root packages. Notably, this will remove warning suppression in
                                                dependency packages
      --silence-warnings                        If set, ignore any compiler warnings
      --warnings-are-errors                     If set, warnings become errors
      --json-errors                             If set, reports errors at JSON
      --no-lint                                 If `true`, disable linters
      --lint                                    If `true`, enables extra linters
  -h, --help                                    Print help
  -V, --version                                 Print version
```

```

../../Downloads/sui-stuff/sui-main/docs/content/references/cli/cheatsheet.mdx
```
---
title: Sui CLI Cheat Sheet
---

The cheat sheet highlights common Sui CLI commands.

:::tip

<a href="/doc/sui-cli-cheatsheet.pdf" target="_blank" rel="noreferrer">Download sheet as PDF</a>

:::

## Addresses & Aliases

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui client active-address`</td>
			<td class="w-1/3">Get the active address</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client addresses`</td>
			<td class="w-1/3">List the addresses, their aliases, and the active address</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client new-address ed25519`</td>
			<td class="w-1/3">Create a new address with ED25519 scheme</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client new-address ed25519 MY_ALIAS`</td>
			<td class="w-1/3">Create a new address with ED25519 scheme and alias</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client switch --address ADDRESS`</td>
			<td class="w-1/3">Make this the active address (accepts also an alias)</td>
		</tr>
		<tr> 	
			<td class="w-2/3">`sui keytool convert PRIVATE_KEY`</td>
			<td class="w-1/3">Convert private key in Hex or Base64 to new format (Bech32 encoded 33 byte flag || private key starting with "suiprivkey")</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui keytool generate ed25519`</td>
			<td class="w-1/3">Generate a new keypair with ED25519 scheme and save it to file</td>
		</tr>
		<tr> 	
      <td class="w-2/3">`sui keytool import INPUT KEY_SCHEME`</td>
			<td class="w-1/3">Add a new key to Sui CLI Keystore using either the input mnemonic phrase or a Bech32 encoded 33-byte flag || privkey starting with "suiprivkey"</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui keytool update-alias OLD_ALIAS NEW_ALIAS`</td>
			<td class="w-1/3">Update the alias of an address</td>
		</tr>
	</tbody>
</table>

## Faucet & Gas

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui client faucet`</td>
			<td class="w-1/3">Get a SUI coin from the faucet associated with the active network</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client faucet --address ADDRESS`</td>
			<td class="w-1/3">Get a SUI coin for the address (accepts also an alias)</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client faucet --url CUSTOM_FAUCET_URL`</td>
			<td class="w-1/3">Get a SUI coin from custom faucet</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client gas`</td>
			<td class="w-1/3">List the gas coins for the active address</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client gas ADDRESS`</td>
			<td class="w-1/3">List the gas coins for the given address (accepts also an alias)</td>
		</tr>
	</tbody>
</table>

## Network Command Description

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui client active-env`</td>
			<td class="w-1/3">Get the active environment</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client envs`</td>
			<td class="w-1/3">List defined environments</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client new-env --rpc URL --alias ALIAS`</td>
			<td class="w-1/3">Create a new environment with URL and alias</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client switch --env ENV_ALIAS`</td>
			<td class="w-1/3">Switch to the given environment</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui genesis`</td>
			<td class="w-1/3">Bootstrap and initialize a new Sui network</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui start`</td>
			<td class="w-1/3">Start the local Sui network</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui-faucet`</td>
			<td class="w-1/3">Start a local faucet. Note this is a different binary</td>
		</tr>
	</tbody>
</table>

## Create, Build, and Test a Move Project

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui move build`</td>
			<td class="w-1/3">Build the Move project in the current directory</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui move build --path PATH`</td>
			<td class="w-1/3">Build the Move project from the given path</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui move migrate PATH`</td>
			<td class="w-1/3">Migrate to Move 2024 for the package at provided path</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui move new PROJECT_NAME`</td>
			<td class="w-1/3">Create a new Move project in the given folder</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui move test`</td>
			<td class="w-1/3">Test the Move project in the current directory</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui move test --trace-execution`</td>
			<td class="w-1/3">Create an execution trace for the Move tests in the current directory. Use with the [Move Trace Debugger](https://marketplace.visualstudio.com/items?itemName=mysten.move-trace-debug) extension.</td>
		</tr>
	</tbody>
</table>

## Executing Transactions

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui client call \`<br/>&nbsp;&nbsp;`--package PACKAGE \`<br/>&nbsp;&nbsp;`--module MODULE \`<br/>&nbsp;&nbsp;`--function FUNCTION`</td>
			<td class="w-1/3">Call a Move package</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client merge-coin \`<br/>&nbsp;&nbsp;`--primary-coin COIN_ID \`<br/>&nbsp;&nbsp;`--coin-to-merge COIN_ID`</td>
			<td class="w-1/3">Merge two coins</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client split-coin \`<br/>&nbsp;&nbsp;`--coin-id COIN_ID \`<br/>&nbsp;&nbsp;`--amounts 1000`</td>
			<td class="w-1/3">Split a coin into two coins: one with 1000 MIST and the rest</td>
		</tr>
		<tr>
			<td class="w-2/3">
				`sui client pay-sui \`<br/>&nbsp;&nbsp;`--input-coins COIN_ID \`<br/>&nbsp;&nbsp;`--recipients ADDRESS \`<br/>&nbsp;&nbsp;`--amounts 100000000`
			</td>
			<td class="w-1/3">Transfer 0.1 SUI to an address and use the same coin for gas</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client transfer-sui \`<br/>&nbsp;&nbsp;`--sui-coin-object-id COIN_ID \`<br/>&nbsp;&nbsp;`--to ADDRESS`</td>
			<td class="w-1/3">Transfer SUI object to an address and use the same coin for gas</td>
		</tr>
	</tbody>
</table>

## Programmable Transaction Blocks (PTBs)

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui client ptb --move-call p::m::f "<type>" args`</td>
			<td class="w-1/3">Call a Move function from a package and module</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client ptb --make-move-vec "<u64>" "[1000,2000]"`</td>
			<td class="w-1/3">Make a Move vector with two elements of type u64</td>
		</tr>
		<tr>
			<td class="w-2/3">
				`sui client ptb \`<br/>&nbsp;&nbsp;`--split-coins gas "[1000]" \`<br/>&nbsp;&nbsp;`--assign new_coins \`<br/>&nbsp;&nbsp;`--transfer-objects
				"[new_coins]" ADDRESS`
			</td>
			<td class="w-1/3">Split a gas coin and transfer it to address</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client ptb --transfer-objects "[object_id]" ADDRESS`</td>
			<td class="w-1/3">
				Transfer an object to an address. Note that you can pass multiple objects in the array
			</td>
		</tr>
		<tr>
			<td class="w-2/3">
				`sui client ptb \`<br/>&nbsp;&nbsp;`--move-call sui::tx_context::sender \`<br/>&nbsp;&nbsp;`--assign sender \`<br/>&nbsp;&nbsp;`--publish "." \`<br/>&nbsp;&nbsp;`--assign
				upgrade_cap \`<br/>&nbsp;&nbsp;`--transfer-objects "[upgrade_cap]" sender`
			</td>
			<td class="w-1/3">Publish a Move package, and transfer the upgrade capability to sender</td>
		</tr>
	</tbody>
</table>

```

../../Downloads/sui-stuff/sui-main/docs/content/references/contribute/mdx-components.mdx
```
---
title: MDX Components
draft: true
---

Sui Docs uses the MDX format for its network documentation, which allows [JSX in markdown content](https://mdxjs.com/). Sui uses features provided by Docusaurus, plugins from its community, and custom plugins in an effort to improve reader experience. None of these features are required in your markdown contributions to the Sui documentation, but the Sui community might include them if it improves experience.

## Custom frontmatter

The frontmatter at the top of MDX pages provides context for the current topic. The only frontmatter entry required at the time of riting is `title`. In addition to the standard frontmatter entries available, the following custom items are useful for certain topic types.

### beta

Including the `beta` entry applies a box to the top of the topic that informa the reader of the beta status of the feature or service described. Possible values include `true` for a standard box, or a list of environments the feature or service is available in (`devnet`, `testnet`, `mainnet`) to include that information in the note.

**Example:**

```
---
title: Page title
description: A page of info describing a beta feature.
beta: devnet, testnet
---
```

### effort

The `effort` option is used for end-to-end guides. Including this entry places a box at the top of the guide to let the reader know what kind of effort is required to complete the guide. Available values are `small`, `medium`, `large`.

**Example:**
```
---
title: A Guides
description: A guide on how to do this thing in Sui.
effort: medium
---
```

## Custom admonition boxes

Beyond the default admonition boxes that Docusaurus offers (info, note, warning, danger), the following are also available.

### Checkpoint

The `:::checkpoint` admonition box is used in end-to-end guides to provide the status of the project that the current guide is walking through. The idea is that if their own work fails the checkpoint, then they know where things went wrong rather than getting to the end of the guide with a broken example.

**Example:**

```
:::checkpoint

Run your app and make sure you can:

- Create an NFT.
- Initiate a trade.

:::
```

## Tabs

`Tabs` and child `TabItem` elements allow for the segmentation of content so that users see only the content that is relevant to them. Sui documentation uses the default Docusaurus tab components. Check the [official documentation](https://docusaurus.io/docs/next/markdown-features/tabs) for all available options.  

### When to use

Use tabs to divide repetitive content that doesn't typically apply to all audiences. Operating system or language specific content are the most ubiquitous examples. Most users are not going to be interested in Rust AND TypeScript instruction, or Windows AND Linux content. Tabs can produce a more focused page that includes only the information the reader cares about. If you use the `groupId` attribute, you can persist user selection across pages and sessions so the reader doesn't have to click the same tab on different pages or select again when revisiting pages.        

### How to use

To create a tabbed section:

1. Add the `<Tabs>` element where you want the tabbed content to go. Include the optional `groupId` property if there are other `Tabs` with the same selections. For example, `<Tabs groupId="operating-systems">` persists users' selections across other `Tabs` with the same `groupId` value.
1. Add a `<TabItem>` element for each section of content as a child of the `Tabs` element. Each `TabItem` needs both `value` and `label` property values. If you're using `groupId` in the parent `Tabs`, make sure the `value` value remains consistent across `TabItem`s that are intended to show the same type of information.
1. Close each `</TabItem>` and the parent `</Tabs>`.
1. Check your page in the Vercel preview of your PR (`sui-core` preview link in Vercel comment) to make sure the content displays as expected.

**Example:**
```
<Tabs groupId="operating-systems">

<TabItem value="linux" label="Linux">

Whatever content is in here is only displayed when the user selects the **Linux** tab.

</TabItem>

<TabItem value="macos" label="MacOS">

Whatever content is in here is only displayed when the user selects the **MacOS** tab.

</TabItem>

<TabItem value="windows" label="Windows">

Whatever content is in here is only displayed when the user selects the **Windows** tab.

</TabItem>

</Tabs>
```

<Tabs groupId="operating-systems">

<TabItem value="linux" label="Linux">

Whatever content is in here is only displayed when the user selects the **Linux** tab.

</TabItem>

<TabItem value="macos" label="MacOS">

Whatever content is in here is only displayed when the user selects the **MacOS** tab.

</TabItem>

<TabItem value="windows" label="Windows">

Whatever content is in here is only displayed when the user selects the **Windows** tab.

</TabItem>

</Tabs>

:::info

The empty newlines between each opening and closing element in the example are important.

:::

## Snippets

Snippets are short pieces of reusable text. This feature uses the Docusaurus community provided [docusaurus-plugin-includes](https://github.com/simologos/docusaurus-plugin-includes) plugin. The `docs/content/snippets` folder contains all the reusable content. Pages in that directory do not appear in the ToC and are hidden from search engines. Upon build, the process deletes the folder so the content doesn't get rendered to the final site as it's own page.

### When to use

Use a snippet for content that appears in more than one place. Snippets are typically a paragraph or smaller. Tables of data, technology requirements, and other information relevant to more than one topic or audience are good candidates to create as snippets (especially if the information is likely to change). If you want to use a snippet for longer form content, consider just using a hyperlink instead.

The use of snippets reduces maintenance effort because one edit updates the content wherever it appears. It also doesn't require the reader to leave the current page to get necessary information, as a hyperlink does.

### How to use

To create and use snippets:

:::info

You do not need to `import` a component to use snippets.

:::

1. Create an .mdx file in the `docs/content/snippets` folder with the content you want to use in different locations. Do not include frontmatter in the file, just markdown content. Frontmatter is the content between `---` at the top of doc source pages.  
1. In the document where you want to include the content from the snippet, add the `{@include}` directive with a relative location of the file. 

    `{@include: ../../snippets/reusable.mdx}`

1. Repeat the previous step for all locations the content should appear. Be sure to update the relative location of the snippet based on where the file containing the directive exists in the repo.
1. Check each page in the Vercel preview of your PR (`sui-core` preview link in Vercel comment) to make sure the content displays. If the relative link you provide does not resolve correctly, the page displays error text instead of the expected content.

:::warning

Do not use links relative to the file structure in snippets (for example, `../concepts/file.mdx`). If your snippet requires a link internal to the Sui docs site, use the relative HTML path instead (`/concepts/file`). 

:::

## Code inject

Sui documentation uses a custom Docusaurus plugin to include code from the Sui repo in its pages. The plugin is based on the docusaurus-plugin-includes plugin used for [snippets](#snippets). 

### When to use

In an active repo, source code changes frequently. If you copy and paste that source code in a document, then the two sources can diverge quickly and drastically. In Sui Docs, you can use the `{@inject}` directive to make a copy of the source when the site builds (merge PR), ensuring the source used in the content always matches the source code in the repo. If the code you inject is tested, this directive ensures the code in your document is also tested.

#### Considerations

The effective use of `{@inject}` often requires code comments in the source file. You might need to balance the granularity of your documentation with the amount of comment chatter your documentation efforts might create.

When including sections of code, understand that the code might change from what you reference during document creation to what a reader eventually consumes. Assume other processes will update the accompanying content, but be mindful of the possibility of changing code when considering the level of detail in your instruction. You can take comfort in the knowledge that the code is always valid, though.

### How to use

To include the entire source file, use the `{@inject}` directive with a path to the file, based on the Sui repo root. For example, to include the source file at `sui/examples/move/hero/sources/example.move`, write `{@inject: examples/move/hero/sources/example.move`. The file location is automatically used as the title for the codeblock.

You can use source code from other GitHub repositories, but should do so sparingly and purposefully. There is almost no way to track those projects to ensure the code is valid, unlike the CI processes running on the sui repo. To use, format the directive as `{@inject: github:<GITHUB_ORG_NAME>/<GITHUB_REPO_NAME>/<PATH_TO_FILE>}`.

#### Include part of code

To include only sections of code, add an ID to identify the section, function, struct, or module. The ID is used in the directive syntax and in source code comments. The following sections provide examples of different uses and how to format them.

#### Include a Move section

:::info

This approach is a work in progress and there are certain formatting situations that prevents their use. In those cases, use the `docs://#id` approach instead.

:::

You can include specific sections of Move code using the following constructs appended to the end of the code directory. You can uses a comma delimited list for functions, structs, and variables to include each in the same codeblock:
- Module: #module=MODULE::NAME
- Function: #fun=FUNCTION_NAME,ANOTHER_FUNCTION
- Struct: #struct=STRUCT_NAME,ANOTHER_STRUCT
- Variables: #var=variableName, anotherVariable
- Move import: #use=LIBRARY::NAME
- React component: #component=ComponentName
- Type declaration: #type=TypeName
- Enum declaration: #enum=EnumName

For example, `{@inject: examples/move/example.source#fun=buy_sword}`

#### Include linear parts of code

If you want to include a complete section of code, use a descriptive ID in the document and source file. 

1. In your document, add the directive to the file with the ID appended. The build process replaces this line with the referenced code, so place where the code should appear.
    `{@inject: examples/foo/bar.move#IDstring}`
1. In the source file, add a comment where the section should begin in the form `// docs::#ID`.
    ```ts
    // docs::#IDstring

    import lib from "library";
    ...
    ```
1. In the source file, add a comment where the section should end in the form `// docs::/#ID`.
    ```ts
    // docs::#IDstring

    import lib from "library";
    ...
    return book;

    // docs::/#IDstring
    ...
    ```

#### Add closing syntax

When including linear sections of code, you sometimes want only the first part of a code source. Often, this requires placing the end directive (`// docs::/#ID`) before the closing syntax of the code source. To display closing syntax for well-formed code in the document, append the necessary syntax to the end directive.

For example,

```ts
// docs::#funcBasic
function func(){ 
    const basic = () => {
        const basic2 = () => {};
        // docs::/#funcBasic};}
        const inter = () => {};
    };
    const advanced = () => {};
}
```

displays as

```
function func(){
    const basic = () => {
        const basic2 = () => {};
    };
}
        
```

#### Include nonlinear parts of code

:::info

Consider restructuring your document before using this approach. This feature is useful in some situations, but it increases the comment chatter in the source file.

:::

If you don't want to include a section of code, but instead focus on the code around it in a single doc instance, you can pause the injection with a source code comment in the form `// docs::#ID-pause`. A second comment in the form `// docs::#ID-resume` continues the injection.

1. In your document, add the directive to the file with the ID appended. The build process replaces this line with the referenced code, so place where the code should appear.
    &#123;`@inject: examples/foo/bar.move#IDstring`
1. In the source file, add a comment where the section should begin in the form `// docs::#ID`.
    ```ts
    // docs::#IDstring

    import lib from "library";
    ...
    ```
1. In the source file, add a comment where the injection should pause and where it should resume. Optionally, append a colon and replacement text to the pause directive. The replacement text displays in the document instead of the code.   
    ```ts
    // docs::#IDstring

    import lib from "library";
    ...
    // docs::#IDstring-pause:TODO

    const Advanced = () => {};

    // docs::#IDstring-resume
    ```
1. In the source file, add a comment where the injection should end. 
    ```ts
    // docs::#IDstring

    import lib from "library";
    ...
    // docs::#IDstring-pause:// TODO

    const Advanced = () => {};
    ...

    // docs::#IDstring-resume

    return book;

    // docs::/#IDstring
    ...
    ```

The final result in the document from these steps is:

```ts
import lib from "library";
...

// TODO

return book;
```

#### Options

You can include a space-limited list of options after the @inject call. The following options are supported:
- `noComments`: Remove comments from Move code.
- `noTests`: Remove tests from captured section of code.
- `noTitle`: Don't place a hyperlinked title at the top of the code block.
- `singleSpace`: If the code source has spurious whitespace, use this option to display code without extra spaces between lines. Useful when the code uses extra blank lines for readability. 

For example, `{@inject: examples/move/example.source#module=example::example noComments noTests noTitle singleSpace}`


## Mermaid graphs

Mermaid graphs are text-based [Mermaid.js](https://mermaid.js.org) diagrams. Mermaid has native support in Docusaurus.

### When to use

Any graph you want to include should use Mermaid. Flowchart and sequence diagram types are particularly useful. Support for newer graph types are dependent on the Docusaurus implementation and might not render correctly. 

The reason for using Mermaid is to allow anyone, anywhere the ability to update or augment information for visual assets without needing separate imaging software or source files.

### How to use

To create a mermaid graph, place the code inside tick fencing with `mermaid` defined as the language. You do not need to import anything into your document. 

The following code

    ```mermaid
    flowchart LR
        CC(CLI Client) --> ClientService
        RC(Rest Client) --> ClientService
        RPCC(RPC Client) --> ClientService
        ClientService --> AuthorityAggregator
        AuthorityAggregator --> AC1[AuthorityClient] & AC2[AuthorityClient]
        subgraph Authority1
        AS[AuthorityState]
        end
        subgraph Authority2
        AS2[AuthorityState]
        end
        AC1 <==>|Network TCP| Authority1
        AC2 <==>|Network TCP| Authority2
    ```

produces

```mermaid
flowchart LR
    CC(CLI Client) --> ClientService
    RC(Rest Client) --> ClientService
    RPCC(RPC Client) --> ClientService
    ClientService --> AuthorityAggregator
    AuthorityAggregator --> AC1[AuthorityClient] & AC2[AuthorityClient]
    subgraph Authority1
      AS[AuthorityState]
    end
    subgraph Authority2
      AS2[AuthorityState]
    end
    AC1 <==>|Network TCP| Authority1
    AC2 <==>|Network TCP| Authority2
```

## YouTube player with thumbnail carousel

Displays a list of YouTube thumbnails and provides a player for the currently selected video.

### When to use

Use when you have three or more YouTube videos. You could use with as few as one but there is currently not a way to turn off the carousel so would look weird.

### How to use

Because there are not many videos on the site, you need to import the component on the page in which you're using it.

`import YTCarousel from "@site/src/components/YTCarousel"`

The import statement can go anywhere, but it's typically added to the top of the page. Then use the component by providing an array of YouTube video IDs. Sui videos should not have this problem, but be aware that videos might not have thumbnails like in the example.

`<YTCarousel ids={["youtubeID1","youtubeID2","youtubeID3",...]}/>`

import YTCarousel from "@site/src/components/YTCarousel"

<YTCarousel ids={["dQw4w9WgXcQ","EwTZ2xpQwpA","1TewCPi92ro"]}/>

```

../../Downloads/sui-stuff/sui-main/docs/content/references/contribute/contribution-process.mdx
```
---
title: Contribute to Sui Documentation
sidebar_label: Docs Contribution
description: Help the Sui community through documentation contributions. Whether its to fix errors or add new content, the entire Sui community benefits from your contributions.
---

As open source software, Sui depends on community contributions. This page covers the process for contributing to Sui's documentation.

To make changes to the documentation, you can fork and clone the Sui repository to your local machine and make changes from your preferred IDE of choice, or by the web interface on GitHub. This guide covers both scenarios.

## Style guide compliance

All changes to the documentation must follow the [style guide](./style-guide.mdx), as well as the review process and information on the editors throughout the process. Do not be offended by the number of change requests your docs PR might receive. This is not a reflection on your writing abilities, but an effort to keep a consistent tone across the documentation set. Depending on reviewer and workload, some reviews are more thorough than others. After your PR merges, your content might be changed at a later date to align better with Sui writing standards.

To create more engaging content, be sure to follow these rules in particular:

- Always prefer [active voice](./style-guide.mdx#active-voice).
- [Present tense](./style-guide.mdx#present-tense) verbs are almost always the right choice.
- Be [concise](./style-guide.mdx#general-considerations). Use only the words strictly necessary to convey an idea.

## Set up local environment {#local-environment}

Cloning the documentation locally is recommended when you are creating larger, more significant changes to the docs. See [Sui Environment Setup](./sui-environment.mdx) for instructions on forking the Sui repository, if necessary. The documentation is in the `docs/content` directory.

1. If you are using the recommended Visual Studio Code IDE, install [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) to ensure that your formatting is consistent.
1. After you make all your changes, stage all files with changes (`git add .` to add all modified files), create a local commit (`git commit -m “message”`), and then push all your changes to your forked repository (`git push`).
1. To view your changes via `localhost`, enter `pnpm install` into a terminal at the `docs/site` directory to install dependencies, then `pnpm start` to view the changes on `localhost:3000` to ensure that the website works as intended. You might need to [install the `pnpm` package manager](https://pnpm.io/installation) if you don't already have it.

## For beginners {#for-beginners}

Editing the documentation via the GitHub web interface is recommended if you are not familiar with working in an IDE, or for smaller changes and fixes.

**Add New Page**

Navigate to the `docs/content` directory, then navigate to the appropriate subdirectory and click the `Add file` button in the top-right. Select `create new file` to create a new file and edit it directly on GitHub's web interface.

**Change Existing Page**

To change an existing page, navigate to the file you want to edit, click on the pencil icon in the top-right, and edit your changes there.

## Review process {#review-process}

When you are finished creating your changes in your own fork or using the web interface, submit a PR to the Sui repository. When you do so, you can view the deployment on Vercel and double-check that everything behaves the way you intend. For every unique commit in a PR, Vercel generates a new preview. A reviewer then takes responsibility for providing clear and actionable feedback to your PR. As the owner of the PR, it is your responsibility to modify your PR to address the feedback that has been provided to you by the reviewer. Keep in mind that you may receive feedback from multiple reviewers. After a reviewer has approved your PR, it is merged into `main` and your contributions are made public.

```

../../Downloads/sui-stuff/sui-main/docs/content/references/contribute/contribute-to-sui-repos.mdx
```
---
title: Contribute to Sui Repositories
slug: /contribute-to-sui-repos
---

This page describes how to contribute to Sui, and provides additional information about participating in the Sui community.

## Join the community {#join-the-community}

To connect with the Sui community, join our [Discord](https://discord.gg/sui).

## Open issues {#open-issues}

To report an issue with Sui, [create an issue](https://github.com/MystenLabs/sui/issues/new/choose) in the GitHub repo. Click **Get started** to open a template for the type of issue to create.

## Fork Sui to contribute {#fork-sui-contribute}

To contribute to Sui source code or documentation, you need only a GitHub account. You can commit updates and then submit a PR directly from the Github website, or create a fork of the repo to your local environment and use your favorite tools to make changes. Always submit PRs to the `main` branch.

See [Sui Environment Setup](./sui-environment.mdx) for instructions on forking the Sui repository, if necessary.

## Contribute via the Sui Improvement Proposal (SIP) process {#SIP}

The Sui Network is an open-source, decentralized, and permissionless protocol that welcomes community contributions. If you have an idea regarding a core protocol upgrade, the best way to make your voice heard is via submitting a Sui Improvement Proposal (SIP). For more information on SIPs, see [Contribute to Sui through SIPs](https://blog.sui.io/sui-improvement-proposals-sips/).


```

../../Downloads/sui-stuff/sui-main/docs/content/references/contribute/style-guide.mdx
```
---
title: Style Guide
slug: /style-guide
---

This document defines the styles, vocabulary usage, and content formatting for Sui documentation. Entries are in alphabetical order. A style guide is never finished. Expect continued iterations to add additional styles, additional information to existing styles, and infrequently a change to an existing style.

## Accessibility {#accessibility}

Reference works for making content accessible:

- [A11Y Style Guide](https://a11y-style-guide.com/style-guide/)
- [Bitsofcode Accessibility Cheatsheet](https://bitsofco.de/the-accessibility-cheatsheet/)
- [Atlassian Design System - Inclusive writing reference](https://atlassian.design/content/inclusive-writing)
- [MailChimp's writing style guide](https://styleguide.mailchimp.com/writing-for-accessibility/)
- [Microsoft Style Guide Accessibility Terms](https://learn.microsoft.com/en-us/style-guide/a-z-word-list-term-collections/term-collections/accessibility-terms)
- [Writing for All Abilities](https://learn.microsoft.com/en-us/style-guide/accessibility/writing-all-abilities) (Microsoft Style Guide)

### Formatting {#formatting}

Don't use color or special symbols to add emphasis to text. Screen readers are designed to interpret bold (`<strong>`) and italic (`<em>`) in web pages.

### Images {#images}

Add captions and alt text that describe the image for someone using a screen reader. What are the important details in the image that someone using a screen reader can't see?

Use alt text to describe what the image shows. Use the caption to explain why the image is meaningful in the context of the page.

An image is not a substitute for text; images should only supplement text. Do not rely on an image to convey information not in text form. For example, an image of a table of values does no one any good if the image fails to display for a host of possible reasons.

## Acronyms {#acronyms}

Spell out a term or phrase on first use in a topic, followed by the acronym in parentheses. Then use the acronym for subsequent mentions.

**Example**

> You can mint non-fungible tokens (NFTs) using your Sui Wallet. To view an NFT after you mint it, click the NFTs tab of your wallet.

## Alerts {#alerts}

Alerts add emphasis to information. Use Admonitions, a Docusaurus feature, to indicate the alert is a Note, Tip, or Caution. The explanation in the alert must be a complete sentence and use sentence case.

### Note {#note}

Use Note to add emphasis to information that the reader should know, but could be overlooked when scanning a topic or document. Provide information that prevents users from getting stuck.

<Tabs>
<TabItem value="example" label="Example" default>

:::note

The system processes updates only once every 24 hours at UTC 00:00.

:::

</TabItem>
<TabItem value="markdown" label="Markdown">

```
:::note

The system processes updates only once every 24 hours at UTC 00:00.

:::

```

</TabItem>
</Tabs>

### Tip {#tip}

Use Tip to give the reader advice that might be helpful, such as a best practice.

<Tabs>
<TabItem value="example" label="Example" default>

:::tip

Change your home directory after installing the IDE.

:::

</TabItem>
<TabItem value="markdown" label="Markdown">

```

:::tip

Change your home directory after installing the IDE.

:::

```

</TabItem>
</Tabs>

### Caution {#caution}

Use Caution when the information could cause the user to lose data or to start over. If you instruct a user to delete something, warn them about what happens when they delete it.

<Tabs>
<TabItem value="example" label="Example" default>

:::caution

Backup your configuration files before you delete your network.

:::

</TabItem>
<TabItem value="markdown" label="Markdown">

```

:::caution

Backup your configuration files before you delete your network.

:::

```

</TabItem>
</Tabs>

## Capitalization {#capitalization}

**Do:**

Use sentence capitalization for section headings, table cells/headers, list items, captions, alt text, and error messages.

Capitalize proper nouns. [Proper nouns](#proper-nouns).

Always capitalize the first word of a new sentence, even when the word is normally lower case, such as Web3 vs web3.

**Don't:**

Don't use all uppercase for emphasis, use bold instead. (IMPORTANT vs Important)

Don't use bi-capitalization / internal capitalization unless it is part of a brand, such as YouTube or DreamWorks.

Don't capitalize the spelled-out form of an acronym unless it's a proper noun, such as HyperText Markup Language (HTML).

When words are joined by a slash, capitalize the word after the slash if the word before the slash is capitalized.

**Example**

> Country/Region

> Turn on the On/Off toggle.

### Title capitalization {#title-capitalization}

For title capitalization, follow these guidelines:

- Don't capitalize a, an, and, but, for, in, or, so, to, with, yet , or other short conjunctions and prepositions unless it's the first or last word
- Capitalize all other words (including Is and Be as they are verbs)
- Capitalize the word after a hyphen
- Match casing for commands or special terms, such as cURL or dApp.
- Match the casing for API elements and programming language keywords

## Code {#code}

Use inline code in a sentence to refer to functions and other code pieces. Use codeblocks to show larger sections of a program. All code should be written exactly as it appears in a code editor, so that other people can copy and paste it from documentation directly into a code editor. Do not use images to show code.

### Inline code {#inline-code}

Use backticks (\`) around individual code within a sentence, which will format it as code in markdown. Do not use quotes, emphasis, or any other formatting to distinguish code from surrounding text.

<Tabs>
<TabItem value="example" label="Example" default>

> The `display::new<T>` call creates a `Display`.

</TabItem>
<TabItem value="markdown" label="Markdown">

```

The `display::new<T>` call creates a `Display`.

```

</TabItem>
</Tabs>

### Codeblocks {#codeblocks}

Use the text before a codeblock to describe what the codeblock does. Use text after the codeblock to point out particular elements in the code and how they work. Do not use codeblocks as a substitute for descriptive text. Codeblocks help readers understand descriptive text in the documentation.

Initiate a codeblock in markdown with three backticks (\`\`\`).

**Example**

```
module sui::display {
/// Sets multiple fields at once
public fun add*multiple(
self: &mut Display,
keys: vector`<String>`,
values: vector`<String>`
) { /* ... \*/ }
```

## Grammar {#grammar}

### Active voice {#active-voice}

Use Active voice whenever possible. Active voice is direct, clear, and uses fewer words. Passive voice is often less clear, awkward, and uses more words.

**Example**

> **Active:** She installed the software.

> **Passive:** The software was installed by her.

### Verbs {#verbs}

Use present tense verbs with the appropriate mood.

There are three grammatical moods:

- **Indicative –** used to deliver facts
- **Imperative –** used to provide directions
- **Subjunctive –** used to convey a wish or possibility

#### Verb moods {#verb-moods}

Use indicative verbs most of the time in conceptual content.

Use imperative verbs for tasks, procedures, and instructions.

**Example**

- **Indicative –** Sui network explorers display transactions on the network.
- **Imperative –** Open a Sui network explorer to view transactions on the network.
- **Subjunctive –** We suggest that you view your transaction in a Sui network explorer after you complete a transfer.

### Person {#person}

Use second person in most cases.

**Example**

> You used to could view transaction history in Sui Explorer.

**Rather than:**

> We used to could view transaction history in Sui Explorer.

### Present tense {#present-tense}

Use present tense whenever possible. Use future tense (something will happen) only for events that occur on a future date, such as a product release or trade show.

Do not use future tense when describing a product, or providing guidance in tasks. From the user perspective, it is the present for them when they follow the steps in a task. Consider the example of saving a file.

**Example present tense**

> Click Save to save the updated file.

> When you click Save, your device writes the changes to disk.

> To save a file after you modify it, click Save.

**Example future tense**

> Your changes will be saved when you click Save.

While this is technically accurate, it separates the person from the object of the action. This makes it more difficult to parse the sentence for ESL speakers, and is harder to localize.

> When you click Save, the file will be written to disk.

In this example, when will the file be written to disk? It happens immediately upon clicking Save. If you check the timestamp on the file, the time reflects the moment at which you clicked Save, not a time after that moment.

### Oxford / serial commas {#oxford-serial-commas}

Do use serial commas.

**Example**

> Rachael Ray finds inspiration in cooking, her family and her dog.

**It is much more clear to use:**

> Rachael Ray finds inspiration in cooking, her family, and her dog.

**Example**

> You must install Cargo, Rust, Docker, and the Sui CLI to create a Sui node.

## Headings and titles {#headings-titles}

Use descriptive titles that include keywords to help readers find the information. Use shorter titles in the navigation pane.

### Optimize for discoverability {#optimize-discoverability}

Use enough words in headings and titles to make it easy to know which link to click on a search results page. One word titles (Installing) do not provide enough information to determine the contents of a topic.

### Topic titles {#topic-titles}

Users search for information to complete a specific task, so help them identify the topic that helps them by using descriptive titles. For example, _Get Started_. Get started with what? If there are multiple products or programs available it could be anything.

_Get Started with Sui_ is better, but users want to get started with a specific task or user journey with Sui. Instead of _Get Started with Sui_, describe the specific task or journey, such as _Create a Sui Full Node_ or _Sui Validator Guide_. Use Get Started as a heading on the Documentation landing page to categorize tasks for new users.

<Tabs>
<TabItem value="example" label="Example" default>

> This is a Topic Title

</TabItem>
<TabItem value="markdown" label="Markdown">

```

## title: This is a Topic Title

```

</TabItem>
</Tabs>

### Section headings {#section-headings}

Use sentence casing for section headers.

<Tabs>
<TabItem value="example" label="Example" default>

> This is a section heading

</TabItem>
<TabItem value="markdown" label="Markdown">

```

## This is a section heading

```

</TabItem>
</Tabs>

### Code elements in section headings

Do not use code styling in section headings. Instead, use regular font in the heading and code styling in the content.

**Example:**

```
## ObjectName

`ObjectName` is an object.
```

## Images / Graphics {#images-graphics}

Only use images and screenshots to supplement and help explain text. Images do not replace text. Readers should be able to understand the documentation without the images. However, images can help readers understand the text more clearly.

### Image format {#image-format}

Use .png when possible, otherwise use .jpg

### Image resolution {#image-resolution}

Images should be at least 400 pixels wide. If an image looks blurry when uploaded, try making a new image in higher resolution.

### Captions {#captions}

Use alt text to describe what the image shows. Use the caption to explain why the image is meaningful in the context of the page.
See Accessibility considerations for captions.

### Mermaid for images in Markdown {#mermaid}

You can create flowcharts and similar images directly in Markdown.

[https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/](https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/)

Use [Snagit](https://www.techsmith.com/screen-capture.html) or other tools to capture screenshots.

## Lists {#lists}

Use a list for a series of items or steps instead of writing them as a sentence. Introduce the list with a description of the list elements ending in a colon (:).

**Instead of:**

The Build section of the documentation includes topics about: Building with Sui, Using the CLI to Start a Network, Creating Smart Contracts, Sui Tutorial, and Sui Examples.

**Use:**

The Build section of the documentation includes the following topics:

- Building with Sui
- Using the CLI to Start a Network
- Creating Smart Contracts
- Sui Tutorial
- Sui Examples

### Numbered or ordered lists {#numbered-ordered-lists}

Use a numbered list when:

- the items in the list must be performed in a specific order, such as the steps in a task
- the items in the list describe a sequence of events, such as a workflow or scenario

<Tabs>
<TabItem value="example" label="Example" default>

1. Create a fork of the repo.
1. Clone your fork of the repo.
1. Install Sui.

</TabItem>
<TabItem value="markdown" label="Markdown">

```

1. Create a fork of the repo.
1. Clone your fork of the repo.
1. Install Sui.

```

</TabItem>
</Tabs>

### Bulleted lists {#bulleted-lists}

Use bulleted lists to list more than two pieces of related information, such as links or terms, that don't need to be in a specific order. Optionally, use a bulleted list for only two items to include a description of the items in the list. Use sentence capitalization in lists, and use punctuation consistently for all list items. Do not use an ending period unless the list item includes a full sentence.

<Tabs>
<TabItem value="example" label="Example" default>

Sui Explorer used to support the following browsers:

- Firefox version X or later
- Chrome version X or later
- Edge version X or later

</TabItem>
<TabItem value="markdown" label="Markdown">

```

Sui Explorer used to support the following browsers:

- Firefox version X or later
- Chrome version X or later
- Edge version X or later

```

</TabItem>
</Tabs>

### Term list {#term-list}

Use a term list to define terms or concepts.

<Tabs>
<TabItem value="example" label="Example" default>

> **Term:** A description of the term.

> **DAG:** A directed acyclic graph (DAG) is a data modeling or structuring tool typically used in data architectures.

</TabItem>
<TabItem value="markdown" label="Markdown">

```

**Term:** A description of the term.
**DAG:** A directed acyclic graph (DAG) is a data modeling or structuring tool typically used in cryptocurrencies.

```

</TabItem>
</Tabs>

### Capitalization in lists {#capitalization-in-lists}

Use initial / sentence capitalization in list items.

<Tabs>
<TabItem value="example" label="Example - bulleted lists" default>

- First list item
- Second list item

</TabItem>
<TabItem value="markdown" label="Markdown">

```

* First list item
* Second list item

```

</TabItem>
</Tabs>

<Tabs>
<TabItem value="example" label="Example - numbered lists" default>

1. First list item
1. Second list item

</TabItem>
<TabItem value="markdown" label="Markdown">

```

1. First list item
1. Second list item

```

</TabItem>
</Tabs>

## Numbers {#numbers}

### Numerals vs. words {#numerals-vs-words}

Write out numbers less than 10

**Example**

> The folder contains seven files.

Use digits for larger numbers.

**Example**

> The folder contains 24 files.

In body text, use numbers consistently if using both numbers less than and greater than 10.

**Example**

> One folder contains 7 files, and the other contains 24 files.

For ease of reading, use both words and numbers when you use two numbers for different things together.

**Example**

> The folder contains twenty 12-page documents.

Don't start a sentence with a numeral. Instead, add a qualifier or spell out the number.

**Example**

> At least 20 pieces of candy fell off the table.

> Twenty pieces of candy melted.

Measurements should be written as numerals.

**Example**

> The server processes 2 terabytes of data in 8 milliseconds.

## Links {#links}

Always use relative links when linking to topics on docs.sui.io.

Include the `.mdx` extension when creating internal links so that they also work from the source file in GitHub.

Use the topic title of the target topic as the link text for the link in a list or "Learn more" sentences. Do not use a URL as the link text.

<Tabs>
<TabItem value="example" label="Example" default>

> To learn more, see [Examples of Sui Smart Contracts](/guides/developer/app-examples.mdx).

</TabItem>
<TabItem value="markdown" label="Markdown">

```markdown
To learn more, see [Examples of Sui Smart Contracts](/guides/developer/app-examples.mdx).

```

</TabItem>
</Tabs>

Use keywords from the target topic title when using links inline.

<Tabs>
<TabItem value="example" label="Example" default>

> Before you install Sui, make sure to install the [prerequisites](/guides/developer/getting-started/sui-install.mdx#prerequisites).

</TabItem>
<TabItem value="markdown" label="Markdown">

```

Before you install Sui, make sure to install the [prerequisites](/guides/developer/getting-started/sui-install.mdx#prerequisites).

```

</TabItem>
</Tabs>

## Procedures / Tasks / Instructions {#procedures-tasks-instructions}

Introduce a procedure with an infinitive verb. Format procedures using a numbered or ordered list.

<Tabs>
<TabItem value="example" label="Example" default>

To get the latest version of the Sui Wallet extension:

1. Open Google Chrome.
1. Click **Extensions**, then click **Manage Extensions**.
1. Click **Details** for the Sui Wallet extension, then click **View in Chrome Web Store**.

</TabItem>
<TabItem value="markdown" label="Markdown">

```

To get the latest version of the Sui Wallet extension:

1. Open Google Chrome.
1. Click **Extensions**, then click **Manage Extensions**.
1. Click **Details** for the Sui Wallet extension, then click **View in Chrome Web Store**.

```

</TabItem>
</Tabs>

### Keyboard keys in procedures {#keyboard-keys-procedures}

When you provide instructions to press keyboard keys, such as Press **Enter** to continue, use uppercase for the key name and format the key name as bold text.

## Proper nouns {#proper-nouns}

Capitalize proper nouns throughout.

Proper nouns include:

- Names of people (Bob Ross)
- Named places, such as a city (San Francisco) or a train station (Union Station)
- Products (Slack) and services (Google Play)
- Trademarks, such as Coca-Cola
- Book titles, such as The Move Book
- Standards or technologies, such as Local Area Network (LAN)

**Example**

> Sui Wallet

## Product names {#product-names}

Product names are proper nouns. Capitalize all words of a product name. When referring to a product, use only the product name without “the”. When referring specifically to a Sui wallet, use Sui Wallet or Ethos Wallet and not just wallet. Users likely have multiple wallets, and we want to make it clear which wallet. Use wallet generically when referring to the concept of a wallet.

**Example**

> There are several types of wallets to choose from.

> Never share the recovery passphrase for your wallet with anyone.

> The Sui network supports the following wallets:

- Sui Wallet
- Ethos Wallet
- Coinbase Wallet

**Example**

> Sui Wallet

**Example**

> You can mint an NFT directly from your Sui Wallet.

## Slashes {#slashes}

Avoid using slashes in place of "and" or "or", such as True / False or True/False. Use True or False, or True | False in code documentation.

If you do use a slash, include a space between the term and slash.

When using fractions, use no spaces, for example 3/4.

## Spelling {#spelling}

Use US English spelling in source content.

## Tables {#tables}

### Table headings {#table-headings}

Capitalize the first word in the heading. Center align the text. Bold labels in the Header row.

<Tabs>
<TabItem value="example" label="Example" default>

| **Column one** | **Column two** | **Column three** | **Column four** |
| :------------- | :------------: | :--------------: | :-------------- |
| Metric name    |       10       |        X         | Text string.    |

</TabItem>
<TabItem value="markdown" label="Markdown">

```

| **Column one** | **Column two** | **Column three** | **Column four** |

```

</TabItem>
</Tabs>

### Table alignment {#table-alignment}

Center align labels in the Heading row. Left align strings of text. Center align values and Xs or checkmarks.

<Tabs>
<TabItem value="example" label="Example" default>

| **Column one** | **Column two** | **Column three** | **Column four** |
| :------------- | :------------: | :--------------: | :-------------- |
| Metric name    |       10       |        X         | Text string.    |

</TabItem>
<TabItem value="markdown" label="Markdown">

```

| **Column one** | **Column two** | **Column three** | **Column four** |
| :--- | :---: | :---: | :--- |

```

</TabItem>
</Tabs>

### Table text {#table-text}

Follow style guidelines for regular body text.

## UI elements {#ui-elements}

Format UI elements, such as field labels, button names, and menu commands, in bold text. Always match the exact text or label of the UI element, including capitalization. Do not include special characters, such as ellipses, if included in the element label.

**Example**

> To open a different file, click File > Open FIle.

**Example**

> Click **More Transactions** to open the **Transactions** page.

## URLs and web addresses {#urls-web-addresses}

Add text and create a link to a site or URL. Provide the URL only when a reader needs to copy it, such as in example code or configuration files.

## Word choice {#word-choice}

### Referring to pages in our docs {#referring}

Refer to pages in the documentation set as “topic”s. A “guide” can comprise many related topics.

**Example**

> See the Install topic in the Validator guide for more information.

:::info

You can also just refer to a topic by title where it makes sense. See Installing Sui for more information.

:::

### General considerations {#general-considerations}

- Use simple words, concise sentences
- Don't use common words in new ways
- Use technical terms carefully
- Avoid jargon

### Contractions {#contractions}

Optionally use contractions to provide a more conversational tone. It's OK to use them inconsistently. Be mindful that they can be confusing to non-native speakers.

## New section template (Heading 2) {#heading-2}

Describe the section.

### Subsection or category (Heading 3) {#heading-3}

Describe the additional entry.

<Tabs>
<TabItem value="example" label="Example" default>

> Indented example for the section. (Normal text, indented)

</TabItem>
<TabItem value="markdown" label="Markdown">

```

Indented example for the section. (Roboto Mono Light)

```

</TabItem>
</Tabs>

## Reference Style Guides {#reference-style-guides}

- [Write the Docs Style Guide article](https://www.writethedocs.org/guide/writing/style-guides/)
- [GitLab Style Guide](https://docs.gitlab.com/ee/development/documentation/styleguide/index.html) - managed as a community project
- [Digital Ocean Style Guide](https://www.digitalocean.com/community/tutorials/digitalocean-s-technical-writing-guidelines)
- [SUSE Style Guide](https://documentation.suse.com/en-us/style/current/single-html/docu_styleguide/#sec-techwriting)
- [Microsoft Style Guide](https://docs.microsoft.com/en-us/style-guide/welcome/)
- [Google Developer Style Guide](https://developers.google.com/style)
- [CDN Language and Style Reference](http://cdn.static-economist.com/sites/default/files/pdfs/style_guide_12.pdf)

```

```

```

../../Downloads/sui-stuff/sui-main/docs/content/references/contribute/localize-sui-docs.mdx
```
---
title: Localize Sui Documentation
slug: /localize-sui-docs
---

The Sui documentation can be localized (translated) into any language of your choosing. The localization platform utilized is Crowdin. For more information regarding the localization process please see [here](https://support.crowdin.com/crowdin-intro/).

```

../../Downloads/sui-stuff/sui-main/docs/content/references/contribute/sui-environment.mdx
```
---
title: Sui Environment Setup
description: Get the background information you need before you start developing on Sui. Learn the layout of the Sui monorepository and the suggested development environment for working with Move.
---

Before you start developing with Sui and Move, you should familiarize yourself with how to contribute to Sui, how Sui is structured, what tools and SDKs exist, and what plugins are available to use in your IDE.

## Fork the Sui repository {#fork}

The recommended way to contribute to the Sui repository is to fork the project, make changes on your fork, then submit a pull request (PR). The Sui repository is available on GitHub: https://github.com/MystenLabs/sui.

To create a local Sui repository:

1. Go to the [Sui repository](https://github.com/MystenLabs/sui) on GitHub.
1. Click the **Fork** button to create a copy of the repository in your account.

   ![Fork Sui repo](./images/fork.png)

1. In your forked repository on GitHub, click the green `Code <>` button and copy the **HTTPS** URL GitHub provides.

   ![Copy URL](./images/gh-url.png)

1. Open a terminal or console on your system at the location you want to save the repository locally. Type `git clone ` and paste the URL you copied in the previous step and press `Enter`.
1. Type `cd sui` to make `sui` the active directory.

You can use any [branching strategy](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-and-deleting-branches-within-your-repository) you prefer on your Sui fork. Make your changes locally and push to your repository, submitting PRs to the official Sui repository from your fork as needed.

:::tip

Be sure to synchronize your fork frequently to keep it up-to-date with active development.

:::

## Sui repository and how to contribute

The Sui repo is a monorepo, containing all the source code that is used to build and run the Sui network, as well as this documentation.

The root folder of the Sui monorepo has the following top-level folders:

- [apps](https://github.com/MystenLabs/apps): Contains the source code for the main web applications that Mysten Labs runs.
- [consensus](https://github.com/MystenLabs/sui/tree/main/consensus): Contains the source code of consensus.
- [crates](https://github.com/MystenLabs/sui/tree/main/crates): Contains all the Rust crates that are part of the Sui system.
- [dapps](https://github.com/MystenLabs/sui/tree/main/dapps): Contains some examples of decentralized applications built on top of Sui, such as Kiosk or Sponsored Transactions.
- [dashboards](https://github.com/MystenLabs/sui/tree/main/dashboards): Currently empty.
- [doc](https://github.com/MystenLabs/sui/tree/main/doc): Contains deprecated documentation related to Move and Sui.
- [docker](https://github.com/MystenLabs/sui/tree/main/docker): Contains the docker files needed to spin up a node, an indexer, a Full node or other services.
- [docs](https://github.com/MystenLabs/sui/tree/main/docs): Contains this documentation and the source for this site.
- [examples](https://github.com/MystenLabs/sui/tree/main/examples): Contains examples of apps written for Sui and smart contracts written in Move.
- [external-crates](https://github.com/MystenLabs/sui/tree/main/external-crates): Contains the source code for the Move programming language.
- [kiosk](https://github.com/MystenLabs/sui/tree/main/kiosk): Contains the source code of the Mysten Labs Kiosk extensions and rules, as well as examples.
- [nre](https://github.com/MystenLabs/sui/tree/main/nre): Contains information about node and network reliability engineering.
- [scripts](https://github.com/MystenLabs/sui/tree/main/scripts): Contains a number of scripts that are used internally.
- [sui-execution](https://github.com/MystenLabs/sui/tree/main/sui-execution): Contains the source code responsible for abstracting access to the execution layer.

The following primary directories offer a good starting point for exploring the Sui codebase:

- [move](https://github.com/MystenLabs/sui/tree/main/external-crates/move) - Move VM, compiler, and tools.
- [consensus](https://github.com/MystenLabs/sui/tree/main/consensus) - Consensus engine.
- [typescript-sdk](https://github.com/MystenLabs/ts-sdks/tree/main/packages/typescript/) - the Sui TypeScript SDK.
- [wallet](https://github.com/MystenLabs/sui/tree/main/apps/wallet) - Chrome extension wallet for Sui.
- [sui](https://github.com/MystenLabs/sui/tree/main/crates/sui) - the Sui command line tool.
- [sui-core](https://github.com/MystenLabs/sui/tree/main/crates/sui-core) - Core Sui components.
- [sui-execution](https://github.com/MystenLabs/sui/tree/main/sui-execution) - Execution Layer (programmable transactions, execution integration).
- [sui-framework](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework) - Move system packages (0x1, 0x2, 0x3, 0xdee9).
- [sui-network](https://github.com/MystenLabs/sui/tree/main/crates/sui-network) - Networking interfaces.
- [sui-node](https://github.com/MystenLabs/sui/tree/main/crates/sui-node) - Validator and Full node software.
- [sui-protocol-config](https://github.com/MystenLabs/sui/tree/main/crates/sui-protocol-config) - On-chain system configuration and limits.
- [sui-sdk](https://github.com/MystenLabs/sui/tree/main/crates/sui-sdk) - The Sui Rust SDK.
- [sui-types](https://github.com/MystenLabs/sui/tree/main/crates/sui-types) - Sui object types, such as coins and gas.

## Development branches

The Sui repository includes four primary branches: `devnet`, `testnet`, `mainnet`, and `main`.

The `devnet` branch includes the latest stable build of Sui. Choose the `devnet` branch if you want to build or test on Sui Devnet. If you encounter an issue or find a bug, it may already be fixed in the `main` branch. To submit a PR, you should push commits to your fork of the `main` branch.

The `testnet` branch includes the code running on the Sui Testnet network.

The `mainnet` branch includes the code running on the Sui Mainnet network.

The `main` branch includes the most recent changes and updates. Use the `main` branch if you want to contribute to the Sui project or to experiment with cutting-edge functionality. The `main` branch might include unreleased changes and experimental features, so use it at your own risk.

```

../../Downloads/sui-stuff/sui-main/docs/content/references/contribute/code-of-conduct.mdx
```
---
title: Sui Contributor Covenant Code of Conduct
sidebar_label: Code of Conduct
slug: /code-of-conduct
---

Sui, as an open-source project, encourages free discussion rooted in respect.
We endeavor to always be mindful of others' perspectives and ask all
fellow contributors to do the same. We welcome you to the Sui platform
and ask you to help us grow it with relevant, on-point contributions.

## Our pledge {#our-pledge}

We, as members, contributors, and leaders, pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual
identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our standards {#our-standards}

Examples of behavior that contributes to a positive environment for our
community include:

- Demonstrating empathy and kindness toward other people
- Being respectful of differing opinions, viewpoints, and experiences
- Giving and gracefully accepting constructive feedback
- Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
- Focusing on what is best, not just for us as individuals, but for the overall
  community

Examples of unacceptable behavior include:

- The use of sexualized language or imagery, and sexual attention or advances of
  any kind
- Trolling, insulting or derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or email address,
  without their explicit permission
- Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement responsibilities {#enforcement-responsibilities}

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope {#scope}

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement {#enforcement}

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement.

All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement guidelines {#enforcement-guidelines}

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction {#correction}

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning {#warning}

**Community Impact**: A violation through a single incident or series of
actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or permanent
ban.

### 3. Temporary ban {#temporary-ban}

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent ban {#permanent-ban}

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within the
community.

## Attribution {#attribution}

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.1, available at
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

Community Impact Guidelines were inspired by
[Mozilla's code of conduct enforcement ladder][Mozilla CoC].

For answers to common questions about this code of conduct, see the FAQ at
[https://www.contributor-covenant.org/faq][FAQ]. Translations are available at
[https://www.contributor-covenant.org/translations][translations].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html
[Mozilla CoC]: https://github.com/mozilla/diversity
[FAQ]: https://www.contributor-covenant.org/faq
[translations]: https://www.contributor-covenant.org/translations

```

../../Downloads/sui-stuff/sui-main/docs/content/references/sui-api/rpc-best-practices.mdx
```
---
title: RPC Best Practices
---

This topic provides some best practices for configuring your RPC settings to ensure a reliable infrastructure for your projects and services built on Sui.

{@include: ../../snippets/warn-ml-rpcs.mdx}

## RPC provisioning guidance

Consider the following when working with a provider:

- **SLA and 24-hour support:** Choose a provider that offers a SLA that meets your needs and 24-hour support.
- **Onboarding call:** Always do an onboarding call with the provider you select to ensure they can provide service that meets your needs. If you have a high-traffic event, such as an NFT mint coming up, notify your RPC provider with the expected traffic increase at least 48 hours in advance.
- **Redundancy:** It is important for high-traffic and time-sensitive apps, like NFT marketplaces and DeFi protocols, to ensure they don't rely on just one provider for RPCs. Many projects default to just using a single provider, but that's extremely risky and you should use other providers to provide redundancy.
- **Traffic estimate:** You should have a good idea about the amount and type of traffic you expect, and you should communicate that information in advance with your RPC provider. During high-traffic events (such as NFT mints), request increased capacity from your RPC provider in advance.
Bot mitigation - As Sui matures, a lot of bots will emerge on the network. Sui dApp builders should think about bot mitigation at the infrastructure level. This depends heavily on use cases. For NFT minting, bots are undesirable. However, for certain DeFi use cases, bots are necessary. Think about the implications and prepare your infrastructure accordingly.
- **Provisioning notice:** Make RPC provisioning requests at least one week in advance. This gives operators and providers advance notice so they can arrange for the configure hardware/servers as necessary. If there’s a sudden, unexpected demand, please reach out to us so we can help set you up with providers that have capacity for urgent situations.

```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/cli-check-install.mdx
```
## Check Sui CLI installation

Before you can use the Sui CLI, you must install it. To check if the CLI exists on your system, open a terminal or console and type the following command:

```sh
$ sui --version
```

If the terminal or console responds with a version number, you already have the Sui CLI installed.

If the command is not found, follow the instructions in [Install Sui](/guides/developer/getting-started/sui-install.mdx) to get the Sui CLI on your system.

```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/initialize-sui-client-cli.mdx
```
:::info 

See [Publish a Package](/guides/developer/first-app/publish.mdx) for a more detailed guide on publishing packages or [Sui Client CLI](/references/cli/client.mdx) for a complete reference of `client` commands in the Sui CLI.

:::

Before publishing your code, you must first initialize the Sui Client CLI, if you haven't already. To do so, in a terminal or console at the root directory of the project enter `sui client`. If you receive the following response, complete the remaining instructions:

```
Config file ["<FILE-PATH>/.sui/sui_config/client.yaml"] doesn't exist, do you want to connect to a Sui Full node server [y/N]?
```

Enter `y` to proceed. You receive the following response:

```
Sui Full node server URL (Defaults to Sui Testnet if not specified) :
```

Leave this blank (press Enter). You receive the following response:

```
Select key scheme to generate keypair (0 for ed25519, 1 for secp256k1, 2: for secp256r1):
```

Select `0`. Now you should have a Sui address set up.


```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/quick-install.mdx
```
Use one of the following commands for [Homebrew](https://brew.sh/) (MacOS, Linux, or Windows Subsystem for Linux), [Chocolatey](https://chocolatey.org/) (Windows), or [suiup](https://github.com/MystenLabs/suiup) (a custom installer and version manager for Sui related tools) to install Sui.

<Tabs groupId="operating-systems">

<TabItem label="Homebrew" value="mac">

```sh
$ brew install sui
```

</TabItem>

<TabItem label="Chocolatey" value="win">

```sh
$ choco install sui
```

Find more [versions of Sui for Windows](https://community.chocolatey.org/packages/sui) on the Chocolatey community website.

</TabItem>

<TabItem label="suiup (experimental)" value="suiup">

```sh
$ suiup install sui@testnet
```

Find more information on installation and a quick start guide in the suiup repository: [https://github.com/MystenLabs/suiup](https://github.com/MystenLabs/suiup).

</TabItem>

</Tabs>

```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/migrate-to-graphql.mdx
```
This guide compares JSON-RPC queries to their equivalent GraphQL counterpart. While it is possible to systematically rewrite JSON-RPC queries (for example, <code>sui_getTotalTransactionBlocks</code>) to their GraphQL counterparts using this guide, it is recommended that you revisit your application's query patterns to take full advantage of the flexibility that GraphQL offers in serving queries that touch multiple potentially nested endpoints (for example transactions, balances, coins), and use the following examples to get a flavor of how the two APIs express similar concepts.
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/info-pnpm-required.mdx
```
:::info

You must use the pnpm or yarn package managers to create Sui project scaffolds. Follow the [pnpm install](https://pnpm.io/installation) or [yarn install](https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable) instructions, if needed.

:::
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/upgrade-single-key-risk.mdx
```
- The entity owning that key might make changes that are in their own interests but not the interests of the broader community.
- Upgrades might happen without enough time for package users to consult on the change or stop using the package if they disagree.
- The key might get lost.
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/move-summary.mdx
```
Move is an open source language for writing safe packages to manipulate on-chain objects (sometimes referred to as "smart contracts"). Move is a platform-agnostic language to enable common libraries, tooling, and developer communities across blockchains with vastly different data and execution models. Move is adaptable to meet the needs of the blockchain the code operates on, see [Move on Sui](concepts/sui-move-concepts.mdx#differences) to review enhancements made to Move for optimization on the Sui blockchain.

```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/deepbook-v2-dep.mdx
```
:::warning 

DeepBook V2 is now deprecated. Update your integrations to use <a href="/standards/deepbookv3">DeepBook V3</a> instead.

:::
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/data-serving-msg.mdx
```
Refer to [Access Sui Data](/guides/developer/getting-started/data-serving.mdx) for an overview of options to access Sui network data.
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/openid-providers.mdx
```
The following table lists the OpenID providers that can support zkLogin or are currently being reviewed to determine whether they can support zkLogin.

| Provider     | Can support? | Devnet   | Testnet  | Mainnet  |
| ------------ | ----------   | -------- | -------- | -------- |
| Facebook     | Yes          |	  Yes    |  Yes     | Yes      |
| Google       | Yes          |   Yes    |  Yes     | Yes      |
| Twitch       | Yes          |   Yes    |  Yes     | Yes      |
| Apple        | Yes          |   Yes    |  Yes     | Yes      |
| Slack        | Yes          |   Yes    |  No      | No       |
| Kakao        | Yes          |   Yes    |  No      | No       |
| Microsoft    | Yes          |   Yes    |  No      | No       |
| AWS (Tenant)*| Yes          |   Yes    |  Yes     | Yes      |
| Karrier One  | Yes          |   Yes    |  Yes     | Yes      |
| Credenza3    | Yes          |   Yes    |  Yes     | Yes      |
| RedBull      | Under review |   No     |  No      | No       |
| Amazon       | Under review |   No     |  No      | No       |
| WeChat       | Under review |   No     |  No      | No       |
| Auth0        | Under review |   No     |  No      | No       |
| Okta         | Under review |   No     |  No      | No       |

* Sui supports AWS (Tenant) but the provider is enabled per tenant. Contact us for more information.
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/linux-deps.mdx
```
```sh
$ sudo apt-get install curl git-all cmake gcc libssl-dev pkg-config libclang-dev libpq-dev build-essential
```

```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/macos-deps.mdx
```
```sh
$ brew install curl cmake libpq git
```

```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/staking-pool-reqs.mdx
```
### Validator staking pool requirements 

There are minimum staking requirements a validator must satisfy to become active and to stay in the active validator set.

#### Stake Requirements

The Sui network is rolling out [SIP-39](https://github.com/sui-foundation/sips/blob/main/sips/sip-39.md), which will significantly lower the barrier to entry for validators. Instead of requiring a minimum amount of SUI tokens, validators will need a minimum amount of *voting power*.

When fully rolled out, SIP-39 will mean the following validator requirements:

- A validator candidate must accrue at least 3 voting power before they can request to join the validator set.
- If an active validator's stake falls below 2 voting power, they have seven epochs of grace period to gain back the stake before being removed from the validator set.
- If an active validator's stake falls below 1 voting power, they are removed from the validator set at the end of the current epoch boundary. Sui uses 24-hour epochs.

For more information on voting power, see [Understanding the voting power formula](/concepts/tokenomics.mdx#understanding-the-voting-power-formula).

:::tip
Want to be a Sui validator?

If you have the required stake and plan to operate a validator on Sui, your participation is welcome and Sui is committed to supporting your onboarding. Kindly complete [this form](https://docs.google.com/forms/d/e/1FAIpQLSf6ZngRJ6Q5RdEiBfnbpUq4Htj8ShL58I6JRkmRTwTVSzeNtQ/viewform) to be added to our Validator Discord and keep up with upcoming validator releases and technical support.
:::

```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/faucet-online.mdx
```
https://faucet.sui.io/: Visit the online faucet to request SUI tokens. You can refresh your browser to perform multiple requests, but the requests are rate-limited per IP address.

```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/warn-ml-rpcs.mdx
```
:::caution

Use dedicated nodes/shared services rather than public endpoints for production apps. The public endpoints maintained by Mysten Labs (`fullnode.<NETWORK>.sui.io:443`) are rate-limited, and support only 100 requests per 30 seconds. Do not use public endpoints in production applications with high traffic volume.

You can either run your own Full nodes, or outsource this to a professional infrastructure provider (preferred for apps that have high traffic). You can find a list of reliable RPC endpoint providers for Sui on the [Sui Dev Portal](https://sui.io/developers#dev-tools) using the **Node Service** tag.

:::
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/address-prefix.mdx
```
You can pass literal addresses and objects IDs by prefixing them with '@'. This is needed to distinguish a hexadecimal value from an address in some situations. 

For addresses that are in your local wallet, you can use their alias instead (passing them without '@', for example, --transfer-objects my_alias).

```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/libpq-req.mdx
```
:::info

You need `libpq-dev` only if you plan to use the `--with-indexer` and `--with-graphql` options with `sui start`. See [Local Network](/guides/developer/getting-started/local-network.mdx#start-the-local-network) for more information.

:::
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/info-gas-budget.mdx
```
:::tip

Beginning with the Sui `v1.24.1` [release](https://github.com/MystenLabs/sui/releases/tag/mainnet-v1.24.1), the `--gas-budget` option is no longer required for CLI commands.

:::
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/data-serving-gql-alpha.mdx
```
Based on valuable feedback from the community, the GraphQL RPC release stage has been updated from beta to alpha. Refer to the high-level timeline for beta and GA releases in the previously linked document.
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/app-examples-swap-source.mdx
```
:::info

You can view the [complete source code for this app example](https://github.com/MystenLabs/sui/tree/main/examples/trading) in the Sui repository.

:::
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/contact-nautilus.mdx
```
:::tip Contact us

For questions about Nautilus, use case discussions, or integration support, contact the Nautilus team on [Sui Discord](https://discord.com/channels/916379725201563759/1361500579603546223).

:::
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/publish-to-devnet-with-coins.mdx
```
Before being able to publish your package to Testnet, you need Testnet SUI tokens. To get some, visit the online faucet at https://faucet.sui.io/. For other ways to get SUI in your Testnet account, see [Get SUI Tokens](/guides/developer/getting-started/get-coins).

Now that you have an account with some Testnet SUI, you can deploy your contracts. To publish your package, use the following command in the same terminal or console:

```
sui client publish --gas-budget <GAS-BUDGET>
```

For the gas budget, use a standard value such as `20000000`.
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/data-wipe.mdx
```

:::info 

Testnet and Devnet data persistence is not guaranteed. Devnet data is wiped regularly as part of scheduled software updates. The data on Testnet persists through the regular update process, but might be wiped when necessary. Testnet data wipes are announced ahead of time.

For more information about the release schedule of Sui networks, see [Sui Network Release](https://sui.io/networkinfo/).

:::

```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/lists/sui-explorers.mdx
```

- [Polymedia Explorer](https://github.com/juzybits/polymedia-explorer): Community fork of the discontinued Sui Explorer from Mysten Labs that you can build locally or use online at https://explorer.polymedia.app/.
- [Sui Explorer](https://github.com/suiware/sui-explorer): Community fork of the discontinued Sui Explorer from Mysten Labs that you can build locally. 
- [suiscan](https://suiscan.xyz/): Popular Sui network scanner available online.
- [SuiVision](https://suivision.xyz/): Popular Sui network scanner available online.
```

../../Downloads/sui-stuff/sui-main/docs/content/snippets/lists/binaries-file-list.mdx
```
    | Name | Description |
    | --- | --- |
    | `move-analyzer` | Language Server Protocol implementation. | 
    | `sui` | Main Sui binary. |
    | `sui-bridge` | Sui native bridge. |
    | `sui-data-ingestion` | Capture Full node data for indexer to store in a database. |
    | `sui-faucet` | Local faucet to mint coins on local network. |
    | `sui-graphql-rpc` | GraphQL service for Sui RPC. |
    | `sui-node` | Run a local node. |
    | `sui-test-validator` | Run test validators on a local network for development. |
    | `sui-tool` | Provides utilities for Sui. |

```

../../Downloads/sui-stuff/sui-main/docs/content/sidebars/concepts.js
```
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

const concepts = [
	'concepts',
	'concepts/components',
	{
		type: 'category',
		label: 'App Developers',
		link: {
			type: 'doc',
			id: 'concepts/app-devs',
		},
		items: [
			{
				type: 'category',
				label: 'Object Model',
				link: {
					type: 'doc',
					id: 'concepts/object-model',
				},
				items: [
					{
						type: 'category',
						label: 'Object Ownership',
						link: {
							type: 'doc',
							id: 'concepts/object-ownership',
						},
						items: [
							'concepts/object-ownership/address-owned',
							'concepts/object-ownership/immutable',
							'concepts/object-ownership/shared',
							'concepts/object-ownership/wrapped',
						],
					},
					{
						type: 'category',
						label: 'Transfers',
						link: {
							type: 'doc',
							id: 'concepts/transfers',
						},
						items: ['concepts/transfers/custom-rules', 'concepts/transfers/transfer-to-object'],
					},
					'concepts/versioning',
				],
			},
			{
				type: 'category',
				label: 'Move Overview',
				link: {
					type: 'doc',
					id: 'concepts/sui-move-concepts',
				},
				items: [
					{
						type: 'category',
						label: 'Packages',
						link: {
							type: 'doc',
							id: 'concepts/sui-move-concepts/packages',
						},
						items: [
							'concepts/sui-move-concepts/packages/upgrade',
							'concepts/sui-move-concepts/packages/custom-policies',
							'concepts/sui-move-concepts/packages/automated-address-management',
						],
					},
					{
						type: 'category',
						label: 'Dynamic Fields',
						link: {
							type: 'doc',
							id: 'concepts/dynamic-fields',
						},
						items: ['concepts/dynamic-fields/tables-bags'],
					},
					'concepts/sui-move-concepts/conventions',
				],
			},
			{
				type: 'category',
				label: 'Transactions',
				link: {
					type: 'doc',
					id: 'concepts/transactions',
				},
				items: [
					'concepts/transactions/prog-txn-blocks',
					'concepts/transactions/sponsored-transactions',
					'concepts/transactions/gas-smashing',
				],
			},
			'concepts/grpc-overview',
			'concepts/graphql-rpc',
			'concepts/gaming'
		],
	},
	{
		type: 'category',
		label: 'Cryptography',
		link: {
			type: 'doc',
			id: 'concepts/cryptography',
		},
		items: [
			{
				type: 'category',
				label: 'Transaction Authentication',
				link: {
					type: 'doc',
					id: 'concepts/cryptography/transaction-auth',
				},
				items: [
					'concepts/cryptography/transaction-auth/keys-addresses',
					'concepts/cryptography/transaction-auth/signatures',
					'concepts/cryptography/transaction-auth/multisig',
					'concepts/cryptography/transaction-auth/offline-signing',
					'concepts/cryptography/transaction-auth/intent-signing',
				],
			},
			'concepts/cryptography/zklogin',
			'concepts/cryptography/passkeys',
			{
				type: 'category',
				label: 'Nautilus',
				link: {
					type: 'doc',
					id: 'concepts/cryptography/nautilus',
				},
				items: [
					'concepts/cryptography/nautilus/nautilus-design',
					'concepts/cryptography/nautilus/using-nautilus',
				],
			},
			'concepts/cryptography/system/checkpoint-verification',
			/*{
				type: 'category',
				label: 'System',
				link: {
					type: 'doc',
					id: 'concepts/cryptography/system',
				},
				items: [
					'concepts/cryptography/system/validator-signatures',
					'concepts/cryptography/system/intents-for-validation',
					'concepts/cryptography/system/checkpoint-verification',
				],
			},*/
		],
	},
	{
		type: 'category',
		label: 'Sui Architecture',
		link: {
			type: 'doc',
			id: 'concepts/sui-architecture',
		},
		items: [
			'concepts/sui-architecture/high-level',
			'concepts/sui-architecture/sui-storage',
			'concepts/sui-architecture/sui-security',
			'concepts/sui-architecture/transaction-lifecycle',
			'concepts/sui-architecture/consensus',
			'concepts/sui-architecture/indexer-functions',
			'concepts/sui-architecture/epochs',
			'concepts/sui-architecture/protocol-upgrades',
			'concepts/sui-architecture/data-management-things',
			'concepts/sui-architecture/staking-rewards',
		],
	},
	{
		type: 'category',
		label: 'Tokenomics',
		link: {
			type: 'doc',
			id: 'concepts/tokenomics',
		},
		items: [
			'concepts/tokenomics/staking-unstaking',
			'concepts/tokenomics/sui-bridging',
			'concepts/tokenomics/gas-pricing',
			'concepts/tokenomics/gas-in-sui',
			'concepts/tokenomics/vesting-strategies'
		],
	},
	'concepts/research-papers',
];
module.exports = concepts;

```

../../Downloads/sui-stuff/sui-main/docs/content/sidebars/guides.js
```
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

const guides = [
	{
		type: 'doc',
		label: 'Guides',
		id: 'guides',
	},
	{
		type: 'category',
		label: 'Developer Guides',
		collapsed: false,
		link: {
			type: 'doc',
			id: 'guides/developer',
		},
		items: [
			{
				type: 'category',
				label: 'Getting Started',
				collapsed: false,
				link: {
					type: 'doc',
					id: 'guides/developer/getting-started',
				},
				items: [
					'guides/developer/getting-started/sui-install',
					'guides/developer/getting-started/connect',
					'guides/developer/getting-started/local-network',
					'guides/developer/getting-started/get-address',
					'guides/developer/getting-started/get-coins',
					'guides/developer/getting-started/data-serving',
				],
			},
			{
				type: 'category',
				label: 'Your First Sui dApp',
				link: {
					type: 'doc',
					id: 'guides/developer/first-app',
				},
				items: [
					'guides/developer/first-app/write-package',
					'guides/developer/first-app/build-test',
					'guides/developer/first-app/publish',
					'guides/developer/first-app/debug',
					'guides/developer/first-app/client-tssdk',
				],
			},
			{
				type: 'category',
				label: 'Sui 101',
				link: {
					type: 'doc',
					id: 'guides/developer/sui-101',
				},
				items: [
					'guides/developer/sui-101/shared-owned',
					'guides/developer/sui-101/using-events',
					'guides/developer/sui-101/access-time',
					'guides/developer/sui-101/sign-and-send-txn',
					'guides/developer/sui-101/sponsor-txn',
					'guides/developer/sui-101/avoid-equivocation',
					{
						type: 'category',
						label: 'Working with PTBs',
						items: [
							'guides/developer/sui-101/building-ptb',
							'guides/developer/sui-101/coin-mgt',
							'guides/developer/sui-101/simulating-refs',
						],
					},
				],
			},
			{
				type: 'category',
				label: 'Coins and Tokens',
				link: {
					type: 'doc',
					id: 'guides/developer/coin',
				},
				items: [
					'guides/developer/coin/regulated',
					'guides/developer/coin/in-game-token',
					'guides/developer/coin/loyalty',
				],
			},
			'guides/developer/stablecoins',
			{
				type: 'category',
				label: 'NFTs',
				link: {
					type: 'doc',
					id: 'guides/developer/nft',
				},
				items: ['guides/developer/nft/nft-soulbound', 'guides/developer/nft/nft-rental', 'guides/developer/nft/asset-tokenization'],
			},
			{
				type: 'category',
				label: 'Cryptography',
				link: {
					type: 'doc',
					id: 'guides/developer/cryptography',
				},
				items: [
					'guides/developer/cryptography/signing',
					'guides/developer/cryptography/groth16',
					'guides/developer/cryptography/hashing',
					'guides/developer/cryptography/ecvrf',
					'guides/developer/cryptography/multisig',
					{
						type: 'category',
						label: 'zkLogin Integration Guide',
						link: {
							type: 'doc',
							id: 'guides/developer/cryptography/zklogin-integration',
						},
						items: [
							'guides/developer/cryptography/zklogin-integration/developer-account',
							'guides/developer/cryptography/zklogin-integration/zklogin-example',
						],
					},
				],
			},
			{
				type: 'category',
				label: 'Advanced Topics',
				link: {
					type: 'doc',
					id: 'guides/developer/advanced',
				},
				items: [
					/*{
						type: 'category',
						label: 'Efficient Smart Contracts',
						link: {
							type: 'doc',
							id: 'guides/developer/advanced/efficient-smart-contracts',
						},
						items: ['guides/developer/advanced/min-gas-fees'],
					},*/
					'guides/developer/advanced/move-2024-migration',
					'guides/developer/advanced/custom-indexer',
					'guides/developer/advanced/randomness-onchain',
					'guides/developer/getting-started/graphql-rpc',
					'guides/developer/advanced/graphql-migration',
					'guides/developer/advanced/local-fee-markets',
				],
			},
			{
				type: 'category',
				label: 'App Examples',
				link: {
					type: 'doc',
					id: 'guides/developer/app-examples',
				},
				items: [
					'guides/developer/app-examples/e2e-counter',
					'guides/developer/app-examples/trustless-swap',
					'guides/developer/app-examples/coin-flip',
					'guides/developer/app-examples/reviews-rating',
					'guides/developer/app-examples/blackjack',
					'guides/developer/app-examples/plinko',
					'guides/developer/app-examples/tic-tac-toe',
					{
						type: 'category',
						label: 'Oracles',
						link: {
							type: 'doc',
							id: 'guides/developer/app-examples/oracle',
						},
						items: [
							'guides/developer/app-examples/weather-oracle',
							'guides/developer/app-examples/meta-pricing-oracle',
						],
					},
					// 'guides/developer/app-examples/recaptcha',
					// 'guides/developer/app-examples/trusted-swap',
					// 'guides/developer/app-examples/turnip-town',
					// 'guides/developer/app-examples/auction',
				],
			},
			'guides/developer/starter-templates',
			'guides/developer/zklogin-onboarding',
			'guides/developer/dev-cheat-sheet',
		],
	},
	{
		type: 'category',
		label: 'Operator Guides',
		link: {
			type: 'doc',
			id: 'guides/operator',
		},
		items: [
			'guides/operator/sui-full-node',
			'guides/operator/validator-config',
			'guides/operator/genesis',
			'guides/operator/monitoring',
			'guides/operator/updates',
			'guides/operator/data-management',
			'guides/operator/snapshots',
			'guides/operator/archives',
			'guides/operator/node-tools',
			'guides/operator/exchange-integration',
			'guides/operator/bridge-node-configuration',
			'guides/operator/validator-committee',
			'guides/operator/validator-tasks',
		],
	},
];
module.exports = guides;

```

../../Downloads/sui-stuff/sui-main/docs/content/sidebars/references.js
```
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

const references = [
	{
		type: 'doc',
		label: 'References',
		id: 'references',
	},
	{
		type: 'category',
		label: 'Sui RPC',
		collapsed: false,
		link: {
			type: 'doc',
			id: 'references/sui-api',
		},
		items: [
			{
				type: 'category',
				label: 'GraphQL (Alpha)',
				link: {
					type: 'doc',
					id: 'references/sui-graphql',
				},
				items: [
					{
						type: 'autogenerated',
						dirName: 'references/sui-api/sui-graphql/reference',
					},
				],
			},
			{
				type: 'link',
				label: 'JSON-RPC',
				href: '/sui-api-ref',
			},
			'references/fullnode-protocol',
			'references/sui-api/rpc-best-practices',
		],
	},
	{
		type: 'category',
		label: 'Sui CLI',
		collapsed: false,
		link: {
			type: 'doc',
			id: 'references/cli',
		},
		items: [
			'references/cli/cheatsheet',
			'references/cli/client',
			'references/cli/ptb',
			'references/cli/keytool',
			'references/cli/move',
			'references/cli/validator',
		],
	},
	{
		type: 'category',
		label: 'Sui IDE Support',
		collapsed: false,
		items: [
			'references/ide/move',
			'references/ide/debugger',
		],
	},
	{
		type: 'category',
		label: 'Sui SDKs',
		collapsed: false,
		link: {
			type: 'doc',
			id: 'references/sui-sdks',
		},
		items: [
			{
				type: 'link',
				label: 'dApp Kit',
				href: 'https://sdk.mystenlabs.com/dapp-kit',
			},
			'references/rust-sdk',
			{
				type: 'link',
				label: 'TypeScript SDK',
				href: 'https://sdk.mystenlabs.com/typescript',
			},
			{
				type: 'link',
				label: 'zkSend SDK',
				href: 'https://sdk.mystenlabs.com/zksend',
			},
		],
	},
	{
		type: 'category',
		label: 'Move',
		collapsed: false,
		link: {
			type: 'doc',
			id: 'references/sui-move',
		},
		items: [
			{
				type: 'category',
				label: 'Framework',
				link: {
					type: 'doc',
					id: 'references/framework',
				},
				items: [{ type: 'autogenerated', dirName: 'references/framework' }],
			},
			{
				type: 'link',
				label: 'The Move Book',
				href: 'https://move-book.com/',
			},
			{
				type: 'link',
				label: 'The Move Reference',
				href: 'https://move-book.com/reference/',
			},
		],
	},
	'references/sui-glossary',
	{
		type: 'category',
		label: 'Contribute',
		link: {
			type: 'doc',
			id: 'references/contribute/contribution-process',
		},
		items: [
			'references/contribute/sui-environment',
			'references/contribute/contribution-process',
			'references/contribute/contribute-to-sui-repos',
			{
				type: 'link',
				label: 'Submit a SIP',
				href: 'https://sips.sui.io',
			},
			'references/contribute/localize-sui-docs',
			'references/contribute/code-of-conduct',
			'references/contribute/style-guide',
			'references/contribute/mdx-components',
		],
	},
];

module.exports = references;

```

../../Downloads/sui-stuff/sui-main/docs/content/sidebars/standards.js
```
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

const standards = [
	'standards',
	'standards/coin',
	{
		type: 'category',
		label: 'Closed-Loop Token',
		link: {
			type: 'doc',
			id: 'standards/closed-loop-token',
		},
		items: [
			'standards/closed-loop-token/action-request',
			'standards/closed-loop-token/token-policy',
			'standards/closed-loop-token/spending',
			'standards/closed-loop-token/rules',
			'standards/closed-loop-token/coin-token-comparison',
		],
	},
	'standards/kiosk',
	'standards/kiosk-apps',
	{
		type: 'category',
		label: 'DeepBook',
		link: {
			type: 'doc',
			id: 'standards/deepbook',
		},
		items: [
			{
				type: 'category',
				label: 'DeepBookV3',
				link: {
					type: 'doc',
					id: 'standards/deepbookv3',
				},
				items: [
					'standards/deepbookv3/design',
					'standards/deepbookv3/balance-manager',
					'standards/deepbookv3/permissionless-pool',
					'standards/deepbookv3/query-the-pool',
					'standards/deepbookv3/orders',
					'standards/deepbookv3/swaps',
					'standards/deepbookv3/flash-loans',
					'standards/deepbookv3/staking-governance',
				],
			},
			'standards/deepbookv3-indexer',
			{
				type: 'category',
				label: 'DeepBookV3 SDK',
				link: {
					type: 'doc',
					id: 'standards/deepbookv3-sdk',
				},
				items: [
					'standards/deepbookv3-sdk/flash-loans',
					'standards/deepbookv3-sdk/orders',
					'standards/deepbookv3-sdk/pools',
					'standards/deepbookv3-sdk/staking-governance',
					'standards/deepbookv3-sdk/swaps',
				],
			},
			{
				type: 'category',
				label: 'DeepBookV2',
				link: {
					type: 'doc',
					id: 'standards/deepbookv2',
				},
				items: [
					'standards/deepbookv2/design',
					'standards/deepbookv2/orders',
					'standards/deepbookv2/pools',
					'standards/deepbookv2/query-the-pool',
					'standards/deepbookv2/routing-a-swap',
					'standards/deepbookv2/trade-and-swap',
				],
			},
		],
	},
	'standards/display',
	'standards/wallet-standard',
];
module.exports = standards;

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/wallet-standard.mdx
```
---
title: Wallet Standard
description: The Wallet standard defines how wallets can automatically be discovered and interacted with from dApps.
---

Browser extension wallets built for Sui use the [Wallet standard](https://github.com/wallet-standard/wallet-standard/). This is a cross-chain standard that defines how dApps can automatically discover and interact with wallets.

If you are building a wallet, the helper library `@mysten/wallet-standard` provides types and utilities to help get started.

## Working with wallets

The Wallet standard includes features to help build wallets.

### Creating a wallet interface

Create a class that represents your wallet. Use the `Wallet` interface from
`@mysten/wallet-standard` to help ensure your class adheres to the standard.

```tsx
import { SUI_DEVNET_CHAIN, Wallet } from '@mysten/wallet-standard';

class YourWallet implements Wallet {
	get version() {
		// Return the version of the Wallet Standard this implements (in this case, 1.0.0).
		return '1.0.0';
	}
	get name() {
		return 'Wallet Name';
	}
	get icon() {
		return 'some-icon-data-url';
	}
	// Return the Sui chains that your wallet supports.
	get chains() {
		return [SUI_DEVNET_CHAIN];
	}
}
```

### Implementing features

Features are standard methods consumers can use to interact with a wallet. To be listed in the Sui
wallet adapter, you must implement the following features in your wallet:

- `standard:connect` - Use to initiate a connection to the wallet.
- `standard:events` - Use to listen for changes that happen within the wallet, such as accounts
  being added or removed.
- `sui:signPersonalMessage` - Use to prompt the user to sign a personal message and return the
  message signature back to the dApp. Use this to verify the user’s public key.
- `sui:signTransaction` - Use to prompt the user to sign a transaction and return the serialized
  transaction and signature back to the dApp. This method does not submit the transaction for
  execution.
- `sui:signAndExecuteTransaction` - Use to prompt the user to sign a transaction, then submit it
  for execution to the blockchain.
- `sui:reportTransactionEffects` - Use to report the effects of a transaction executed in the dApp
  to the wallet. This allows the wallet to update its internal state to reflect the changes the transaction makes.
- `sui:signTransactionBlock` - The previous version of `sui:signTransaction`. Still
  implemented for compatibility with dApps that have not updated to the new feature.
- `sui:signAndExecuteTransactionBlock` - The previous version of `sui:signAndExecuteTransaction`. Still implemented for compatibility with dApps that have not updated to the new feature.

Implement these features in your wallet class under the `features` property:

```tsx
import {
  StandardConnectFeature,
  StandardConnectMethod,
  StandardEventsFeature,
  StandardEventsOnMethod,
  SuiFeatures,
  SuiSignPersonalMessageMethod,
  SuiSignTransactionMethod,
  SuiSignAndExecuteTransactionMethod,
  SuiReportTransactionEffectsMethod
} from "@mysten/wallet-standard";

class YourWallet implements Wallet {
	/* ... existing code from above ... */

  get features(): ConnectFeature & EventsFeature & SuiFeatures {
    return {
      "standard:connect": {
        version: "1.0.0",
        connect: this.#connect,
      },
      "standard:events": {
        version: "1.0.0",
        on: this.#on,
      },
			"sui:signPersonalMessage": {
        version: "1.0.0",
				signPersonalMessage: this.#signPersonalMessage,
			},
      "sui:signTransaction": {
        version: "2.0.0",
        signTransaction: this.#signTransaction,
      },
      "sui:signAndExecuteTransaction": {
        version: "2.0.0",
        signAndExecuteTransaction: this.#signAndExecuteTransactionBlock,
      },
      "sui:reportTransactionEffects": {
        version: "1.0.0",
        reportTransactionEffects: this.#reportTransactionEffects,
    };
  },

  #on: EventsOnMethod = () => {
    // Your wallet's events on implementation.
  };

  #connect: ConnectMethod = () => {
    // Your wallet's connect implementation
  };

	#signPersonalMessage: SuiSignPersonalMessageMethod = () => {
    // Your wallet's signTransaction implementation
  };

  #signTransaction: SuiSignTransactionMethod = () => {
    // Your wallet's signTransaction implementation
  };

  #signAndExecuteTransaction: SuiSignAndExecuteTransactionMethod = () => {
    // Your wallet's signAndExecuteTransaction implementation
  };

  #reportTransactionEffects: SuiReportTransactionEffectsMethod = () => {
    // Your wallet's reportTransactionEffects implementation
  };
}
```

### Exposing accounts

The last requirement of the wallet interface is to expose an `accounts` interface. This should
expose all of the accounts that a connected dApp has access to. It can be empty prior to initiating
a connection through the `standard:connect` feature.

The accounts use the `ReadonlyWalletAccount` class to construct an account matching the
required interface.

```tsx
import { ReadonlyWalletAccount } from '@mysten/wallet-standard';

class YourWallet implements Wallet {
	get accounts() {
		// Assuming we already have some internal representation of accounts:
		return someWalletAccounts.map(
			(walletAccount) =>
				// Return
				new ReadonlyWalletAccount({
					address: walletAccount.suiAddress,
					publicKey: walletAccount.pubkey,
					// The Sui chains that your wallet supports.
					chains: [SUI_DEVNET_CHAIN],
					// The features that this account supports. This can be a subset of the wallet's supported features.
					// These features must exist on the wallet as well.
					features: [
						'sui:signPersonalMessage',
						'sui:signTransactionBlock',
						'sui:signAndExecuteTransactionBlock',
					],
				}),
		);
	}
}
```

### Registering in the window

After you have a compatible interface for your wallet, use the `registerWallet`
function to register it.

```tsx
import { registerWallet } from '@mysten/wallet-standard';

registerWallet(new YourWallet());
```

### Best practices for efficient transaction execution

The Wallet standard has been updated from its original design to better support changes in the Sui ecosystem. For example, the GraphQL service was introduced after Mainnet launched. The `sui:signAndExecuteTransactionBlock` feature is closely tied to the JSON RPC options and data structures, so its continued maintenance becomes increasingly difficult as the GraphQL service becomes more ubiquitous.

Consequently, the Wallet standard introduced the `sui:signAndExecuteTransaction` feature. The features of this method are more useful, regardless of which API you use to execute transactions. This usefulness comes at the expense
of flexibility in what `sui:signAndExecuteTransaction` returns.

To solve this problem, use the `sui:signTransaction` feature to sign transactions, and
leave transaction execution to the dApp. The dApp can query for additional data during
execution using whichever API it chooses. This is consistent with the default `@mysten/dapp-kit` uses for the `useSignAndExecuteTransaction` hook, and enables dApps to take
advantage of read-after-write consistency when interacting with the Full-node based JSON RPC.

The downside of this strategy is that wallets often use different RPC nodes than the dApp,
and might not have indexed the previous transaction when executing multiple transactions in rapid
succession. This leads to building transactions using stale data that fail upon execution.

To mitigate this, wallets can use the `sui:reportTransactionEffects` feature so that dApps can report
the effects of transactions to the wallet. Transaction effects contain the updated versions and
digests of any objects that a transaction uses or creates. By caching these values, wallets can build
transactions without needing to resolve the most recent versions through an API call.

The `@mysten/sui/transaction` SDK exports the `SerialTransactionExecutor` class, which you can use
to build transactions using an object cache. The class has a method to update its internal cache using the
effects of a transaction.

Using the combination of `sui:signTransaction` and `sui:reportTransactionEffects`, dApps can use
either API to execute transactions and query for any data the API exposes. The dApp can then report the effects of the transaction to the wallet, and the wallet can then execute transactions without running into issues caused by a lagging indexer.

## Managing wallets

The Wallet standard includes features to help your apps interact with wallets.

### Wallet data

To query the installed wallets in a user's browser, use the `get` function of `getWallets`.

```tsx
import { getWallets } from '@mysten/wallet-standard';

const availableWallets = getWallets().get();
```

The return from this call (`availableWallets` in the previous code) is an array of `Wallet` types.

Use the `Wallet.icon` and `Wallet.name` attributes to display the wallet details on your web page.

The `Wallet.accounts` is an array of `WalletAccount`s. Each `WalletAccount` type has `address` and `publicKey` properties, which are most useful during development. This data fills and caches after connection.

### Features

Both the `Wallet` type and the `WalletAccount` type have a property called `features`. The main wallet functionality is found here. The mandatory features that wallets must implement are listed in the previous code.

Many wallets choose to omit some non-mandatory features or add some custom features, so be sure to check the relevant wallet documentation if you intend to integrate a specific wallet.

### Connecting a wallet

Connecting in the context of a wallet refers to a user that joins the web site for the first time and has to choose the wallet and addresses to use.

The feature that provides this functionality is called `standard:connect`. To connect using this feature, make the following call:

```tsx
wallet.features['standard:connect'].connect(); // connect call
```

This call results in the wallet opening a pop-up dialog for the user to continue the connection process.

### Disconnecting a wallet

Similar to the connecting feature, the Wallet standard also includes `standard:disconnect`. The following example calls this feature:

```tsx
wallet.features['standard:disconnect'].disconnect();
```

### Transactions - suggested approach

Upon wallet connection, your app has the necessary information to execute transactions, such as address and method.

Construct the transaction separately with the `@mysten/sui` library and then sign it with the private key of the user. Use the `sui:signTransaction` feature to achieve this:

```tsx
wallet.features[sui:signTransaction].signTransaction(<Transaction>, <WalletAccount>);
```

Similar to connections, this process opens a pop-up dialog for the user to either accept or decline the transaction. Upon accepting, the function returns an object in the form `{bytes: String, signature: Uint8Array}`. The `bytes` value is the `b64` encoding of the transaction and the `signature` value is the transaction signature.

To execute the transaction, use `SuiClient` from `@mysten/sui`:

```tsx
const client: SuiClient
client.executeTransactionBlock({
    transactionBlock: bytes,
    signature: signature,
    options: {}
})
```

Your app then sends the transaction effects back to the wallet, which reports results to the user. The wallet expects the effects to be `b64` encoded.

```tsx
import { toBase64 } from '@mysten/sui/utils';

wallet.features['sui:reportTransactionEffects'].reportTransactionEffects(
    effects: Array.isArray(transactionResponse.effects) ? toBase64(
        Uint8Array.from(transactionResponse.effects) : transactionResponse.effects,
        account: wallet.accounts[0], // for example
        chain: wallet.chains[0]
    )
```

### Transactions - abbreviated approach

Many wallets abstract the above flow into one feature: `sui:signAndExecuteTransaction`. The required arguments for this feature are the raw transaction and the options with the desired information to be included in the response:

- `showEffects`: Include the transaction effects.
- `showEvents`: Include the transaction events.
- `showObjectChanges`: Include all the objects that were deleted, created, or mutated.
- `showBalanceChanges`: Include any coin transfer that took place.
- `showInput`: Include the transaction's input.
- `showRawInput`: Same as `showInput` but the format is raw.

### Events wallets emit

The wallet emits events on certain user actions that apps can listen to. These events allow your app to be responsive to user actions on their wallets.

The wallet standard only defines the change event that can apply to chains, features, or accounts.

- `chains`: A change event on the chains means the user switched the wallet's active network, such as from Devnet to Testnet.
- `features`: The user added or removed permission for your app to access certain wallet features.
- `accounts`: The user added or removed an account (address) to interact with your app.

To subscribe your apps to events with the following call:

```tsx
const unsubscribe = wallet.features['standard:events'].on('change', callback);
```

This call returns a function that can be called to unsubscribe from listening to the events.

The callback is the handler that contains the logic to perform when the event fires. The input to the callback function is an object with the following type:

```tsx
{
    accounts: WalletAccount[],
    chains: IdentifierArray,
    features: IdentifierRecord<unknown>
}
```

These values are all arrays containing the new or changed items. Consequently, every event populates only one array in most cases, the rest are empty.

### Implementation example

Mysten Labs offers a bare bones scaffold for React-based applications called `@mysten/dapp-kit`. See the [dApp Kit documentation](https://sdk.mystenlabs.com/dapp-kit) for more information.

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3-indexer.mdx
```
---
title: DeepBookV3 Indexer
---

import Admonition from '@theme/Admonition';


DeepBook Indexer provides streamlined, real-time access to order book and trading data from the DeepBook protocol. It acts as a centralized service to aggregate and expose critical data points for developers, traders, and analysts who interact with DeepBook.

DeepBook Indexer simplifies data retrieval by offering endpoints that enable:

-	**Viewing pool information:** Retrieve detailed metadata about all available trading pools, including base and quote assets, tick sizes, and lot sizes.
-	**Historical volume analysis:** Fetch volume metrics for specific pools or balance managers over custom time ranges, with support for interval-based breakdowns.
-	**User-specific volume tracking:** Provide insights into individual trader activities by querying their balance manager-specific volumes.

You can either use a publicly available indexer or spin up your own service. The choice you make depends on a few factors.

Use the public service if:

-	You have standard data needs.
-	Latency and availability provided by the public endpoint meet your requirements.
-	You want to avoid the operational overhead of running your own service.

Run your own indexer if:

-	You require guaranteed uptime and low latency.
-	You have specific customization needs.
-	Your application depends on proprietary features or extended data sets.

## Public DeepBook Indexer

[Mysten Labs](https://www.mystenlabs.com/) provides a public indexer for DeepBook. You can access this indexer at the following URL:

```http
https://deepbook-indexer.mainnet.mystenlabs.com/
```

## Asset conversions

Volumes returned by the following endpoints are expressed in the smallest unit of the corresponding asset. 

- `/all_historical_volume`
- `/historical_volume`
- `/historical_volume_by_balance_manager_id`
- `/historical_volume_by_balance_manager_id_with_interval`

Following are the decimal places (scalars) used to determine the base unit for each asset.

| Asset | Scalar |
| --- | --- |
| AUSD | 6 |
| Bridged Eth (bETH) | 8 |
| Deepbook Token (DEEP) | 6 |
| Native USDC | 6 |
| SUI | 9 |
| SuiNS Token (NS) | 6 |
| TYPUS | 9 |
| Wrapped USDC (wUSDC) | 6 |
| Wrapped USDT (wUSDT) | 6 |

To convert the returned volume to the standard asset unit, divide the value by 10^SCALAR. For example:

If the volume returned in the base asset for the SUI/USDC pool is 1,000,000,000 SUI UNIT, the correct volume in SUI is 1,000,000,000 / 10^(SUI_SCALAR) = 1 SUI. Similarly, if the volume returned in the quote asset for the SUI/USDC pool is 1,000,000,000 USDC UNIT, the correct volume is  1,000,000,000 / 10^(USDC_SCALAR) = 1,000 USDC.

Use these conversions to interpret the volumes correctly across all pools and assets.

## API endpoints

You can perform the following tasks using the endpoints that the indexer API for DeepBook provides.

### Get all pool information

```
/get_pools
```

Returns a list of all available pools, each containing detailed information about the base and quote assets, as well as pool parameters like minimum size, lot size, and tick size.

#### Response

```json
[
	{
	  "pool_id": "string",
	  "pool_name": "string",
	  "base_asset_id": "string",
	  "base_asset_decimals": integer,
	  "base_asset_symbol": "string",
	  "base_asset_name": "string",
	  "quote_asset_id": "string",
	  "quote_asset_decimals": integer,
	  "quote_asset_symbol": "string",
	  "quote_asset_name": "string",
	  "min_size": integer,
	  "lot_size": integer,
	  "tick_size": integer
	},
	...
]
```

Each pool object in the response includes the following fields:

-	**pool_id:** ID for the pool.
-	**pool_name:** Name of the pool.
-	**base_asset_id:** ID for the base asset.
-	**base_asset_decimals:** Number of decimals for the base asset.
-	**base_asset_symbol:** Symbol for the base asset.
-	**base_asset_name:** Name of the base asset.
-	**quote_asset_id:** ID for the quote asset.
-	**quote_asset_decimals:** Number of decimals for the quote asset.
-	**quote_asset_symbol:** Symbol for the quote asset.
-	**quote_asset_name:** Name of the quote asset.
-	**min_size:** Minimum trade size for the pool, in smallest units of the base asset.
-	**lot_size:** Minimum increment for trades in this pool, in smallest units of the base asset.
-	**tick_size:** Minimum price increment for trades in this pool.

#### Example

A successful request to the following endpoint

```http
/get_pools
```

produces a response similar to

```json
[
	{
		"pool_id": "0xb663828d6217467c8a1838a03793da896cbe745b150ebd57d82f814ca579fc22",
		"pool_name": "DEEP_SUI",
		"base_asset_id": "0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP",
		"base_asset_decimals": 6,
		"base_asset_symbol": "DEEP",
		"base_asset_name": "DeepBook Token",
		"quote_asset_id": "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",
		"quote_asset_decimals": 9,
		"quote_asset_symbol": "SUI",
		"quote_asset_name": "Sui",
		"min_size": 100000000,
		"lot_size": 10000000,
		"tick_size": 10000000
	},
	{
		"pool_id": "0xf948981b806057580f91622417534f491da5f61aeaf33d0ed8e69fd5691c95ce",
		"pool_name": "DEEP_USDC",
		"base_asset_id": "0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP",
		"base_asset_decimals": 6,
		"base_asset_symbol": "DEEP",
		"base_asset_name": "DeepBook Token",
		"quote_asset_id": "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
		"quote_asset_decimals": 6,
		"quote_asset_symbol": "USDC",
		"quote_asset_name": "USDC",
		"min_size": 100000000,
		"lot_size": 10000000,
		"tick_size": 10000
	}
]
```

### Get historical volume for pool in a specific time range

```http
/historical_volume/:pool_names?start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&volume_in_base=<BOOLEAN>
```

Use this endpoint to get historical volume for pools for a specific time range. Delimit the	`pool_names` with commas, and use Unix timestamp seconds for `start_time` and `end_time` values. 

By default, this endpoint retrieves the last 24-hour trading volume in the quote asset for specified pools. If you want to query the base asset instead, set `volume_in_base` to `true`.

#### Response

Returns the historical volume for each specified pool within the given time range.

```json
{
	"pool_name_1": total_pool1_volume,
	"pool_name_2": total_pool2_volume,
	...
}
```

#### Example

A successful request to the following endpoint

```http
/historical_volume/DEEP_SUI,SUI_USDC?start_time=1731260703&end_time=1731692703&volume_in_base=true
```

produces a response similar to

```json
{
	"DEEP_SUI": 22557460000000,
	"SUI_USDC": 19430171000000000
}
```

### Get historical volume for all pools

```http
/all_historical_volume?start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&volume_in_base=<BOOLEAN>
```

Use this endpoint to get historical volume for all pools. Include the optional `start_time` and `end_time` values as Unix timestamp seconds to retrieve the volume within that time range.

By default, this endpoint retrieves the last 24-hour trading volume in the quote asset. If you want to query the base asset instead, set `volume_in_base` to `true`.

#### Response

Returns the historical volume for all available pools within the time range (if provided).

```json
{
	"pool_name_1": total_pool1_volume,
	"pool_name_2": total_pool2_volume
}
```

#### Example

A successful request to the following endpoint

```http
/all_historical_volume?start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&volume_in_base=<BOOLEAN>
```

produces a response similar to

```json
{
	"DEEP_SUI": 22557460000000,
	"WUSDT_USDC": 10265000000,
	"NS_USDC": 4399650900000,
	"NS_SUI": 6975475200000,
	"SUI_USDC": 19430171000000000,
	"WUSDC_USDC": 23349574900000,
	"DEEP_USDC": 130000590000000
}
```

### Get historical volume by balance manager

```
/historical_volume_by_balance_manager_id/:pool_names/:balance_manager_id?start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&volume_in_base=<BOOLEAN>
```

Get historical volume by balance manager for a specific time range. Delimit the	`pool_names` with commas, and use Unix timestamp seconds for the optional `start_time` and `end_time` values.

By default, this endpoint retrieves the last 24-hour trading volume for the balance manager in the quote asset for specified pools. If you want to query the base asset instead, set `volume_in_base` to `true`.

#### Response

```json
{
	"pool_name_1": [maker_volume, taker_volume],
	"pool_name_2": …
}
```

#### Example

A successful request to the following endpoint

```http
/historical_volume_by_balance_manager_id/SUI_USDC,DEEP_SUI/0x344c2734b1d211bd15212bfb7847c66a3b18803f3f5ab00f5ff6f87b6fe6d27d?start_time=1731260703&end_time=1731692703&volume_in_base=true
```

produces a response similar to

```json
{
	"DEEP_SUI": [
		14207960000000,
		3690000000
	],
	"SUI_USDC": [
		2089300100000000,
		17349400000000
	]
}
```

### Get historical volume by balance manager within a specific time range and intervals

```
/historical_volume_by_balance_manager_id_with_interval/:pool_names/:balance_manager_id?start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&interval=<UNIX_TIMESTAMP_SECONDS>&volume_in_base=<BOOLEAN>
```

Get historical volume by `BalanceManager` for a specific time range with intervals. Delimit `pool_names` with commas and use Unix timestamp seconds for the optional `start_time` and `end_time` values. Use number of seconds for the `interval` value. As a simplified interval example, if `start_time` is 5, `end_time` is 10, and `interval` is 2, then the response includes volume from 5 to 7 and 7 to 9, with start time of the periods as keys.

By default, this endpoint retrieves the last 24-hour trading volume for the balance manager in the quote asset for specified pools. If you want to query the base asset instead, set `volume_in_base` to `true`.

#### Response

```json
{
	"[time_1_start, time_1_end]": {
		"pool_name_1": [maker_volume, taker_volume],
		"pool_name_2": …
	},
	"[time_2_start, time_2_end]": {
		"pool_name_1": [maker_volume, taker_volume],
		"pool_name_2": …
	}
}
```

#### Example

A successful request to the following endpoint with an interval of 24 hours

```http
/historical_volume_by_balance_manager_id_with_interval/USDC_DEEP,SUI_USDC/0x344c2734b1d211bd15212bfb7847c66a3b18803f3f5ab00f5ff6f87b6fe6d27d?start_time=1731460703&end_time=1731692703&interval=86400&volume_in_base=true
```
produces a response similar to

```json
{
	"[1731460703, 1731547103]": {
		"SUI_USDC": [
			505887400000000,
			2051300000000
		]
	},
	"[1731547103, 1731633503]": {
		"SUI_USDC": [
			336777500000000,
			470600000000
		]
	}
}
```

### Get summary 

```http
/summary
```

Returns a summary in JSON for all trading pairs in DeepBook.

#### Response

Each summary object has the following form. The order of fields in the JSON object is not guaranteed.

```json
{
	"trading_pairs": "string",
	"quote_currency": "string",
	"last_price": float,
	"lowest_price_24h": float,
	"highest_bid": float,
	"base_volume": float,
	"price_change_percent_24h": float,
	"quote_volume": float,
	"lowest_ask": float,
	"highest_price_24h": float,
	"base_currency": "string"
}
```

#### Example

A successful request to 

```
/summary
```
produces a response similar to
```json
[
	{
    "trading_pairs": "AUSD_USDC",
    "quote_currency": "USDC",
    "last_price": 1.0006,
    "lowest_price_24h": 0.99905,
    "highest_bid": 1.0006,
    "base_volume": 1169.2,
    "price_change_percent_24h": 0.07501125168773992,
    "quote_volume": 1168.961637,
    "lowest_ask": 1.0007,
    "highest_price_24h": 1.00145,
    "base_currency": "AUSD"
  },
  {
    "quote_volume": 4063809.55231,
    "lowest_price_24h": 0.9999,
    "highest_price_24h": 1.009,
    "base_volume": 4063883.6,
    "quote_currency": "USDC",
    "price_change_percent_24h": 0.0,
    "base_currency": "WUSDC",
    "trading_pairs": "WUSDC_USDC",
    "last_price": 1.0,
    "highest_bid": 1.0,
    "lowest_ask": 1.0001
  },
  {
		"price_change_percent_24h": 0.0,
		"quote_currency": "USDC",
		"lowest_price_24h": 0.0,
		"quote_volume": 0.0,
		"base_volume": 0.0,
		"highest_price_24h": 0.0,
		"lowest_ask": 1.04,
		"last_price": 1.04,
		"base_currency": "WUSDT",
		"highest_bid": 0.90002,
		"trading_pairs": "WUSDT_USDC"
	},
	...
]
```

### Get ticker information

```http
/ticker
```

Returns all trading pairs volume (already scaled), last price, and `isFrozen` value. Possible values for `isFrozen` is either:
- `0`: Pool is active
- `1`: Pool is inactive

#### Response

```json
{
  "TRADING_PAIR": {
    "base_volume": float,
    "quote_volume": float,
    "last_price": float,
    "isFrozen": integer (0 | 1)
  }
}
```

#### Example

A successful request to 

```
/ticker
```
produces a response similar to

```json
{
	"DEEP_USDC": {
		"last_price": 0.07055,
		"base_volume": 43760440.0,
		"quote_volume": 3096546.9161,
		"isFrozen": 0
	},
	"NS_SUI": {
		"last_price": 0.08323,
		"base_volume": 280820.8,
		"quote_volume": 23636.83837,
		"isFrozen": 0
	},
	...
}
```

### Get trades

```http
/trades/:pool_name?limit=<INTEGER>&start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&maker_balance_manager_id=<ID>&taker_balance_manager_id=<ID>
```

Returns the most recent trade in the pool. 

#### Response

```json
[
    {
        "trade_id": "string",
        "base_volume": integer,
        "quote_volume": integer,
        "price": integer,
        "type": "string",
        "timestamp": integer,
        "maker_order_id": "string",
        "taker_order_id": "string",
        "maker_balance_manager_id": "string",
        "taker_balance_manager_id": "string"
    }
]
```

The `timestamp` value is in Unix milliseconds.

#### Example

A successful request to 

```http
trades/SUI_USDC?limit=2&start_time=1738093405&end_time=1738096485&maker_balance_manager_id=0x344c2734b1d211bd15212bfb7847c66a3b18803f3f5ab00f5ff6f87b6fe6d27d&taker_balance_manager_id=0x47dcbbc8561fe3d52198336855f0983878152a12524749e054357ac2e3573d58
```

produces a response similar to

```json
[
    {
        "trade_id": "136321457151457660152049680",
        "base_volume": 405,
        "quote_volume": 1499,
        "price": 3695,
        "type": "sell",
        "timestamp": 1738096392913,
        "maker_order_id": "68160737799100866923792791",
        "taker_order_id": "170141183460537392451039660509112362617",
        "maker_balance_manager_id": "0x344c2734b1d211bd15212bfb7847c66a3b18803f3f5ab00f5ff6f87b6fe6d27d",
        "taker_balance_manager_id": "0x47dcbbc8561fe3d52198336855f0983878152a12524749e054357ac2e3573d58"
    },
	...
]
```

### Get order updates

```http
/order_updates/:pool_name?limit=<INTEGER>&start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&status=<"Placed" or "Canceled">&balance_manager_id=<ID>
```

Returns the orders that were recently placed or canceled in the pool

#### Response

```json
[
    {
        "order_id": "string",
        "balance_manager_id": "string",
        "timestamp": integer,
        "original_quantity": integer,
        "remaining_quantity": integer,
        "filled_quantity": integer,
        "price": integer,
        "status": "string",
        "type": "string"
    }
]
```

The `timestamp` value is in Unix milliseconds.

#### Example

A successful request to 

```http
/order_updates/DEEP_USDC?start_time=1738703053&end_time=1738704080&limit=2&status=Placed&balance_manager_id=0xd335e8aa19d6dc04273d77e364c936bad69db4905a4ab3b2733d644dd2b31e0a
```

produces a response similar to

```json
[
    {
        "order_id": "170141183464610341308794360958165054983",
        "balance_manager_id": "0xd335e8aa19d6dc04273d77e364c936bad69db4905a4ab3b2733d644dd2b31e0a",
        "timestamp": 1738704071994,
        "original_quantity": 8910,
        "remaining_quantity": 8910,
        "filled_quantity": 0,
        "price": 22449,
        "status": "Placed",
        "type": "sell"
    },
	...
]
```

### Get order book information

```http
/orderbook/:pool_name?level={1|2}&depth={integer}
```

Returns the bids and asks for the relevant pool. The bids and asks returned are each sorted from best to worst. There are two optional query parameters in the endpoint:

- **level**: The `level` value can be either 1 or 2. 
	- `1`: Only the best bid and ask. 
	- `2`: Arranged by best bids and asks. This is the default value.
- **depth**: The `depth` value can be `0` or greater than `1`. A value of `0` returns the entire order book, and a value greater than `1` returns the specified number of both bids and asks. In other words, if you provide `depth=100`, then your response includes 50 bids and 50 asks. If the `depth` value is odd, it's treated as the next lowest even value. Consequently, `depth=101` also returns 50 bids and 50 asks. If you do not provide a `depth` parameter, the response defaults to all orders in the order book.

#### Response

```json
{
	"timestamp": "string",
	"bids": [
		[
			"string",
			"string"
		],
		[
			"string",
			"string"
		]
	],
	"asks": [
		[
			"string",
			"string"
		],
		[
			"string",
			"string"
		]
	]
}
```

The timestamp returned is a string that represents a Unix timestamp in milliseconds.

#### Example

A successful request to 

```json
/orderbook/SUI_USDC?level=2&depth=4
```

produces a response similar to

```json
{
	"timestamp": "1733874965431",
	"bids": [
		[
			"3.715",
			"2.7"
		],
		[
			"3.713",
			"2294.8"
		]
	],
	"asks": [
		[
			"3.717",
			"0.9"
		],
		[
			"3.718",
			"1000"
		]
	]
}
```

### Get asset information

```http
/assets
```

Returns asset information for all coins being traded on DeepBook.

#### Response

Each asset object has the following form:

```json
"ASSET_NAME": {
	"unified_cryptoasset_id": "string",
	"name": "string",
	"contractAddress": "string",
	"contractAddressUrl": "string",
	"can_deposit": "string (true | false)",
	"can_withdraw": "string (true | false)"
}
```

#### Example

A successful request to 

```json
/assets
```

produces a response similar to

```json
{
  "NS": {
    "unified_cryptoasset_id": "32942",
    "name": "Sui Name Service",
    "contractAddress": "0x5145494a5f5100e645e4b0aa950fa6b68f614e8c59e17bc5ded3495123a79178",
    "contractAddressUrl": "https://suiscan.xyz/mainnet/object/0x5145494a5f5100e645e4b0aa950fa6b68f614e8c59e17bc5ded3495123a79178",
    "can_deposit": "true",
    "can_withdraw": "true"
  },
  "AUSD": {
    "unified_cryptoasset_id": "32864",
    "name": "AUSD",
    "contractAddress": "0x2053d08c1e2bd02791056171aab0fd12bd7cd7efad2ab8f6b9c8902f14df2ff2",
    "contractAddressUrl": "https://suiscan.xyz/mainnet/object/0x2053d08c1e2bd02791056171aab0fd12bd7cd7efad2ab8f6b9c8902f14df2ff2",
    "can_deposit": "true",
    "can_withdraw": "true"
  },
	...
}
```
```

../../Downloads/sui-stuff/sui-main/docs/content/standards/kiosk.mdx
```
---
title: Sui Kiosk
description: Kiosk is a decentralized system for commerce applications on Sui. Kiosk is a part of the Sui framework, native to the system, and available to everyone.
---

Kiosk is a decentralized system for commerce applications on Sui. It consists of `Kiosk` objects - shared objects owned by individual parties that store assets and allow listing them for sale as well as utilize custom trading functionality - for example, an auction. While being highly decentralized, Sui Kiosk provides a set of strong guarantees:

- Kiosk owners retain ownership of their assets to the moment of purchase.
- Creators set custom policies - sets of rules applied to every trade (such as pay royalty fee or do some arbitrary action X).
- Marketplaces can index events the `Kiosk` object emits and subscribe to a single feed for on-chain asset trading.

Practically, Kiosk is a part of the Sui framework, and it is native to the system and available to everyone out of the box.

:::info

See the [Kiosk SDK documentation](https://sdk.mystenlabs.com/kiosk) for examples of working with Kiosk using TypeScript.

:::

## Sui Kiosk owners

Anyone can create a Sui Kiosk. Ownership of a kiosk is determined by the owner of the `KioskOwnerCap`, a special object that grants full access to a single kiosk. As the owner, you can sell any asset with a type (T) that has a shared `TransferPolicy` available, or you can use a kiosk to store assets even without a shared policy. You can’t sell or transfer any assets from your kiosk that do not have an associated transfer policy available.

To sell an item, if there is an existing transfer policy for the type (T), you just add your assets to your kiosk and then list them. You specify an offer amount when you list an item. Anyone can then purchase the item for the amount of SUI specified in the listing. The associated transfer policy determines what the buyer can do with the purchased asset.

A kiosk owner can:

- Place and take items
- List items for sale
- Add and remove Extensions
- Withdraw profits from sales
- Borrow and mutate owned assets
- Access the full set of trading tools, such as auctions, lotteries, and collection bidding

## Sui Kiosk for buyers

A buyer is a party that purchases (or - more generally - receives) items from kiosks, anyone on the network can be a buyer (and, for example, a kiosk owner at the same time).

**Benefits:**

- Buyers get access to global liquidity and can get the best offer
- Buyers can place bids on collections through their kiosks
- Most buyer actions performed in kiosks clean up seller objects, which results in free (gas-less) actions

**Responsibilities:**

- Buyer is the party that pays the fees if they're set in the policy
- Buyer must follow the rules set by creators or a transaction won't succeed

**Guarantees:**

- When using a custom trading logic such as an auction, the items are guaranteed to be unchanged until the trade is complete

## Sui Kiosk for marketplaces

As a marketplace operator, you can implement Sui Kiosk to watch for offers made in a collection of kiosks and display them on a marketplace site. You can also implement a custom system using Kiosk extensions (created by the community or third-parties). For example, marketplaces can use a `TransferPolicyCap` to implement application-specific transfer rules.

## Sui Kiosk for creators

As a creator, Sui Kiosk supports strong enforcement for transfer policies and associated rules to protect assets and enforce asset ownership. Sui Kiosk gives creators more control over their creations, and puts creators and owners in control of how their works can be used.

Creator is a party that creates and controls the TransferPolicy for a single type. For example, the authors of SuiFrens are the Creators of the `SuiFren<Capy>` type and act as creators in the Kiosk ecosystem. Creators set the policy, but they might also be the first sellers of their assets through a kiosk.

**Creators can:**

- Set any rules for trades
- Set multiple ways ("tracks") of rules
- Enable or disable trades at any moment with a policy
- Enforce policies (like royalties) on all trades
- Perform a primary sale of their assets through a kiosk

All of the above is effective immediately and globally.

**Creators cannot:**

- Take or modify items stored in someone else's kiosk
- Restrict taking items from kiosks if the "locking" rule was not set in the policy

## Sui Kiosk guarantees

Sui Kiosk provides a set of guarantees that Sui enforces through smart contracts.
These guarantees include:

- Every trade in Sui Kiosk requires a `TransferPolicy` resolution. This gives creators control over how their assets can be traded.
- True ownership, which means that only a kiosk owner can take, list, borrow, or modify the assets added to their kiosk. This is similar to how single-owner objects work on Sui.
- Strong policy enforcement, for example Royalty policies, that lets creators enable or disable policies at any time that applies to all trades on the platform for objects with that policy attached.
- Changes to a `TransferPolicy` apply instantly and globally.

In practice, these guarantees mean that:

- When you list an item for sale, no one can modify it or take it from the kiosk.
- When you define a `PurchaseCap`, an item remains locked and you can’t modify or take the item from the kiosk unless the trade uses or returns the `PurchaseCap`.
- You can remove any rule at any time (as the owner).
- You can disable any extension at any time (as the owner).
- The state of an extension state is always accessible to the extension.

### Asset states in Sui Kiosk {#asset-states}

Sui Kiosk is a shared object that can store heterogeneous values, such as different sets of asset collectibles. When you add an asset to your kiosk, it has one of the following states:

- PLACED - an item placed in the kiosk using the `kiosk::place` function. The kiosk owner can withdraw it and use it directly, borrow it (mutably or immutably), or list an item for sale.
- LOCKED - an item placed in the kiosk using the `kiosk::lock` function. You can’t withdraw a Locked item from a kiosk, but you can borrow it mutably and list it for sale. Any item placed in a kiosk that has an associated kiosk lock policy have a LOCKED state.
- LISTED - an item in the kiosk that is listed for sale using the `kiosk::list` or `kiosk::place_and_list` functions. You can’t modify an item while listed, but you can borrow it immutably or delist it, which returns it to its previous state.
- LISTED EXCLUSIVELY - an item placed or locked in the kiosk by an extension that calls the `kiosk::list_with_purchase_cap` function. Only the kiosk owner can approve calling the function. The owner can only borrow it immutably. The extension must provide the functionality to delist / unlock the asset, or it might stay locked forever. Given that this action is explicitly performed by the owner - it is the responsibility of the owner to choose verified and audited extensions to use.

When someone purchases an asset from a kiosk, the asset leaves the kiosk and ownership transfers to the buyer’s address.

## Open a Sui Kiosk

To use a Sui Kiosk, you must create one and have the `KioskOwnerCap` that matches the `Kiosk` object. You can create a new kiosk using a single transaction by calling the `kiosk::default` function. The function creates and shares a `Kiosk`, and transfers the `KioskOwnerCap` to your address.

### Create a Sui Kiosk using programmable transaction blocks

```javascript
let tx = new Transaction();
tx.moveCall({
	target: '0x2::kiosk::default',
});
```

### Create a Sui Kiosk using the Sui CLI

{@include: ../snippets/info-gas-budget.mdx}

```sh
$ sui client call \
    --package 0x2 \
    --module kiosk \
    --function default \
    --gas-budget 1000000000
```

### Create a Sui Kiosk with advanced options

For more advanced use cases, when you want to choose the storage model or perform an action right away, you can use the programmable transaction block (PTB) friendly function `kiosk::new`.
Kiosk is designed to be shared. If you choose a different storage model, such as owned, your kiosk might not function as intended or not be accessible to other users. You can make sure your kiosk works by testing it on Sui Testnet.

### Create a Sui Kiosk with advanced options using programmable transaction blocks

```javascript
let tx = new Transaction();
let [kiosk, kioskOwnerCap] = tx.moveCall({
	target: '0x2::kiosk::new',
});

tx.transferObjects([kioskOwnerCap], sender);
tx.moveCall({
	target: '0x2::transfer::public_share_object',
	arguments: [kiosk],
	typeArguments: '0x2::kiosk::Kiosk',
});
```

### Create a Sui Kiosk with advanced options using the SUI CLI

Sui CLI does not support PTBs and transaction chaining yet. You can use the `kiosk::default` function instead.

## Place items in and take items from your kiosk

As a kiosk owner, you can place any assets into your Sui Kiosk. You can take any item from your kiosk that is not currently listed for sale.

There's no limitations on which assets you can place in your kiosk. However, you can’t necessarily list and trade all of the items you place in your kiosk. The `TransferPolicy` associated with the type for the item determines whether you can trade it. To learn more, see the [Purchase items from a kiosk](#purchase) section.

### Place an item in your kiosk

To place an item to the kiosk, the owner needs to call the `sui::kiosk::place` function on the `Kiosk` object and pass the `KioskOwnerCap` and the `Item` as arguments.

`ITEM_TYPE` in the following examples represents the full type of the item.

### Place an item using programmable transaction blocks

```javascript
let tx = new Transaction();

let itemArg = tx.object('<ID>');
let kioskArg = tx.object('<ID>');
let kioskOwnerCapArg = tx.object('<ID>');

tx.moveCall({
	target: '0x2::kiosk::place',
	arguments: [kioskArg, kioskOwnerCapArg, itemArg],
	typeArguments: ['<ITEM_TYPE>'],
});
```

### Place an item using the Sui CLI

```sh
$ sui client call \
    --package 0x2 \
    --module kiosk \
    --function place \
    --args "<KIOSK_ID>" "<CAP_ID>" "<ITEM_ID>" \
    --type-args "<ITEM_TYPE>" \
    --gas-budget 1000000000
```

## Take items from a kiosk

To take an item from a kiosk you must be the kiosk owner. As the owner, call the `sui::kiosk::take` function on the `Kiosk` object, and pass the `KioskOwnerCap` and `ID` of the item as arguments.

`ITEM_TYPE` in the following examples represents the full type of the item.

### Take an item from a kiosk using programmable transaction blocks

```javascript
let tx = new Transaction();

let itemId = tx.pure.id('<ITEM_ID>');
let kioskArg = tx.object('<ID>');
let kioskOwnerCapArg = tx.object('<ID>');

let item = tx.moveCall({
	target: '0x2::kiosk::take',
	arguments: [kioskArg, kioskOwnerCapArg, itemId],
	typeArguments: ['<ITEM_TYPE>'],
});
```

### Take an item from a kiosk using the Sui CLI

The `kiosk::take` function is built to be PTB friendly and returns the asset. The Sui CLI does not yet support transaction chaining.

## Lock items in a kiosk

Some policies require that assets never get removed from a kiosk, such as for strong royalty enforcement. To support this, Sui Kiosk provides a locking mechanism. Locking is similar to placing except that you can't take a locked asset out of the kiosk.

To lock an asset in a kiosk, call the `sui::kiosk::lock` function. To ensure that you can later unlock the asset you must associate a `TransferPolicy` with the asset.

:::info

After you lock an asset, you must use `list` or `list_with_purchase_cap` functions to list it.

:::

### Lock an item in a kiosk

When you use the `lock` function, similar to using the `place` function, you specify the `KioskOwnerCap` and the `Item` as arguments. But to lock the item, you must also show the `TransferPolicy`.

`<ITEM_TYPE>` in the following examples represents the full type of the asset.

### Lock an item using programmable transaction blocks

```javascript
const tx = new Transaction();

let kioskArg = tx.object('<ID>');
let kioskOwnerCapArg = tx.object('<ID>');
let itemArg = tx.object('<ID>');
let transferPolicyArg = tx.object('<ID>');

tx.moveCall({
	target: '0x2::kiosk::lock',
	arguments: [kioskArg, kioskOwnerCapArg, transferPolicyArg, itemArg],
	typeArguments: ['<ITEM_TYPE>'],
});
```

### Lock an item using the Sui CLI

```sh
$ sui client call \
    --package 0x2 \
    --module kiosk \
    --function lock \
    --args "<KIOSK_ID>" "<CAP_ID>" "<TRANSFER_POLICY_ID>" "<ITEM_ID>" \
    --type-args "<ITEM_TYPE>" \
    --gas-budget 1000000000
```

## List and delist items from a kiosk

Sui Kiosk provides basic trading functionality. As a kiosk owner, you can list assets for sale, and buyers can discover and purchase them. Sui Kiosk supports listing items by default with three primary functions:

- `kiosk::list` - list an asset for sale for a fixed price
- `kiosk::delist` - remove an existing listing
- `kiosk::purchase` - purchase an asset listed for sale

Anyone on the network can purchase an item listed from a Sui Kiosk. To learn more about the purchase flow, see the [Purchase section](#purchase). To learn more about asset states and what can be done with a listed item, see the [Asset States](#asset-states) section.

### List an item from a kiosk

As a kiosk owner, you can use the `kiosk::list` function to list any asset you added to your kiosk. Include the item to sell and the list price as arguments. All listings on Sui are in SUI tokens.
When you list an item, Sui emits a `kiosk::ItemListed` event that contains the kiosk ID, item ID, type of the item, and the list price.

### List an item using programmable transaction blocks

```javascript
let tx = new Transaction();

let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');
let itemId = tx.pure.id('<ID>');
let itemType = 'ITEM_TYPE';
let priceArg = tx.pure.u64('<price>'); // in MIST (1 SUI = 10^9 MIST)

tx.moveCall({
	target: '0x2::kiosk::list',
	arguments: [kioskArg, capArg, itemId, priceArg],
	typeArguments: [itemType],
});
```

### List an item using the Sui CLI

```sh
$ sui client call \
    --package 0x2 \
    --module kiosk \
    --function list \
    --args "<KIOSK_ID>" "<CAP_ID>" "<ITEM_ID>" "<PRICE>" \
    --type-args "ITEM_TYPE" \
    --gas-budget 1000000000
```

### Delist an item

As a kiosk owner you can use the `kiosk::delist` to delist any currently listed asset. Specify the item to delist as an argument.

When you delist an item, Sui returns to the kiosk owner the gas fees charged to list the item.

When you delist an item, Sui emits a `kiosk::ItemDelisted` event that contains the kiosk ID, item ID, and the type of the item.

### Delist an item using the programmable transaction blocks

```javascript
let tx = new Transaction();
let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');
let itemId = tx.pure.id('<ID>');
let itemType = 'ITEM_TYPE';

tx.moveCall({
	target: '0x2::kiosk::delist',
	arguments: [kioskArg, capArg, itemId],
	typeArguments: [itemType],
});
```

### Delist an item using the Sui CLI

```sh
$ sui client call \
    --package 0x2 \
    --module kiosk \
    --function delist \
    --args "<KIOSK_ID>" "<CAP_ID>" "<ITEM_ID>" \
    --type-args "ITEM_TYPE" \
    --gas-budget 1000000000
```

## Purchase an item from a kiosk {#purchase}

Anyone that has an address on the Sui network can purchase an item listed from a Sui Kiosk. To purchase an item, you can use the `kiosk::purchase` function. Specify the item to purchase and pay the list price set by the kiosk owner.

You can discover the items listed on the network with the `kiosk::ItemListed` event.

When you use the `kiosk::purchase` function, it returns the purchased asset and the `TransferRequest` for the type associated with the asset. To complete the purchase, you must meet the terms defined in the `TransferPolicy` applied to the asset.

## Borrow an item from a kiosk

As a kiosk owner, you can access an asset placed or locked in a kiosk without taking the asset from the kiosk. You can always borrow the asset immutably. Whether you can mutably borrow an asset depends on the state of the asset. For example, you can’t borrow a listed asset because you can’t modify it while listed. The functions available include:

- `kiosk::borrow` - returns an immutable reference to the asset
- `kiosk::borrow_mut` - returns a mutable reference to the asset
- `kiosk::borrow_val` - a PTB-friendly version of `borrow_mut`, which allows you to take an asset and place it back in the same transaction.

### Immutable borrow

You can always borrow an asset from a kiosk immutably. You can use the `kiosk::borrow` function to borrow an asset, however, it is not possible to use references within a programmable transaction block. To access the asset you must use a published module (function).

### Immutably borrow an asset using Sui Move

```move
module examples::immutable_borrow;

use sui::kiosk::{Self, Kiosk, KioskOwnerCap};

public fun immutable_borrow_example<T>(self: &Kiosk, cap: &KioskOwnerCap, item_id: ID): &T {
    self.borrow(cap, item_id)
}
```

### Mutable borrow with borrow_mut

You can mutably borrow an asset from a kiosk if it is not listed. You can use the `kiosk::borrow_mut` function to mutably borrow an asset. However, it is not possible to use references within a PTB, so to access the mutably borrowed asset you must use a published module (function).

### Mutably borrow an asset using Sui Move

```move
module examples::mutable_borrow;

use sui::kiosk::{Self, Kiosk, KioskOwnerCap};

public fun mutable_borrow_example<T>(
    self: &mut Kiosk, cap: &KioskOwnerCap, item_id: ID
): &mut T {
    self.borrow_mut(cap, item_id)
}
```

### Mutable borrow with borrow_val

You can use the PTB-friendly kiosk::borrow_val function. It allows you to take an asset and place it back in the same transaction. To make sure the asset is placed back into the kiosk, the function "obliges" the caller with a “Hot Potato”.

### Mutable borrow with `borrow_val` using programmable transaction blocks

```javascript
let tx = new Transaction();

let itemType = 'ITEM_TYPE';
let itemId = tx.pure.id('<ITEM_ID>');
let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');

let [item, promise] = tx.moveCall({
	target: '0x2::kiosk::borrow_val',
	arguments: [kioskArg, capArg, itemId],
	typeArguments: [itemType],
});

// freely mutate or reference the `item`
// any calls are available as long as they take a reference
// `returnValue` must be explicitly called

tx.moveCall({
	target: '0x2::kiosk::return_val',
	arguments: [kioskArg, item, promise],
	typeArguments: [itemType],
});
```

## Withdraw proceeds from a completed sale

When someone purchases an item, Sui stores the proceeds from the sale in the kiosk. As the kiosk owner, you can withdraw the proceeds at any time by calling the `kiosk::withdraw` function. The function is simple, but because it is PTB friendly it is not currently supported in the Sui CLI.

### Withdraw proceeds using programmable transaction blocks

```javascript
let tx = new Transaction();
let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');

// because the function uses an Option<u64> argument,
// constructing is a bit more complex
let amountArg = tx.moveCall({
	target: '0x1::option::some',
	arguments: [tx.pure.u64('<amount>')],
	typeArguments: ['u64'],
});

// alternatively
let withdrawAllArg = tx.moveCall({
	target: '0x1::option::none',
	typeArguments: ['u64'],
});

let coin = tx.moveCall({
	target: '0x2::kiosk::withdraw',
	arguments: [kioskArg, capArg, amountArg],
	typeArguments: ['u64'],
});
```

### Withdraw proceeds using the Sui CLI

This action is not currently supported in the CLI environment.

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/kiosk-apps.mdx
```
---
title: Kiosk Apps
description: Kiosk apps are a way to extend the functionality of Sui Kiosk while keeping the core functionality intact. You can develop apps to add new features to a kiosk without having to modify the core code or move the assets elsewhere.
---

Kiosk apps are a way to extend the functionality of Sui Kiosk while keeping the core functionality intact. You can develop apps to add new features to a kiosk without having to modify the core code or move the assets elsewhere.

There are two types of apps:

- [Basic apps](#basic-apps)
- [Permissioned apps](#permissioned-apps)

## Basic apps

Basic Kiosk apps do not require Kiosk Apps API to function. They usually serve the purpose of adding custom metadata to a kiosk or wrapping/working with existing objects such as `Kiosk` or `KioskOwnerCap`. An example of an app that does not require the API is the Personal Kiosk app.

### UID access via the uid_mut

Kiosk has an `id: UID` field like all objects on Sui, which allows this object to be uniquely identified and carry custom dynamic fields and dynamic object fields. The Kiosk itself is built around dynamic fields and features like place and list are built around dynamic object fields.

### The uid_mut_as_owner function

Kiosk can carry additional dynamic fields and dynamic object fields. The `uid_mut_as_owner` function allows the Kiosk owner to mutably access the UID of the Kiosk object and use it to add or remove custom fields.

Function signature:

`kiosk::uid_mut_as_owner(self: &mut Kiosk, cap: &KioskOwnerCap): &mut UID`

### The public uid getter

Anyone can read the `uid` of kiosks. This allows third party modules to read the fields of the kiosk if they're allowed to do so. Therefore enabling the object capability and other patterns.

### Basic app ideas

You can attach custom dynamic fields to your kiosks that anyone can then read (but only you can modify), you can use this to implement basic apps. For example, a Kiosk Name app where you as the kiosk owner can set a name for the kiosk, attach it as a dynamic field, and make it readable by anyone.

```move
module examples::kiosk_name_ext;

use std::string::String;
use sui::dynamic_field as df;
use sui::kiosk::{Self, Kiosk, KioskOwnerCap};

/// The dynamic field key for the Kiosk Name Extension
struct KioskName has copy, store, drop {}

/// Add a name to the Kiosk (in this implementation can be called only once)
public fun add(self: &mut Kiosk, cap: &KioskOwnerCap, name: String) {
    let uid_mut = self.uid_mut_as_owner(cap);
    df::add(uid_mut, KioskName {}, name)
}

/// Try to read the name of the Kiosk - if set - return Some(String), if not - None
public fun name(self: &Kiosk): Option<String> {
    if (df::exists_(self.uid(), KioskName {})) {
        option::some(*df::borrow(self.uid(), KioskName {}))
    } else {
        option::none()
    }
}
```

## Permissioned apps using the Kiosk Apps API {#permissioned-apps}

Permissioned apps use the Kiosk Apps API to perform actions in the kiosk. They usually imply interaction with a third party and provide guarantees for the storage access (preventing malicious actions from the seller).

Just having access to the `uid` is often not enough to build an app due to the security limitations. Only the owner of a kiosk has full access to the `uid`, which means that an app involving a third party would require involvement from the kiosk owner in every step of the process.

In addition to limited and constrained access to storage, app permissions are also owner dependent. In the default setup, no party can place or lock items in a kiosk without its owner's consent. As a result, some cases such as collection bidding (offering X SUI for any item in a collection) requires the kiosk owner to approve the bid.

## kiosk_extension module

The `kiosk_extension` module addresses concerns over owner bottlenecks and provides more guarantees for storage access. The module provides a set of functions that enable you to perform certain actions in the kiosk without the kiosk owner's involvement and have a guarantee that the storage of the app is not tampered with.

```move
module example::my_extension;

use sui::kiosk_extension;

// ...
```

## App lifecycle

These are the key points in the lifecycle of a Sui Kiosk app:

- You can only install an app with an explicit call in the `kiosk_extension` module.
- A kiosk owner can revoke permissions of an app at any time by calling the `disable` function.
- A kiosk owner can re-enable a disabled app at any time by calling the `enable` function.
- You can only remove apps if the app storage is empty (all items are removed).

## Adding an app

For the app to function, the kiosk owner first needs to install it. To achieve that, an app needs to implement the `add` function that the kiosk owner calls to request all necessary permissions.

### Implementing add function

The signature of the `kiosk_extension::add` function requires the app witness, making it impossible to install an app without an explicit implementation. The following example shows how to implement the `add` function for an app that requires the `place` permission:

```move
module examples::letterbox_ext;

use sui::kiosk_extension;

// ... dependencies

/// The expected set of permissions for extension. It requires `place`.
const PERMISSIONS: u128 = 1;

/// The Witness struct used to identify and authorize the extension.
struct Extension has drop {}

/// Install the Mallbox extension into the Kiosk.
public fun add(kiosk: &mut Kiosk, cap: &KioskOwnerCap, ctx: &mut TxContext) {
    kiosk_extension::add(Extension {}, kiosk, cap, PERMISSIONS, ctx)
}
```

## App permissions

Apps can request permissions from the kiosk owner on installation. Permissions follow the all or nothing principle. If the kiosk owner adds an app, it gets all of the requested permissions; if the kiosk owner then disables an app, it loses all of its permissions.

### Structure

Permissions are represented as a `u128` integer storing a bitmap. Each of the bits corresponds to a permission, the first bit is the least significant bit. The following table lists all permissions and their corresponding bit:

| Bit |	Decimal	| Permission |
| --- | --- | --- |
| 0000 | 0 | No permissions |
| 0001 | 1 | App can place |
| 0010| 2 |	App can place and lock |
| 0011| 3 |	App can place and lock |

:::info

Currently, Sui Kiosk has only two permissions: `place` (first bit) and `lock` and `place` (second bit). The remaining bits are reserved for future use.

:::

### Using permissions in the add function

It's considered good practice to define a constant containing permissions of the app:

```move
module examples::letterbox_ext;
// ... dependencies

/// The expected set of permissions for the app. It requires `place`.
const PERMISSIONS: u128 = 1;

/// The witness struct used to identify and authorize the app.
struct Extension has drop {}

/// Install the Mallbox app into the kiosk and request `place` permission.
public fun add(kiosk: &mut Kiosk, cap: &KioskOwnerCap, ctx: &mut TxContext) {
    kiosk_extension::add(Extension {}, kiosk, cap, PERMISSIONS, ctx)
}
```

### Accessing protected functions

If an app requests and is granted permissions (and isn't disabled), it can access protected functions. The following example shows how to access the `place` function:

```move
module examples::letterbox_ext;
// ...

/// Emitted when trying to place an item without permissions.
const ENotEnoughPermissions: u64 = 1;

/// Place a letter into the kiosk without the `KioskOwnerCap`.
public fun place(kiosk: &mut Kiosk, letter: Letter, policy: &TransferPolicy<T>) {
    assert!(kiosk_extension::can_place<Extension>(kiosk), ENotEnoughPermissions)

    kiosk_extension::place(Extension {}, kiosk, letter, policy)
}
```
Currently, two functions are available:

- `place<Ext, T>(Ext, &mut Kiosk, T, &TransferPolicy<T>)` - similar to place
- `lock<Ext, T>(Ext, &mut Kiosk, T, &TransferPolicy<T>)` - similar to lock

### Checking permissions

Use the `can_place<Ext>(kiosk: &Kiosk): bool` function to check if the app has the `place` permission. Similarly, you can use the `can_lock<Ext>(kiosk: &Kiosk): bool` function to check if the app has the `lock` permission. Both functions make sure that the app is enabled, so you don't need to explicitly check for that.

## App storage

Every app gets its isolated storage as a bag type that only the app module can access (providing the app witness). See [The Move Book](https://move-book.com/programmability/dynamic-collections.html) to learn more about dynamic collections, like bags, available in Move. After you install an app, it can use the storage to store its data. Ideally, the storage should be managed in a way that allows the app to be removed from the kiosk if there are no active trades or other activities happening at the moment.

The storage is always available to the app if it is installed. The owner of a kiosk can't access the storage of the app if the logic for it is not implemented.

### Accessing the storage

An installed app can access the storage mutably or immutably using one of the following functions:

- `storage(_ext: Extension {}, kiosk: &Kiosk): Bag`: returns a reference to the storage of the app. Use the function to read the storage.
- `storage_mut(_ext: Extension {}, kiosk: &mut Kiosk): &mut Bag`: returns a mutable reference to the storage of the app. Use the function to read and write to the storage.

## Disabling and removing

The kiosk owner can disable any app at any time. Doing so revokes all permissions of the app and prevents it from performing any actions in the kiosk. The kiosk owner can also re-enable the app at any time.

Disabling an app does not remove it from the kiosk. An installed app has access to its storage until completely removed from the kiosk.

### Disabling an app

Use the `disable<Ext>(kiosk: &mut Kiosk, cap: &KioskOwnerCap)` function to disable an app. It revokes all permissions of the app and prevents it from performing any protected actions in the kiosk.

**Example PTB**

```javascript
let txb = new TransactionBuilder();
let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');

txb.moveCall({
    target: '0x2::kiosk_extension::disable',
    arguments: [ kioskArg, capArg ],
    typeArguments: '<letter_box_package>::letterbox_ext::Extension'
});
```

### Removing an app

You can remove an app only if the storage is empty. Use the `remove<Ext>(kiosk: &mut Kiosk, cap: &KioskOwnerCap)` function to facilitate removal. The function removes the app, unpacks the app storage and configuration and rebates the storage cost to the kiosk owner. Only the kiosk owner can perform this action.

The call fails if the storage is not empty.

**Example PTB**

```javascript
let txb = new TransactionBuilder();
let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');

txb.moveCall({
    target: '0x2::kiosk_extension::remove',
    arguments: [ kioskArg, capArg ],
    typeArguments: '<letter_box_package>::letterbox_ext::Extension'
});
```

## Related links

- [NFT Rental](../guides/developer/nft/nft-rental.mdx): An example implementation of the Kiosk Apps standard that enables renting NFTs.
- [NFT Rental repository](https://github.com/MystenLabs/sui/tree/main/examples/move/nft-rental): GitHub repo that contains the source code for the NFT Rental app.

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3.mdx
```
---
title: DeepBookV3
description: A central limit order book that offers features and functionality for marketplaces on Sui. Token exchanges leveraging the layer can feature transparency, a full range of trading options, and customer privacy.
---

DeepBook is a next-generation decentralized central limit order book (CLOB) built on Sui. DeepBook leverages Sui's parallel execution and low transaction fees to bring a highly performant, low-latency exchange on chain. 

The latest version delivers new features including flash loans, governance, improved account abstraction, and enhancements to the existing matching engine. This version also introduces its own tokenomics with the [DEEP token](https://suiscan.xyz/mainnet/coin/0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP/txs), which you can stake for additional benefits. 

DeepBook does not include an end-user interface for token trading. Rather, it offers built-in trading functionality that can support token trades from decentralized exchanges, wallets, or other apps. The available SDK abstracts away a lot of the complexities of interacting with the chain and building programmable transaction blocks, lowering the barrier of entry for active market making.

## DeepBook tokenomics  

The DEEP token pays for trading fees on the exchange. Users can pay trading fees using DEEP tokens or input tokens, but owning, using, and staking DEEP continues to provide the most benefits to active DeepBook traders on the Sui network.

As an example, governance determines the fee for paying in DEEP tokens, which is 20% lower than the fee for using input tokens.

Users that stake DEEP can enjoy taker and maker incentives. Taker incentives can reduce trading fees by half, dropping them to as low as 0.25 basis points (bps) on stable pairs and 2.5 bps on volatile pairs. Maker incentives are rebates earned based on maker volume generated.

## Liquidity support

Similar to order books for other market places, DeepBook's CLOB architecture enables you to enter market and limit orders. You can sell SUI tokens, referred to as an "ask," can set your price, referred to as a limit order, or sell at the market's going rate. If you are seeking to buy SUI, referred to as a "bid," you can pay the current market price or set a limit price. Limit orders only get fulfilled if the CLOB finds a match between a buyer and seller.

If you put in a limit order for 1,000 SUI, and no single seller is currently offering that quantity of tokens, DeepBook automatically pools the current asks to meet the quantity of your bid.

## Transparency and privacy

As a CLOB, DeepBook works like a digital ledger, logging bids and asks in chronological order and automatically finding matches between the two sides. It takes into account user parameters on trades such as prices.

The digital ledger is open so people can view the trades and prices, giving clear proof of fairness. You can use this transparency to create metrics and dashboards to monitor trading activity.

## Documentation

This documentation outlines the design of DeepBook, its public endpoints, and provides guidance for integrations. The SDK abstracts away a lot of the complexities of interacting with the chain and building programmable transaction blocks, lowering the barrier of entry for active market making.

## Open source

DeepBook is open for community development. You can use the [Sui Improvement Proposals](https://github.com/sui-foundation/sips?ref=blog.sui.io) (SIPs) process to suggest changes to make DeepBook better.

[DeepBook repository on GitHub](https://github.com/MystenLabs/deepbookv3).

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3-sdk.mdx
```
---
title: DeepBookV3 SDK
---

The DeepBook typescript SDK abstracts away the transaction calls, allowing for direct interactions with the DeepBook package.

- [SDK Repository](https://github.com/MystenLabs/ts-sdks/tree/main/packages/deepbook-v3)
- [NPM version](https://www.npmjs.com/package/@mysten/deepbook-v3)

## Install

To use the SDK in your projects, install the `@mysten/deepbook` package.

```sh npm2yarn
npm install @mysten/deepbook-v3
```

## Constants

The DeepBookV3 SDK includes a constants file (`/utils/constants.ts`) that maintains the latest deployed addresses for DeepBook, as well as a few staple coins and pools.

<details>
<summary>
`constants.ts`
</summary>
{@inject: github:MystenLabs/ts-sdks/packages/deepbook-v3/src/utils/constants.ts}
</details>

## DeepBookClient

To work with DeepBook, you must create a `DeepBookClient`. To construct the `DeepBookClient`, pass in a `SuiClient`, the sender address, and environment. The [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript) provides the `SuiClient` and key functionality necessary to process transactions. The following example imports those libraries, as well.

```tsx
import { DeepBookClient } from '@mysten/deepbook-v3';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { decodeSuiPrivateKey } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';

class DeepBookMarketMaker {
	dbClient: DeepBookClient; // For building transactions
	suiClient: SuiClient; // For executing transactions
	keypair: Ed25519Keypair; // For signing transactions

	constructor(privateKey: string, env: 'testnet' | 'mainnet') {
		this.keypair = this.getSignerFromPK(privateKey);
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: env,
			client: this.suiClient,
		});
	}

	getSignerFromPK = (privateKey: string): Ed25519Keypair => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	getActiveAddress() {
		return this.keypair.toSuiAddress();
	}
}
```

## Keys: Coin, Pool, and Manager {#keys}

Functions that require the input of a coin, pool, or a manager require the key of any such object as the parameter. The SDK manages a key:value relationship of this data in memory. Some default data comes with the SDK (as seen in `utils/constants.ts`). Coins are stored in a `CoinMap` and pools in a `PoolMap` in the config.

### Balance manager

Before placing any trade, you must supply a balance manager address to the client. The manager key points to an object defined by the `BalanceManager` interface in the client. [BalanceManager docs](./deepbookv3/balance-manager.mdx). Initialize the balance manager with the client. If you don't create a balance manager, you can rely on the client to create one, but then the user must reinitialize the client.

Example using an existing balance manager:

```tsx
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { decodeSuiPrivateKey } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { config } from 'dotenv';

import { DeepBookClient } from '../src';
import { BalanceManager } from './types';

config();

// Used wherever balance manager key is required
const BALANCE_MANAGER_KEY = 'MANAGER_1';

class DeepBookMarketMaker {
	dbClient: DeepBookClient; // For building transactions
	suiClient: SuiClient; // For executing transactions
	keypair: Ed25519Keypair; // For signing transactions
	env: 'testnet' | 'mainnet';

	constructor(privateKey: string, env: 'testnet' | 'mainnet') {
		this.env = env;
		this.keypair = this.getSignerFromPK(privateKey);
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: env,
			client: this.suiClient,
			balanceManagers: this.getBalanceManagers(),
		});
	}

	getSignerFromPK = (privateKey: string): Ed25519Keypair => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	getActiveAddress() {
		return this.keypair.toSuiAddress();
	}

	getBalanceManagers(): { [key: string]: BalanceManager } {
		// Used wherever balance manager key is required
		const balanceManagerAddress = process.env.BALANCE_MANAGER_ADDRESS;
		const balanceManagerTradeCap = process.env.BALANCE_MANAGER_TRADE_CAP;
		if (!balanceManagerAddress) {
			throw new Error('No balance manager address found');
		}
		return {
			[BALANCE_MANAGER_KEY]: {
				address: balanceManagerAddress,
				tradeCap: balanceManagerTradeCap,
			},
		};
	}
}
```

Example creating a balance manager:

```tsx
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { decodeSuiPrivateKey } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';

import { DeepBookClient } from '../src';
import { BalanceManager } from './types';

// Used wherever balance manager key is required
const BALANCE_MANAGER_KEY = 'MANAGER_1';

class DeepBookMarketMaker {
	dbClient: DeepBookClient; // For building transactions
	suiClient: SuiClient; // For executing transactions
	keypair: Ed25519Keypair; // For signing transactions
	env: 'testnet' | 'mainnet';

	constructor(privateKey: string, env: 'testnet' | 'mainnet') {
		this.env = env;
		this.keypair = this.getSignerFromPK(privateKey);
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: env,
			client: this.suiClient,
		});
	}

	getSignerFromPK = (privateKey: string): Ed25519Keypair => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	getActiveAddress() {
		return this.keypair.toSuiAddress();
	}

	async createBalanceManagerAndReinitialize() {
		let tx = new Transaction();
		tx.add(this.dbClient.balanceManager.createAndShareBalanceManager());

		const res = await this.suiClient.signAndExecuteTransaction({
			transaction: tx,
			signer: this.keypair,
			options: {
				showEffects: true,
				showObjectChanges: true,
			},
		});

		// @ts-ignore
		const balanceManagerAddress = res.objectChanges?.find((change) => {
			return change.type === 'created' && change.objectType.includes('BalanceManager');
		})?.['objectId'];

		const balanceManagers: { [key: string]: BalanceManager } = {
			[BALANCE_MANAGER_KEY]: {
				address: balanceManagerAddress,
				tradeCap: undefined,
			},
		};

		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: this.env,
			client: this.suiClient,
			balanceManagers: balanceManagers,
		});
	}
}
```

### Coin

The SDK comes with four default coins on Testnet and five default coins on Mainnet.

**Default Testnet coins**

- DEEP
- SUI
- DBUSDC
- DBUSDT

**Default Mainnet coins**

- DEEP
- SUI
- USDC
- USDT
- WETH

You can also initialize the SDK with custom coins to interact with pools that are not supported by default. To do this, create a `CoinMap` object and pass it to the constructor of the client.

### Pool

Similar to coins, the SDK comes with default pools. You can provide a `PoolMap` during construction to override this behavior.

```tsx
import { decodeSuiPrivateKey } from '@mysten/sui.js/cryptography';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import type { Keypair } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import type { Transaction } from '@mysten/sui/transactions';

import { DeepBookClient } from '../src/index.js'; // Adjust path according to new structure
import type { BalanceManager } from '../src/types/index.js';

export class DeepBookMarketMaker extends DeepBookClient {
	keypair: Keypair;
	suiClient: SuiClient;

	constructor(
		keypair: string | Keypair,
		env: 'testnet' | 'mainnet',
		balanceManagers?: { [key: string]: BalanceManager },
		adminCap?: string,
	) {
		let resolvedKeypair: Keypair;

		if (typeof keypair === 'string') {
			resolvedKeypair = DeepBookMarketMaker.#getSignerFromPK(keypair);
		} else {
			resolvedKeypair = keypair;
		}

		const address = resolvedKeypair.toSuiAddress();

		super({
			address: address,
			env: env,
			client: new SuiClient({
				url: getFullnodeUrl(env),
			}),
			balanceManagers: balanceManagers,
			adminCap: adminCap,
		});

		this.keypair = resolvedKeypair;
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
	}

	static #getSignerFromPK = (privateKey: string) => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	signAndExecute = async (tx: Transaction) => {
		// remove arguments
		return this.suiClient.signAndExecuteTransaction({
			transaction: tx,
			signer: this.keypair,
			options: {
				showEffects: true,
				showObjectChanges: true,
			},
		});
	};

	getActiveAddress() {
		return this.keypair.getPublicKey().toSuiAddress();
	}
}
```

### Example setup

The following example uses the default pools and coins provided.

```tsx
import { Transaction } from '@mysten/sui/transactions';

import { DeepBookMarketMaker } from './deepbookMarketMaker.js';

(async () => {
	const privateKey = ''; // Can encapsalate this in a .env file

	// Initialize with balance managers if created
	const balanceManagers = {
		MANAGER_1: {
			address: '',
			tradeCap: '',
		},
	};
	const mmClient = new DeepBookMarketMaker(privateKey, 'testnet', balanceManagers);

	const tx = new Transaction();

	// Read only call
	console.log(await mmClient.checkManagerBalance('MANAGER_1', 'SUI'));
	console.log(await mmClient.getLevel2Range('SUI_DBUSDC', 0.1, 100, true));

	// Balance manager contract call
	mmClient.balanceManager.depositIntoManager('MANAGER_1', 'DBUSDT', 10000)(tx);
	mmClient.balanceManager.withdrawAllFromManager(
		'MANAGER_1',
		'DBUSDT',
		mmClient.getActiveAddress(),
	)(tx);

	// Example custom PTB call in DeepBookMarketMaker class
	mmClient.placeLimitOrderExample(tx);
	mmClient.flashLoanExample(tx);

	let res = await mmClient.signAndExecute(tx);

	console.dir(res, { depth: null });
})();
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/coin.mdx
```
---
title: Coin Standard
description: The Sui Coin standard enables you to create a broad range of fungible tokens on the Sui network to satisfy a number of use cases. The Coin standed on Sui is equivalent to the ERC-20 technical standard on Ethereum.
sidebar_label: Coin
---

The Coin standard is the technical standard used for smart contracts on Sui for creating coins on the Sui blockchain. The standardization of coin creation on Sui means that wallets, exchanges, and other smart contracts can manage coins created on Sui the same as they manage SUI, without any additional processing logic.

See [Sui Tokenomics](../concepts/tokenomics.mdx) to learn more about the SUI native coin and its use on the Sui network.

Although coins on Sui follow the Coin standard, they can offer specialized abilities. For example, you can create a regulated token that allows its creator to add specific addresses to a deny list, so that the identified addresses cannot use the token as inputs to transactions.

See the [coin module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/coin.md) documentation for all available options when creating a coin-type token on Sui.

## Fungible tokens

In the Sui blockchain ecosystem, the `Coin<T>` type represents open-loop fungible tokens (see `Token<T>` for closed-loop tokens). Coins are denominated by their type parameter, `T`, which is also associated with metadata (like name, symbol, decimal precision, and so on) that applies to all instances of `Coin<T>`. The `sui::coin` module exposes an interface over `Coin<T>` that treats it as fungible, meaning that a unit of `T` held in one instance of `Coin<T>` is interchangeable with any other unit of `T`, much like how traditional fiat currencies operate.

:::info

The documentation refers to fungible tokens created on Sui using the Coin standard as "coins". For fungible tokens created on Sui using the [Closed-Loop Token standard](./closed-loop-token.mdx), the documentation uses the term "tokens". In practice, the terms for both these objects are often interchangeable.

:::

## Treasury capability

When you create a coin using the `coin::create_currency` function, the publisher of the smart contract that creates the coin receives a `TreasuryCap` object. The `TreasuryCap` object is required to mint new coins or to burn current ones. Consequently, only addresses that have access to this object are able to maintain the coin supply on the Sui network.

The `TreasuryCap` object is transferable, so a third party can take over the management of a coin that you create if you transfer the `TreasuryCap`. After transferring the capability, however, you are no longer able to mint and burn tokens yourself.

## Regulated coins

The Coin standard includes the ability to create regulated coins. To create a regulated coin, you use the `coin::create_regulated_currency_v2` function (which uses the `coin::create_currency` function itself), but which also returns a `DenyCap` capability. The `DenyCap` capability allows the bearer to maintain a list of addresses that aren't allowed to use the token.

:::tip

The [regulated-coin-sample repository](https://github.com/MystenLabs/regulated-coin-sample) provides an example of regulated coin creation.

:::

### DenyList object

The list of addresses that aren't able to use a particular regulated coin is held within a system-created `DenyList` shared object. If you have access to the `DenyCap`, then you can use the `coin::deny_list_v2_add` and `coin::deny_list_v2_remove` functions to add and remove addresses.

### Global pause switch

Regulated coin objects include an `allow_global_pause` Boolean field. When set to `true`, the bearer of the `DenyCapV2` object for the coin type can use the `coin::deny_list_v2_enable_global_pause` function to pause coin activity indefinitely. Immediately upon the bearer initiating the pause, the network disallows the coin type as input for any transactions. At the start of the next epoch (epochs last ~24 hours), the network additionally disallows all addresses from receiving the coin type.

When the bearer of the `DenyCapV2` object for the coin type removes the pause using `coin::deny_list_v2_disable_global_pause`, the coins are immediately available to use again as transaction inputs. Addresses cannot receive the coin type, however, until the following epoch.

The global pause functionality does not affect the deny list for the coin. After clearing the pause for the coin, any addresses included in the deny list are still unable to interact with the coin.

## Coin metadata

Each coin you create includes metadata that describes it. Typically, smart contracts freeze this object upon creation using the `transfer::public_freeze_object` function because the metadata for coins should almost never change. Regulated coins freeze the metadata they create automatically.

Regular coins using the Coin standard include a `CoinMetadata` object. As mentioned previously, regulated coins build on top of the same procedure that creates regular coins, so they receive the same metadata object in addition to a `RegulatedCoinMetadata` object that includes deny list information.

The fields of the metadata objects include the following:

#### CoinMetadata

| Name          | Description                                                                                                                                                                                              |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `id`          | The object ID of the metadata for the token.                                                                                                                                                             |
| `decimals`    | The number of decimals the token uses. If you set this field to `3`, then a token of value `1000` would display as `1.000`.                                                                              |
| `name`        | Name of the coin.                                                                                                                                                                                        |
| `symbol`      | Symbol for the coin. This might be the same as `name`, but is typically fewer than five all capital letters. For example, `SUI` is the `symbol` for the native coin on Sui but its `name` is also `SUI`. |
| `description` | A short description to describe the token.                                                                                                                                                               |
| `icon_url`    | The URL for the token's icon, used for display in wallets, explorers, and other apps.                                                                                                                    |

#### RegulatedCoinMetadata

| Name                   | Description                                                                                                                                    |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `id`                   | The ID of the metadata object for the regulated token.                                                                                         |
| `coin_metadata_object` | The ID of the underlying metadata object (`CoinMetadata`) for the regulated token.                                                             |
| `deny_cap_object`      | The ID of the token's `DenyCapV2` object, which is necessary to maintain the deny list entries that controls who can and cannot use the token. |

## Minting and burning coins

The `coin` module provides the logic for creating and destroying coins on the Sui network (as long as you own the associated `TreasuryCap`). These functions are the same for all coins and each requires the `TreasuryCap` as an input.

### Mint

Use the `coin::mint` function to create new tokens.

{@inject: crates/sui-framework/packages/sui-framework/sources/coin.move#fun=mint noComments}

The signature shows that a `Coin<T>` results from calling the function with a `TreasuryCap`, value for the coin created, and the transaction context. The function updates the total supply in `TreasuryCap` automatically. Upon display, the coin `value` respects the `decimals` value in the metadata. So, if you supply 1000000 as the coin `value` that has a `decimal` value of `6`, the coin's value displays as `1.000000`.

### Burn

Use the `coin::burn` function to destroy current tokens.

{@inject: crates/sui-framework/packages/sui-framework/sources/coin.move#fun=burn noComments}

The signature shows that only the `TreasuryCap` and coin object you want to burn are necessary inputs, returning the amount by which the supply was decreased (value of the coin). The function does not allow you to burn more coins than are available in the supply.

## Adding and removing addresses to and from the deny list

The deny list is only applicable to regulated coins. As mentioned previously, when you create a regulated coin you receive a `DenyCapV2` that authorizes the bearer to add and remove addresses from the system-created `DenyList` object. Any address on the list for your coin is unable to use the coin as an input to transactions starting immediately upon being added. At the epoch that follows address addition to the deny list, the addresses additionally cannot receive the coin type. In other words, an address that gets added to the deny list for a coin type is immediately unable to send the coin. At the start of the following epoch, the address is still unable to send the coin but is also unable to receive it. From that point, the address cannot interact with the coin until expressly removed from the deny list by the `DenyCapV2` bearer.

### Add address to deny list

Use the `coin::deny_list_v2_add` function to add the provided address to the deny list for your coin. The signature for the function is:

{@inject: crates/sui-framework/packages/sui-framework/sources/coin.move#fun=deny_list_v2_add noComments}

When using this function, you provide the `DenyList` object (`0x403`), the `DenyCap` you receive on coin creation, the address to add to the list, and the transaction context. After using this function, the address you provide is unable to use your coin by the next epoch.

### Remove address from deny list

Use the `coin::deny_list_v2_remove` function to remove addresses from the deny list for your coin.

{@inject: crates/sui-framework/packages/sui-framework/sources/coin.move#fun=deny_list_v2_remove noComments}

When using this function, you provide the `DenyList` object (`0x403`), the `DenyCapV2` you receive on coin creation, the address to remove from the list, and the transaction context. If you try to remove an address that isn't on the list, you receive an `ENotFrozen` error and the function aborts. After calling this function, the address you provide is able to use your coin by the next epoch.

### Using an SDK

You can use either the TypeScript or Rust SDK to manipulate the addresses held in the `DenyList` for your coin. The following examples are based on the [regulated coin sample](https://github.com/MystenLabs/regulated-coin-sample).

<Tabs groupId="sdk-language">

<TabItem label="TypeScript" value="typescript">

```ts
const tx = new Transaction();

tx.moveCall({
    target: `0x2::coin::deny_list_v2_add`,
    arguments: [
        tx.object(<SUI-DENY-LIST-OBJECT-ID>),
        tx.object(<DENY-CAP-ID>),
        tx.pure.address(options.address),
    ],
    typeArguments: [<COIN-TYPE>],
});
```

- `<SUI-DENY-LIST-OBJECT-ID>` is `"0x403"`
- `<DENY-CAP-ID>` is the object of type `DenyCapV2<REGULATED_COIN>` you receive from publishing the contract
- `options.address` is the address to ban
- `<COIN-TYPE>` is `${PACKAGE-ID}::${MODULE-NAME}::${COIN-NAME}`, which is `${PACKAGE-ID}::regulated_coin::REGULATED_COIN` based on the example.

</TabItem>

<TabItem label="Rust" value="rust">

```rust
let mut ptb = ProgrammableTransactionBuilder::new();

let deny_list = ptb.obj(ObjectArg::SharedObject {
    id: deny_list.0,
    initial_shared_version: deny_list.1,
    mutable: true,
})?;
let deny_cap = ptb.obj(ObjectArg::ImmOrOwnedObject(deny_cap))?;
let address = ptb.pure(cmd.address())?;
ptb.command(Command::move_call(
    SUI_FRAMEWORK_PACKAGE_ID,
    Identifier::from(COIN_MODULE_NAME),
    Identifier::from_str("deny_list_v2_add".to_string())?,
    vec![<otw-type>],
    vec![deny_list, deny_cap, address],
));

let builder = ptb.finish();
```

- `deny_list` is of type `(ObjectID, SequenceNumber)`.
  - `ObjectID` is `0x403`.
  - `SequenceNumber` is the `initial_shared_version` of the `DenyList` singleton.
- `deny_cap` is the `ObjectRef` (`(ObjectID, SequenceNumber, ObjectDigest)`) of the `DenyCapV2<REGULATED_COIN>` the publisher has received.
- `otw_type` is the `TypeTag` created from `<PACKAGE_ID>::regulated_coin::REGULATED_COIN` type.
- `cmd.address()` returns the address to ban as a `SuiAddress`.

</TabItem>

</Tabs>

## Globally pausing and unpausing regulated coin activity

Globally pausing coin activity is only applicable to regulated coin types.

### Pause coin activity

To pause activity across the network for a regulated coin type with the `allow_global_pause` field set to `true`, use `coin::deny_list_v2_enable_global_pause`. You must provide the `DenyCapV2` object for the coin type to initiate the pause. Transaction activity is paused immediately, and no addresses can receive the coin in the epoch that follows the call to pause.

{@inject: crates/sui-framework/packages/sui-framework/sources/coin.move#fun=deny_list_v2_enable_global_pause noComments}

### Unpause coin activity

To restart network activity for a paused regulated coin, use the `coin::deny_list_v2_disable_global_pause` function. As with pausing, you must provide the `DenyCapV2` object for the coin type. Transaction activity resumes immediately, and addresses can begin receiving the coin in the epoch that follows the call to remove the pause.

{@inject: crates/sui-framework/packages/sui-framework/sources/coin.move#fun=deny_list_v2_disable_global_pause noComments}

## Query coin data

You can use the following functions to retrieve data from coins.

### Metadata

Use the following functions to get the values for the respective fields on the metadata object for coins.

| Function          | Signature                                                                                |
| ----------------- | ---------------------------------------------------------------------------------------- |
| `get_decimals`    | `public fun get_decimals<T>(metadata: &coin::CoinMetadata<T>): u8`                       |
| `get_name`        | `public fun get_name<T>(metadata: &coin::CoinMetadata<T>): string::String`               |
| `get_symbol`      | `public fun get_symbol<T>(metadata: &coin::CoinMetadata<T>): ascii::String`              |
| `get_description` | `public fun get_description<T>(metadata: &coin::CoinMetadata<T>): string::String`        |
| `get_icon_url`    | `public fun get_icon_url<T>(metadata: &coin::CoinMetadata<T>): option::Option<url::Url>` |

### Supply

Use the `coin::supply` function to get the current supply of a given coin.

## Update coin metadata

If the `CoinMetadata` object was not frozen upon creation, you can use the following functions to update its values.

Each function signature is similar. Replace `<FUNCTION-NAME>` and `<ATTRIBUTE-TYPE>` with the values defined in the table to get the signature of each function:

```move
public entry fun <FUNCTION-NAME><T>(
  _treasury: &coin::TreasuryCap<T>,
  metadata: &mut coin::CoinMetadata<T>,
  <ATTRIBUTE-TYPE>
)
```

| `<FUNCTION-NAME>`    | `<ATTRIBUTE-TYPE>`            |
| -------------------- | ----------------------------- |
| `update_name`        | `name: string::String`        |
| `update_symbol`      | `symbol: ascii::String`       |
| `update_description` | `description: string::String` |
| `update_icon_url`    | `url: ascii::String`          |

:::info

`RegulatedCoinMetadata` is frozen upon creation, so there are no functions to update its data.

:::

## Related links

Check out the following content for more information about coins and tokens on Sui:

- [Create a Coin](../guides/developer/coin.mdx): Guide for creating coins and regulated coins in your smart contracts.
- [Closed-Loop Token Standard](./closed-loop-token.mdx): Details the Token standard on Sui.
- [`coin` module rustdoc documentation](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/coin.md): Automated documentation output for the Sui framework `coin` module.
- [`token` module rustdoc documentation](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/token.md): Automated documentation output for the Sui framework `token` module.
- [Tokenomics](../concepts/tokenomics.mdx): Discover the Sui ecosystem and where SUI coins fit within it.

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbook.mdx
```
---
title: DeepBook
description: A central limit order book that offers features and functionality for marketplaces on Sui. Token exchanges leveraging the layer can feature transparency, a full range of trading options, and customer privacy.
---

import DocCardList from '@theme/DocCardList';

DeepBook is a next-generation decentralized central limit order book (CLOB) built on Sui. DeepBook leverages Sui's parallel execution and low transaction fees to bring a highly performant, low-latency exchange on chain. 

## Versioning

The latest development iteration of DeepBook is version 3 (DeepBookV3). [DeepBookV3](./deepbookv3.mdx) is currently available across all Sui networks. [DeepBookV2](./deepbookv2.mdx) is now deprecated. Merge any existing integrations to DeepBookV3. 

## Open source

DeepBook is open for community development. You can use the [Sui Improvement Proposals](https://github.com/sui-foundation/sips?ref=blog.sui.io) (SIPs) process to suggest changes to make DeepBook better.

## Related links

- [DeepBookV3 repository on GitHub](https://github.com/MystenLabs/deepbookv3)
- <a href="/references/framework/deepbook" data-no-link-check>DeepBook framework docs</a>: Autogenerated framework documentation for DeepBookV2.


```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv2.mdx
```
---
title: DeepBookV2
description: A central limit order book that offers features and functionality for marketplaces on Sui. Token exchanges leveraging the layer can feature transparency, a full range of trading options, and customer privacy.
---

{@include: ../snippets/deepbook-v2-dep.mdx}

As Sui's first native liquidity layer, DeepBook provides token trading activity. Token exchanges leveraging the layer can feature transparency, a full range of trading options, and customer privacy. DeepBook operates as a decentralized and permissionless environment to support token trades.

DeepBook is open for community development. You can use the [Sui Improvement Proposals](https://github.com/sui-foundation/sips?ref=blog.sui.io) (SIPs) process to suggest changes to make DeepBook better.

DeepBook does not include an end-user interface for token trading. Rather, it offers built-in trading functionality that can support token trades from decentralized exchanges, wallets, or other apps. You can leverage its SDK to build functionality for token trades and price queries.

## Liquidity support

Similar to order books for other market places, DeepBook's central limit order book (CLOB) architecture enables you to enter market and limit orders. You can sell SUI tokens, referred to as an "ask," can set your price, referred to as a limit order, or sell at the market's going rate. If you are seeking to buy SUI, referred to as a "bid," you can pay the current market price or set a limit amount you're willing to pay. Limit orders only get fulfilled if the CLOB finds a match between a buyer and seller.

If you put in a limit order for 1,000 SUI, and no single seller is currently offering that quantity of tokens, DeepBook automatically pools the current asks to meet the quantity of your bid.

## Transparency and privacy

As a CLOB, DeepBook works like a digital ledger, logging bids and asks in chronological order and automatically finding matches between the two sides. It takes into account user parameters on trades such as prices.

The digital ledger is open so people can view the trades and prices, giving clear proof of fairness. You can use this transparency to create metrics and dashboards to monitor trading activity.


```

../../Downloads/sui-stuff/sui-main/docs/content/standards/closed-loop-token.mdx
```
---
title: Closed-Loop Token
---

Using the Closed-Loop Token standard, you can limit the applications that can use the token and set up custom policies for transfers, spends, and conversions. The [`sui::token` module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/token.md) in the Sui framework defines the standard.

## Background and use cases

The [Coin standard](./coin.mdx) on Sui is an example of an open-loop system - coins are free-flowing, [wrappable](/concepts/object-ownership/wrapped.mdx), [freely transferable](/concepts/transfers/custom-rules.mdx#the-store-ability-and-transfer-rules) and you can store them in any application. The best real world analogy would be cash - hardly regulated and can be freely used and passed.

Some applications, however, require constraining the scope of the token to a specific purpose. For example, some applications might need a token that you can only use for a specific service, or that an authorized account can only use, or a token that you can block certain accounts from using. A real-world analogy would be a bank account - regulated, bank-controlled, and compliant with certain rules and policies.

## Difference with Coin

```mermaid
flowchart RL
    subgraph "&nbsp;&nbsp;Balance has store { u64 }&nbsp;&nbsp;"
        A["Balance&lt;T>
        Supply&lt;T>"];
    end
    subgraph "&nbsp;&nbsp;Coin has key, store { Balance }&nbsp;&nbsp;"
        B["Coin&lt;T>
        TreasuryCap&lt;T>"];
    end
        subgraph "&nbsp;&nbsp;Token has key { Balance }&nbsp;&nbsp;"
        C["Token&lt;T>
        TreasuryCap&lt;T>"];
    end
    B-- to_balance -->A;
    C-- to_coin -->B;
```

```mermaid
flowchart LR
    subgraph "&nbsp;&nbsp;Balance has store { u64 }&nbsp;&nbsp;"
        A["Balance&lt;T>
        Supply&lt;T>"];
    end
    subgraph "&nbsp;&nbsp;Coin has key, store { Balance }&nbsp;&nbsp;"
        B["Coin&lt;T>
        TreasuryCap&lt;T>"];
    end
        subgraph "&nbsp;&nbsp;Token has key { Balance }&nbsp;&nbsp;"
        C["Token&lt;T>
        TreasuryCap&lt;T>"];
    end
    A-- from_balance -->B;
    B-- from_coin -->C;
```

Unlike Coin, which has `key + store` abilities and thus supports wrapping and public transfers, Token has only the `key` ability and cannot be wrapped, stored as a dynamic field, or freely transferred (unless there's a custom policy for that). Due to this restriction, Token **can only be owned by an account** and can't be stored in an application (however, it can be "spent" - see [Spending section](./closed-loop-token/spending.mdx) section).

```move
// defined in `sui::coin`
struct Coin<phantom T> has key, store { id: UID, balance: Balance<T> }

// defined in `sui::token`
struct Token<phantom T> has key { id: UID, balance: Balance<T> }
```

## Compliance and rules

You can set up any rules for transfers, spends, and conversions for the tokens you create. You specify these rules per action in the [TokenPolicy](./closed-loop-token/token-policy.mdx). [Rules](./closed-loop-token/rules.mdx) are custom programmable restrictions that you can use to implement any request authorization or validation logic.

For example, a policy can set a limit on a transfer - `X` tokens per operation; or require user verification before spending tokens; or allow spending tokens only on a specific service.

You can reuse rules across different policies and applications; and you can freely combine rules to create complex policies.

## Public actions

Tokens have a set of public and protected actions that you can use to manage the token. Public actions are available to everyone and don't require any authorization. They have similar APIs to coins, but operate on the `Token` type:

- `token::keep` - send a token to the transaction sender
- `token::join` - join two tokens
- `token::split` - split a token into two, specify the amount to split
- `token::zero` - create an empty (zero balance) token
- `token::destroy_zero` - destroy a token with zero balance

See [Coin Token Comparison](./closed-loop-token/coin-token-comparison.mdx) for coin and token methods comparison.

## Protected actions

Protected actions are ones that issue an [`ActionRequest`](./closed-loop-token/action-request.mdx) - a hot-potato struct that must be resolved for the transaction to succeed. There are three main ways to resolve an `ActionRequest`, most common of which is via the [`TokenPolicy`](./closed-loop-token/token-policy.mdx).

- `token::transfer` - transfer a token to a specified address
- `token::to_coin` - convert a token to a coin
- `token::from_coin` - convert a coin to a token
- `token::spend` - spend a token on a specified address

The previous methods are included in the base implementation, however it is possible to create `ActionRequest`s for custom actions.

## Token policy and rules

Protected actions are disabled by default but you can enable them in a [`TokenPolicy`](./closed-loop-token/token-policy.mdx). Additionally, you can set custom restrictions called [rules](./closed-loop-token/rules.mdx) that a specific action must satisfy for it to succeed.

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/display.mdx
```
---
title: Sui Object Display
description: The Sui Object Display standard is a template engine that enables on-chain management of off-chain representation (display) for a type.
---

The Sui Object Display standard is a template engine that enables on-chain management of off-chain representation (display) for a type. With it, you can substitute data for an object into a template string. The standard doesn’t limit the fields you can set. You can use the  `{property}` syntax to access all object properties, and then insert them as a part of the template string.

Use a `Publisher` object that you own to set `sui::display` for a type. For more information about `Publisher` objects, see [Publisher](https://examples.sui.io/basics/publisher.html) topic in *Sui Move by Example*.

In Sui Move, `Display<T>` represents an object that specifies a set of named templates for the type `T`. For example, for a type `0x2::capy::Capy` the display syntax is:  `Display<0x2::capy::Capy>`.

Sui Full nodes process all objects of the type `T` by matching the `Display` definition, and return the processed result when you query an object with the `{ showDisplay: true }` setting in the query.

## Display properties

The basic set of properties suggested includes:

- `name` - A name for the object. The name is displayed when users view the object.
- `description` - A description for the object. The description is displayed when users view the object.
- `link` - A link to the object to use in an application.
- `image_url` - A URL or a blob with the image for the object.
- `thumbnail_url` - A URL to a **smaller** image to use in wallets, explorers, and other products as a preview.
- `project_url` - A link to a website associated with the object or creator.
- `creator` - A string that indicates the object creator.


### An example Sui Hero module
The following code sample demonstrates how the `Display` for an example `Hero` module varies based on the `name`, `id`, and `image_url` properties of the type `Hero`.
The following represents the template the `init` function defines:

```json
{
    "name": "{name}",
    "link": "https://sui-heroes.io/hero/{id}",
    "image_url": "https://sui-heroes.io/hero/{image_url}",
    "description": "A true Hero of the Sui ecosystem!",
    "project_url": "https://sui-heroes.io",
    "creator": "Unknown Sui Fan"
}
```

```move
/// Example of an unlimited "Sui Hero" collection - anyone can
/// mint their Hero. Shows how to initialize the `Publisher` and how
/// to use it to get the `Display<Hero>` object - a way to describe a
/// type for the ecosystem.
module examples::my_hero;

use std::string::String;

// The creator bundle: these two packages often go together.
use sui::package;
use sui::display;

/// The Hero - an outstanding collection of digital art.
public struct Hero has key, store {
    id: UID,
    name: String,
    image_url: String,
}

/// One-Time-Witness for the module.
public struct MY_HERO has drop {}

/// Claim the `Publisher` object in the module initializer 
/// to then create a `Display`. The `Display` is initialized with
/// a set of fields (but can be modified later) and published via
/// the `update_version` call.
///
/// Keys and values are set in the initializer but could also be
/// set after publishing if a `Publisher` object was created.
fun init(otw: MY_HERO, ctx: &mut TxContext) {
    let keys = vector[
        b"name".to_string(),
        b"link".to_string(),
        b"image_url".to_string(),
        b"description".to_string(),
        b"project_url".to_string(),
        b"creator".to_string(),
    ];

    let values = vector[
        // For `name` one can use the `Hero.name` property
        b"{name}".to_string(),
        // For `link` one can build a URL using an `id` property
        b"https://sui-heroes.io/hero/{id}".to_string(),
        // For `image_url` use an IPFS template + `image_url` property.
        b"ipfs://{image_url}".to_string(),
        // Description is static for all `Hero` objects.
        b"A true Hero of the Sui ecosystem!".to_string(),
        // Project URL is usually static
        b"https://sui-heroes.io".to_string(),
        // Creator field can be any
        b"Unknown Sui Fan".to_string(),
    ];

    // Claim the `Publisher` for the package!
    let publisher = package::claim(otw, ctx);

    // Get a new `Display` object for the `Hero` type.
    let mut display = display::new_with_fields<Hero>(
        &publisher, keys, values, ctx
    );

    // Commit first version of `Display` to apply changes.
    display.update_version();

    transfer::public_transfer(publisher, ctx.sender());
    transfer::public_transfer(display, ctx.sender());
}

/// Anyone can mint their `Hero`!
public fun mint(name: String, image_url: String, ctx: &mut TxContext): Hero {
    Hero {
        id: object::new(ctx),
        name,
        image_url
    }
}
```

## Work with Object Display

The `display::new<T>` call creates a `Display`, either in a custom function or module initializer, or as part of a programmable transaction.
The following code sample demonstrates how to create a `Display`:

```move
module sui::display;

/// Get a new Display object for the `T`.
/// Publisher must be the publisher of the T, `from_package`
/// check is performed.
public fun new<T>(pub: &Publisher): Display<T> { /* ... */ }
```

After you create the `Display`, you can modify it. The following code sample demonstrates how to modify a `Display`:

```move
module sui::display;

/// Sets multiple fields at once
public fun add_multiple(
    self: &mut Display,
    keys: vector<String>,
    values: vector<String>
) { /* ... */ }

/// Edit a single field
public fun edit(self: &mut Display, key: String, value: String) { /* ... */ }

/// Remove a key from Display
public fun remove(self: &mut Display, key: String ) { /* ... */ }
```

Next, the `update_version` call applies the changes and sets the `Display` for the `T` by emitting an event. Full nodes receive the event and use the data in the event to retrieve a template for the type.

The following code sample demonstrates how to use the `update_version` call:

```move
module sui::display;

/// Update the version of Display and emit an event
public fun update_version(self: &mut Display) { /* ... */ }
```

## Sui utility objects

In Sui, utility objects enable authorization for capabilities. Almost all modules have features that can be accessed only with the required capability. Generic modules allow one capability per application, such as a marketplace. Some capabilities mark ownership of a shared object on-chain, or access the shared data from another account.
With capabilities, it is important to provide a meaningful description of objects to facilitate user interface implementation. This helps avoid accidentally transferring the wrong object when objects are similar. It also provides a user-friendly description of items that users see.

The following example demonstrates how to create a capy capability:

```move
module capy::utility;

/// A capability which grants Capy Manager permission to add
/// new genes and manage the Capy Market
public struct CapyManagerCap has key, store { id: UID }
```

## Typical objects with data duplication

A common case with in-game items is to have a large number of similar objects grouped by some criteria. It is important to optimize their size and the cost to mint and update them. Typically, a game uses a single source image or URL per group or item criteria. Storing the source image inside of every object is not optimal.
In some cases, users mint in-game items when a game allows them or when they purchase an in-game item. To enable this, some IPFS/Arweave metadata must be created and stored in advance. This requires additional logic that is usually not related to the in-game properties of the item.

The following example demonstrates how to create a Capy:

```move
module capy::capy_items;

use std::string::String;

/// A wearable Capy item. For some items there can be an
/// unlimited supply. And items with the same name are identical.
public struct CapyItem has key, store {
    id: UID,
    name: String
}
```

## Unique objects with dynamic representation

Sui Capys use dynamic image generation. When a Capy is born, its attributes determine the Capy’s appearance, such as color or pattern. When a user puts an item on a Capy, the Capy’s appearance changes. When users put multiple items on a Capy, there’s a chance of a bonus for a combination of items.

To implement this, the Capys game API service refreshes the image in response to a user-initiated change. The URL for a Capy is a template with the `capy.id`. But storing the full URL - as well as other fields in the Capy object due to their diverse population - also leads to users paying for excess storage and increased gas fees.

The following example demonstrates how to implement dynamic image generation:

```move
module capy::capy;

/// A Capy - very diverse object with different combination
/// of genes. Created dynamically + for images a dynamic SVG
/// generation is used.
public struct Capy has key, store {
    id: UID,
    genes: vector<u8>
}
```

## Objects with unique static content

This is the simplest scenario - an object represents everything itself. It is very easy to apply a metadata standard to an object of this kind, especially if the object stays immutable forever. However, if the metadata standard evolves and some ecosystem projects add new features for some properties, this object always stays in its original form and might require backward-compatible changes.

```move
module sui::devnet_nft;

use std::string::String;

/// A Collectible with a static data. URL, name, description are
/// set only once on a mint event
public struct DevNetNFT has key, store {
    id: UID,
    name: String,
    description: String,
    url: String,
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3-sdk/flash-loans.mdx
```
---
title: Flash Loans SDK
sidebar_label: Flash Loans
---

A flash loan is one where the borrowing and returning of loans from pools is performed within a single programmable transaction block. The SDK exposes functions that allow you to implement this functionality. See [Flash Loans](https://docs.sui.io/standards/deepbookv3/flash-loans) for more details on the API.

## Flash loan functions

The DeepBookV3 SDK provides the following flash loan related functions. 

### borrowBaseAsset

Use `borrowBaseAsset` to borrow a base asset from the pool identified by the `poolKey` value you provide. The call returns a function that takes a `Transaction` object

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `borrowAmount`: Number that represents the amount to borrow from the pool.

```tsx
borrowBaseAsset(poolKey: string, borrowAmount: number);
```

### returnBaseAsset

Use `returnBaseAsset` to return the base asset to the pool identified by the `poolKey` value you provide. The call returns a function that takes a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `borrowAmount`: Number that represents the amount to borrow from the pool.
- `baseCoinInput`: Coin object representing the base asset to be returned.
- `flashLoan`: Flash loan object representing the loan to be settled.

```tsx
returnBaseAsset(
  {
    poolKey: string,
    borrowAmount: number,
    baseCoinInput: TransactionObjectArgument,
    flashLoan: TransactionObjectArgument,
  }
)
```

### borrowQuoteAsset

Use `borrowQuoteAsset` to borrow a quote asset from the pool identified by the `poolKey` value you provide. The call returns a function that takes a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `borrowAmount`: Number that represents the amount to borrow from the pool.

```tsx
borrowQuoteAsset(poolKey: string, borrowAmount: number);
```

### returnQuoteAsset

Use `returnQuoteAsset` to return a quote asset to the pool identified by the `poolKey` you provide. The call returns a function that takes a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `borrowAmount`: Number that represents the amount to borrow from the pool.
- `baseCoinInput`: Coin object representing the quote asset to be returned.
- `flashLoan`: Flash loan object representing the loan to be settled.

```tsx
returnQuoteAsset(
  poolKey: string,
  borrowAmount: number,
  quoteCoinInput: TransactionObjectArgument,
  flashLoan: TransactionObjectArgument,
);
```

## Flash loan example

The following example demonstrates flash loan usage in `DeepBookMarketMaker` class.
    
```tsx
// Example of a flash loan transaction
// Borrow 1 DEEP from DEEP_SUI pool
// Swap 0.5 DBUSDC for SUI in SUI_DBUSDC pool, pay with deep borrowed
// Swap SUI back to DEEP
// Return 1 DEEP to DEEP_SUI pool
flashLoanExample = async (tx: Transaction) => {
  const borrowAmount = 1;
  const [deepCoin, flashLoan] = tx.add(this.flashLoans.borrowBaseAsset('DEEP_SUI', borrowAmount));

  // Execute trade using borrowed DEEP
  const [baseOut, quoteOut, deepOut] = tx.add(
    this.deepBook.swapExactQuoteForBase({
      poolKey: 'SUI_DBUSDC',
      amount: 0.5,
      deepAmount: 1,
      minOut: 0,
      deepCoin: deepCoin,
    }),
  );

  tx.transferObjects([baseOut, quoteOut, deepOut], this.getActiveAddress());

  // Execute second trade to get back DEEP for repayment
  const [baseOut2, quoteOut2, deepOut2] = tx.add(
    this.deepBook.swapExactQuoteForBase({
      poolKey: 'DEEP_SUI',
      amount: 10,
      deepAmount: 0,
      minOut: 0,
    }),
  );

  tx.transferObjects([quoteOut2, deepOut2], this.getActiveAddress());

  // Return borrowed DEEP
  const loanRemain = tx.add(
    this.flashLoans.returnBaseAsset('DEEP_SUI', borrowAmount, baseOut2, flashLoan),
  );
  
  // Send the remaining coin to user's address
  tx.transferObjects([loanRemain], this.getActiveAddress());
};
```
```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3-sdk/swaps.mdx
```
---
title: Swaps
---

DeepBookV3 provides a swap-like interface commonly seen in automatic market makers (AMMs). The DeepBookV3 SDK provides functions to leverage the features of this interface. See [Swaps](../deepbookv3/swaps.mdx) in the API section for more details.

## Swap functions

The SDK provides the following functions to perform swaps between the base and quote asset.

### swapExactBaseForQuote

Use `swapExactBaseForQuote` to swap exact base amount for quote amount. The call returns a function that takes a `Transaction` object.

**Parameters**

- `params`: `SwapParams` object that represents the parameters for the swap.

```tsx
swapExactBaseForQuote({ params: SwapParams });
```

### swapExactQuoteForBase

Use `swapExactQuoteForBase` to swap exact quote amount for base amount. The call returns a function that takes a `Transaction` object. 

**Parameters**

- `params`: `SwapParams` object that represents the parameters for the swap.

```tsx
swapExactQuoteForBase({ params: SwapParams });
```

### Examples

The following examples demonstrate custom swap functions that you can place into the `DeepBookMarketMaker` class. Base coin, quote coin, and deep coin are automatically determined by the coin available in the user address unless you explicitly pass one in as an argument. You can transfer the coin outputs to their address or execute other operations using the outputs.

```tsx
swapExactBaseForQuote = (tx: Transaction) => {
  const [baseOut, quoteOut, deepOut] = this.deepBook.swapExactBaseForQuote({
    poolKey: 'SUI_DBUSDC',
    amount: 1, // amount of SUI to swap
    deepAmount: 1, // amount of DEEP to pay as fees, excess is returned
    minOut: 0.1, // minimum amount of DBUSDC to receive or transactionf fails
  })(tx);

  // Transfer received coins to own address
  tx.transferObjects([baseOut, quoteOut, deepOut], this.getActiveAddress());
};

swapExactQuoteForBase = (tx: Transaction) => {
  const [baseOut, quoteOut, deepOut] = this.deepBook.swapExactQuoteForBase({
    poolKey: 'SUI_DBUSDC',
    amount: 1, // amount of DBUSDC to swap
    deepAmount: 1, // amount of DEEP to pay as fees, excess is returned
    minOut: 0.1, // minimum amount of SUI to receive or transactionf fails
  })(tx);

  // Transfer received coins to own address
  tx.transferObjects([baseOut, quoteOut, deepOut], this.getActiveAddress());
};
```
```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3-sdk/orders.mdx
```
---
title: Orders SDK
sidebar_label: Orders
---

Placing orders is a main function of any DeepBook integration. Before you can place orders, though, you must first set up a balance manager. See [DeepBookV3 SDK](../deepbookv3-sdk.mdx) for information on setting up a balance manager.

## Order functions

The DeepBookV3 SDK provides the following functions for leveraging orders against pools.

### placeLimitOrder

Use `placeLimitOrder` to place limit orders. The call returns a function that takes a `Transaction` object.

**Parameters**

- `params`: `SwapParams` object that represents the parameters for the swap.

```tsx
placeLimitOrder({ params: PlaceLimitOrderParams });
```

### placeMarketOrder

Use `placeMarketOrder` to place market orders. The call returns a function that takes a `Transaction` object.

**Parameters**

- `params`: `SwapParams` object that represents the parameters for the swap.

```tsx
placeMarketOrder({ params: PlaceMarketOrderParams });
```

### cancelOrder

Use `cancelOrder` to cancel an existing order that is identified by the `orderId` thqt you provide. The call returns a function that takes a `Transaction` object.

:::warning
The `orderId` is the protocol `orderId` generated during order placement, which is different from the client `orderId`.
:::

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `balanceManagerKey`: String that identifies the `BalanceManager`.
- `orderId`: String of the protocol order ID that identifies the order to cancel. 

```tsx
cancelOrder(poolKey: string, balanceManagerKey: string, orderId: string);
```

### cancelAllOrders

Use `cancelAllOrders` to cancel every order for the balance manager whose key you provide. The call returns a function that takes a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `balanceManagerKey`: String that identifies the `BalanceManager`.

```tsx
cancelAllOrders(poolKey: string, balanceManagerKey: string);
```

## Examples

The following examples demonstrate some custom functions for DeepBookV3 orders.

### Limit orders

See the [Order API](../deepbookv3/orders) for the different order types and self matching options.
    
```tsx
// Params for limit order
interface PlaceLimitOrderParams {
    poolKey: string;
    balanceManagerKey: string;
    clientOrderId: string;
    price: number;
    quantity: number;
    isBid: boolean;
    expiration?: number | bigint; // Default no expiration
    orderType?: OrderType; // Default no restrictions
    selfMatchingOption?: SelfMatchingOptions; // Default self matching allowed
    payWithDeep?: boolean; // Default true
}

/**
  * @description Place a limit order
  * @param {PlaceLimitOrderParams} params Parameters for placing a limit order
  * @returns A function that takes a Transaction object
  */
placeLimitOrder = (params: PlaceLimitOrderParams) => (tx: Transaction) => {}

// Example usage in DeepBookMarketMaker class
// Place a bid of 10 DEEP at $0.1
customPlaceLimitOrder = (tx: Transaction) => {
  const poolKey = 'DEEP_DBUSDC'; // Pool key, check constants.ts for more
  const managerKey = 'MANAGER_1'; // Balance manager key, initialized during client creation by user
  tx.add(
    this.deepBook.placeLimitOrder({
      poolKey: poolKey,
      balanceManagerKey: managerKey,
      clientOrderId: '1',
      price: 0.1,
      quantity: 10,
      isBid: true,
      payWithDeep: true,
    }),
  );
};
```

### Place market order

Example of placing a market order.

```tsx
// Params for market order
interface PlaceMarketOrderParams {
    poolKey: string;
    balanceManagerKey: string;
    clientOrderId: string;
    quantity: number;
    isBid: boolean;
    selfMatchingOption?: SelfMatchingOptions;
    payWithDeep?: boolean;
}

// Example usage in DeepBookMarketMaker class
// Place a market sell of 10 SUI in the SUI_DBUSDC pool
customPlaceMarketOrder = (tx: Transaction) => {
  const poolKey = 'SUI_DBUSDC'; // Pool key, check constants.ts for more
  const managerKey = 'MANAGER_1'; // Balance manager key, initialized during client creation by user
  tx.add(
    this.deepBook.placeMarketOrder({
      poolKey: poolKey,
      balanceManagerKey: managerKey,
      clientOrderId: '2',
      quantity: 10,
      isBid: true,
      payWithDeep: true,
    }),
  );
};
```
    
### Cancel an order

Example of canceling a single order in a pool for a balance manager. 
    
```tsx
/**
  * @description Cancel an existing order
  * @param {string} poolKey The key to identify the pool
  * @param {string} balanceManagerKey The key to identify the BalanceManager
  * @param {number} orderId Order ID to cancel
  * @returns A function that takes a Transaction object
  */
cancelOrder = (
  poolKey: string, 
  balanceManagerKey: string, 
  orderId: number
) => (tx: Transaction) => {}

// Example usage in DeepBookMarketMaker class
// Cancel order 12345678 in SUI_DBUSDC pool
cancelOrder = (tx: Transaction) => {
  const poolKey = 'SUI_DBUSDC'; // Pool key, check constants.ts for more
  const managerKey = 'MANAGER_1'; // Balance manager key, initialized during client creation by user
  tx.add(this.deepBook.cancelOrder(poolKey, managerKey, 12345678));
};
```

### Cancel all orders

Example of canceling all orders in a pool for a balance manager.
    
```tsx
/**
  * @description Cancel all open orders for a balance manager
  * @param {string} poolKey The key to identify the pool
  * @param {string} balanceManagerKey The key to identify the BalanceManager
  * @returns A function that takes a Transaction object
  */
cancelAllOrders = (
  poolKey: string, 
  balanceManagerKey: string
) => (tx: Transaction) => {}

// Example usage in DeepBookMarketMaker class
// Cancel order 12345678 in SUI_DBUSDC pool
cancelOrder = (tx: Transaction) => {
  const poolKey = 'SUI_DBUSDC'; // Pool key, check constants.ts for more
  const managerKey = 'MANAGER_1'; // Balance manager key, initialized during client creation by user
  tx.add(this.deepBook.cancelAllOrders(poolKey, managerKey));
};
```
```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3-sdk/staking-governance.mdx
```
---
title: Staking and Governance SDK
sidebar_label: Staking and Governance
---

Examples of interacting with staking and governance. These functions typically require a `balanceManagerKey`, `poolKey`, or both. For details on these keys, see [DeepBookV3 SDK](../deepbookv3-sdk.mdx#keys). The SDK includes some default keys that you can view in the `constants.ts` file. 

See [Staking and Governance](../deepbookv3/staking-governance.mdx) for more information on the staking and governance API.

## Staking and governance functions

### stake

Use `stake` to stake an amount you specify into a specific pool. The call returns a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool.
- `balanceManagerKey`: String that identifies the balance manager.
- `stakeAmount`: Number representing the amount to stake.

```tsx
stake(poolKey: string, balanceManagerKey: string, stakeAmount: number);
```

### unstake

Use `unstake` to unstake from a particular pool. The call returns a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool.
- `balanceManagerKey`: String that identifies the balance manager.

```tsx
unstake(poolKey: string, balanceManagerKey: string);
```

### submitProposal

Use `submitProposal` to submit a governance proposal. The call returns a `Transaction` object.

**Parameters**

- `params`: A `ProposalParams` object that defines the proposal.

```tsx
submitProposal({ params: ProposalParams });
```

### vote

Use `vote` to vote on a proposal. The call returns a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool.
- `balanceManagerKey`: String that identifies the balance manager.
- `proposal_id`: String that identifies the proposal to vote on.

```tsx
vote(poolKey: string, balanceManagerKey: string, proposal_id: string)
```

## Examples

The following examples demonstrate custom staking and governance functions that you can place into the `DeepBookMarketMaker` class. 

### stake custom function

```tsx
stake = (
  poolKey: string, 
  balanceManagerKey: string, 
  stakeAmount: number
) => (tx: Transaction) => {}

// Custom function to stake 100 DEEP in DeepBookMarketMaker class
stake = (tx: Transaction) => {
  const poolKey = 'DBUSDT_DBUSDC';
  const balanceManagerKey = 'MANAGER_1';
  tx.add(this.governance.stake(poolKey, balanceManagerKey, 100));
};
```

### unstake custom function

```tsx
unstake = (
  poolKey: string, 
  balanceManagerKey: string
) => (tx: Transaction) => {}

// Custom function to unstake in DeepBookMarketMaker class
unstake = (tx: Transaction) => {
  const poolKey = 'DBUSDT_DBUSDC';
  const balanceManagerKey = 'MANAGER_1';
  tx.add(this.governance.unstake(poolKey, balanceManagerKey));
};
```

### submitProposal custom function

```tsx
// Proposal params
export interface ProposalParams {
  poolKey: string;
  balanceManagerKey: string;
  takerFee: number;
  makerFee: number;
  stakeRequired: number;
}

submitProposal = (params: ProposalParams) => (tx: Transaction) => {}

// Custom function to submit proposal in DeepBookMarketMaker class
submitProposal = (tx: Transaction) => {
  const poolKey = 'DBUSDT_DBUSDC';
  const balanceManagerKey = 'MANAGER_1';
  tx.add(
    this.governance.submitProposal({
      poolKey,
      balanceManagerKey,
      takerFee: 0.002,
      makerFee: 0.001,
      stakeRequired: 100,
    }),
  );
};
```

### vote custom function

```tsx
vote = (
  poolKey: string, 
  balanceManagerKey: string, 
  proposal_id: string
) => (tx: Transaction) => {}

// Custom function to vote in DeepBookMarketMaker class
vote = (tx: Transaction) => {
  const poolKey = 'DBUSDT_DBUSDC';
  const balanceManagerKey = 'MANAGER_1';
  const proposalID = '0x123456789';
  tx.add(this.governance.vote(poolKey, balanceManagerKey, proposalID));
};
```
```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3-sdk/pools.mdx
```
---
title: Pools SDK
sidebar_label: Pools
---

Pools are shared objects that represent a market. See [Query the Pool](../deepbookv3/query-the-pool.mdx) for more information on pools.

## Pool functions

The DeepBookV3 SDK exposes functions that you can call to read the state of a pool. These functions typically require a `managerKey`, `coinKey`, `poolKey`, or a combination of these. For details on these keys, see [DeepBookV3 SDK](../deepbookv3-sdk.mdx#keys). The SDK includes some default keys that you can view in the `constants.ts` file.

:::tip SDK Unit Handling
Input amounts, quantities, and prices should be provided in standard decimal format (e.g., `10.5` SUI, `0.00001` nBTC). The SDK handles conversion to base units internally. Returned amounts are also in standard decimal format.
:::


### account

Use `account` to retrieve the account information for a `BalanceManager` in a pool, which has the following form:

```tsx
{
  epoch: '511',
  open_orders: {
    constants: [
      '170141211130585342296014727715884105730',
      '18446744092156295689709543266',
      '18446744092156295689709543265'
    ]
  },
  taker_volume: 0,
  maker_volume: 0,
  active_stake: 0,
  inactive_stake: 0,
  created_proposal: false,
  voted_proposal: null,
  unclaimed_rebates: { base: 0, quote: 0, deep: 0 },
  settled_balances: { base: 0, quote: 0, deep: 0 },
  owed_balances: { base: 0, quote: 0, deep: 0 }
}
```

**Parameters**

- `poolKey`: String that identifies the pool to query. 
- `balanceManagerKey`: key of the balance manager defined in the SDK.

```tsx
async account(poolKey: string, managerKey: string) {}
```

### accountOpenOrders

Use `accountOpenOrders` to retrieve open orders for the balance manager and pool with the IDs you provide. The call returns a `Promise` that contains an array of open order IDs.

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `managerKey`: String that identifies the balance manager to query.

```tsx
async accountOpenOrders(poolKey: string, managerKey: string) {}
```

### checkManagerBalance

Use `checkManagerBalance` to check the balance manager for a specific coin. The call returns a `Promise` in the form:

```
{ 
  coinType: string,
  balance: number 
}
```

**Parameters**

- `managerKey`: String that identifies the balance manager to query.
- `coinKey`: String that identifies the coin to query the balance of.

```tsx
async checkManagerBalance(managerKey: string, coinKey: string) {}
```

### getOrder

Use `getOrder` to retrieve an order's information. The call returns a `Promise` in the `Order` struct, which has the following form:

```tsx
{
  balance_manager_id: {
    bytes: '0x6149bfe6808f0d6a9db1c766552b7ae1df477f5885493436214ed4228e842393'
  },
  order_id: '9223372036873222552073709551614',
  client_order_id: '888',
  quantity: '50000000',
  filled_quantity: '0',
  fee_is_deep: true,
  order_deep_price: { asset_is_base: false, deep_per_asset: '0' },
  epoch: '440',
  status: 0,
  expire_timestamp: '1844674407370955161'
}
```

**Parameters**

`poolKey`: String that identifies the pool to query.
`orderId`: ID of the order to query.

```tsx
async getOrder(poolKey: string, orderId: string) {}
```

### getQuoteQuantityOut

Use `getQuoteQuantityOut` to retrieve the quote quantity out for the base quantity you provide. The call returns a `Promise` in the form:
```
{ 
  baseQuantity: number,
  baseOut: number,
  quoteOut: number,
  deepRequired: number 
}
```
where `deepRequired` is the amount of DEEP required for the dry run.

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `baseQuantity`: Number that defines the base quantity you want to convert.

 ```tsx
async getQuoteQuantityOut(poolKey: string, baseQuantity: number) {}
```

### getBaseQuantityOut

Use `getBaseQuantityOut` to retrieve the base quantity out for the quote quantity that you provide. The call returns a `Promise` in the form:
```
{
  quoteQuantity: number,
  baseOut: number,
  quoteOut: number,
  deepRequired: number
}
```
where `deepRequired` is the amount of DEEP required for the dry run.

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `quoteQuantity`: Number that defines the quote quantity you want to convert.

```tsx
async getBaseQuantityOut(poolKey: string, quoteQuantity: number) {}
```

### getQuantityOut

Use `getQuantityOut` to retrieve the output quantities for the base or quote quantity you provide. You provide values for both quantities, but only one of them can be non-zero. The call returns a `Promise` with the form:
```
{
  baseQuantity: number,
  quoteQuantity: number,
  baseOut: number,
  quoteOut: number,
  deepRequired: number
}
```
where `deepRequired` is the amount of DEEP required for the dry run.

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `baseQuantity`: Number that defines the base quantity you want to convert. Set to `0` if using quote quantity.
- `quoteQuantity`: Number that defines the quote quantity you want to convert. Set to `0` if using base quantity.

```tsx
async getQuantityOut(poolKey: string, baseQuantity: number, quoteQuantity: number) {}
```

### getLevel2Range

Use `getLevel2Range` to retrieve level 2 order book within the boundary price range you provide. The call returns a `Promise` in the form:
```
{
  prices: Array<number>,
  quantities: Array<number>
}
```

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `priceLow`: Number for lower bound of price range.
- `priceHigh`: Number for upper bound of price range.
- `isBid`: Boolean when set to `true` gets bid orders, else retrieve ask orders.

 ```tsx
async getLevel2Range(poolKey: string, priceLow: number, priceHigh: number, isBid: boolean) {}
```

### getLevel2TicksFromMid

Use `getLevel2TicksFromMid` to retrieve level 2 order book ticks from mid-price for a pool with the ID you provide. The call returns a `Promise` in the form:
```
{
  bid_prices: Array<number>,
  bid_quantities: Array<number>,
  ask_prices: Array<number>,
  ask_quantities: Array<number>
}
```

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `ticks`: Number of ticks from mid-price.

 ```tsx
async getLevel2TicksFromMid(poolKey: string, ticks: number) {}
```

### lockedBalance

Use `lockedBalance` to retrieve a `BalanceManager` locked balance in the pool. The call returns a `Promise` in the `Order` struct, which has the following form:

```tsx
{
  base: 5.5,
	quote: 2,
	deep: 0.15,
}
```

**Parameters**

`poolKey`: String that identifies the pool to query. `balanceManagerKey`: key of the balance manager defined in the SDK.

```tsx
async lockedBalance(poolKey: string, balanceManagerKey: string) {}
```

### poolTradeParams

Use `poolTradeParams` to retrieve the trade params for the pool, which has the following form:

```tsx
{
  takerFee: 0.001,
	makerFee: 0.0005,
	stakeRequired: 100,
}
```

**Parameters**

- `poolKey`: String that identifies the pool to query.

```tsx
async poolTradeParams(poolKey: string) {}
```

### vaultBalances

Use `vaultBalances` to get the vault balances for a pool with the ID you provide. The call returns a `Promise` in the form:

```tsx
{
  base: number, 
  quote: number, 
  deep: number
} 
```

**Parameters**

- `poolKey`: String that identifies the pool to query.

```tsx
async vaultBalances(poolKey: string) {}
```

### getPoolIdByAssets

Use `getPoolIdByAssets` to retrieve the pool ID for the asset types you provide. The call returns a `Promise` with the address of the pool if it's found.

**Parameters**

- `baseType`: String of the type of base asset.
- `quoteType`: String of the type of quote asset.

```tsx
async getPoolIdByAssets(baseType: string, quoteType: string) {}
```

### midPrice

Use `midPrice` to retrieve the mid price for a pool with the ID that you provide. The call returns a `Promise` with the mid price.

**Parameters**

- `poolKey`: String that identifies the pool to query.

```tsx
async midPrice(poolKey: string) {}
```

### whitelisted

Use `whitelisted` to check if the pool with the ID you provide is whitelisted. The call returns a `Promise` as a boolean indicating whether the pool is whitelisted.

**Parameters**

- `poolKey`: String that identifies the pool to query.

```tsx
async whitelisted(poolKey: string) {}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/closed-loop-token/action-request.mdx
```
---
title: Action Request
---

The main difference between tokens and coins is that tokens do not allow transfers, conversions, or spends by default. There is an authorization mechanism, however, that allows these actions. This mechanism is called an `ActionRequest`. You can choose to allow or disallow any of the actions independently (see the [Request confirmation](#request-confirmation) section).

## Protected actions

Tokens have four protected actions that create an `ActionRequest`:

| Function           | Action name | Description                     | Special fields in `ActionRequest` |
| ------------------ | ----------- | ------------------------------- | --------------------------------- |
| `token::from_coin` | `from_coin` | Convert a coin into a token     | -                                 |
| `token::to_coin`   | `to_coin`   | Convert a token into a coin     | -                                 |
| `token::transfer`  | `transfer`  | Transfer a token to a recipient | Contains `recipient` field        |
| `token::spend`     | `spend`     | Spend a token                   | Contains `spent_balance` field    |

## ActionRequest structure

`ActionRequest` is defined in the `sui::token` module and contains the following fields:

- `name`: Name of the performed action, standard ones are `transfer`, `spend`, `to_coin` and `from_coin`, and you can create custom actions.
- `amount`: The amount of the token that is being transferred, spent, converted, and so on.
- `sender`: The account that initiated the action.
- `recipient`: The account that receives the token in `transfer` action (use for custom actions).
- `spent_balance`: The balance of a spent token in the [`spend` action](./spending.mdx) (use in custom actions).

Rules can use these fields to determine whether the action should be allowed or not. Rules are custom modules that implement restriction logic. See [Rules](./rules.mdx) for more details.

An example of a function creating an `ActionRequest`:

```move
// module: sui::token
public fun transfer<T>(
    t: Token<T>, recipient: address, ctx: &mut TxContext
): ActionRequest<T>;
```

## Request confirmation {#request-confirmation}

There are three ways to confirm an `ActionRequest` using a:

1. `TreasuryCap` - you (or an application storing the `TreasuryCap`) can call the `token::confirm_with_treasury_cap` function to confirm any request. This method is useful for applications that store the `TreasuryCap` and implement custom logic; it also allows you to `mint` and `transfer` tokens, bypassing the restrictions.
2. [`TokenPolicy`](./token-policy.mdx) - create a shared `TokenPolicy` and set up allowed actions and requirements for each action. This way, applications or wallets know which actions are considered `public` and so they are able to perform them.
3. `TokenPolicyCap` - use the capability managing the `TokenPolicy` to confirm requests. This can be useful for applications that have the `TreasuryCap` wrapped and inaccessible; and you need to authorize some administrator action.

:::info

You can't use `TokenPolicyCap` to confirm `spend` requests.

:::

### Confirming with TreasuryCap

Use the `TreasuryCap` to confirm any action request for the token. It's useful for administrator actions (like `mint` and `transfer`), as well as for simple applications that don't require a token policy and wrap the `TreasuryCap` into the main object.

The signature for the `token::confirm_with_treasury_cap` function is:

```move
// module: sui::token
public fun confirm_with_treasury_cap<T>(
    treasury_cap: &mut TreasuryCap<T>,
    request: ActionRequest<T>,
    ctx: &mut TxContext
): (String, u64, address, Option<address>);
```

An example of a transaction implemented in TypeScript with sui.js, confirming an action request with a `TreasuryCap`. Here the admin account owns the `TreasuryCap`, which is used to mint and confirm the transfer request for the token:

```js
let tx = new Transaction();
let tokenType = '0x....::my_token::MY_TOKEN';
let treasuryCapArg = tx.object('0x....');

// mint 10 tokens using the `TreasuryCap`
let token = tx.moveCall({
	target: '0x2::token::mint',
	arguments: [treasuryCapArg, tx.pure.u64(10)],
	typeArguments: [tokenType],
});

// transfer the token to a recipient; receive an `ActionRequest`
let request = tx.moveCall({
	target: '0x2::token::transfer',
	arguments: [token, tx.pure.address('0x...')],
	typeArguments: [tokenType],
});

// confirm the request with the `TreasuryCap`
tx.moveCall({
	target: '0x2::token::confirm_with_treasury_cap',
	arguments: [treasuryCapArg, request],
	typeArguments: [tokenType],
});

// submit the transaction
// ...
```

### Confirming with TokenPolicy

`TokenPolicy` is a way of enabling certain actions network-wide. After sharing, the `TokenPolicy` is available to everyone. Hence, wallets or other clients can use it to confirm allowed operations.

The signature for the `token::confirm_request` function is:

```move
// module: sui::token
public fun confirm_request<T>(
    treasury_cap: &TokenPolicy<T>,
    request: ActionRequest<T>,
    ctx: &mut TxContext
): (String, u64, address, Option<address>);
```

:::info

If it's a `spend` request, use the `confirm_request_mut` function instead.

:::

An example of a client transfer request confirmation in JavaScript:

```js
let tx = new Transaction();
let tokenType = '0x....::my_token::MY_TOKEN';
let myTokenArg = tx.object('0x...token_object');
let receiverArg = tx.pure.address('0x...receiver');
let tokenPolicyArg = tx.object('0x...token_policy');

let request = tx.moveCall({
	target: '0x2::token::transfer',
	arguments: [myTokenArg, receiverArg],
	typeArguments: [tokenType],
});

// expecting the `TokenPolicy` to have the `transfer` operation allowed
tx.moveCall({
	target: '0x2::token::confirm_request',
	arguments: [tokenPolicyArg, request],
	typeArguments: [tokenType],
});

// submit the transaction
// ...
```

### Confirming with TokenPolicyCap

Use `TokenPolicyCap` to confirm action requests. A convenient approach when the `TreasuryCap` is wrapped in another object, and `TokenPolicy` does not allow certain action or has rules that make the default way of confirming impossible.

:::info

You can't use `TokenPolicyCap` to confirm `spend` requests.

:::

```move
// module: sui::token

public fun confirm_with_policy_cap<T>(
    token_policy_cap: &TokenPolicyCap<T>,
    request: ActionRequest<T>,
    ctx: &mut TxContext
): (String, u64, address, Option<address>);
```

An example of a client transfer request confirmation in JavaScript:

```js
let tx = new Transaction();
let tokenType = '0x....::my_token::MY_TOKEN';
let myTokenArg = tx.object('0x...token_object');
let receiverArg = tx.pure.address('0x...receiver');
let tokenPolicyCapArg = tx.object('0x...token_policy_cap');

let request = tx.moveCall({
	target: '0x2::token::transfer',
	arguments: [myTokenArg, receiverArg],
	typeArguments: [tokenType],
});

// confirming the request with the TokenPolicyCap
tx.moveCall({
	target: '0x2::token::confirm_with_policy_cap',
	arguments: [tokenPolicyCapArg, request],
	typeArguments: [tokenType],
});

// submit the transaction
// ...
```

## Approving actions

`ActionRequest`s can collect approvals - witness stamps from applications or rules. They carry the confirmation that a certain module or a rule has approved the action. This mechanic allows gating actions behind certain requirements.

The signature for the `token::add_approval` function is:

```move
// module: sui::token
public fun add_approval<T, W: drop>(
    _t: W, request: &mut ActionRequest<T>, _ctx: &mut TxContext
);
```

Approvals are mostly used for rules, but they can carry confirmations from any module.

## Creating a custom request

Anyone can create a new `ActionRequest` using the `token::new_request` function. You can use it to create custom actions and rules, not necessarily related to the token itself.

:::info

Because you can create an `ActionRequest` freely for any type `T`, you can't use them as a proof of the action. Their purpose is **authorization**, not proof.

:::

The signature for the `token::new_request` function is:

```move
public fun new_request<T>(
    name: vector<u8>,
    amount: u64,
    recipient: option<address>,
    spent_balance: option<Balance<T>>,
    ctx: &mut TxContext
): ActionRequest<T>;
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/closed-loop-token/rules.mdx
```
---
title: Rules
---

Rules are programmable restrictions that you can apply to any action in the [`TokenPolicy`](./token-policy.mdx). They are the tool of compliance, regulation, and enforcement of certain business logic in the closed-loop system.

## Rule structure

A rule is represented as a witness - a type with a `drop` ability. You can either encode it in your application logic, or include it as part of a separate module for a more modular approach.

```move
/// The Rule type
struct Rule has drop {}
```

After you [add a rule](./token-policy.mdx#adding-rules) to an action in the `TokenPolicy`, the action requires a stamp of the rule to pass confirmation.

See the [Approving actions](./action-request.mdx#approving-actions) section for more details on how to approve an action.

## Modular rules

You can publish rules as separate reusable modules. This enables you to create a library of rules that you can use in different token policies, maximizing code reuse and minimizing the risk of errors.

A rule module is a regular module with a `verify`-like function that typically takes a `TokenPolicy`, [`ActionRequest`](./action-request.mdx), and a `TxContext` as arguments. The function is responsible for verifying the action and stamping the `ActionRequest` with the rule type.

```move
module example::pass_rule {
    use sui::tx_context;
    use sui::token::{Self, ActionRequest, TokenPolicy};

    /// The Rule type
    struct Pass has drop {}

    /// Add approval from the Pass rule to the ActionRequest
    public fun verify<T>(
        _policy: &TokenPolicy<T>,
        action_request: &mut ActionRequest<T>,
        ctx: &mut TxContext,
    ) {
        // ...
        token::add_approval(Pass {}, action_request, ctx)
    }
}
```

## Rule configuration

Some rules, such as `denylist` or `allowlist` require configuration. For example, a `denylist` rule might require a list of addresses that are not allowed to perform certain actions. A rule module can define a configuration structure and provide functions to add, modify, retrieve, and remove the configuration.

:::info

A single rule has a single configuration, even when assigned to multiple actions. If there's a need to have configuration per action, a rule module needs to define a storage structure that can hold and manage multiple configurations.

:::

The configuration system comes with a set of guarantees to protect token owners from malicious actions (or upgrades) from rule module developers:

1. The `rule` module defines the type and structure of the configuration.
2. Addition or modification and removal of the configuration are available only to the `TokenPolicy` owner.
3. Only a rule can read the configuration.
4. Rules cannot modify the configuration without the `TokenPolicy` owner's approval.

The only attack vector available to the rule creator is upgrading the module and creating a function to bypass the restriction. Make sure to use rules provided by a trusted developer.

## Configuration API

The `sui::token` module defines the configuration API and has the following set of functions.

### Add new configuration

A rule must approve new configurations (the rule witness) and the `TokenPolicy` owner. The type of the configuration can be any as long as it has the `store` ability.

```move
// module: sui::token
public fun add_rule_config<T, Rule: drop, Config: store>(
    _rule: Rule,
    policy: &mut TokenPolicy<T>,
    policy_cap: &TokenPolicyCap<T>,
    config: Config,
    _ctx: &mut TxContext
);
```

### Read the configuration

Rules can read the configuration stored in the `TokenPolicy`.

```move
// module: sui::token
public fun rule_config<T, Rule: drop, Config: store>(
    _rule: Rule, policy: &TokenPolicy<T>
): &Config;
```

### Modify the configuration

A rule must approve configuration modifications (the rule witness) as well as the `TokenPolicy` owner.

```move
// module: sui::token
public fun rule_config_mut<T, Rule: drop, Config: store>(
    _rule: Rule, policy: &mut TokenPolicy<T>, policy_cap: &TokenPolicyCap<T>
): &mut Config;
```

### Remove configuration

A good practice for rules is to provide a method to remove the configuration, as a rule can use a custom type for it. However, a token owner can always call the `remove_rule_config` function to remove the configuration.

```move
// module: sui::token
public fun remove_rule_config<T, Rule, Config: store>(
    policy: &mut TokenPolicy<T>,
    policy_cap: &TokenPolicyCap<T>,
    _ctx: &mut TxContext
): Config;
```

Because the configuration has `store`, the token owner can wrap and transfer or store the configuration somewhere else. If the `Config` type has `drop`, the value can be ignored.

## Cheatsheet: Rule configuration API

| Method name                 | Description                              | Notes                                          |
|-----------------------------|------------------------------------------|------------------------------------------------|
| `add_rule_config`           | Adds a new config for the rule           | Requires rule witness and token owner approval |
| `remove_rule_config`        | Removes config object from the policy    | Token Owner can perform any time           |
| `rule_config`               | Access the config immutably              | Only available to a rule                       |
| `rule_config_mut`           | Get mutable reference to config          | Requires rule witness and token owner approval |
| `has_rule_config`           | Check if the rule has a config set       | -                                              |
| `has_rule_config_with_type` | Check if the rule has a config with type | -                                              |

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/closed-loop-token/spending.mdx
```
---
title: Spending
---

Because `Token` types do not have the `store` ability, it is impossible to store them in another object. Hence, `Coin`-like approaches to spending are not possible - an application that takes `Token` as a payment won't be able to add it to its balance. To address this issue, `Token` has a `spend` method, which allows spending it in one application and then delivering it as a `spent_balance` to the [`TokenPolicy`](./token-policy.mdx) or burning right away with a `TreasuryCap`.

## Spend action

Tokens can be spent by calling the `spend` method. It takes the following arguments:

```move
// module sui::token
public fun spend<T>(token: Token<T>, ctx: &mut TxContext): ActionRequest<T>;
```

As the signature shows, the `Token` object is consumed. Its balance becomes the `spent_balance` in the [`ActionRequest`](./action-request.mdx#actionrequest-structure).

## Spent token

The `ActionRequest` for the `spend` action contains the `Balance` of the spent `Token`, and it can either be confirmed [with a `TreasuryCap`](./action-request#confirming-with-treasurycap) or [delivered to the `TokenPolicy`](./action-request#confirming-with-tokenpolicy). In the first case, the balance is burned directly in the `TreasuryCap`, and in the second case, it's delivered to the `TokenPolicy` `spent_balance`.

Spent balance cannot be used in any way, and it is not possible to withdraw it. The only available action is [flushing](./token-policy#consume-spent-balance) - burning the `spent_balance` by bringing a `TreasuryCap`.


## Gating the spend action

Normally, the `spend` action should have at least one rule assigned to it to prevent aimless spending, and the recommended way of authorizing the spend in an application that accepts the token is to stamp it right in the function where a spend is performed. For example:

```move
/// Rule-like witness to stamp the ActionRequest
struct GiftShop has drop {}

/// Spend the token and return a Gift + ActionRequest
public fun buy_gift(
    token: Token<CREDITS>,
    ctx: &mut TxContext
): (Gift, ActionRequest<CREDITS>) {

    // token is spent
    let action_request = token::spend(token, ctx);

    // stamp the ActionRequest as performed by GiftShop
    token::add_approval(GiftShop {}, &mut action_request, ctx);

    // return already stamped ActionRequest
    (Gift { ... }, action_request)
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/closed-loop-token/token-policy.mdx
```
---
title: Token Policy
---

`TokenPolicy` is a shared object that you, as the token owner, can create using the `TreasuryCap`. Having a publicly available `TokenPolicy` enables on-chain discovery of allowed actions and their conditions. This is useful for wallets and other services that want to provide a better user experience for token holders.

## Create and share

You create a new `TokenPolicy` using the `token::new_policy` function. The function takes the `TreasuryCap` as an argument and returns a `TokenPolicy` object and a managing capability.

```move
// module: sui::token
public fun new_policy<T>(
    treasury_cap: &TreasuryCap<T>,
    ctx: &mut TxContext
): (TokenPolicy<TokenType>, TokenPolicyCap<TokenType>);
```

You must use the `token::share_policy` function to share the `TokenPolicy` object.

## Allow and disallow

To allow methods without any conditions, use the `token::allow` function. The function takes a `TokenPolicy` and `TokenPolicyCap` as arguments. If allowed, the action can be confirmed in the `TokenPolicy` using the `token::confirm_request` function (see [`ActionRequest`](./action-request.mdx#confirming-with-tokenpolicy)).

```move
// module sui::token
public fun allow<T>(
    policy: &mut TokenPolicy<T>,
    policy_cap: &TokenPolicyCap<T>,
    action: String,
    ctx: &mut TxContext
);
```

Similarly, you can use the `token::disallow` function to completely disable an action; it takes the same arguments as `token::allow`.

## Adding rules

`TokenPolicy` can specify custom conditions for each action. These conditions are called rules and are typically implemented as separate Move modules. The identifier of the rule is its type. See [Rules](./rules.mdx) for more information.

The pseudo-code structure of the `TokenPolicy` is as follows. Each action can have multiple rules associated with it.

```yaml
TokenPolicy
  rules:
    - action: "transfer"
      rules:
        - 0x0...::denylist::Denylist
    - action: "to_coin"
      rules:
        - 0x0...::limiter::Limiter
        - 0x0...::allowlist::Allowlist
    ...
```

To add a rule for an action, use the `token::add_rule_for_action` function. The function takes a `TokenPolicy` and `TokenPolicyCap` as arguments. The rule is specified by its type (for example, `0x0...::denylist::Denylist`).

```move
// module: sui::token
public fun add_rule_for_action<T, Rule: drop>(
    policy: &mut TokenPolicy<T>,
    policy_cap: &TokenPolicyCap<T>,
    action: String,
    ctx: &mut TxContext
);
```

Signature for the reverse operation `token::remove_rule_for_action` is symmetrical to `token::add_rule_for_action`.

## Consume spent balance

Spent balance can be consumed from the `TokenPolicy` using the `token::flush` function. It requires a `TreasuryCap`.

```move
// module sui::token
public fun flush<T>(
    policy: &mut TokenPolicy<T>,
    treasury_cap: &mut TreasuryCap<T>,
    ctx: &mut TxContext
);
```

## Cheatsheet: TokenPolicy API

| Function                    | Note                                                                 |
|-----------------------------|----------------------------------------------------------------------|
| new_policy                  | Create a new `TokenPolicy` using the `TreasuryCap`                       |
| allow                       | Allow an action in the `TokenPolicy`                                   |
| disallow                    | Disallow an action in the `TokenPolicy`                                |
| add_rule_for_action         | Add a rule for an action in the `TokenPolicy`                          |
| remove_rule_for_action      | Remove a rule for an action in the `TokenPolicy`                       |
| confirm_request             | Confirm an `ActionRequest` with a `TokenPolicy`                          |
| confirm_request_mut         | Similar to `confirm_request` but only works for `spend` action       |
| flush                       | Flush the spent balance from the `TokenPolicy` (see [Spending](./spending.mdx)) |

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/closed-loop-token/coin-token-comparison.mdx
```
---
title: Coin/Token API comparison
---

Use this appendix as a quick reference to compare the API of the `coin` and `token` modules.

| Function                    | Coin | Token       | Note                                                                             |
|-----------------------------|------|-------------|----------------------------------------------------------------------------------|
| `mint`                        | +    | +           | Requires `TreasuryCap`                                                             |
| `burn`                        | +    | +           | Requires `TreasuryCap`                                                             |
| `join`                        | +    | +           | Public                                                                           |
| `split`                       | +    | +           | Public                                                                           |
| `zero`                        | +    | +           | Public                                                                           |
| `destroy_zero`                | +    | +           | Public                                                                           |
| `keep`                        | -    | +           | Send token to sender, not required for coin due to lack of transfer restrictions |
| `transfer`                    | +    | \[protected] | Coin is transferable by default, token requires authorization                   |
| `to_balance`/`to_coin`        | +    | \[protected] | Token can be converted `to_coin`, requires authorization                        |
| `from_balance`/`from_coin`    | +    | \[protected] | Token can be created `from_coin`, requires authorization                        |
| `spend`                       | -    | \[protected] | Token can be spent, requires authorization                   |

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv2/trade-and-swap.mdx
```
---
title: Trade and Swap
---

{@include: ../../snippets/deepbook-v2-dep.mdx}

This section shows how to construct and execute a trade on the DeepBook protocol.

## Create a pool {#create-pool}

When you create a pool in DeepBook, you need to specify the `BaseAsset`, `QuoteAsset`, `tick_size`, and `lot_size`. You also need to pay a transaction fee (in SUI) to create a pool.

**Function signature for `create_pool` in Move contract**

```move
/// Parameters expected by this function
///
///   0. `[registry]` Object ID refers to the pool registry
///   1. `[tick_size]` Minimal Price Change Accuracy of this pool
///   2. `[lot_size]` Minimal lot Change Accuracy of this pool
///   3. `[coin]` Object ID of the sui coin, to pay fee for create pool (100 MIST sui charged)

/// Returns the AccountCap
public fun create_pool<BaseAsset, QuoteAsset, SUI>(
    registry: &mut Registry,
    tick_size: u64,
    lot_size: u64,
    coin: Coin<SUI>,
    ctx: &mut TxContext,
)
```

**TypeScript SDK for invoking `create_pool`**

```ts
/**
 * @description: Create pool for trading pair
 * @param tickSize: Minimal Price Change Accuracy of this pool
 * @param lotSize: Minimal Lot Change Accuracy of this pool
 * @param token1: Full coin type(recommend) or coin name of the base asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::wbtc::WBTC" for example
 * @param token2: Full coin type(recommend) of quote asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::usdt::USDT" for example
 * @param overrides: overriders for blockchain params. Like gas budget, transaction block and the provider, default we will set to the max gas budget, and create a new transaction block
 * @notice: the packageId and registryId should be set in configs.json, if it is not set, the transaction will fail.
 */
public createPool(
    tickSize: number,
    lotSize: number,
    token1: string,
    token2: string,
    overrides: Overrides = new Overrides(),
): TransactionBlock {
    const coinType1 = convertToTokenType(token1, this.records);
    const coinType2 = convertToTokenType(token2, this.records);
    // we have to split sui as a param into the code
    const [coin] = overrides.txb.splitCoins(overrides.txb.gas, [overrides.txb.pure(200000000)]);
    overrides.txb.moveCall({
        typeArguments: [coinType1, coinType2, '0x2::sui::SUI'],
        target: `${this.configs.swapPackageId}::clob::create_pool`,
        arguments: [
            overrides.txb.object(String(this.configs.registryId)),
            overrides.txb.pure(tickSize),
            overrides.txb.pure(lotSize),
            coin,
        ],
    });
    overrides.txb.setGasBudget(overrides.gasBudget);
    return overrides.txb;
}
```

## Create an order {#create-order}

There are two types of orders, `limit order` and `market order` in DeepBook.

For limit order, you need to create a custodian account the first time you interact with a particular pool and deposit assets to the pool.

### Scaling precision {#scaling-precision}

Tokens are created with different decimal precision. For example, SUI has nine decimals of precision, while the wormhole wrapped ethereum USDC has
six decimals of precision. To accommodate proper pricing within DeepBook, every decimal is scaled with 10^9 precision. All the decimals in DeepBook
meet the equation: `10^9 \* (priceInRealWorld/priceInDeepBook) = (10^baseAssetDecimal) / (10^quoteAssetDecimal)`.

Let's walk through an example between SUI/USDC. For this example, assume Sui price is $1.10 and is the base asset
of the SUI/USDC trading pair.

Thus, the calculation is `10^9 \* (1.10/ P_d) = 1000`, where `P_d` should be the price of sui in the DeepBook SUI/USDC trading pair. You can solve for `P_d = 1100000`,
so if the user wants to sell SUI at the market price in DeepBook, they should enter a price with six decimal points of precision.

### Limit order {#limit-order}

#### Limit order type {#limit-order-type}

There are four types of restrictions that you could put on limit orders.

- `NO_RESTRICTION`: 0

    Fill as much quantity as possible in the current transaction as taker, and inject the remaining as a maker order.

- `IMMEDIATE_OR_CANCEL`: 1

    Fill as much quantity as possible in the current transaction as taker, and cancel the rest of the order.

- `FILL_OR_KILL`: 2

    Only fill if the entire order size can be filled as taker in the current transaction. Otherwise, abort the entire transaction.

- `POST_OR_ABORT`: 3

    Only proceed if the entire order size can be posted to the order book as maker in the current transaction. Otherwise, abort the entire transaction.

#### Custodian account {#custodian-account}

Before placing a limit order, traders need to host a custodian account with asset deposited. Traders could generate a custodian account by invoking `create_account` to get an `AccountCap` object authorizing them to access their custodian accounts. The `AccountCap` object is the key to the custodian account, and if you transfer this object to others, the new owner has access to all the funds and orders in the custodian account.

```mermaid
flowchart LR
 A((user_address\n0x1234\ncustodian_cap_address\n0xABCD))
 subgraph Sui_blockchain
    direction TB
    B["account_balances: Table&lt;address, Account&lt;T>>"]
    C("<table><tbody><tr><td>0xABCD</td><td>5 SUI</td></tr><tr><td>0xBCDE</td><td>12 SUI</td></tr><tr><td>...</td><td>...</td></tr></tbody></table>")
 end

 A ----> Sui_blockchain
```

**Function signature for `create_account` in Move contract**

```move
/// Parameters expected by this func
///
/// 0. `[ctx]` Information about the current transaction.

/// Returns the AccountCap
public fun create_account(ctx: &mut TxContext): AccountCap {
    mint_account_cap(ctx)
}
```

**TypeScript SDK for invoking `create_account`**

```ts
/**
 * @description: Create and Transfer custodian account to user
 * @param currentAddress: current user address
 * @param needsTransfer: if needs transfer the cap to user, default true, if false, which means we need to use the cap in the next transaction.
 * @param overrides: overriders for blockchain params. Like gas budget, transaction block and the provider, default we will set to the max gas budget, and create a new transaction block
 * @notice: the packageId should be set in configs.json, if it is not set, the transaction will fail.
 */
async createAccount(
    currentAddress: string,
    needsTransfer: boolean = true,
    overrides: Overrides = new Overrides(),
): Promise<TransactionBlock | TransactionArgument> {
    let [cap] = overrides.txb.moveCall({
        typeArguments: [],
        target: `${this.configs.swapPackageId}::clob::create_account`,
        arguments: [],
    });
    if (!needsTransfer) {
        return cap;
    } else {
        overrides.txb.transferObjects([cap], overrides.txb.pure(currentAddress));
        overrides.txb.setSenderIfNotSet(currentAddress);
        overrides.txb.setGasBudget(overrides.gasBudget);
        return overrides.txb;
    }
}
```

#### Deposit asset {#deposit-asset}

Traders could deposit base/quote assets to their custodian account, so they could later use it for placing limit orders. We provide two functions to deposit base and quote assets, respectively.

**Function signature for deposit base asset in Move contract**

```move
/// Parameters expected by this func
///
/// 0. `[pool]` Object ID refers to the pool containing the trading pair
/// 1. `[coin]` Object ID of the base asset coin
/// 2. `[account_cap]` Object ID of the account_cap authorizing the
/// accessilility to the escrow account

/// Returns none
public fun deposit_base<BaseAsset, QuoteAsset>(
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    coin: Coin<BaseAsset>,
    account_cap: &AccountCap
)
```

**TypeScript SDK for invoking `deposit_base`**

```ts
/**
 * @description: Deposit base asset into custodian account
 * @param accountCap: Object id of Account Capacity under user address, created after invoking createAccount
 * @param token1: Full coin type(recommend) or coin name of the base asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::wbtc::WBTC" for example
 * @param token2: Full coin type(recommend) of quote asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::usdt::USDT" for example
 * @param coin: Object id of coin to deposit
 * @param overrides: overriders for blockchain params. Like gas budget, transaction block and the provider, default we will set to the max gas budget, and create a new transaction block
 * @notice: the packageId should be set in configs.json, if it is not set, the transaction will fail.
 */
public depositBase(
    token1: string,
    token2: string,
    coin: string | TransactionArgument,
    accountCap: string,
    overrides: Overrides = new Overrides(),
): TransactionBlock {
    const tokenType1 = convertToTokenType(token1, this.records);
    const tokenType2 = convertToTokenType(token2, this.records);
    const poolInfo = getPoolInfoByRecords(tokenType1, tokenType2, this.records);
    overrides.txb.moveCall({
        typeArguments: [tokenType1, tokenType2],
        target: `${this.configs.swapPackageId}::clob::deposit_base`,
        arguments: [
            overrides.txb.object(String(poolInfo.clob)),
            typeof coin == 'string' ? overrides.txb.object(coin) : coin,
            overrides.txb.object(String(accountCap)),
        ],
    });
    overrides.txb.setGasBudget(overrides.gasBudget);
    return overrides.txb;
}
```

**Function signature for `deposit_quote` in contract**

```move
/// Parameters expected by this func
///
/// 0. `[pool]` Object ID refers to the pool containing the trading pair
/// 1. `[coin]` Object ID of the coin
/// 2. `[account_cap]` Object ID of the account_cap authorizing the
/// accessilility to the escrow account

/// Returns none
public fun deposit_quote<BaseAsset, QuoteAsset>(
    pool: &mut Pool<BaseAsset, QuoteAsset>,
    coin: Coin<QuoteAsset>,
    account_cap: &AccountCap
)
```

**TypeScript SDK for invoking `deposit_quote`**

```ts
/**
 * @description: Deposit quote asset into custodian account
 * @param accountCap: Object id of Account Capacity under user address, created after invoking createAccount
 * @param token1: Full coin type(recommend) or coin name of the base asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::wbtc::WBTC" for example
 * @param token2: Full coin type(recommend) of quote asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::usdt::USDT" for example
 * @param coin: Object id of coin to deposit
 * @param overrides: overriders for blockchain params. Like gas budget, transaction block and the provider, default we will set to the max gas budget, and create a new transaction block
 * @notice: the packageId should be set in configs.json, if it is not set, the transaction will fail.
 */
public depositQuote(
    token1: string,
    token2: string,
    coin: string | TransactionArgument,
    accountCap: string | TransactionArgument,
    overrides: Overrides = new Overrides(),
): TransactionBlock {
    const tokenType1 = convertToTokenType(token1, this.records);
    const tokenType2 = convertToTokenType(token2, this.records);
    const poolInfo = getPoolInfoByRecords(tokenType1, tokenType2, this.records);
    overrides.txb.moveCall({
        typeArguments: [tokenType1, tokenType2],
        target: `${this.configs.swapPackageId}::clob::deposit_quote`,
        arguments: [
            overrides.txb.object(String(poolInfo.clob)),
            typeof coin == 'string' ? overrides.txb.object(coin) : coin,
            typeof accountCap == 'string' ? overrides.txb.object(String(accountCap)) : accountCap,
        ],
    });
    overrides.txb.setGasBudget(overrides.gasBudget);
    return overrides.txb;
}
```

#### Place limit order {#limit-order}

Ensure you have a custodian account with enough base/quote assets to trade. You can now place limit orders on DeepBook with the following functions:

**Function signature for placing limit order in Move contract**

```move
/// Parameters expected by this func
///
///   0. `[pool]` Object ID refers to the pool of the trading pair
///   1. `[price]` Price of the placed limit order to sell or buy
///   2. `[quantity]` Quantity of the base asset want to sell or buy
///   3. `[is_bid]` Flag indicate sell base asset out or buy base asset in
///   4. `[expire_timestamp]` Expire timestamp in ms in absolute value inclusive., if exceeded, order turn invalid
///   5. `[restriction]` Object ID of the pool containing the trading pair
///   6. `[clock]` Object ID of global system clock
///   7. `[account_cap]` Object ID of the account_cap authorizing the
///       accessilility to the escrow account
///   8. `[ctx]` Information about the current transaction.

/// Returns (base quantity filled, quote quantity filled, whether a maker order is being placed, order id of the maker order)
public fun place_limit_order<BaseAsset, QuoteAsset>(
        pool: &mut Pool<BaseAsset, QuoteAsset>,
        price: u64,
        quantity: u64,
        is_bid: bool,
        expire_timestamp: u64,
        restriction: u8,
        clock: &Clock,
        account_cap: &AccountCap,
        ctx: &mut TxContext
    ): (u64, u64, bool, u64)
```

**TypeScript SDK for invoking `place_limit_order`**

```ts
/**
 * @description: place a limit order
 * @param token1: Full coin type(recommend) of base asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::wbtc::WBTC" for example
 * @param token2: Full coin type(recommend) of quote asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::wbtc::WBTC" for example
 * @param price: price of the limit order
 * @param quantity: quantity of the limit order in BASE ASSET.
 * @param isBid: true for buying base with quote, false for selling base for quote
 * @param expireTimestamp: expire timestamp of the limit order
 * @param restriction restrictions on limit orders, explain in doc for more details
 * @param accountCap: account cap for the limit order
 * @param overrides: overriders for blockchain params. Like gas budget, transaction block and the provider, default we will set to the max gas budget, and create a new transaction block
 * @notice: the packageId should be set in configs.json, if it is not set, the transaction will fail.
 */
public placeLimitOrder(
    token1: string,
    token2: string,
    price: number,
    quantity: number,
    isBid: boolean,
    expireTimestamp: number,
    restriction: number,
    accountCap: string | TransactionArgument,
    overrides: Overrides = new Overrides(),
): TransactionBlock {
    const tokenType1 = convertToTokenType(token1, this.records);
    const tokenType2 = convertToTokenType(token2, this.records);
    const poolInfo = getPoolInfoByRecords(tokenType1, tokenType2, this.records);
    overrides.txb.moveCall({
        typeArguments: [tokenType1, tokenType2],
        target: `${this.configs.swapPackageId}::clob::place_limit_order`,
        arguments: [
            overrides.txb.object(String(poolInfo.clob)),
            overrides.txb.pure(Math.floor(price * F)),
            overrides.txb.pure(quantity),
            overrides.txb.pure(isBid),
            overrides.txb.pure(Math.floor(expireTimestamp)),
            overrides.txb.pure(restriction),
            overrides.txb.object(normalizeSuiObjectId(this.configs.clock)),
            typeof accountCap == "string" ? overrides.txb.object(accountCap) : accountCap,
        ],
    });
    overrides.txb.setGasBudget(overrides.gasBudget);
    return overrides.txb;
}
```

### Place market order {#market-order}

Placing a market order does not require a custodian account. The remaining order is canceled if it can be filled only partially.

Function signature for placing market order in Move contract:

```move
/// Parameters expected by this func
///
///   0. `[pool]` Object ID refers to the pool of the trading pair
///   1. `[quantity]` Quantity of the base asset usr want to buy or sell
///   2. `[is_bid]` Flag indicates buy or sell, true for buy and false for sell
///   3. `[base_coin]` Object id of base coin, can be zero balance
///   4. `[quote_coin]` Object id of the quote coin, can be zero balance
///   5. `[clock]` Object ID refers to global system clock
///   6. `[ctx]` Information about the transaction currently being executed.

/// Returns the base asset coin and quote asset coin after transaction
public fun place_market_order<BaseAsset, QuoteAsset>(
        pool: &mut Pool<BaseAsset, QuoteAsset>,
        quantity: u64,
        is_bid: bool,
        base_coin: Coin<BaseAsset>,
        quote_coin: Coin<QuoteAsset>,
        clock: &Clock,
        ctx: &mut TxContext,
    ): (Coin<BaseAsset>, Coin<QuoteAsset>)
```

**TypeScript SDK for invoking `place_market_order`**

```ts
/**
 * @description: place a market order
 * @param tokenObjectIn: Object id of the token to buy or sell
 * @param tokenOut: Full coin type(recommend) or coin name of the asset one want to get "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::wbtc::WBTC" for example
 * @param amountIn: amount of token to buy or sell
 * @param currentAddress: user address
 * @param overrides: overriders for blockchain params. Like gas budget, transaction block and the provider, default we will set to the max gas budget, and create a new transaction block
 * @notice: the packageId should be set in configs.json, if it is not set, the transaction will fail.
 */
public async placeMarketOrder(
    tokenObjectIn: string,
    tokenOut: string,
    amountIn: number,
    currentAddress: string,
    overrides: Overrides = new Overrides(),
): Promise<TransactionBlock> {
    // in this case, we assume that the tokenIn--tokenOut always exists.
    const tokenTypeOut = convertToTokenType(tokenOut, this.records);
    const tokenIn = overrides.txb.object(tokenObjectIn);
    const tokenInfo = await this.provider.getObject({
        id: tokenObjectIn,
        options: {
            showType: true,
        },
    });
    const tokenTypeIn = tokenInfo.data.type.split('<')[1].split('>')[0];
    let base_coin_ret, quote_coin_ret, amount;
    const poolInfo: PoolInfo = getPoolInfoByRecords(tokenTypeIn, tokenTypeOut, this.records);
    let _isBid, _tokenIn, _tokenOut, _amount;
    if (!poolInfo.needChange) {
        _isBid = false;
        _tokenIn = tokenIn;
        _tokenOut = this.mint(tokenTypeOut, 0, {txb: overrides.txb});
        _amount = overrides.txb.object(String(amountIn));
    } else {
        _isBid = true;
        // _tokenIn = this.mint(txb, nextPath, 0)
        _tokenOut = tokenIn;
        _amount = overrides.txb.object(String(amountIn));
    }
    if (_isBid) {
        // here swap_exact_quote_for_base
        [base_coin_ret, quote_coin_ret, amount] = overrides.txb.moveCall({
            typeArguments: [
                poolInfo.needChange ? tokenTypeOut : tokenTypeIn,
                poolInfo.needChange ? tokenTypeIn : tokenTypeOut,
            ],
            target: `${this.configs.swapPackageId}::clob::swap_exact_quote_for_base`,
            arguments: [
                overrides.txb.object(String(poolInfo.clob)),
                _amount,
                overrides.txb.object(normalizeSuiObjectId(this.configs.clock)),
                _tokenOut,
            ],
        });
    } else {
        // here swap_exact_base_for_quote
        [base_coin_ret, quote_coin_ret, amount] = overrides.txb.moveCall({
            typeArguments: [
                poolInfo.needChange ? tokenTypeOut : tokenTypeIn,
                poolInfo.needChange ? tokenTypeIn : tokenTypeOut,
            ],
            target: `${this.configs.swapPackageId}::clob::swap_exact_base_for_quote`,
            arguments: [
                overrides.txb.object(String(poolInfo.clob)),
                _amount,
                _tokenIn,
                _tokenOut,
                overrides.txb.object(normalizeSuiObjectId(this.configs.clock)),
            ],
        });
    }
    overrides.txb.transferObjects([base_coin_ret], overrides.txb.pure(currentAddress));
    overrides.txb.transferObjects([quote_coin_ret], overrides.txb.pure(currentAddress));
    overrides.txb.setSenderIfNotSet(currentAddress);
    overrides.txb.setGasBudget(overrides.gasBudget);
    return overrides.txb;
}
```

## Cancel order {#cancel-order}

### Cancel single order {#cancel-single-order}

Cancel a limit order placed onto the CLOB. Abort if `order_id` is invalid or if the order is not submitted by the transaction sender.

**Function signature for canceling single order in Move contract**

```move
/// parameters expected by this func
///
///   0. `[pool]` Object ID refers to the pool of the trading pair
///   1. `[order_id]` Order ID of the placed limit order
///   2. `[account_cap]` Object ID of the account_cap authorizing the
///       accessilility to the escrow account

/// Returns none
public fun cancel_order<BaseAsset, QuoteAsset>(
        pool: &mut Pool<BaseAsset, QuoteAsset>,
        order_id: u64,
        account_cap: &AccountCap
        )
```

**TypeScript SDK for invoking `cancel_order`**

```ts
/**
 * @description: cancel single order
 * @param token1: Full coin type(recommend) of base asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::wbtc::WBTC" for example
 * @param token2: Full coin type(recommend) of quote asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::wbtc::WBTC" for example
 * @param orderId: Order id to cancel corresponding order
 * @param accountCap: Object id of account capacity under usr address, created after invoking createAccount
 * @param overrides: overriders for blockchain params. Like gas budget, transaction block and the provider, default we will set to the max gas budget, and create a new transaction block
 * @notice: the packageId should be set in configs.json, if it is not set, the transaction will fail.
 */
public async cancelOrder(
    token1: string,
    token2: string,
    orderId: bigint,
    accountCap: string,
    overrides: Overrides = new Overrides(),
): Promise<TransactionBlock> {
    const tokenType1 = convertToTokenType(token1, this.records);
    const tokenType2 = convertToTokenType(token2, this.records);
    const poolInfo: PoolInfo = getPoolInfoByRecords(tokenType1, tokenType2, this.records);
    overrides.txb.moveCall({
        typeArguments: [tokenType1, tokenType2],
        target: `${this.configs.swapPackageId}::clob::cancel_order`,
        arguments: [
            overrides.txb.object(poolInfo.clob),
            overrides.txb.pure(String(orderId)),
            overrides.txb.object(accountCap),
        ],
    });
    overrides.txb.setGasBudget(overrides.gasBudget);
    return overrides.txb;
}
```

### Cancel all orders {#cancel-all-orders}

Cancel all limit orders under a certain account capacity.

**Function signature for canceling single order in Move contract**

```move
/// parameters expected by this func
///
///   0. `[pool]` Object ID refers to the pool of the trading pair
///   1. `[account_cap]` Object ID of the account_cap authorizing the
///       accessilility to the escrow account

/// Returns none
public fun cancel_all_orders<BaseAsset, QuoteAsset>(
     pool: &mut Pool<BaseAsset, QuoteAsset>,
     account_cap: &AccountCap
)
```

**TypeScript SDK for cancel all orders**

```ts
/**
 * @description: Cancel all limit orders under a certain account capacity
 * @param token1: Full coin type(recommend) of base asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::wbtc::WBTC" for example
 * @param token2: Full coin type(recommend) of quote asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::usdt::USDT" for example
 * @param accountCap: Object id of account capacity under usr address, created after invoking createAccount
 * @param overrides: overriders for blockchain params. Like gas budget, transaction block and the provider, default we will set to the max gas budget, and create a new transaction block
 * @notice: the packageId should be set in configs.json, if it is not set, the transaction will fail.
 */
public async cancelAllOrders(
    token1: string,
    token2: string,
    accountCap: string,
    overrides: Overrides = new Overrides(),
): Promise<TransactionBlock> {
    const tokenType1 = convertToTokenType(token1, this.records);
    const tokenType2 = convertToTokenType(token2, this.records);
    const poolInfo: PoolInfo = getPoolInfoByRecords(tokenType1, tokenType2, this.records);
    overrides.txb.moveCall({
        typeArguments: [token1, token2],
        target: `${this.configs.swapPackageId}::clob::cancel_all_orders`,
        arguments: [overrides.txb.object(poolInfo.clob), overrides.txb.object(accountCap)],
    });
    overrides.txb.setGasBudget(overrides.gasBudget);
    return overrides.txb;
}
```

### Batch cancel orders {#batch-cancel-orders}

Cancel multiple limit orders to save gas costs. Abort if any of the order ids is invalid or is not submitted by the sender. Note that this function can reduce gas costs even further if the caller has multiple orders at the same price level and if orders with the same price are grouped in the vector.

For example, if we have the following `order_id` to price mapping, `{0: 100., 1: 200., 2: 100., 3: 200.}`. Grouping `order_ids` like `[0, 2, 1, 3]` would make it the most gas efficient.

**Function signature for batch cancel order**

```move
/// parameters expected by this func
///
///   0. `[pool]` Object ID refers to the pool containing the trading pair
///   1. `[order_ids]` List of object ID of the pool containing the trading pair
///   2. `[account_cap]` Object ID of the account_cap authorize the
///       accessilility to the escrow account

/// Returns none
public fun batch_cancel_order<BaseAsset, QuoteAsset>(
        pool: &mut Pool<BaseAsset, QuoteAsset>,
        order_ids: vector<u64>,
        account_cap: &AccountCap
)
```

**TypeScript SDK for cancel all orders**

```ts
/**
 * @description: batch cancel order
 * @param token1: Full coin type(recommend) of base asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::wbtc::WBTC" for example
 * @param token2: Full coin type(recommend) of quote asset "0x3d0d0ce17dcd3b40c2d839d96ce66871ffb40e1154a8dd99af72292b3d10d7fc::usdt::USDT" for example
 * @param orderIds: Order ids to cancel corresponding orders
 * @param accountCap: Object id of account capacity under usr address, created after invoking createAccount
 * @param overrides: overriders for blockchain params. Like gas budget, transaction block and the provider, default we will set to the max gas budget, and create a new transaction block
 * @notice: the packageId should be set in configs.json, if it is not set, the transaction will fail.
 */
public async batchCancelOrder(
    token1: string,
    token2: string,
    orderIds: Uint8Array,
    accountCap: string,
    overrides: Overrides = new Overrides(),
): Promise<TransactionBlock> {
    const tokenType1 = convertToTokenType(token1, this.records);
    const tokenType2 = convertToTokenType(token2, this.records);
    const poolInfo: PoolInfo = getPoolInfoByRecords(tokenType1, tokenType2, this.records);
    overrides.txb.moveCall({
        typeArguments: [tokenType1, tokenType2],
        target: `${this.configs.swapPackageId}::clob::batch_cancel_order`,
        arguments: [
            overrides.txb.object(String(poolInfo.clob)),
            overrides.txb.pure(String(orderIds)),
            overrides.txb.object(accountCap),
        ],
    });
    overrides.txb.setGasBudget(defaultGasBudget);
    return overrides.txb;
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv2/query-the-pool.mdx
```
---
title: Query the Pool
---

{@include: ../../snippets/deepbook-v2-dep.mdx}

This section shows how to query the pool and order status.

## Order status {#order-status}

For limit order, query its data using the following API functions

**Function signature for query order info in Move contract**

```move
/// Parameters expected by this func
///
///   0. `[pool]` Object ID refers to the pool containing the trading pair
///   1. `[order_id]` order id of the order being queried
///   2. `[account_cap]` Object ID of the account_cap authorizing the
///       accessilility to the escrow account

/// Returns the order info of the order being queried
public fun get_order_status<BaseAsset, QuoteAsset>(
     pool: &Pool<BaseAsset, QuoteAsset>,
     order_id: u64,
     account_cap: &AccountCap
): &Order
```

## Pool status {#pool-status}

API functions to query the depth of `level2` orders on both ask-side and bid-side.

**Function signature for get depth of level2 order (ask side) in Move contract**

```move
/// Parameters expected by this func
///
///   0. `[pool]` Object ID refers to the pool containing the trading pair
///   1. `[price_low]` the lower price of the price interval to query, inclusive
///   2. `[price_high]` the upper price of the price interval to query, inclusive
///   3. `[clock]` Object ID of global system clock

/// Returns the list of all valid prices and corresponding depthes
public fun get_level2_book_status_bid_side<BaseAsset, QuoteAsset>(
     pool: &Pool<BaseAsset, QuoteAsset>,
     price_low: u64,
     price_high: u64,
     clock: &Clock
): (vector<u64>, vector<u64>)
```

## User account status {#user-account-status}

### Open orders {#open-orders}

We provide API function to list all open orders under one account

**Function signature for list all open orders in Move contract**

```move
/// Parameters expected by this func
///
///   0. `[pool]` Object ID refers to the pool containing the trading pair
///   1. `[account_cap]` Object ID of the account_cap authorizing the
///       accessilility to the escrow account

/// Returns list of user's all open orders
public fun list_open_orders<BaseAsset, QuoteAsset>(
     pool: &Pool<BaseAsset, QuoteAsset>,
     account_cap: &AccountCap
): vector<Order>
```

### Account balance {#order-status}

The API function to query the custodian account balance for users follows. Note that each pool has its own custodian account.

**Function signature for query user balance in Move contract**

```move
/// Parameters expected by this func
///
///   0. `[pool]` Object ID refers to the pool containing the trading pair
///   1. `[account_cap]` Object ID of the account_cap authorizing the
///       accessilility to the escrow account

/// Returns user's base_asset_available, base_asset_locked,
///                quote_asset_available, quote_asset_locked
public fun usr_balance<BaseAsset, QuoteAsset>(
     pool: &Pool<BaseAsset, QuoteAsset>,
     account_cap: &AccountCap
): (u64, u64, u64, u64)
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv2/routing-a-swap.mdx
```
---
title: Routing a Swap
---

{@include: ../../snippets/deepbook-v2-dep.mdx}

Follow these instructions to construct and execute a trade using a smart-routing swap.

## Find the best route to swap {#swap-route}

To use the smart routing functionality, one should first find the best route. The route uses a Depth-First-Search (DFS) algorithm to find all the routes in the swap pools and use dry-run to simulate how much token one can get from each route. The function will return the best route which can provide maximum tokens.

**Typescript SDK for invoking `findBestRoute`**

```ts
/**
 * @param tokenInObject: the tokenObject you want to swap
 * @param tokenOut: the token you want to swap to
 * @param amountIn: the amount of token you want to swap
 * @notice: the packageId should be set in configs.json, if it is not set, the transaction will fail.
 */
public async findBestRoute(tokenInObject: string, tokenOut: string, amountIn: number): Promise<smartRouteResult> {
    // const tokenTypeIn: string = convertToTokenType(tokenIn, this.records);
    // should get the tokenTypeIn from tokenInObject
    const tokenInfo = await this.suiClient.getObject({
        id: tokenInObject,
        options: {
            showType: true,
        },
    });
    const tokenTypeIn = tokenInfo.data.type.split('<')[1].split('>')[0];
    const tokenTypeOut: string = convertToTokenType(tokenOut, this.records);
    const paths: string[][] = this.dfs(tokenTypeIn, tokenTypeOut, this.records);
    let maxSwapTokens = 0;
    let smartRoute: string[] = [];
    for (const path of paths) {
        const smartRouteResultWithExactPath = await this.placeMarketOrderWithSmartRouting(
            tokenInObject,
            tokenTypeOut,
            amountIn,
            this.currentAddress,
            path,
        );
        if (smartRouteResultWithExactPath && smartRouteResultWithExactPath.amount > maxSwapTokens) {
            maxSwapTokens = smartRouteResultWithExactPath.amount;
            smartRoute = path;
        }
    }
    return {maxSwapTokens, smartRoute};
}
```

## Place a market order with a given routing path {#market-order}

After users find the best route to swap the tokens, they can place the market order using this route. In this function, users input the path as one of the parameters to build a transaction for execution.

**Typescript SDK for invoking `placeMarketOrderWithSmartRouting`**

```ts
/**
 * @param tokenInObject: the tokenObject you want to swap
 * @param tokenTypeOut: the token type you want to swap to
 * @param amountIn: the amount of token you want to swap
 * @param currentAddress: your own address
 * @param path: the path you want to swap through
 * @param overrides: overriders for gas budget and transaction block, default we will set to the max gas budget, and create a new transaction block
 * @notice: the packageId should be set in configs.json, if it is not set, the transaction will fail.
 */
public async placeMarketOrderWithSmartRouting(
    tokenInObject: string,
    tokenTypeOut: string,
    amountIn: number,
    currentAddress: string,
    path: string[],
    overrides: Overrides = new Overrides(),
): Promise<smartRouteResultWithExactPath> {
    const tokenIn = overrides.txb.object(tokenInObject);
    overrides.txb.setGasBudget(overrides.gasBudget);
    overrides.txb.setSenderIfNotSet(currentAddress);
    let i = 0;
    let base_coin_ret, quote_coin_ret, amount;
    let lastBid: boolean;
    while (path[i]) {
        const nextPath = path[i + 1] ? path[i + 1] : tokenTypeOut;
        const poolInfo: PoolInfo = getPoolInfoByRecords(path[i], nextPath, this.records);
        let _isBid, _tokenIn, _tokenOut, _amount;
        if (i == 0) {
            if (!poolInfo.needChange) {
                _isBid = false;
                _tokenIn = tokenIn;
                _tokenOut = this.mint(nextPath, 0, {
                    txb: overrides.txb,
                });
                _amount = overrides.txb.object(String(amountIn));
            } else {
                _isBid = true;
                // _tokenIn = this.mint(txb, nextPath, 0)
                _tokenOut = tokenIn;
                _amount = overrides.txb.object(String(amountIn));
            }
        } else {
            if (!poolInfo.needChange) {
                overrides.txb.transferObjects(
                    [lastBid ? quote_coin_ret : base_coin_ret],
                    overrides.txb.pure(currentAddress),
                );
                _isBid = false;
                _tokenIn = lastBid ? base_coin_ret : quote_coin_ret;
                _tokenOut = this.mint(nextPath, 0, {
                    txb: overrides.txb,
                });
                _amount = amount;
            } else {
                overrides.txb.transferObjects(
                    [lastBid ? quote_coin_ret : base_coin_ret],
                    overrides.txb.pure(currentAddress),
                );
                _isBid = true;
                // _tokenIn = this.mint(txb, nextPath, 0)
                _tokenOut = lastBid ? base_coin_ret : quote_coin_ret;
                _amount = amount;
            }
        }
        lastBid = _isBid;
        // in this moveCall we will change to swap_exact_base_for_quote
        // if isBid, we will use swap_exact_quote_for_base
        // is !isBid, we will use swap_exact_base_for_quote
        if (_isBid) {
            // here swap_exact_quote_for_base
            [base_coin_ret, quote_coin_ret, amount] = overrides.txb.moveCall({
                typeArguments: [poolInfo.needChange ? nextPath : path[i], poolInfo.needChange ? path[i] : nextPath],
                target: `${this.configs.swapPackageId}::clob::swap_exact_quote_for_base`,
                arguments: [
                    overrides.txb.object(String(poolInfo.clob)),
                    _amount,
                    overrides.txb.object(normalizeSuiObjectId(this.configs.clock)),
                    _tokenOut,
                ],
            });
        } else {
            // here swap_exact_base_for_quote
            [base_coin_ret, quote_coin_ret, amount] = overrides.txb.moveCall({
                typeArguments: [poolInfo.needChange ? nextPath : path[i], poolInfo.needChange ? path[i] : nextPath],
                target: `${this.configs.swapPackageId}::clob::swap_exact_base_for_quote`,
                arguments: [
                    overrides.txb.object(String(poolInfo.clob)),
                    _amount,
                    _tokenIn,
                    _tokenOut,
                    overrides.txb.object(normalizeSuiObjectId(this.configs.clock)),
                ],
            });
        }
        if (nextPath == tokenTypeOut) {
            overrides.txb.transferObjects([base_coin_ret], overrides.txb.pure(currentAddress));
            overrides.txb.transferObjects([quote_coin_ret], overrides.txb.pure(currentAddress));
            break;
        } else {
            i += 1;
        }
    }
    const r = await this.suiClient.dryRunTransactionBlock({
        transactionBlock: await overrides.txb.build({
            client: this.suiClient,
        }),
    });
    if (r.effects.status.status === 'success') {
        for (const ele of r.balanceChanges) {
            if (ele.coinType == tokenTypeOut) {
                return {
                    txb: overrides.txb,
                    amount: Number(ele.amount),
                };
            }
        }
    }
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv2/orders.mdx
```
---
title: DeepBook Orders
sidebar_label: Orders
---

{@include: ../../snippets/deepbook-v2-dep.mdx}

## Order book structure {#order-book-structure}

DeepBook adopts a hyper-efficient approach to store orders. Each pool stores the unfilled maker orders. Taker orders are filled instantaneously within the same transaction the order is submitted. Bid and ask orders are stored separately, each with a two-level nested crit-bit tree. The first level crit-bit tree is ordered using the price of the maker order, and the second level crit-bit tree is ordered using the order id of the maker order.

## Placing orders {#placing-orders}

DeepBook supports the placement of market orders and limit orders. DeepBook also supports a few configurations of limit orders, which is covered in the API section. When users submit a market order, it is matched against the existing maker orders on the order book instantaneously in the same transaction upon submission of the market order. When users submit a limit order, the limit order is first matched against the existing maker orders as a taker order. If the order cannot be fully filled, the remaining quantity can either be injected as a maker order or be dropped, depending on the configuration of the limit order. See the API section for further details.

```move
struct Order has store, drop {
    // For each pool, order id is incremental and unique for each opening order.
    // Orders that are submitted earlier have lower order ids.
    // 64 bits are sufficient for order ids, whereas 32 bits are not.
    // Assuming a maximum TPS of 100K/s of Sui chain, it would take (1<<63) / 100000 / 3600 / 24 / 365 = 2924712 years to reach the full capacity.
    // The highest bit of the order id denotes the order type, 0 for bid, 1 for ask.
    order_id: u64,
    // Only used for limit orders.
    price: u64,
    quantity: u64,
    is_bid: bool,
    // Order can only be canceled by the owner.
    owner: ID,
    // Expiration timestamp in ms.
    expire_timestamp: u64,
}
```

## Order matching {#order-matching}

Order matching occurs when a taker order is submitted to the CLOB without a centralized entity or crank involvement. Taker orders are matched against the existing maker orders in the CLOB in the same transaction the taker order is submitted.

## Order tracking {#order-tracking}

DeepBook supports efficient tracking of maker orders. Each unfilled maker order is associated with a unique u64 order id, and users can query the order status using the order id together with the Sui RPC call. Users can also subscribe to the event stream emitted by DeepBook related to changes in order status. DeepBook currently supports the following events, `OrderPlaced`, `OrderFilled` and `OrderCanceled`.

```move
/// Emitted when a maker order is injected into the order book.
struct OrderPlaced<phantom BaseAsset, phantom QuoteAsset> has copy, store, drop {
    order_id: u64,
    is_bid: bool,
    owner: ID,
    base_asset_quantity_placed: u64,
    price: u64
}

/// Emitted when a maker order is canceled.
struct OrderCanceled<phantom BaseAsset, phantom QuoteAsset> has copy, store, drop {
    order_id: u64,
    is_bid: bool,
    owner: ID,
    base_asset_quantity_canceled: u64,
    price: u64
}

/// Emitted only when a maker order is filled.
struct OrderFilled<phantom BaseAsset, phantom QuoteAsset> has copy, store, drop {
    order_id: u64,
    is_bid: bool,
    owner: ID,
    total_quantity: u64,
    base_asset_quantity_filled: u64,
    base_asset_quantity_remaining: u64,
    price: u64
}
```

The following example uses the [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript) to connect via websocket to listen to events.

```javascript
const local_client = new SuiClient({ url: 'https://fullnode.mainnet.sui.io:443/' });
const deepbook_client = new DeepBookClient(local_client);

const deepbook = '0x000000000000000000000000000000000000000000000000000000000000dee9';
const deepbookClobEventsFilter = {
	MoveModule: { package: deepbook, module: 'clob_v2' },
};

// Note that these names must be exact
const moveEventsFilter = {
	MoveEventType:
		'0xdee9::clob_v2::OrderPlaced<0xaf8cd5edc19c4512f4259f0bee101a40d41ebed738ade5874359610ef8eeced5::coin::COIN, 0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>',
};
const orderFilledFilter = {
	MoveEventType:
		'0xdee9::clob_v2::OrderFilled<0xaf8cd5edc19c4512f4259f0bee101a40d41ebed738ade5874359610ef8eeced5::coin::COIN, 0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>',
};
const poolFilter = {
	MoveEventField: {
		path: '/pool_id',
		value: '0xd9e45ab5440d61cc52e3b2bd915cdd643146f7593d587c715bc7bfa48311d826',
	},
};

deepbook_client.suiClient.subscribeEvent({
	filter: moveEventsFilter,
	onMessage(event) {
		console.log(event);
		// handle subscription notification message here
	},
});
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv2/pools.mdx
```
---
title: DeepBook Pools
---

{@include: ../../snippets/deepbook-v2-dep.mdx}

At the center of DeepBook is a hyper-efficient per-current pair shared-object `Pool` structure. This architecture maximally utilizes Sui's Mysticeti consensus engine to minimize contention and achieve high throughput.

For each base and quote asset trading pair, a globally shared `Pool` is created to bookkeep open orders on the order book and handle placement, cancellation, and settlement of orders. Under this architecture, transactions involving different trading pairs can be easily parallelized to maximize throughput.

DeepBook uses a critical bit (crit-bit) tree structure to process orders. Each left and right node is based on the critical bit of the price. Inside each of the nodes is a list of orders placed with a hierarchy based on the time each occurred.

```mermaid
flowchart TB
    A{"Ask crit-bit tree"};
    B("Price level: 1000000000\nOrders queue: A > B > ...");
    C("Price level: 1100000000\nOrder queue: C");
    A-->B;
    A-->C;
```

```move
struct Pool<phantom BaseAsset, phantom QuoteAsset> has key {
    // The key to the following crit-bit tree are order prices.
    id: UID,
    // All open bid orders.
    bids: CritbitTree<TickLevel>,
    // All open ask orders.
    asks: CritbitTree<TickLevel>,
    // Order id of the next bid order, starting from 0.
    next_bid_order_id: u64,
    // Order id of the next ask order, starting from 1<<63.
    next_ask_order_id: u64,
    // Map from order id to price level for fast retrieval of orders upon canceling of orders.
    usr_open_orders: Table<ID, Table<u64, Order>>,
    // taker_fee_rate should be strictly greater than maker_rebate_rate.
    // The difference between taker_fee_rate and maker_rabate_rate goes to the protocol.
    // 10^9 scaling
    taker_fee_rate: u64,
    // 10^9 scaling
    maker_rebate_rate: u64,
    tick_size: u64,
    lot_size: u64,
    // other pool info
    base_custodian: Custodian<BaseAsset>,
    quote_custodian: Custodian<QuoteAsset>,
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv2/design.mdx
```
---
title: DeepBook Design
sidebar_label: Design
---

{@include: ../../snippets/deepbook-v2-dep.mdx}

## Pools {#pools}

At the center of DeepBook is a hyper-efficient per-current pair shared-object pool structure. This architecture maximally utilizes Sui's Mysticeti consensus engine to minimize contention and achieve high throughput.

For each base and quote asset trading pair, a globally shared pool is created to bookkeep open orders on the order book and handle placement, cancellation, and settlement of orders. Under this architecture, you can parallelize transactions involving different trading pairs to maximize throughput.

```move
struct Pool<phantom BaseAsset, phantom QuoteAsset> has key {
    // The key to the following crit-bit tree are order prices.
    id: UID,
    // All open bid orders.
    bids: CritbitTree<TickLevel>,
    // All open ask orders.
    asks: CritbitTree<TickLevel>,
    // Order id of the next bid order, starting from 0.
    next_bid_order_id: u64,
    // Order id of the next ask order, starting from 1<<63.
    next_ask_order_id: u64,
    // Map from order id to price level for fast retrieval of orders upon canceling of orders.
    usr_open_orders: Table<ID, Table<u64, Order>>,
    // taker_fee_rate should be strictly greater than maker_rebate_rate.
    // The difference between taker_fee_rate and maker_rabate_rate goes to the protocol.
    // 10^9 scaling
    taker_fee_rate: u64,
    // 10^9 scaling
    maker_rebate_rate: u64,
    tick_size: u64,
    lot_size: u64,
    // other pool info
    base_custodian: Custodian<BaseAsset>,
    quote_custodian: Custodian<QuoteAsset>,
}
```

### Order book structure {#order-book-structure}

DeepBook adopts a hyper-efficient approach to store orders. Each pool stores the unfilled maker orders. Taker orders are filled instantaneously within the same transaction the order is submitted. Bid and ask orders are stored separately, each with a two-level nested crit-bit tree. The first level crit-bit tree is ordered using the price of the maker order, and the second level crit-bit tree is ordered using the order ID of the maker order.

```mermaid
flowchart LR
    subgraph Buy side orders
     B("5 @ .4222\n10 @ .4221\n125 @ .4215\n50 @ .4214\n200 @ .4200\n10000 @ .4000")
    end
    subgraph Sell side orders
     C("10000 @ .4500\n10 @ .4421\n125 @ .4255\n50 @ .4244\n200 @ .4240\n15 @ .4230")
    end
    B---C;
```
<small>Orders are prioritized by value</small>

### Placing orders {#placing-orders}

DeepBook supports the placement of market orders and limit orders. DeepBook also supports a few configurations of limit orders, which are covered in the API section. When users submit a market order, it is matched against the existing maker orders on the order book instantaneously in the same transaction upon submission of the market order. When users submit a limit order, the limit order is first matched against the existing maker orders as a taker order. If the order cannot be fully filled, the remaining quantity can either be injected as a maker order or be dropped, depending on the configuration of the limit order. See the API section for further details.

```move
struct Order has store, drop {
    // For each pool, order id is incremental and unique for each opening order.
    // Orders that are submitted earlier have lower order ids.
    // 64 bits are sufficient for order ids, whereas 32 bits are not.
    // Assuming a maximum TPS of 100K/s of Sui chain, it would take (1<<63) / 100000 / 3600 / 24 / 365 = 2924712 years to reach the full capacity.
    // The highest bit of the order id denotes the order type, 0 for bid, 1 for ask.
    order_id: u64,
    // Only used for limit orders.
    price: u64,
    quantity: u64,
    is_bid: bool,
    // Order can only be canceled by the owner.
    owner: ID,
    // Expiration timestamp in ms.
    expire_timestamp: u64,
}
```

## Orders {#orders}

### Order matching {#order-matching}

Order matching occurs when a taker order is submitted to the Central Limit Order Book (CLOB) without a centralized entity or crank involvement. Taker orders are matched against the existing maker orders in the CLOB in the same transaction the taker order is submitted.

### Order tracking {#order-tracking}

DeepBook supports efficient tracking of maker orders. Each unfilled maker order is associated with a unique u64 order id, and users can query the order status using the order id together with the Sui RPC call. Users can also subscribe to the event stream emitted by DeepBook related to changes in order status. DeepBook currently supports the following events, `OrderPlaced`, `OrderFilled`, and `OrderCanceled`.

```move
/// Emitted when a maker order is injected into the order book.
struct OrderPlaced<phantom BaseAsset, phantom QuoteAsset> has copy, store, drop {
    order_id: u64,
    is_bid: bool,
    owner: ID,
    base_asset_quantity_placed: u64,
    price: u64
}

/// Emitted when a maker order is canceled.
struct OrderCanceled<phantom BaseAsset, phantom QuoteAsset> has copy, store, drop {
    order_id: u64,
    is_bid: bool,
    owner: ID,
    base_asset_quantity_canceled: u64,
    price: u64
}

/// Emitted only when a maker order is filled.
struct OrderFilled<phantom BaseAsset, phantom QuoteAsset> has copy, store, drop {
    order_id: u64,
    is_bid: bool,
    owner: ID,
    total_quantity: u64,
    base_asset_quantity_filled: u64,
    base_asset_quantity_remaining: u64,
    price: u64
}
```

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3/flash-loans.mdx
```
---
title: Flash Loans
description: Use DeepBook to perform flash loans, uncollaterized loans that are borrowed and repaid within the same programmable transaction block.
---

Flash loans by definition are uncollaterized loans that are borrowed and repaid within the same programmable transaction block. Users can borrow flash loans in the base or quote asset from any DeepBook pool. Flash loans return a `FlashLoan` hot potato (struct with no abilities), which must be returned back to the pool by the end of the call. The transaction is atomic, so the entire transaction fails if the loan is not returned. 

The quantity borrowed can be the maximum amount that the pool owns. Borrowing from a pool and trading in the same pool can result in failures because trading requires the movement of funds. If the funds are borrowed, then there are no funds to move.

## API

Following are the endpoints that the `Pool` exposes for flash loans.

### Borrow flash loan base

Borrow base assets from the `Pool`. The function returns a hot potato, forcing the borrower to return the assets within the same transaction.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=borrow_flashloan_base noComments}

### Borrow flash loan quote

Borrow quote assets from the `Pool`. The function returns a hot potato, forcing the borrower to return the assets within the same transaction.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=borrow_flashloan_quote noComments}

### Retrieve flash loan base

Return the flash loaned base assets to the `Pool`. `FlashLoan` object is unwrapped only if the assets are returned, otherwise the transaction fails.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=return_flashloan_base noComments}

### Retrieve flash loan quote

Return the flash loaned quote assets to the `Pool`. `FlashLoan` object is unwrapped only if the assets are returned,
otherwise the transaction fails.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=return_flashloan_quote noComments}

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3/query-the-pool.mdx
```
---
title: Query the Pool
---

The `Pool` shared object represents a market, such as a SUI/USDC market. That `Pool` is the only one representing that unique pairing (SUI/USDC) and the pairing is the only member of that particular `Pool`. See [DeepBook Design](./design.mdx#pool) to learn more about the structure of pools.

To perform trades, you pass a `BalanceManager` and `TradeProof` into the relevant `Pool`. Unlike `Pool`s, `BalanceManager` shared objects can contain any type of token, such that the same `BalanceManager` can access multiple `Pool`s to interact with many different trade pairings. See [BalanceManager](./balance-manager.mdx) to learn more.

## API

DeepBook exposes a set of endpoints that can be used to query any pool.

### Check whitelist status

Accessor to check whether the pool is whitelisted.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=whitelisted noComments}

### Check quote quantity against base (DEEP fees)

Dry run to determine the quote quantity out for a given base quantity. Uses DEEP as fee.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_quote_quantity_out noComments}

### Check base quantity against quote (DEEP fees)

Dry run to determine the base quantity out for a given quote quantity. Uses DEEP as fee.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_base_quantity_out noComments}

### Check quote quantity against base (input token fees)

Dry run to determine the quote quantity out for a given base quantity. Uses input token as fee.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_quote_quantity_out_input_fee noComments}

### Check base quantity against quote (input token fees)

Dry run to determine the base quantity out for a given quote quantity. Uses input token as fee.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_base_quantity_out_input_fee noComments}

### Check quote quantity against quote or base

Dry run to determine the quantity out for a given base or quote quantity. Only one out of base or quote quantity should be non-zero. Returns the (`base_quantity_out`, `quote_quantity_out`, `deep_quantity_required`).

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_quantity_out noComments}

### Check fee required

Returns the DEEP required for an order if it's a taker or maker given quantity and price (`deep_required_taker`, `deep_required_maker`).

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_order_deep_required noComments}

### Retrieve mid price for a pool

Returns the mid price of the pool.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=mid_price noComments}

### Retrieve order IDs

Returns the `order_id` for all open orders for the `balance_manager` in the pool.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=account_open_orders noComments}

### Retrieve prices and quantities for an order book

Returns vectors holding the prices (`price_vec`) and quantities (`quantity_vec`) for the level2 order book. The `price_low` and `price_high` are inclusive, all orders within the range are returned. `is_bid` is `true` for bids and `false` for asks.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_level2_range noComments}

Returns vectors holding the prices (`price_vec`) and quantities (`quantity_vec`) for the level2 order book. `ticks` are the maximum number of ticks to return starting from best bid and best ask. (`bid_price`, `bid_quantity`, `ask_price`, `ask_quantity`) are returned as four vectors. The price vectors are sorted in descending order for bids and ascending order for asks.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_level2_ticks_from_mid noComments}

### Retrieve balances

Get all balances held in this pool.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=vault_balances noComments}

### Retrieve pool ID

Get the ID of the pool given the asset types.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_pool_id_by_asset noComments}

### Retrieve order information

Returns the `Order` struct using the order ID.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_order noComments}

Returns a vector of `Order` structs using a vector of order IDs.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_orders noComments}

Returns a vector of `Order` structs for all orders that belong to a `BalanceManager` in the pool.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_account_order_details noComments}

### Retrieve locked balance

Returns the locked balance for a `BalanceManager` in the pool (`base_quantity`, `quote_quantity`, `deep_quantity`).

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=locked_balance noComments}

### Retrieve pool parameters

Returns the trade parameters for the pool (`taker_fee`, `maker_fee`, `stake_required`).

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=pool_trade_params noComments}

Returns the trade parameters for the next epoch for the currently leading proposal of the pool (`taker_fee`, `maker_fee`, `stake_required`).

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=pool_trade_params_next noComments}

Returns the quorum needed to pass proposal in the current epoch.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=quorum noComments}

Returns the book parameters for the pool (`tick_size`, `lot_size`, `min_size`).

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=pool_book_params noComments}

Returns the `OrderDeepPrice` struct for the pool, which determines the conversion for DEEP fees.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=get_order_deep_price noComments}

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3/swaps.mdx
```
---
title: Swaps
---

DeepBook provides a swap-like interface commonly seen in automatic market makers (AMMs). Unlike the order functions, you can call `swap_exact_amount` without a `BalanceManager`. You call it directly with `Coin` objects instead. When swapping from base to quote, `base_in` must have a positive value while `quote_in` must be zero. When swapping from quote to base, `quote_in` must be positive and `base_in` zero. Some `deep_in` amount is required to pay for trading fees. You can overestimate this amount, as the unused DEEP tokens are returned at the end of the call.

You can use the `get_amount_out` endpoint to simulate a swap. The function returns the exact amount of DEEP tokens that the swap requires.

## API

Following are the endpoints that the `Pool` exposes for swaps.

### Swap exact base for quote

Swap exact base quantity without needing a `balance_manager`. DEEP quantity can be overestimated. Returns three `Coin` objects:     
    - `BaseAsset`
    - `QuoteAsset`
    - `DEEP` 

Some base quantity may be left over, if the input quantity is not divisible by lot size.

You can overestimate the amount of DEEP required. The remaining balance is returned.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=swap_exact_base_for_quote noComments}

### Swap exact quote for base

Swap exact quote quantity without needing a `balance_manager`. You can overestimate DEEP quantity. Returns three `Coin` objects:
    - `BaseAsset`
    - `QuoteAsset`
    - `DEEP`

Some quote quantity might be left over if the input quantity is not divisible by lot size.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=swap_exact_quote_for_base noComments}

### Swap exact quantity

This function is what the previous two functions call with `coin::zero()` set for the third coin. Users can call this directly for base → quote or quote → base as long as base or quote have a zero value.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=swap_exact_quantity noComments}

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3/orders.mdx
```
---
title: DeepBook Orders
sidebar_label: Orders
---

Users can create limit or market orders, modify orders, and cancel orders. The `BalanceManager` must have the necessary funds to process orders. DeepBook has four order options and three self matching options. If you set the `pay_with_deep` flag to `true`, trading fees are paid with the DEEP token. If you set the `pay_with_deep` flag to `false`, trading fees are paid with the input token.

Users can modify their existing order, reducing the size, lowering the expiration time, or both. Users cannot modify their order to increase their size or increase their expiration time. To do that, they must cancel the original order and place a new order.

Users can cancel a single order or cancel all of their orders.

## API

Following are the order related endpoints that `Pool` exposes.

### Order options

The following constants define the options available for orders.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/helper/constants.move#variable=NO_RESTRICTION,IMMEDIATE_OR_CANCEL,FILL_OR_KILL,POST_ONLY}

### Self-matching options

The following constants define the options available for self-matching orders.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/helper/constants.move#variable=SELF_MATCHING_ALLOWED,CANCEL_TAKER,CANCEL_MAKER}

### OrderInfo struct

Placing a limit order or a market order creates and returns an `OrderInfo` object. DeepBook automatically drops this object after the order completes or is placed in the book. Use `OrderInfo` to inspect the execution details of the request as it represents all order information. DeepBook does not catch any errors, so if there’s a failure of any kind, then the entire transaction fails.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/book/order_info.move#struct=OrderInfo}

### OrderDeepPrice struct

The `OrderDeepPrice` struct represents the conversion rate of DEEP at the time the order was placed.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/vault/deep_price.move#struct=OrderDeepPrice}

### Fill struct

The `Fill` struct represents the results of a match between two orders. Use this struct to update the state.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/book/fill.move#struct=Fill}

### Events

DeepBook emits `OrderFilled` when a maker order is filled.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/book/order_info.move#struct=OrderFilled}

DeepBook emits `OrderCanceled` when a maker order is canceled.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/book/order.move#struct=OrderCanceled}

DeepBook emits `OrderModified` on modification of a maker order.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/book/order.move#struct=OrderModified}

DeepBook emits `OrderPlaced` when it injects a maker order into the order book.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/book/order_info.move#struct=OrderPlaced}

### Place limit order

Place a limit order. Quantity is in base asset terms. For current version `pay_with_deep` must be true, so the 
fee is paid with DEEP tokens. 

You must combine a `BalanceManager` call of generating a `TradeProof` before placing orders.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=place_limit_order noComments}

### Place market order

Place a market order. Quantity is in base asset terms. Calls `place_limit_order` with a price of `MAX_PRICE` for bids and `MIN_PRICE` for asks. DeepBook cancels the order for any quantity not filled.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=place_market_order noComments}

### Modify order

Modifies an order given `order_id` and `new_quantity`. New quantity must be less than the original quantity and more than the filled quantity. Order must not have already expired.

The `modify_order` function does not return anything. If the transaction is successful, then assume the modification was successful.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=modify_order noComments}

### Cancel order

Cancel an order. The order must be owned by the `balance_manager`. The order is removed from the book and the `balance_manager` open orders. The `balance_manager` balance is updated with the order's remaining quantity.

Similar to modify, `cancel_order` does not return anything. DeepBook emits `OrderCanceled` event.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=cancel_order noComments}

### Withdraw settled amounts

Withdraw settled amounts to the `balance_manager`. All orders automatically withdraw settled amounts. This can be called explicitly to withdraw all settled funds from the pool.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=withdraw_settled_amounts noComments}

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3/staking-governance.mdx
```
---
title: Staking and Governance
---

DeepBook's novel approach to governance allows users to update a single pool's three parameters: 
  - taker fee rate
  - maker fee rate
  - stake required

Stake required is the amount of DEEP tokens a user must have staked in the pool to take advantage of taker and maker incentives. Each individual DeepBook pool has independent governance, and governance can be conducted every epoch. See [Design](./design.mdx#governance) to learn more about governance.

![DeepBook Governance Timeline.png](./images/governance.png)

## API

`Pool` exposes the following endpoints for staking and governance.

### Stake

DEEP tokens must be available in the `balance_manager` for staking. A user's stake becomes active in the following epoch. If the user's active stake is greater than the stake required, the user can get reduced taker fees and can accumulate trading fee rebates during that epoch.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=stake noComments}

### Unstake

All of the user's active and inactive stake are removed and added back into the `BalanceManager`. Any casted votes are removed. Maker rebates for the epoch are forfeited, and any reduced taker fees for the remaining epoch are disabled.

The `balance_manager` must have enough staked DEEP tokens. The `balance_manager` data is updated with the unstaked amount. Balance is transferred to the `balance_manager` immediately.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=unstake noComments}

### Submit proposal

Users with a non zero active stake can submit proposals. One proposal per user. The user automatically votes for the proposal they submit.

Submit a proposal to change the taker fee, maker fee, and stake required. The `balance_manager` must have enough staked DEEP tokens to participate. Each `balance_manager` can only submit one proposal per epoch. If the maximum proposal is reached, the proposal with the lowest vote is removed. If the `balance_manager` has less voting power than the lowest voted proposal, the proposal is not added.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=submit_proposal noComments}

### Vote

Users with non-zero voting power can vote on a proposal. All voting power is used on a single proposal. If the user has voted on a different proposal during this epoch, then that vote is removed and recasted into the new proposal. The `balance_manager` must have enough staked DEEP tokens to participate.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=vote noComments}

### Claim rebates

Use `claim_rebates` to claim the rewards for the `balance_manager`. The `balance_manager` must have rewards to claim. The `balance_manager` data is updated with the claimed rewards.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=claim_rebates noComments}

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3/permissionless-pool.mdx
```
---
title: Permissionless Pool Creation
description: Learn how to create a pool permissionlessly.
---

The `Pool` shared object represents a market, such as a SUI/USDC market. That `Pool` is the only one representing that unique pairing (SUI/USDC) and the pairing is the only member of that particular `Pool`. See [DeepBook Design](./design.mdx#pool) to learn more about the structure of pools.

## API

### Create a `Pool`

The `create_permissionless_pool()` function creates a `Pool`

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=create_permissionless_pool noComments}

Tick size should be 10^(9 - base_decimals + quote_decimals - decimal_desired). For example, if creating a SUI(9 decimals)/USDC(6 decimals) pool, with a desired decimal of 3 for tick size (0.001), tick size should be 10^(9 - 9 + 6 - 3) = 10^(3) = 1000.

Decimal desired should be at most 1bps, or 0.01%, of the price between base and quote asset. For example, if 3 decimals is the target, 0.001 (three decimals) / price should be less than or equal to 0.0001. Consider a lower tick size for pools where both base and quote assets are stablecoins.

Lot size is in MIST of the base asset, and should be approximately &dollar;0.01 to &dollar;0.10 nominal of the base asset. Lot size must be a power of 10, and less than or equal to min size. Lot size should also be greater than or equal to 1,000.

Min size is in MIST of the base asset, and should be approximately &dollar;0.10 to &dollar;1.00 nominal of the base asset. Min size must be a power of 10, and larger than or equal to lot size.

Creation fee is 500 DEEP tokens.

:::info

Pools can only be created if the asset pair has not already been created before.

:::

### Add DEEP price point

The `add_deep_price_point()` function allows for the calculation of DEEP price and correct collection of fees in DEEP.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=add_deep_price_point noComments}

All pools support input token fees. To allow a permissionless pool to pay fees in DEEP, which has a 20% discount compared to input token fees, two conditions must be met:

1. Either the base or quote asset must be `USDC` or `SUI`.
2. To calculate DEEP fees accurately, you must set up a cron job to call the `add_deep_price_point()` function on the pool every 1-10 minutes.

For a pool with `USDC` as an asset, use the `DEEP/USDC` pool at `0xf948981b806057580f91622417534f491da5f61aeaf33d0ed8e69fd5691c95ce` as the reference pool.

For a pool with `SUI` as an asset, use the `DEEP/SUI` pool at `0xb663828d6217467c8a1838a03793da896cbe745b150ebd57d82f814ca579fc22` as the reference pool.

### Update allowed versions

The `update_allowed_versions()` function takes a pool and the registry, and updates the allowed contract versions within the pool.
This is very important after contract upgrades to ensure the newest contract can be used on the pool.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/pool.move#fun=update_allowed_versions noComments}

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3/balance-manager.mdx
```
---
title: BalanceManager
description: Learn about the balance manager and how it works
---

The `BalanceManager` shared object holds all balances for different assets. To perform trades, pass a combination of `BalanceManager` and `TradeProof` into a [pool](./design.mdx#pool). `TradeProof`s are generated in one of two ways, either by the `BalanceManager` owner directly, or by any `TradeCap` owner. The owner can generate a `TradeProof` without the risk of equivocation. The `TradeCap` owner, because it's an owned object, risks equivocation when generating a `TradeProof`. Generally, a high frequency trading engine trades as the default owner.

With exception to swaps, all interactions with DeepBook require a `BalanceManager` as one of its inputs. When orders are matched, funds are transferred to or from the `BalanceManager`. You can use a single `BalanceManager` between all pools.

## API

Following are the different public functions that the `BalanceManager` exposes.

### Create a `BalanceManager`

The `new()` function creates a `BalanceManager` hot potato (a struct with no abilities). Combine it with `share`, or else the transaction fails. You can combine the transaction with deposit calls, allowing you to create, deposit, then share the balance manager in one transaction.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/balance_manager.move#fun=new noComments}

### Create a `BalanceManager` with custom owner

The `new_with_owner()` function creates a `BalanceManager` hot potato (a struct with no abilities) with a custom owner. Combine it with `share`, or else the transaction fails. You can combine the transaction with deposit calls, allowing you to create, deposit, then share the balance manager in one transaction.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/balance_manager.move#fun=new_with_owner noComments}

### Mint a `TradeCap`

The owner of a `BalanceManager` can mint a `TradeCap` and send it to another address. Upon receipt, that address will have the capability to place orders with this `BalanceManager`. The address owner cannot deposit or withdraw funds, however. The maximum total number of `TradeCap`, `WithdrawCap`, and `DepositCap` that can be assigned for a `BalanceManager` is `1000`. If this limit is reached, one or more existing caps must be revoked before minting new ones. You can also use `revoke_trade_cap` to revoke `DepositCap` and `WithdrawCap`.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/balance_manager.move#fun=mint_trade_cap,revoke_trade_cap}

### Mint a `DepositCap` or `WithdrawCap`

The owner of a `BalanceManager` can mint a `DepositCap` or `WithdrawCap` and send it to another address. Upon receipt, that address will have the capability to deposit in or withdraw from `BalanceManager`. The address owner cannot execute trades, however. The maximum total number of `TradeCap`, `WithdrawCap`, and `DepositCap` that can be assigned for a `BalanceManager` is `1000`. If this limit is reached, one or more existing caps must be revoked before minting new ones.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/balance_manager.move#fun=mint_deposit_cap,mint_withdraw_cap}

### Generate a `TradeProof`

To call any function that requires a balance check or transfer, the user must provide their `BalanceManager` as well as a `TradeProof`. There are two ways to generate a trade proof, one used by the owner and another used by a `TradeCap` owner.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/balance_manager.move#fun=generate_proof_as_owner,generate_proof_as_trader}

### Deposit funds

Only the owner can call this function to deposit funds into the `BalanceManager`.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/balance_manager.move#fun=deposit}

### Withdraw funds

Only the owner can call this function to withdraw funds from the `BalanceManager`.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/balance_manager.move#fun=withdraw,withdraw_all}

### Deposit funds using `DepositCap`

Only holders of a `DepositCap` for the `BalanceManager` can call this function to deposit funds into the `BalanceManager`.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/balance_manager.move#fun=deposit_with_cap}

### Withdraw funds using `WithdrawCap`

Only holders of a `WithdrawCap` for the `BalanceManager` can call this function to withdraw funds from the `BalanceManager`.

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/balance_manager.move#fun=withdraw_with_cap}

### Read endpoints

{@inject: github:MystenLabs/deepbookv3/packages/deepbook/sources/balance_manager.move#fun=validate_proof,balance,owner,id}

```

../../Downloads/sui-stuff/sui-main/docs/content/standards/deepbookv3/design.mdx
```
---
title: DeepBook Design
sidebar_label: Design
---

At a high level, the DeepBook design follows the following flow, which revolves around three shared objects:
  - `Pool`: A shared object that represents one market and is responsible for managing its order book, users, stakes, and so on. See the [Pool shared object](#pool) section to learn more.
  - `PoolRegistry`: Used only during pool creation, it makes sure that duplicate pools are not created and maintains package versioning.
  - `BalanceManager`: Used to source a user's funds when placing orders. A single `BalanceManager` can be used between all pools. See [BalanceManager](./balance-manager.mdx) to learn more.

<p class="flex justify-center">![1](./images/DBv3Architecture.png)</p>

## Pool shared object {#pool}

All public facing functions take in the `Pool` shared object as a mutable or immutable reference. `Pool` is made up of three distinct components: 
  - [`Book`](#book)
  - [`State`](#state)
  - [`Vault`](#vault)

Logic is isolated between components and each component builds on top of the previous one. By maintaining a book, then state, then vault relationship, DeepBook can provide data availability guarantees, improve code readability, and help make maintaining and upgrading the protocol easier. 

<p class="flex justify-center">![Pool Modules](./images/pool.png)</p>

### Book

This component is made up of the main `Book` module along with `Fill`, `OrderInfo`, and `Order` modules. The `Book` struct maintains two `BigVector<Order>` objects for bids and asks, as well as some metadata. It is responsible for storing, matching, modifying, and removing `Orders`.

When placing an order, an `OrderInfo` is first created. If applicable, it is first matched against existing maker orders, accumulating `Fill`s in the process. Any remaining quantity will be used to create an `Order` object and injected into the book. By the end of book processing, the `OrderInfo` object has enough information to update all relevant users and the overall state.

### State

`State` stores `Governance`, `History`, and `Account`. It processes all requests, updating at least one of these stored structs.

#### Governance

The `Governance` module stores data related to the pool's trading params. These parameters are the taker fee, maker fee, and the stake required. Stake required represents the amount of DEEP tokens that a user must have staked in this specific pool to be eligible for taker and maker incentives.

Every epoch, users with non zero stake can submit a proposal to change these parameters. The proposed fees are bounded.

<style jsx>{`
  table {
    width: 100%;
    display: inline-table;
  }
  th:nth-child(1),
  td:nth-child(1) {
    width: 15%;
  }
  th:nth-child(2),
  td:nth-child(2) {
    width: 15%;
  }
`}</style>

| min_value (bps) | max_value (bps) | Pool type | Taker or maker |
| --- | --- | --- | --- |
| 1 | 10 | Volatile | Taker |
| 0 | 5 | Volatile | Maker |
| 0.1 | 1 | Stable | Taker |
| 0 | 0.5 | Stable | Maker |
| 0 | 0 | Whitelisted | Taker and maker |

Users can also vote on live proposals. When a proposal exceeds the quorum, the new trade parameters are queued to go live from the following epoch and onwards.  Proposals and votes are reset every epoch. Users can start submitting and voting on proposals the epoch following their stake. Quorum is equivalent to half of the total voting power. A user's voting power is calculated with the following formula where ${V}$ is the voting power, ${S}$ is the amount staked, and ${V_c}$ is the voting power cutoff. ${V_c}$ is currently set to 100,000 DEEP.

<p class="flex justify-center">$\LARGE V=\min\lparen S,V_c \rparen + \max\lparen \sqrt{S} - \sqrt{V_c} ,0 \rparen$</p>

The following diagram helps visualize the governance lifecycle.

<p class="flex justify-center">![DeepBook Governance Timeline](./images/governance.png)</p>

#### History

The `History` module stores aggregated volumes, trading params, fees collected and fees to burn for the current epoch and previous epochs. During order processing, fills are used to calculate and update the total volume. Additionally, if the maker of the trade has enough stake, the total staked volume is also updated.

The first operation of every epoch will trigger an update, moving the current epoch data into historic data, and resetting the current epoch data.

User rebate calculations are done in this module. During every epoch, a maker is eligible for rebates as long as their DEEP staked is over the stake required and have contributed in maker volume. The following formula is used to calculate maker fees, quoted from the [Whitepaper: DeepBook Token](/doc/deepbook.pdf) document. Details on maker incentives can be found in section 2.2 of the whitepaper.

<blockquote cite="/doc/deepbook.pdf">

The computation of incentives – which happens after an epoch ends and is only given to makers
who have staked the required number of DEEP tokens in advance – is calculated in Equation (3) for
a given maker ${i}$. Equation (3) introduces several new variables. First, ${M}$ refers to the set of makers
who stake a sufficient number of DEEP tokens, and $\bar{M}$ refers to the set of makers who do not fulfill
this condition. Second, ${F}$ refers to total fees (collected both from takers and the maker) that a
maker’s volume has generated in a given epoch. Third, ${L}$ refers to the total liquidity provided by
a maker – and specifically the liquidity traded, not just the liquidity quoted. Finally, the critical
point ${p}$ is the “phaseout” point, at which – if total liquidity provided by other makers’ crosses this
point – incentives are zero for the maker in that epoch. This point ${p}$ is constant for all makers in
a pool and epoch.

<p class="flex justify-center">$\LARGE \textsf {Incentives }  \textsf {for } \textsf {Maker } i = \max\Bigg\lbrack F_i\Bigg\lparen 1 + \large\cfrac{\sum_{j \in \bar{M}} F_j} {\sum_{j \in M} F_j} \Bigg\rparen\Bigg\lparen \LARGE 1 - \large\cfrac{\sum_{j \in M \cup \bar{M}} L_j - L_i}{p}\Bigg\rparen \LARGE ,0 \Bigg\rbrack$ (3)</p>

</blockquote>

In essence, if the total volume during an epoch is greater than the median volume from the last 28 days, then there are no rebates. The lower the volume compared to the median, the more rebates are available. The maximum amount of rebates for an epoch is equivalent to the total amount of DEEP collected during that epoch. Remaining DEEP is burned.

#### Account

`Account` represents a single user and their relevant data. Everything related to volumes, stake, voted proposal, unclaimed rebates, and balances to be transferred. There is a one to one relationship between a `BalanceManager` and an `Account`.

Every epoch, the first action that a user performs will update their account, triggering a calculation of any potential rebates from the previous epoch, as well as resetting their volumes for the current epoch. Any new stakes from the previous epoch become active.

Each account has settled and owed balances. Settled balances are what the pool owes to the user, and owed balances are what the user owes to the pool. For example, when placing an order, the user's owed balances increase, representing the funds that the user has to pay to place that order. Then, if a maker order is taken by another user, the maker's settled balances increase, representing the funds that the maker is owed.

### Vault

Every transaction that a user performs on DeepBook resets their settled and owed balances. The vault then processes these balances for the user, deducting or adding to funds to their `BalanceManager`.

The vault also stores the `DeepPrice` struct. This object holds up to 100 data points representing the conversion rate between the pool's base or quote asset and DEEP. These data points are sourced from a whitelisted pool, DEEP/USDC or DEEP/SUI. This conversion rate is used to determine the quantity of DEEP tokens required to pay for trading fees.

### BigVector

`BigVector` is an arbitrary sized vector-like data structure, implemented using an on-chain B+ Tree to support almost constant time (log base max_fan_out) random access, insertion and removal.

Iteration is supported by exposing access to leaf nodes (slices). Finding the initial slice can be done in almost constant time, and subsequently finding the previous or next slice can also be done in constant time.

Nodes in the B+ Tree are stored as individual dynamic fields hanging off the `BigVector`.

## Place limit order flow

The following diagram of the lifecycle of an order placement action helps visualize the book, then state, then vault flow.

<p class="flex justify-center">![Place limit order flow](./images/placeorder.png)</p>

### Pool

In the `Pool` module, `place_order_int` is called with the user's input parameters. In this function, four things happen in order: 
  1. An `OrderInfo` is created.
  1. The `Book` function `create_order` is called.
  1. The `State` function `process_create` is called.
  1. The `Vault` function `settle_balance_manager` is called. 

### Book

The order creation within the book involves three primary tasks:
  - Validate inputs.
  - Match against existing orders.
  - Inject any remaining quantity into the order book as a limit order.

Validation of inputs ensures that quantity, price, timestamp, and order type are within expected ranges.

To match an `OrderInfo` against the book, the list of `Order`s is iterated in the opposite side of the book. If there is an overlap in price and the existing maker order has not expired, then DeepBook matches their quantities and generates a `Fill`. DeepBook appends that fill to the `OrderInfo` fills, to use later in state. DeepBook updates the existing maker order quantities and status during each match, and removes them from the book if they are completely filled or expired.

Finally, if the `OrderInfo` object has any remaining quantity, DeepBook converts it into a compact `Order` object and injects it into the order book. `Order` has the minimum amount of data necessary for matching, while `OrderInfo` has the maximum amount of data for general processing.

Regardless of direction or order type, all DeepBook matching is processed in a single function.

### State

The `process_create` function in `State` handles the processing of an order creation event within the pool's state: calculating the transaction amounts and fees for the order, and updating the account volumes accordingly. 

First, the function processes the list of fills from the `OrderInfo` object, updating volumes tracked and settling funds for the makers involved. Next, the function retrieves the account's total trading volume and active stake. It calculates the taker's fee based on the user's account stake and volume in DEEP tokens, while the maker fee is retrieved from the governance trade parameters. To receive discounted taker fees, the account must have more than the minimum stake for the pool, and the trading volume in DEEP tokens must exceed the same threshold. If any quantity remains in the `OrderInfo` object, it is added to the account's list of orders as an `Order` and is already created in `Book`. 

Finally, the function calculates the partial taker fills and maker order quantities, if there are any, with consideration for the taker and maker fees. It adds these to the previously settled and owed balances from the account. Trade history is updated with the total fees collected from the order and two tuples are returned to `Pool`, settled and owed balances, in (base, quote, DEEP) format, ensuring the correct assets are transferred in `Vault`.

### Vault

The `settle_balance_manager` function in `Vault` is responsible for managing the transfer of any settled and owed amounts for the `BalanceManager`. 

First, the function validates that a trader is authorized to use the `BalanceManager`. 

Then, for each asset type the process compares `balances_out` against `balances_in`. If the `balances_out` total exceeds `balances_in`, the function splits the difference from the vault's balance and deposits it into the `BalanceManager`. Conversely, if the `balances_in` total exceeds `balances_out`, the function withdraws the difference from the `BalanceManager` and joins it to the vault's balance. 

This process is repeated for base, quote, and DEEP asset balances, ensuring all asset balances are accurately reflected and settled between the vault and the `BalanceManager`.
```
